/**
 * tgsnake - Telegram MTProto framework for nodejs.
 * Copyright (C) 2023 butthx <https://github.com/butthx>
 *
 * THIS FILE IS PART OF TGSNAKE
 *
 * tgsnake is a free software : you can redistribute it and/or modify
 * it under the terms of the MIT License as published.
 */

/***********************************************************
 *                         Warning!!                        *
 *               This file is auto generate.                *
 *         All change made in this file will be lost!       *
 ***********************************************************/
import { TLObject, BytesIO, Primitive, type UpdateSecretChatMessage } from './core/index.ts';

/**
 * This is a telegram schema, so you can see the documentation in https://core.telegram.org/schema.
 * All schema wrapped in Raw namespace.
 */
export namespace Raw {
  export type X = TLObject;
  export type Type = TLObject;
  export type Bool = boolean;
  export type int = number;
  export type double = number;
  export type float = number;
  export type int128 = bigint;
  export type int256 = bigint;
  export type long = bigint;
  export type bytes = Buffer;
  export type Vector<T> = Array<T>;
  /**
   * The Telegram layer we using.
   */
  export const Layer: number = 166;
  /**
   * The highest telegram secret chat schema layer.
   */
  export const HighestSCLayer: number = 144;
  // Start telegram schema

  export type TypesTLRequest =
    | Raw.ReqPq
    | Raw.ReqPqMulti
    | Raw.ReqDhParams
    | Raw.SetClientDhParams
    | Raw.DestroyAuthKey
    | Raw.RpcDropAnswer
    | Raw.GetFutureSalts
    | Raw.Ping
    | Raw.PingDelayDisconnect
    | Raw.DestroySession
    | Raw.InvokeAfterMsg
    | Raw.InvokeAfterMsgs
    | Raw.InitConnection
    | Raw.InvokeWithLayer
    | Raw.InvokeWithoutUpdates
    | Raw.InvokeWithMessagesRange
    | Raw.InvokeWithTakeout
    | Raw.auth.SendCode
    | Raw.auth.SignUp
    | Raw.auth.SignIn
    | Raw.auth.LogOut
    | Raw.auth.ResetAuthorizations
    | Raw.auth.ExportAuthorization
    | Raw.auth.ImportAuthorization
    | Raw.auth.BindTempAuthKey
    | Raw.auth.ImportBotAuthorization
    | Raw.auth.CheckPassword
    | Raw.auth.RequestPasswordRecovery
    | Raw.auth.RecoverPassword
    | Raw.auth.ResendCode
    | Raw.auth.CancelCode
    | Raw.auth.DropTempAuthKeys
    | Raw.auth.ExportLoginToken
    | Raw.auth.ImportLoginToken
    | Raw.auth.AcceptLoginToken
    | Raw.auth.CheckRecoveryPassword
    | Raw.auth.ImportWebTokenAuthorization
    | Raw.auth.RequestFirebaseSms
    | Raw.auth.ResetLoginEmail
    | Raw.account.RegisterDevice
    | Raw.account.UnregisterDevice
    | Raw.account.UpdateNotifySettings
    | Raw.account.GetNotifySettings
    | Raw.account.ResetNotifySettings
    | Raw.account.UpdateProfile
    | Raw.account.UpdateStatus
    | Raw.account.GetWallPapers
    | Raw.account.ReportPeer
    | Raw.account.CheckUsername
    | Raw.account.UpdateUsername
    | Raw.account.GetPrivacy
    | Raw.account.SetPrivacy
    | Raw.account.DeleteAccount
    | Raw.account.GetAccountTTL
    | Raw.account.SetAccountTTL
    | Raw.account.SendChangePhoneCode
    | Raw.account.ChangePhone
    | Raw.account.UpdateDeviceLocked
    | Raw.account.GetAuthorizations
    | Raw.account.ResetAuthorization
    | Raw.account.GetPassword
    | Raw.account.GetPasswordSettings
    | Raw.account.UpdatePasswordSettings
    | Raw.account.SendConfirmPhoneCode
    | Raw.account.ConfirmPhone
    | Raw.account.GetTmpPassword
    | Raw.account.GetWebAuthorizations
    | Raw.account.ResetWebAuthorization
    | Raw.account.ResetWebAuthorizations
    | Raw.account.GetAllSecureValues
    | Raw.account.GetSecureValue
    | Raw.account.SaveSecureValue
    | Raw.account.DeleteSecureValue
    | Raw.account.GetAuthorizationForm
    | Raw.account.AcceptAuthorization
    | Raw.account.SendVerifyPhoneCode
    | Raw.account.VerifyPhone
    | Raw.account.SendVerifyEmailCode
    | Raw.account.VerifyEmail
    | Raw.account.InitTakeoutSession
    | Raw.account.FinishTakeoutSession
    | Raw.account.ConfirmPasswordEmail
    | Raw.account.ResendPasswordEmail
    | Raw.account.CancelPasswordEmail
    | Raw.account.GetContactSignUpNotification
    | Raw.account.SetContactSignUpNotification
    | Raw.account.GetNotifyExceptions
    | Raw.account.GetWallPaper
    | Raw.account.UploadWallPaper
    | Raw.account.SaveWallPaper
    | Raw.account.InstallWallPaper
    | Raw.account.ResetWallPapers
    | Raw.account.GetAutoDownloadSettings
    | Raw.account.SaveAutoDownloadSettings
    | Raw.account.UploadTheme
    | Raw.account.CreateTheme
    | Raw.account.UpdateTheme
    | Raw.account.SaveTheme
    | Raw.account.InstallTheme
    | Raw.account.GetTheme
    | Raw.account.GetThemes
    | Raw.account.SetContentSettings
    | Raw.account.GetContentSettings
    | Raw.account.GetMultiWallPapers
    | Raw.account.GetGlobalPrivacySettings
    | Raw.account.SetGlobalPrivacySettings
    | Raw.account.ReportProfilePhoto
    | Raw.account.ResetPassword
    | Raw.account.DeclinePasswordReset
    | Raw.account.GetChatThemes
    | Raw.account.SetAuthorizationTTL
    | Raw.account.ChangeAuthorizationSettings
    | Raw.account.GetSavedRingtones
    | Raw.account.SaveRingtone
    | Raw.account.UploadRingtone
    | Raw.account.UpdateEmojiStatus
    | Raw.account.GetDefaultEmojiStatuses
    | Raw.account.GetRecentEmojiStatuses
    | Raw.account.ClearRecentEmojiStatuses
    | Raw.account.ReorderUsernames
    | Raw.account.ToggleUsername
    | Raw.account.GetDefaultProfilePhotoEmojis
    | Raw.account.GetDefaultGroupPhotoEmojis
    | Raw.account.GetAutoSaveSettings
    | Raw.account.SaveAutoSaveSettings
    | Raw.account.DeleteAutoSaveExceptions
    | Raw.account.InvalidateSignInCodes
    | Raw.account.UpdateColor
    | Raw.account.GetDefaultBackgroundEmojis
    | Raw.users.GetUsers
    | Raw.users.GetFullUser
    | Raw.users.SetSecureValueErrors
    | Raw.contacts.GetContactIDs
    | Raw.contacts.GetStatuses
    | Raw.contacts.GetContacts
    | Raw.contacts.ImportContacts
    | Raw.contacts.DeleteContacts
    | Raw.contacts.DeleteByPhones
    | Raw.contacts.Block
    | Raw.contacts.Unblock
    | Raw.contacts.GetBlocked
    | Raw.contacts.Search
    | Raw.contacts.ResolveUsername
    | Raw.contacts.GetTopPeers
    | Raw.contacts.ResetTopPeerRating
    | Raw.contacts.ResetSaved
    | Raw.contacts.GetSaved
    | Raw.contacts.ToggleTopPeers
    | Raw.contacts.AddContact
    | Raw.contacts.AcceptContact
    | Raw.contacts.GetLocated
    | Raw.contacts.BlockFromReplies
    | Raw.contacts.ResolvePhone
    | Raw.contacts.ExportContactToken
    | Raw.contacts.ImportContactToken
    | Raw.contacts.EditCloseFriends
    | Raw.contacts.SetBlocked
    | Raw.messages.GetMessages
    | Raw.messages.GetDialogs
    | Raw.messages.GetHistory
    | Raw.messages.Search
    | Raw.messages.ReadHistory
    | Raw.messages.DeleteHistory
    | Raw.messages.DeleteMessages
    | Raw.messages.ReceivedMessages
    | Raw.messages.SetTyping
    | Raw.messages.SendMessage
    | Raw.messages.SendMedia
    | Raw.messages.ForwardMessages
    | Raw.messages.ReportSpam
    | Raw.messages.GetPeerSettings
    | Raw.messages.Report
    | Raw.messages.GetChats
    | Raw.messages.GetFullChat
    | Raw.messages.EditChatTitle
    | Raw.messages.EditChatPhoto
    | Raw.messages.AddChatUser
    | Raw.messages.DeleteChatUser
    | Raw.messages.CreateChat
    | Raw.messages.GetDhConfig
    | Raw.messages.RequestEncryption
    | Raw.messages.AcceptEncryption
    | Raw.messages.DiscardEncryption
    | Raw.messages.SetEncryptedTyping
    | Raw.messages.ReadEncryptedHistory
    | Raw.messages.SendEncrypted
    | Raw.messages.SendEncryptedFile
    | Raw.messages.SendEncryptedService
    | Raw.messages.ReceivedQueue
    | Raw.messages.ReportEncryptedSpam
    | Raw.messages.ReadMessageContents
    | Raw.messages.GetStickers
    | Raw.messages.GetAllStickers
    | Raw.messages.GetWebPagePreview
    | Raw.messages.ExportChatInvite
    | Raw.messages.CheckChatInvite
    | Raw.messages.ImportChatInvite
    | Raw.messages.GetStickerSet
    | Raw.messages.InstallStickerSet
    | Raw.messages.UninstallStickerSet
    | Raw.messages.StartBot
    | Raw.messages.GetMessagesViews
    | Raw.messages.EditChatAdmin
    | Raw.messages.MigrateChat
    | Raw.messages.SearchGlobal
    | Raw.messages.ReorderStickerSets
    | Raw.messages.GetDocumentByHash
    | Raw.messages.GetSavedGifs
    | Raw.messages.SaveGif
    | Raw.messages.GetInlineBotResults
    | Raw.messages.SetInlineBotResults
    | Raw.messages.SendInlineBotResult
    | Raw.messages.GetMessageEditData
    | Raw.messages.EditMessage
    | Raw.messages.EditInlineBotMessage
    | Raw.messages.GetBotCallbackAnswer
    | Raw.messages.SetBotCallbackAnswer
    | Raw.messages.GetPeerDialogs
    | Raw.messages.SaveDraft
    | Raw.messages.GetAllDrafts
    | Raw.messages.GetFeaturedStickers
    | Raw.messages.ReadFeaturedStickers
    | Raw.messages.GetRecentStickers
    | Raw.messages.SaveRecentSticker
    | Raw.messages.ClearRecentStickers
    | Raw.messages.GetArchivedStickers
    | Raw.messages.GetMaskStickers
    | Raw.messages.GetAttachedStickers
    | Raw.messages.SetGameScore
    | Raw.messages.SetInlineGameScore
    | Raw.messages.GetGameHighScores
    | Raw.messages.GetInlineGameHighScores
    | Raw.messages.GetCommonChats
    | Raw.messages.GetWebPage
    | Raw.messages.ToggleDialogPin
    | Raw.messages.ReorderPinnedDialogs
    | Raw.messages.GetPinnedDialogs
    | Raw.messages.SetBotShippingResults
    | Raw.messages.SetBotPrecheckoutResults
    | Raw.messages.UploadMedia
    | Raw.messages.SendScreenshotNotification
    | Raw.messages.GetFavedStickers
    | Raw.messages.FaveSticker
    | Raw.messages.GetUnreadMentions
    | Raw.messages.ReadMentions
    | Raw.messages.GetRecentLocations
    | Raw.messages.SendMultiMedia
    | Raw.messages.UploadEncryptedFile
    | Raw.messages.SearchStickerSets
    | Raw.messages.GetSplitRanges
    | Raw.messages.MarkDialogUnread
    | Raw.messages.GetDialogUnreadMarks
    | Raw.messages.ClearAllDrafts
    | Raw.messages.UpdatePinnedMessage
    | Raw.messages.SendVote
    | Raw.messages.GetPollResults
    | Raw.messages.GetOnlines
    | Raw.messages.EditChatAbout
    | Raw.messages.EditChatDefaultBannedRights
    | Raw.messages.GetEmojiKeywords
    | Raw.messages.GetEmojiKeywordsDifference
    | Raw.messages.GetEmojiKeywordsLanguages
    | Raw.messages.GetEmojiURL
    | Raw.messages.GetSearchCounters
    | Raw.messages.RequestUrlAuth
    | Raw.messages.AcceptUrlAuth
    | Raw.messages.HidePeerSettingsBar
    | Raw.messages.GetScheduledHistory
    | Raw.messages.GetScheduledMessages
    | Raw.messages.SendScheduledMessages
    | Raw.messages.DeleteScheduledMessages
    | Raw.messages.GetPollVotes
    | Raw.messages.ToggleStickerSets
    | Raw.messages.GetDialogFilters
    | Raw.messages.GetSuggestedDialogFilters
    | Raw.messages.UpdateDialogFilter
    | Raw.messages.UpdateDialogFiltersOrder
    | Raw.messages.GetOldFeaturedStickers
    | Raw.messages.GetReplies
    | Raw.messages.GetDiscussionMessage
    | Raw.messages.ReadDiscussion
    | Raw.messages.UnpinAllMessages
    | Raw.messages.DeleteChat
    | Raw.messages.DeletePhoneCallHistory
    | Raw.messages.CheckHistoryImport
    | Raw.messages.InitHistoryImport
    | Raw.messages.UploadImportedMedia
    | Raw.messages.StartHistoryImport
    | Raw.messages.GetExportedChatInvites
    | Raw.messages.GetExportedChatInvite
    | Raw.messages.EditExportedChatInvite
    | Raw.messages.DeleteRevokedExportedChatInvites
    | Raw.messages.DeleteExportedChatInvite
    | Raw.messages.GetAdminsWithInvites
    | Raw.messages.GetChatInviteImporters
    | Raw.messages.SetHistoryTTL
    | Raw.messages.CheckHistoryImportPeer
    | Raw.messages.SetChatTheme
    | Raw.messages.GetMessageReadParticipants
    | Raw.messages.GetSearchResultsCalendar
    | Raw.messages.GetSearchResultsPositions
    | Raw.messages.HideChatJoinRequest
    | Raw.messages.HideAllChatJoinRequests
    | Raw.messages.ToggleNoForwards
    | Raw.messages.SaveDefaultSendAs
    | Raw.messages.SendReaction
    | Raw.messages.GetMessagesReactions
    | Raw.messages.GetMessageReactionsList
    | Raw.messages.SetChatAvailableReactions
    | Raw.messages.GetAvailableReactions
    | Raw.messages.SetDefaultReaction
    | Raw.messages.TranslateText
    | Raw.messages.GetUnreadReactions
    | Raw.messages.ReadReactions
    | Raw.messages.SearchSentMedia
    | Raw.messages.GetAttachMenuBots
    | Raw.messages.GetAttachMenuBot
    | Raw.messages.ToggleBotInAttachMenu
    | Raw.messages.RequestWebView
    | Raw.messages.ProlongWebView
    | Raw.messages.RequestSimpleWebView
    | Raw.messages.SendWebViewResultMessage
    | Raw.messages.SendWebViewData
    | Raw.messages.TranscribeAudio
    | Raw.messages.RateTranscribedAudio
    | Raw.messages.GetCustomEmojiDocuments
    | Raw.messages.GetEmojiStickers
    | Raw.messages.GetFeaturedEmojiStickers
    | Raw.messages.ReportReaction
    | Raw.messages.GetTopReactions
    | Raw.messages.GetRecentReactions
    | Raw.messages.ClearRecentReactions
    | Raw.messages.GetExtendedMedia
    | Raw.messages.SetDefaultHistoryTTL
    | Raw.messages.GetDefaultHistoryTTL
    | Raw.messages.SendBotRequestedPeer
    | Raw.messages.GetEmojiGroups
    | Raw.messages.GetEmojiStatusGroups
    | Raw.messages.GetEmojiProfilePhotoGroups
    | Raw.messages.SearchCustomEmoji
    | Raw.messages.TogglePeerTranslations
    | Raw.messages.GetBotApp
    | Raw.messages.RequestAppWebView
    | Raw.messages.SetChatWallPaper
    | Raw.updates.GetState
    | Raw.updates.GetDifference
    | Raw.updates.GetChannelDifference
    | Raw.photos.UpdateProfilePhoto
    | Raw.photos.UploadProfilePhoto
    | Raw.photos.DeletePhotos
    | Raw.photos.GetUserPhotos
    | Raw.photos.UploadContactProfilePhoto
    | Raw.upload.SaveFilePart
    | Raw.upload.GetFile
    | Raw.upload.SaveBigFilePart
    | Raw.upload.GetWebFile
    | Raw.upload.GetCdnFile
    | Raw.upload.ReuploadCdnFile
    | Raw.upload.GetCdnFileHashes
    | Raw.upload.GetFileHashes
    | Raw.help.GetConfig
    | Raw.help.GetNearestDc
    | Raw.help.GetAppUpdate
    | Raw.help.GetInviteText
    | Raw.help.GetSupport
    | Raw.help.GetAppChangelog
    | Raw.help.SetBotUpdatesStatus
    | Raw.help.GetCdnConfig
    | Raw.help.GetRecentMeUrls
    | Raw.help.GetTermsOfServiceUpdate
    | Raw.help.AcceptTermsOfService
    | Raw.help.GetDeepLinkInfo
    | Raw.help.GetAppConfig
    | Raw.help.SaveAppLog
    | Raw.help.GetPassportConfig
    | Raw.help.GetSupportName
    | Raw.help.GetUserInfo
    | Raw.help.EditUserInfo
    | Raw.help.GetPromoData
    | Raw.help.HidePromoData
    | Raw.help.DismissSuggestion
    | Raw.help.GetCountriesList
    | Raw.help.GetPremiumPromo
    | Raw.channels.ReadHistory
    | Raw.channels.DeleteMessages
    | Raw.channels.ReportSpam
    | Raw.channels.GetMessages
    | Raw.channels.GetParticipants
    | Raw.channels.GetParticipant
    | Raw.channels.GetChannels
    | Raw.channels.GetFullChannel
    | Raw.channels.CreateChannel
    | Raw.channels.EditAdmin
    | Raw.channels.EditTitle
    | Raw.channels.EditPhoto
    | Raw.channels.CheckUsername
    | Raw.channels.UpdateUsername
    | Raw.channels.JoinChannel
    | Raw.channels.LeaveChannel
    | Raw.channels.InviteToChannel
    | Raw.channels.DeleteChannel
    | Raw.channels.ExportMessageLink
    | Raw.channels.ToggleSignatures
    | Raw.channels.GetAdminedPublicChannels
    | Raw.channels.EditBanned
    | Raw.channels.GetAdminLog
    | Raw.channels.SetStickers
    | Raw.channels.ReadMessageContents
    | Raw.channels.DeleteHistory
    | Raw.channels.TogglePreHistoryHidden
    | Raw.channels.GetLeftChannels
    | Raw.channels.GetGroupsForDiscussion
    | Raw.channels.SetDiscussionGroup
    | Raw.channels.EditCreator
    | Raw.channels.EditLocation
    | Raw.channels.ToggleSlowMode
    | Raw.channels.GetInactiveChannels
    | Raw.channels.ConvertToGigagroup
    | Raw.channels.ViewSponsoredMessage
    | Raw.channels.GetSponsoredMessages
    | Raw.channels.GetSendAs
    | Raw.channels.DeleteParticipantHistory
    | Raw.channels.ToggleJoinToSend
    | Raw.channels.ToggleJoinRequest
    | Raw.channels.ReorderUsernames
    | Raw.channels.ToggleUsername
    | Raw.channels.DeactivateAllUsernames
    | Raw.channels.ToggleForum
    | Raw.channels.CreateForumTopic
    | Raw.channels.GetForumTopics
    | Raw.channels.GetForumTopicsByID
    | Raw.channels.EditForumTopic
    | Raw.channels.UpdatePinnedForumTopic
    | Raw.channels.DeleteTopicHistory
    | Raw.channels.ReorderPinnedForumTopics
    | Raw.channels.ToggleAntiSpam
    | Raw.channels.ReportAntiSpamFalsePositive
    | Raw.channels.ToggleParticipantsHidden
    | Raw.channels.ClickSponsoredMessage
    | Raw.channels.UpdateColor
    | Raw.bots.SendCustomRequest
    | Raw.bots.AnswerWebhookJSONQuery
    | Raw.bots.SetBotCommands
    | Raw.bots.ResetBotCommands
    | Raw.bots.GetBotCommands
    | Raw.bots.SetBotMenuButton
    | Raw.bots.GetBotMenuButton
    | Raw.bots.SetBotBroadcastDefaultAdminRights
    | Raw.bots.SetBotGroupDefaultAdminRights
    | Raw.bots.SetBotInfo
    | Raw.bots.GetBotInfo
    | Raw.bots.ReorderUsernames
    | Raw.bots.ToggleUsername
    | Raw.bots.CanSendMessage
    | Raw.bots.AllowSendMessage
    | Raw.bots.InvokeWebViewCustomMethod
    | Raw.payments.GetPaymentForm
    | Raw.payments.GetPaymentReceipt
    | Raw.payments.ValidateRequestedInfo
    | Raw.payments.SendPaymentForm
    | Raw.payments.GetSavedInfo
    | Raw.payments.ClearSavedInfo
    | Raw.payments.GetBankCardData
    | Raw.payments.ExportInvoice
    | Raw.payments.AssignAppStoreTransaction
    | Raw.payments.AssignPlayMarketTransaction
    | Raw.payments.CanPurchasePremium
    | Raw.payments.GetPremiumGiftCodeOptions
    | Raw.payments.CheckGiftCode
    | Raw.payments.ApplyGiftCode
    | Raw.payments.GetGiveawayInfo
    | Raw.payments.LaunchPrepaidGiveaway
    | Raw.stickers.CreateStickerSet
    | Raw.stickers.RemoveStickerFromSet
    | Raw.stickers.ChangeStickerPosition
    | Raw.stickers.AddStickerToSet
    | Raw.stickers.SetStickerSetThumb
    | Raw.stickers.CheckShortName
    | Raw.stickers.SuggestShortName
    | Raw.stickers.ChangeSticker
    | Raw.stickers.RenameStickerSet
    | Raw.stickers.DeleteStickerSet
    | Raw.phone.GetCallConfig
    | Raw.phone.RequestCall
    | Raw.phone.AcceptCall
    | Raw.phone.ConfirmCall
    | Raw.phone.ReceivedCall
    | Raw.phone.DiscardCall
    | Raw.phone.SetCallRating
    | Raw.phone.SaveCallDebug
    | Raw.phone.SendSignalingData
    | Raw.phone.CreateGroupCall
    | Raw.phone.JoinGroupCall
    | Raw.phone.LeaveGroupCall
    | Raw.phone.InviteToGroupCall
    | Raw.phone.DiscardGroupCall
    | Raw.phone.ToggleGroupCallSettings
    | Raw.phone.GetGroupCall
    | Raw.phone.GetGroupParticipants
    | Raw.phone.CheckGroupCall
    | Raw.phone.ToggleGroupCallRecord
    | Raw.phone.EditGroupCallParticipant
    | Raw.phone.EditGroupCallTitle
    | Raw.phone.GetGroupCallJoinAs
    | Raw.phone.ExportGroupCallInvite
    | Raw.phone.ToggleGroupCallStartSubscription
    | Raw.phone.StartScheduledGroupCall
    | Raw.phone.SaveDefaultGroupCallJoinAs
    | Raw.phone.JoinGroupCallPresentation
    | Raw.phone.LeaveGroupCallPresentation
    | Raw.phone.GetGroupCallStreamChannels
    | Raw.phone.GetGroupCallStreamRtmpUrl
    | Raw.phone.SaveCallLog
    | Raw.langpack.GetLangPack
    | Raw.langpack.GetStrings
    | Raw.langpack.GetDifference
    | Raw.langpack.GetLanguages
    | Raw.langpack.GetLanguage
    | Raw.folders.EditPeerFolders
    | Raw.stats.GetBroadcastStats
    | Raw.stats.LoadAsyncGraph
    | Raw.stats.GetMegagroupStats
    | Raw.stats.GetMessagePublicForwards
    | Raw.stats.GetMessageStats
    | Raw.chatlists.ExportChatlistInvite
    | Raw.chatlists.DeleteExportedInvite
    | Raw.chatlists.EditExportedInvite
    | Raw.chatlists.GetExportedInvites
    | Raw.chatlists.CheckChatlistInvite
    | Raw.chatlists.JoinChatlistInvite
    | Raw.chatlists.GetChatlistUpdates
    | Raw.chatlists.JoinChatlistUpdates
    | Raw.chatlists.HideChatlistUpdates
    | Raw.chatlists.GetLeaveChatlistSuggestions
    | Raw.chatlists.LeaveChatlist
    | Raw.stories.CanSendStory
    | Raw.stories.SendStory
    | Raw.stories.EditStory
    | Raw.stories.DeleteStories
    | Raw.stories.TogglePinned
    | Raw.stories.GetAllStories
    | Raw.stories.GetPinnedStories
    | Raw.stories.GetStoriesArchive
    | Raw.stories.GetStoriesByID
    | Raw.stories.ToggleAllStoriesHidden
    | Raw.stories.ReadStories
    | Raw.stories.IncrementStoryViews
    | Raw.stories.GetStoryViewsList
    | Raw.stories.GetStoriesViews
    | Raw.stories.ExportStoryLink
    | Raw.stories.Report
    | Raw.stories.ActivateStealthMode
    | Raw.stories.SendReaction
    | Raw.stories.GetPeerStories
    | Raw.stories.GetAllReadPeerStories
    | Raw.stories.GetPeerMaxIDs
    | Raw.stories.GetChatsToSend
    | Raw.stories.TogglePeerStoriesHidden
    | Raw.premium.GetBoostsList
    | Raw.premium.GetMyBoosts
    | Raw.premium.ApplyBoost
    | Raw.premium.GetBoostsStatus;
  export type TypeFileLocation = Raw.FileLocationUnavailable23 | Raw.FileLocation23;
  export type TypeDecryptedMessage =
    | Raw.DecryptedMessage8
    | Raw.DecryptedMessageService8
    | Raw.DecryptedMessage17
    | Raw.DecryptedMessageService17
    | Raw.DecryptedMessage45
    | Raw.DecryptedMessage73;
  export type TypeDecryptedMessageAction =
    | Raw.DecryptedMessageActionSetMessageTTL8
    | Raw.DecryptedMessageActionReadMessages8
    | Raw.DecryptedMessageActionDeleteMessages8
    | Raw.DecryptedMessageActionScreenshotMessages8
    | Raw.DecryptedMessageActionFlushHistory8
    | Raw.DecryptedMessageActionResend17
    | Raw.DecryptedMessageActionNotifyLayer17
    | Raw.DecryptedMessageActionTyping17
    | Raw.DecryptedMessageActionRequestKey20
    | Raw.DecryptedMessageActionAcceptKey20
    | Raw.DecryptedMessageActionAbortKey20
    | Raw.DecryptedMessageActionCommitKey20
    | Raw.DecryptedMessageActionNoop20;
  export type TypeDecryptedMessageMedia =
    | Raw.DecryptedMessageMediaEmpty8
    | Raw.DecryptedMessageMediaPhoto8
    | Raw.DecryptedMessageMediaVideo8
    | Raw.DecryptedMessageMediaGeoPoint8
    | Raw.DecryptedMessageMediaContact8
    | Raw.DecryptedMessageMediaDocument8
    | Raw.DecryptedMessageMediaAudio8
    | Raw.DecryptedMessageMediaVideo17
    | Raw.DecryptedMessageMediaAudio17
    | Raw.DecryptedMessageMediaExternalDocument23
    | Raw.DecryptedMessageMediaPhoto45
    | Raw.DecryptedMessageMediaVideo45
    | Raw.DecryptedMessageMediaDocument45
    | Raw.DecryptedMessageMediaVenue45
    | Raw.DecryptedMessageMediaWebPage45
    | Raw.DecryptedMessageMediaDocument143;
  export type TypeExportedStoryLink = Raw.ExportedStoryLink;
  export type TypeInputChatlist = Raw.InputChatlistDialogFilter;
  export type TypeInputFolderPeer = Raw.InputFolderPeer;
  export type TypeLangPackLanguage = Raw.LangPackLanguage;
  export type TypeInputPhoneCall = Raw.InputPhoneCall;
  export type TypeInputStickerSetItem = Raw.InputStickerSetItem;
  export type TypeInputPaymentCredentials =
    | Raw.InputPaymentCredentialsSaved
    | Raw.InputPaymentCredentials
    | Raw.InputPaymentCredentialsApplePay
    | Raw.InputPaymentCredentialsGooglePay;
  export type TypeInputInvoice =
    | Raw.InputInvoiceMessage
    | Raw.InputInvoiceSlug
    | Raw.InputInvoicePremiumGiftCode;
  export type TypeBotCommandScope =
    | Raw.BotCommandScopeDefault
    | Raw.BotCommandScopeUsers
    | Raw.BotCommandScopeChats
    | Raw.BotCommandScopeChatAdmins
    | Raw.BotCommandScopePeer
    | Raw.BotCommandScopePeerAdmins
    | Raw.BotCommandScopePeerUser;
  export type TypeChannelAdminLogEventsFilter = Raw.ChannelAdminLogEventsFilter;
  export type TypeExportedMessageLink = Raw.ExportedMessageLink;
  export type TypeChannelParticipantsFilter =
    | Raw.ChannelParticipantsRecent
    | Raw.ChannelParticipantsAdmins
    | Raw.ChannelParticipantsKicked
    | Raw.ChannelParticipantsBots
    | Raw.ChannelParticipantsBanned
    | Raw.ChannelParticipantsSearch
    | Raw.ChannelParticipantsContacts
    | Raw.ChannelParticipantsMentions;
  export type TypeInputAppEvent = Raw.InputAppEvent;
  export type TypeCdnConfig = Raw.CdnConfig;
  export type TypeNearestDc = Raw.NearestDc;
  export type TypeConfig = Raw.Config;
  export type TypeInputWebFileLocation =
    | Raw.InputWebFileLocation
    | Raw.InputWebFileGeoPointLocation
    | Raw.InputWebFileAudioAlbumThumbLocation;
  export type TypeInputFileLocation =
    | Raw.InputFileLocation
    | Raw.InputEncryptedFileLocation
    | Raw.InputDocumentFileLocation
    | Raw.InputSecureFileLocation
    | Raw.InputTakeoutFileLocation
    | Raw.InputPhotoFileLocation
    | Raw.InputPhotoLegacyFileLocation
    | Raw.InputPeerPhotoFileLocation
    | Raw.InputStickerSetThumb
    | Raw.InputGroupCallStream;
  export type TypeChannelMessagesFilter =
    | Raw.ChannelMessagesFilterEmpty
    | Raw.ChannelMessagesFilter;
  export type TypeAppWebViewResult = Raw.AppWebViewResultUrl;
  export type TypeInputBotApp = Raw.InputBotAppID | Raw.InputBotAppShortName;
  export type TypeDefaultHistoryTTL = Raw.DefaultHistoryTTL;
  export type TypeWebViewMessageSent = Raw.WebViewMessageSent;
  export type TypeSimpleWebViewResult = Raw.SimpleWebViewResultUrl;
  export type TypeWebViewResult = Raw.WebViewResultUrl;
  export type TypeAttachMenuBotsBot = Raw.AttachMenuBotsBot;
  export type TypeAttachMenuBots = Raw.AttachMenuBotsNotModified | Raw.AttachMenuBots;
  export type TypeReadParticipantDate = Raw.ReadParticipantDate;
  export type TypeDialogFilterSuggested = Raw.DialogFilterSuggested;
  export type TypeUrlAuthResult =
    | Raw.UrlAuthResultRequest
    | Raw.UrlAuthResultAccepted
    | Raw.UrlAuthResultDefault;
  export type TypeEmojiURL = Raw.EmojiURL;
  export type TypeEmojiLanguage = Raw.EmojiLanguage;
  export type TypeEmojiKeywordsDifference = Raw.EmojiKeywordsDifference;
  export type TypeChatOnlines = Raw.ChatOnlines;
  export type TypeInputSingleMedia = Raw.InputSingleMedia;
  export type TypeInputStickeredMedia =
    | Raw.InputStickeredMediaPhoto
    | Raw.InputStickeredMediaDocument;
  export type TypeInputDialogPeer = Raw.InputDialogPeer | Raw.InputDialogPeerFolder;
  export type TypeInputBotInlineResult =
    | Raw.InputBotInlineResult
    | Raw.InputBotInlineResultPhoto
    | Raw.InputBotInlineResultDocument
    | Raw.InputBotInlineResultGame;
  export type TypeInputEncryptedFile =
    | Raw.InputEncryptedFileEmpty
    | Raw.InputEncryptedFileUploaded
    | Raw.InputEncryptedFile
    | Raw.InputEncryptedFileBigUploaded;
  export type TypeInputEncryptedChat = Raw.InputEncryptedChat;
  export type TypeInputChatPhoto =
    | Raw.InputChatPhotoEmpty
    | Raw.InputChatUploadedPhoto
    | Raw.InputChatPhoto;
  export type TypeReceivedNotifyMessage = Raw.ReceivedNotifyMessage;
  export type TypeInputMessage =
    | Raw.InputMessageID
    | Raw.InputMessageReplyTo
    | Raw.InputMessagePinned
    | Raw.InputMessageCallbackQuery;
  export type TypeExportedContactToken = Raw.ExportedContactToken;
  export type TypeSavedContact = Raw.SavedPhoneContact;
  export type TypeInputContact = Raw.InputPhoneContact;
  export type TypeContactStatus = Raw.ContactStatus;
  export type TypeEmojiList = Raw.EmojiListNotModified | Raw.EmojiList;
  export type TypeGlobalPrivacySettings = Raw.GlobalPrivacySettings;
  export type TypeInputTheme = Raw.InputTheme | Raw.InputThemeSlug;
  export type TypeInputThemeSettings = Raw.InputThemeSettings;
  export type TypeEmailVerifyPurpose =
    | Raw.EmailVerifyPurposeLoginSetup
    | Raw.EmailVerifyPurposeLoginChange
    | Raw.EmailVerifyPurposePassport;
  export type TypeSecureValueHash = Raw.SecureValueHash;
  export type TypeInputSecureValue = Raw.InputSecureValue;
  export type TypeAccountDaysTTL = Raw.AccountDaysTTL;
  export type TypeInputPrivacyRule =
    | Raw.InputPrivacyValueAllowContacts
    | Raw.InputPrivacyValueAllowAll
    | Raw.InputPrivacyValueAllowUsers
    | Raw.InputPrivacyValueDisallowContacts
    | Raw.InputPrivacyValueDisallowAll
    | Raw.InputPrivacyValueDisallowUsers
    | Raw.InputPrivacyValueAllowChatParticipants
    | Raw.InputPrivacyValueDisallowChatParticipants
    | Raw.InputPrivacyValueAllowCloseFriends;
  export type TypeInputPrivacyKey =
    | Raw.InputPrivacyKeyStatusTimestamp
    | Raw.InputPrivacyKeyChatInvite
    | Raw.InputPrivacyKeyPhoneCall
    | Raw.InputPrivacyKeyPhoneP2P
    | Raw.InputPrivacyKeyForwards
    | Raw.InputPrivacyKeyProfilePhoto
    | Raw.InputPrivacyKeyPhoneNumber
    | Raw.InputPrivacyKeyAddedByPhone
    | Raw.InputPrivacyKeyVoiceMessages
    | Raw.InputPrivacyKeyAbout;
  export type TypeReportReason =
    | Raw.InputReportReasonSpam
    | Raw.InputReportReasonViolence
    | Raw.InputReportReasonPornography
    | Raw.InputReportReasonChildAbuse
    | Raw.InputReportReasonOther
    | Raw.InputReportReasonCopyright
    | Raw.InputReportReasonGeoIrrelevant
    | Raw.InputReportReasonFake
    | Raw.InputReportReasonIllegalDrugs
    | Raw.InputReportReasonPersonalDetails;
  export type TypeInputPeerNotifySettings = Raw.InputPeerNotifySettings;
  export type TypeInputNotifyPeer =
    | Raw.InputNotifyPeer
    | Raw.InputNotifyUsers
    | Raw.InputNotifyChats
    | Raw.InputNotifyBroadcasts
    | Raw.InputNotifyForumTopic;
  export type TypeInputCheckPasswordSRP = Raw.InputCheckPasswordEmpty | Raw.InputCheckPasswordSRP;
  export type TypeEmailVerification =
    | Raw.EmailVerificationCode
    | Raw.EmailVerificationGoogle
    | Raw.EmailVerificationApple;
  export type TypeCodeSettings = Raw.CodeSettings;
  export type TypeInputClientProxy = Raw.InputClientProxy;
  export type TypePrepaidGiveaway = Raw.PrepaidGiveaway;
  export type TypeMyBoost = Raw.MyBoost;
  export type TypeBoost = Raw.Boost;
  export type TypeMediaAreaCoordinates = Raw.MediaAreaCoordinates;
  export type TypeStoryView = Raw.StoryView;
  export type TypeStoryViews = Raw.StoryViews;
  export type TypeMediaArea =
    | Raw.MediaAreaVenue
    | Raw.InputMediaAreaVenue
    | Raw.MediaAreaGeoPoint
    | Raw.MediaAreaSuggestedReaction;
  export type TypeExportedChatlistInvite = Raw.ExportedChatlistInvite;
  export type TypeAutoSaveException = Raw.AutoSaveException;
  export type TypeAutoSaveSettings = Raw.AutoSaveSettings;
  export type TypeTextWithEntities = Raw.TextWithEntities;
  export type TypeEmojiGroup = Raw.EmojiGroup;
  export type TypePremiumSubscriptionOption = Raw.PremiumSubscriptionOption;
  export type TypePremiumGiftCodeOption = Raw.PremiumGiftCodeOption;
  export type TypeInputStorePaymentPurpose =
    | Raw.InputStorePaymentPremiumSubscription
    | Raw.InputStorePaymentGiftPremium
    | Raw.InputStorePaymentPremiumGiftCode
    | Raw.InputStorePaymentPremiumGiveaway;
  export type TypeAttachMenuBot = Raw.AttachMenuBot;
  export type TypeAttachMenuBotIcon = Raw.AttachMenuBotIcon;
  export type TypeAttachMenuPeerType =
    | Raw.AttachMenuPeerTypeSameBotPM
    | Raw.AttachMenuPeerTypeBotPM
    | Raw.AttachMenuPeerTypePM
    | Raw.AttachMenuPeerTypeChat
    | Raw.AttachMenuPeerTypeBroadcast;
  export type TypeAttachMenuBotIconColor = Raw.AttachMenuBotIconColor;
  export type TypeGroupCallStreamChannel = Raw.GroupCallStreamChannel;
  export type TypeAvailableReaction = Raw.AvailableReaction;
  export type TypeMessagePeerReaction = Raw.MessagePeerReaction;
  export type TypeReactionCount = Raw.ReactionCount;
  export type TypeUserFull = Raw.UserFull;
  export type TypeSendAsPeer = Raw.SendAsPeer;
  export type TypeSearchResultsPosition = Raw.SearchResultPosition;
  export type TypeSearchResultsCalendarPeriod = Raw.SearchResultsCalendarPeriod;
  export type TypeSponsoredMessage = Raw.SponsoredMessage;
  export type TypeSponsoredWebPage = Raw.SponsoredWebPage;
  export type TypeGroupCallParticipantVideoSourceGroup = Raw.GroupCallParticipantVideoSourceGroup;
  export type TypeChatAdminWithInvites = Raw.ChatAdminWithInvites;
  export type TypeChatInviteImporter = Raw.ChatInviteImporter;
  export type TypeGroupCallParticipantVideo = Raw.GroupCallParticipantVideo;
  export type TypeMessageViews = Raw.MessageViews;
  export type TypeStatsGroupTopInviter = Raw.StatsGroupTopInviter;
  export type TypeStatsGroupTopAdmin = Raw.StatsGroupTopAdmin;
  export type TypeStatsGroupTopPoster = Raw.StatsGroupTopPoster;
  export type TypeMessageInteractionCounters = Raw.MessageInteractionCounters;
  export type TypeStatsGraph = Raw.StatsGraphAsync | Raw.StatsGraphError | Raw.StatsGraph;
  export type TypeStatsPercentValue = Raw.StatsPercentValue;
  export type TypeStatsAbsValueAndPrev = Raw.StatsAbsValueAndPrev;
  export type TypeStatsDateRangeDays = Raw.StatsDateRangeDays;
  export type TypeBankCardOpenUrl = Raw.BankCardOpenUrl;
  export type TypeMessagePeerVote =
    | Raw.MessagePeerVote
    | Raw.MessagePeerVoteInputOption
    | Raw.MessagePeerVoteMultiple;
  export type TypeInputWallPaper =
    | Raw.InputWallPaper
    | Raw.InputWallPaperSlug
    | Raw.InputWallPaperNoFile;
  export type TypeBaseTheme =
    | Raw.BaseThemeClassic
    | Raw.BaseThemeDay
    | Raw.BaseThemeNight
    | Raw.BaseThemeTinted
    | Raw.BaseThemeArctic;
  export type TypeThemeSettings = Raw.ThemeSettings;
  export type TypeMessagesFilter =
    | Raw.InputMessagesFilterEmpty
    | Raw.InputMessagesFilterPhotos
    | Raw.InputMessagesFilterVideo
    | Raw.InputMessagesFilterPhotoVideo
    | Raw.InputMessagesFilterDocument
    | Raw.InputMessagesFilterUrl
    | Raw.InputMessagesFilterGif
    | Raw.InputMessagesFilterVoice
    | Raw.InputMessagesFilterMusic
    | Raw.InputMessagesFilterChatPhotos
    | Raw.InputMessagesFilterPhoneCalls
    | Raw.InputMessagesFilterRoundVoice
    | Raw.InputMessagesFilterRoundVideo
    | Raw.InputMessagesFilterMyMentions
    | Raw.InputMessagesFilterGeo
    | Raw.InputMessagesFilterContacts
    | Raw.InputMessagesFilterPinned;
  export type TypeEmojiKeyword = Raw.EmojiKeyword | Raw.EmojiKeywordDeleted;
  export type TypeAutoDownloadSettings = Raw.AutoDownloadSettings;
  export type TypePollAnswerVoters = Raw.PollAnswerVoters;
  export type TypePollAnswer = Raw.PollAnswer;
  export type TypePageTableCell = Raw.PageTableCell;
  export type TypeJSONObjectValue = Raw.JsonObjectValue;
  export type TypeJSONValue =
    | Raw.JsonNull
    | Raw.JsonBool
    | Raw.JsonNumber
    | Raw.JsonString
    | Raw.JsonArray
    | Raw.JsonObject;
  export type TypeSecureValueError =
    | Raw.SecureValueErrorData
    | Raw.SecureValueErrorFrontSide
    | Raw.SecureValueErrorReverseSide
    | Raw.SecureValueErrorSelfie
    | Raw.SecureValueErrorFile
    | Raw.SecureValueErrorFiles
    | Raw.SecureValueError
    | Raw.SecureValueErrorTranslationFile
    | Raw.SecureValueErrorTranslationFiles;
  export type TypeSecureRequiredType = Raw.SecureRequiredType | Raw.SecureRequiredTypeOneOf;
  export type TypeInputSecureFile = Raw.InputSecureFileUploaded | Raw.InputSecureFile;
  export type TypeSecurePlainData = Raw.SecurePlainPhone | Raw.SecurePlainEmail;
  export type TypeSecureFile = Raw.SecureFileEmpty | Raw.SecureFile;
  export type TypeSecureData = Raw.SecureData;
  export type TypeWebAuthorization = Raw.WebAuthorization;
  export type TypeRecentMeUrl =
    | Raw.RecentMeUrlUnknown
    | Raw.RecentMeUrlUser
    | Raw.RecentMeUrlChat
    | Raw.RecentMeUrlChatInvite
    | Raw.RecentMeUrlStickerSet;
  export type TypeChatInvite = Raw.ChatInviteAlready | Raw.ChatInvite | Raw.ChatInvitePeek;
  export type TypeChannelAdminLogEvent = Raw.ChannelAdminLogEvent;
  export type TypeChannelAdminLogEventAction =
    | Raw.ChannelAdminLogEventActionChangeTitle
    | Raw.ChannelAdminLogEventActionChangeAbout
    | Raw.ChannelAdminLogEventActionChangeUsername
    | Raw.ChannelAdminLogEventActionChangePhoto
    | Raw.ChannelAdminLogEventActionToggleInvites
    | Raw.ChannelAdminLogEventActionToggleSignatures
    | Raw.ChannelAdminLogEventActionUpdatePinned
    | Raw.ChannelAdminLogEventActionEditMessage
    | Raw.ChannelAdminLogEventActionDeleteMessage
    | Raw.ChannelAdminLogEventActionParticipantJoin
    | Raw.ChannelAdminLogEventActionParticipantLeave
    | Raw.ChannelAdminLogEventActionParticipantInvite
    | Raw.ChannelAdminLogEventActionParticipantToggleBan
    | Raw.ChannelAdminLogEventActionParticipantToggleAdmin
    | Raw.ChannelAdminLogEventActionChangeStickerSet
    | Raw.ChannelAdminLogEventActionTogglePreHistoryHidden
    | Raw.ChannelAdminLogEventActionDefaultBannedRights
    | Raw.ChannelAdminLogEventActionStopPoll
    | Raw.ChannelAdminLogEventActionChangeLinkedChat
    | Raw.ChannelAdminLogEventActionChangeLocation
    | Raw.ChannelAdminLogEventActionToggleSlowMode
    | Raw.ChannelAdminLogEventActionStartGroupCall
    | Raw.ChannelAdminLogEventActionDiscardGroupCall
    | Raw.ChannelAdminLogEventActionParticipantMute
    | Raw.ChannelAdminLogEventActionParticipantUnmute
    | Raw.ChannelAdminLogEventActionToggleGroupCallSetting
    | Raw.ChannelAdminLogEventActionParticipantJoinByInvite
    | Raw.ChannelAdminLogEventActionExportedInviteDelete
    | Raw.ChannelAdminLogEventActionExportedInviteRevoke
    | Raw.ChannelAdminLogEventActionExportedInviteEdit
    | Raw.ChannelAdminLogEventActionParticipantVolume
    | Raw.ChannelAdminLogEventActionChangeHistoryTTL
    | Raw.ChannelAdminLogEventActionParticipantJoinByRequest
    | Raw.ChannelAdminLogEventActionToggleNoForwards
    | Raw.ChannelAdminLogEventActionSendMessage
    | Raw.ChannelAdminLogEventActionChangeAvailableReactions
    | Raw.ChannelAdminLogEventActionChangeUsernames
    | Raw.ChannelAdminLogEventActionToggleForum
    | Raw.ChannelAdminLogEventActionCreateTopic
    | Raw.ChannelAdminLogEventActionEditTopic
    | Raw.ChannelAdminLogEventActionDeleteTopic
    | Raw.ChannelAdminLogEventActionPinTopic
    | Raw.ChannelAdminLogEventActionToggleAntiSpam
    | Raw.ChannelAdminLogEventActionChangeColor
    | Raw.ChannelAdminLogEventActionChangeBackgroundEmoji;
  export type TypeLangPackString =
    | Raw.LangPackString
    | Raw.LangPackStringPluralized
    | Raw.LangPackStringDeleted;
  export type TypeCdnPublicKey = Raw.CdnPublicKey;
  export type TypePhoneConnection = Raw.PhoneConnection | Raw.PhoneConnectionWebrtc;
  export type TypePhoneCallProtocol = Raw.PhoneCallProtocol;
  export type TypeUpdates =
    | Raw.UpdatesTooLong
    | Raw.UpdateShortMessage
    | Raw.UpdateShortChatMessage
    | Raw.UpdateShort
    | Raw.UpdatesCombined
    | Raw.Updates
    | Raw.UpdateShortSentMessage;
  export type TypeShippingOption = Raw.ShippingOption;
  export type TypePaymentSavedCredentials = Raw.PaymentSavedCredentialsCard;
  export type TypePaymentFormMethod = Raw.PaymentFormMethod;
  export type TypeLabeledPrice = Raw.LabeledPrice;
  export type TypePageRelatedArticle = Raw.PageRelatedArticle;
  export type TypePageListOrderedItem = Raw.PageListOrderedItemText | Raw.PageListOrderedItemBlocks;
  export type TypePageTableRow = Raw.PageTableRow;
  export type TypePageBlock =
    | Raw.PageBlockUnsupported
    | Raw.PageBlockTitle
    | Raw.PageBlockSubtitle
    | Raw.PageBlockAuthorDate
    | Raw.PageBlockHeader
    | Raw.PageBlockSubheader
    | Raw.PageBlockParagraph
    | Raw.PageBlockPreformatted
    | Raw.PageBlockFooter
    | Raw.PageBlockDivider
    | Raw.PageBlockAnchor
    | Raw.PageBlockList
    | Raw.PageBlockBlockquote
    | Raw.PageBlockPullquote
    | Raw.PageBlockPhoto
    | Raw.PageBlockVideo
    | Raw.PageBlockCover
    | Raw.PageBlockEmbed
    | Raw.PageBlockEmbedPost
    | Raw.PageBlockCollage
    | Raw.PageBlockSlideshow
    | Raw.PageBlockChannel
    | Raw.PageBlockAudio
    | Raw.PageBlockKicker
    | Raw.PageBlockTable
    | Raw.PageBlockOrderedList
    | Raw.PageBlockDetails
    | Raw.PageBlockRelatedArticles
    | Raw.PageBlockMap;
  export type TypePageCaption = Raw.PageCaption;
  export type TypePageListItem = Raw.PageListItemText | Raw.PageListItemBlocks;
  export type TypeRichText =
    | Raw.TextEmpty
    | Raw.TextPlain
    | Raw.TextBold
    | Raw.TextItalic
    | Raw.TextUnderline
    | Raw.TextStrike
    | Raw.TextFixed
    | Raw.TextUrl
    | Raw.TextEmail
    | Raw.TextConcat
    | Raw.TextSubscript
    | Raw.TextSuperscript
    | Raw.TextMarked
    | Raw.TextPhone
    | Raw.TextImage
    | Raw.TextAnchor;
  export type TypeHighScore = Raw.HighScore;
  export type TypeStickerSetCovered =
    | Raw.StickerSetCovered
    | Raw.StickerSetMultiCovered
    | Raw.StickerSetFullCovered
    | Raw.StickerSetNoCovered;
  export type TypeInputReplyTo = Raw.InputReplyToMessage | Raw.InputReplyToStory;
  export type TypeTopPeerCategoryPeers = Raw.TopPeerCategoryPeers;
  export type TypeTopPeer = Raw.TopPeer;
  export type TypeTopPeerCategory =
    | Raw.TopPeerCategoryBotsPM
    | Raw.TopPeerCategoryBotsInline
    | Raw.TopPeerCategoryCorrespondents
    | Raw.TopPeerCategoryGroups
    | Raw.TopPeerCategoryChannels
    | Raw.TopPeerCategoryPhoneCalls
    | Raw.TopPeerCategoryForwardUsers
    | Raw.TopPeerCategoryForwardChats;
  export type TypeBotInlineResult = Raw.BotInlineResult | Raw.BotInlineMediaResult;
  export type TypeInlineBotWebView = Raw.InlineBotWebView;
  export type TypeInlineBotSwitchPM = Raw.InlineBotSwitchPM;
  export type TypeBotInlineMessage =
    | Raw.BotInlineMessageMediaAuto
    | Raw.BotInlineMessageText
    | Raw.BotInlineMessageMediaGeo
    | Raw.BotInlineMessageMediaVenue
    | Raw.BotInlineMessageMediaContact
    | Raw.BotInlineMessageMediaInvoice
    | Raw.BotInlineMessageMediaWebPage;
  export type TypeInputBotInlineMessage =
    | Raw.InputBotInlineMessageMediaAuto
    | Raw.InputBotInlineMessageText
    | Raw.InputBotInlineMessageMediaGeo
    | Raw.InputBotInlineMessageMediaVenue
    | Raw.InputBotInlineMessageMediaContact
    | Raw.InputBotInlineMessageGame
    | Raw.InputBotInlineMessageMediaInvoice
    | Raw.InputBotInlineMessageMediaWebPage;
  export type TypeMessageRange = Raw.MessageRange;
  export type TypeKeyboardButtonRow = Raw.KeyboardButtonRow;
  export type TypeKeyboardButton =
    | Raw.KeyboardButton
    | Raw.KeyboardButtonUrl
    | Raw.KeyboardButtonCallback
    | Raw.KeyboardButtonRequestPhone
    | Raw.KeyboardButtonRequestGeoLocation
    | Raw.KeyboardButtonSwitchInline
    | Raw.KeyboardButtonGame
    | Raw.KeyboardButtonBuy
    | Raw.KeyboardButtonUrlAuth
    | Raw.InputKeyboardButtonUrlAuth
    | Raw.KeyboardButtonRequestPoll
    | Raw.InputKeyboardButtonUserProfile
    | Raw.KeyboardButtonUserProfile
    | Raw.KeyboardButtonWebView
    | Raw.KeyboardButtonSimpleWebView
    | Raw.KeyboardButtonRequestPeer;
  export type TypeRequestPeerType =
    | Raw.RequestPeerTypeUser
    | Raw.RequestPeerTypeChat
    | Raw.RequestPeerTypeBroadcast;
  export type TypeStickerKeyword = Raw.StickerKeyword;
  export type TypeStickerPack = Raw.StickerPack;
  export type TypeSecureSecretSettings = Raw.SecureSecretSettings;
  export type TypeSecurePasswordKdfAlgo =
    | Raw.SecurePasswordKdfAlgoUnknown
    | Raw.SecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000
    | Raw.SecurePasswordKdfAlgoSHA512;
  export type TypePasswordKdfAlgo =
    | Raw.PasswordKdfAlgoUnknown
    | Raw.PasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow;
  export type TypeAuthorization = Raw.Authorization;
  export type TypeWebPageAttribute = Raw.WebPageAttributeTheme | Raw.WebPageAttributeStory;
  export type TypePage = Raw.Page;
  export type TypeMaskCoords = Raw.MaskCoords;
  export type TypeInputUser =
    | Raw.InputUserEmpty
    | Raw.InputUserSelf
    | Raw.InputUser
    | Raw.InputUserFromMessage;
  export type TypeEncryptedFile = Raw.EncryptedFileEmpty | Raw.EncryptedFile;
  export type TypeFileHash = Raw.FileHash;
  export type TypeUpdate =
    | Raw.UpdateNewMessage
    | Raw.UpdateMessageID
    | Raw.UpdateDeleteMessages
    | Raw.UpdateUserTyping
    | Raw.UpdateChatUserTyping
    | Raw.UpdateChatParticipants
    | Raw.UpdateUserStatus
    | Raw.UpdateUserName
    | Raw.UpdateNewAuthorization
    | Raw.UpdateNewEncryptedMessage
    | Raw.UpdateEncryptedChatTyping
    | Raw.UpdateEncryption
    | Raw.UpdateEncryptedMessagesRead
    | Raw.UpdateChatParticipantAdd
    | Raw.UpdateChatParticipantDelete
    | Raw.UpdateDcOptions
    | Raw.UpdateNotifySettings
    | Raw.UpdateServiceNotification
    | Raw.UpdatePrivacy
    | Raw.UpdateUserPhone
    | Raw.UpdateReadHistoryInbox
    | Raw.UpdateReadHistoryOutbox
    | Raw.UpdateWebPage
    | Raw.UpdateReadMessagesContents
    | Raw.UpdateChannelTooLong
    | Raw.UpdateChannel
    | Raw.UpdateNewChannelMessage
    | Raw.UpdateReadChannelInbox
    | Raw.UpdateDeleteChannelMessages
    | Raw.UpdateChannelMessageViews
    | Raw.UpdateChatParticipantAdmin
    | Raw.UpdateNewStickerSet
    | Raw.UpdateStickerSetsOrder
    | Raw.UpdateStickerSets
    | Raw.UpdateSavedGifs
    | Raw.UpdateBotInlineQuery
    | Raw.UpdateBotInlineSend
    | Raw.UpdateEditChannelMessage
    | Raw.UpdateBotCallbackQuery
    | Raw.UpdateEditMessage
    | Raw.UpdateInlineBotCallbackQuery
    | Raw.UpdateReadChannelOutbox
    | Raw.UpdateDraftMessage
    | Raw.UpdateReadFeaturedStickers
    | Raw.UpdateRecentStickers
    | Raw.UpdateConfig
    | Raw.UpdatePtsChanged
    | Raw.UpdateChannelWebPage
    | Raw.UpdateDialogPinned
    | Raw.UpdatePinnedDialogs
    | Raw.UpdateBotWebhookJSON
    | Raw.UpdateBotWebhookJSONQuery
    | Raw.UpdateBotShippingQuery
    | Raw.UpdateBotPrecheckoutQuery
    | Raw.UpdatePhoneCall
    | Raw.UpdateLangPackTooLong
    | Raw.UpdateLangPack
    | Raw.UpdateFavedStickers
    | Raw.UpdateChannelReadMessagesContents
    | Raw.UpdateContactsReset
    | Raw.UpdateChannelAvailableMessages
    | Raw.UpdateDialogUnreadMark
    | Raw.UpdateMessagePoll
    | Raw.UpdateChatDefaultBannedRights
    | Raw.UpdateFolderPeers
    | Raw.UpdatePeerSettings
    | Raw.UpdatePeerLocated
    | Raw.UpdateNewScheduledMessage
    | Raw.UpdateDeleteScheduledMessages
    | Raw.UpdateTheme
    | Raw.UpdateGeoLiveViewed
    | Raw.UpdateLoginToken
    | Raw.UpdateMessagePollVote
    | Raw.UpdateDialogFilter
    | Raw.UpdateDialogFilterOrder
    | Raw.UpdateDialogFilters
    | Raw.UpdatePhoneCallSignalingData
    | Raw.UpdateChannelMessageForwards
    | Raw.UpdateReadChannelDiscussionInbox
    | Raw.UpdateReadChannelDiscussionOutbox
    | Raw.UpdatePeerBlocked
    | Raw.UpdateChannelUserTyping
    | Raw.UpdatePinnedMessages
    | Raw.UpdatePinnedChannelMessages
    | Raw.UpdateChat
    | Raw.UpdateGroupCallParticipants
    | Raw.UpdateGroupCall
    | Raw.UpdatePeerHistoryTTL
    | Raw.UpdateChatParticipant
    | Raw.UpdateChannelParticipant
    | Raw.UpdateBotStopped
    | Raw.UpdateGroupCallConnection
    | Raw.UpdateBotCommands
    | Raw.UpdatePendingJoinRequests
    | Raw.UpdateBotChatInviteRequester
    | Raw.UpdateMessageReactions
    | Raw.UpdateAttachMenuBots
    | Raw.UpdateWebViewResultSent
    | Raw.UpdateBotMenuButton
    | Raw.UpdateSavedRingtones
    | Raw.UpdateTranscribedAudio
    | Raw.UpdateReadFeaturedEmojiStickers
    | Raw.UpdateUserEmojiStatus
    | Raw.UpdateRecentEmojiStatuses
    | Raw.UpdateRecentReactions
    | Raw.UpdateMoveStickerSetToTop
    | Raw.UpdateMessageExtendedMedia
    | Raw.UpdateChannelPinnedTopic
    | Raw.UpdateChannelPinnedTopics
    | Raw.UpdateUser
    | Raw.UpdateAutoSaveSettings
    | Raw.UpdateGroupInvitePrivacyForbidden
    | Raw.UpdateStory
    | Raw.UpdateReadStories
    | Raw.UpdateStoryID
    | Raw.UpdateStoriesStealthMode
    | Raw.UpdateSentStoryReaction
    | UpdateSecretChatMessage;
  export type TypeReaction = Raw.ReactionEmpty | Raw.ReactionEmoji | Raw.ReactionCustomEmoji;
  export type TypeStoriesStealthMode = Raw.StoriesStealthMode;
  export type TypeBotMenuButton =
    | Raw.BotMenuButtonDefault
    | Raw.BotMenuButtonCommands
    | Raw.BotMenuButton;
  export type TypeBotCommand = Raw.BotCommand;
  export type TypeChannelParticipant =
    | Raw.ChannelParticipant
    | Raw.ChannelParticipantSelf
    | Raw.ChannelParticipantCreator
    | Raw.ChannelParticipantAdmin
    | Raw.ChannelParticipantBanned
    | Raw.ChannelParticipantLeft;
  export type TypeGroupCall = Raw.GroupCallDiscarded | Raw.GroupCall;
  export type TypeGroupCallParticipant = Raw.GroupCallParticipant;
  export type TypeDialogFilter =
    | Raw.DialogFilter
    | Raw.DialogFilterDefault
    | Raw.DialogFilterChatlist;
  export type TypeTheme = Raw.Theme;
  export type TypePeerLocated = Raw.PeerLocated | Raw.PeerSelfLocated;
  export type TypeFolderPeer = Raw.FolderPeer;
  export type TypeLangPackDifference = Raw.LangPackDifference;
  export type TypePhoneCall =
    | Raw.PhoneCallEmpty
    | Raw.PhoneCallWaiting
    | Raw.PhoneCallRequested
    | Raw.PhoneCallAccepted
    | Raw.PhoneCall
    | Raw.PhoneCallDiscarded;
  export type TypePostAddress = Raw.PostAddress;
  export type TypeDialogPeer = Raw.DialogPeer | Raw.DialogPeerFolder;
  export type TypeInputBotInlineMessageID =
    | Raw.InputBotInlineMessageID
    | Raw.InputBotInlineMessageID64;
  export type TypeInlineQueryPeerType =
    | Raw.InlineQueryPeerTypeSameBotPM
    | Raw.InlineQueryPeerTypePM
    | Raw.InlineQueryPeerTypeChat
    | Raw.InlineQueryPeerTypeMegagroup
    | Raw.InlineQueryPeerTypeBroadcast
    | Raw.InlineQueryPeerTypeBotPM;
  export type TypePrivacyRule =
    | Raw.PrivacyValueAllowContacts
    | Raw.PrivacyValueAllowAll
    | Raw.PrivacyValueAllowUsers
    | Raw.PrivacyValueDisallowContacts
    | Raw.PrivacyValueDisallowAll
    | Raw.PrivacyValueDisallowUsers
    | Raw.PrivacyValueAllowChatParticipants
    | Raw.PrivacyValueDisallowChatParticipants
    | Raw.PrivacyValueAllowCloseFriends;
  export type TypePrivacyKey =
    | Raw.PrivacyKeyStatusTimestamp
    | Raw.PrivacyKeyChatInvite
    | Raw.PrivacyKeyPhoneCall
    | Raw.PrivacyKeyPhoneP2P
    | Raw.PrivacyKeyForwards
    | Raw.PrivacyKeyProfilePhoto
    | Raw.PrivacyKeyPhoneNumber
    | Raw.PrivacyKeyAddedByPhone
    | Raw.PrivacyKeyVoiceMessages
    | Raw.PrivacyKeyAbout;
  export type TypeNotifyPeer =
    | Raw.NotifyPeer
    | Raw.NotifyUsers
    | Raw.NotifyChats
    | Raw.NotifyBroadcasts
    | Raw.NotifyForumTopic;
  export type TypeDcOption = Raw.DcOption;
  export type TypeEncryptedChat =
    | Raw.EncryptedChatEmpty
    | Raw.EncryptedChatWaiting
    | Raw.EncryptedChatRequested
    | Raw.EncryptedChat
    | Raw.EncryptedChatDiscarded;
  export type TypeEncryptedMessage = Raw.EncryptedMessage | Raw.EncryptedMessageService;
  export type TypeSendMessageAction =
    | Raw.SendMessageTypingAction
    | Raw.SendMessageCancelAction
    | Raw.SendMessageRecordVideoAction
    | Raw.SendMessageUploadVideoAction
    | Raw.SendMessageRecordAudioAction
    | Raw.SendMessageUploadAudioAction
    | Raw.SendMessageUploadPhotoAction
    | Raw.SendMessageUploadDocumentAction
    | Raw.SendMessageGeoLocationAction
    | Raw.SendMessageChooseContactAction
    | Raw.SendMessageGamePlayAction
    | Raw.SendMessageRecordRoundAction
    | Raw.SendMessageUploadRoundAction
    | Raw.SpeakingInGroupCallAction
    | Raw.SendMessageHistoryImportAction
    | Raw.SendMessageChooseStickerAction
    | Raw.SendMessageEmojiInteraction
    | Raw.SendMessageEmojiInteractionSeen
    | Raw.SendMessageUploadVideoAction17
    | Raw.SendMessageUploadAudioAction17
    | Raw.SendMessageUploadPhotoAction17
    | Raw.SendMessageUploadDocumentAction17
    | Raw.SendMessageUploadRoundAction66;
  export type TypeChatFull = Raw.ChatFull | Raw.ChannelFull;
  export type TypeForumTopic = Raw.ForumTopicDeleted | Raw.ForumTopic;
  export type TypeMessage = Raw.MessageEmpty | Raw.Message | Raw.MessageService;
  export type TypeDialog = Raw.Dialog | Raw.DialogFolder;
  export type TypeChat =
    | Raw.ChatEmpty
    | Raw.Chat
    | Raw.ChatForbidden
    | Raw.Channel
    | Raw.ChannelForbidden;
  export type TypePeerBlocked = Raw.PeerBlocked;
  export type TypePopularContact = Raw.PopularContact;
  export type TypeImportedContact = Raw.ImportedContact;
  export type TypeContact = Raw.Contact;
  export type TypePremiumGiftOption = Raw.PremiumGiftOption;
  export type TypePeerSettings = Raw.PeerSettings;
  export type TypeWallPaperSettings = Raw.WallPaperSettings;
  export type TypeNotificationSound =
    | Raw.NotificationSoundDefault
    | Raw.NotificationSoundNone
    | Raw.NotificationSoundLocal
    | Raw.NotificationSoundRingtone;
  export type TypeUser = Raw.UserEmpty | Raw.User;
  export type TypePhotoSize =
    | Raw.PhotoSizeEmpty
    | Raw.PhotoSize
    | Raw.PhotoCachedSize
    | Raw.PhotoStrippedSize
    | Raw.PhotoSizeProgressive
    | Raw.PhotoPathSize
    | Raw.PhotoSize23
    | Raw.PhotoCachedSize23;
  export type TypeFolder = Raw.Folder;
  export type TypeDraftMessage = Raw.DraftMessageEmpty | Raw.DraftMessage;
  export type TypeWallPaper = Raw.WallPaper | Raw.WallPaperNoFile;
  export type TypeSecureValueType =
    | Raw.SecureValueTypePersonalDetails
    | Raw.SecureValueTypePassport
    | Raw.SecureValueTypeDriverLicense
    | Raw.SecureValueTypeIdentityCard
    | Raw.SecureValueTypeInternalPassport
    | Raw.SecureValueTypeAddress
    | Raw.SecureValueTypeUtilityBill
    | Raw.SecureValueTypeBankStatement
    | Raw.SecureValueTypeRentalAgreement
    | Raw.SecureValueTypePassportRegistration
    | Raw.SecureValueTypeTemporaryRegistration
    | Raw.SecureValueTypePhone
    | Raw.SecureValueTypeEmail;
  export type TypeSecureCredentialsEncrypted = Raw.SecureCredentialsEncrypted;
  export type TypeSecureValue = Raw.SecureValue;
  export type TypeBotApp = Raw.BotAppNotModified | Raw.BotApp;
  export type TypePhoneCallDiscardReason =
    | Raw.PhoneCallDiscardReasonMissed
    | Raw.PhoneCallDiscardReasonDisconnect
    | Raw.PhoneCallDiscardReasonHangup
    | Raw.PhoneCallDiscardReasonBusy;
  export type TypePaymentCharge = Raw.PaymentCharge;
  export type TypePaymentRequestedInfo = Raw.PaymentRequestedInfo;
  export type TypeStoryItem = Raw.StoryItemDeleted | Raw.StoryItemSkipped | Raw.StoryItem;
  export type TypePollResults = Raw.PollResults;
  export type TypeMessageExtendedMedia = Raw.MessageExtendedMediaPreview | Raw.MessageExtendedMedia;
  export type TypeWebDocument = Raw.WebDocument | Raw.WebDocumentNoProxy;
  export type TypeGame = Raw.Game;
  export type TypeWebPage =
    | Raw.WebPageEmpty
    | Raw.WebPagePending
    | Raw.WebPage
    | Raw.WebPageNotModified;
  export type TypeDocument = Raw.DocumentEmpty | Raw.Document;
  export type TypeGeoPoint = Raw.GeoPointEmpty | Raw.GeoPoint;
  export type TypeMessageAction =
    | Raw.MessageActionEmpty
    | Raw.MessageActionChatCreate
    | Raw.MessageActionChatEditTitle
    | Raw.MessageActionChatEditPhoto
    | Raw.MessageActionChatDeletePhoto
    | Raw.MessageActionChatAddUser
    | Raw.MessageActionChatDeleteUser
    | Raw.MessageActionChatJoinedByLink
    | Raw.MessageActionChannelCreate
    | Raw.MessageActionChatMigrateTo
    | Raw.MessageActionChannelMigrateFrom
    | Raw.MessageActionPinMessage
    | Raw.MessageActionHistoryClear
    | Raw.MessageActionGameScore
    | Raw.MessageActionPaymentSentMe
    | Raw.MessageActionPaymentSent
    | Raw.MessageActionPhoneCall
    | Raw.MessageActionScreenshotTaken
    | Raw.MessageActionCustomAction
    | Raw.MessageActionBotAllowed
    | Raw.MessageActionSecureValuesSentMe
    | Raw.MessageActionSecureValuesSent
    | Raw.MessageActionContactSignUp
    | Raw.MessageActionGeoProximityReached
    | Raw.MessageActionGroupCall
    | Raw.MessageActionInviteToGroupCall
    | Raw.MessageActionSetMessagesTTL
    | Raw.MessageActionGroupCallScheduled
    | Raw.MessageActionSetChatTheme
    | Raw.MessageActionChatJoinedByRequest
    | Raw.MessageActionWebViewDataSentMe
    | Raw.MessageActionWebViewDataSent
    | Raw.MessageActionGiftPremium
    | Raw.MessageActionTopicCreate
    | Raw.MessageActionTopicEdit
    | Raw.MessageActionSuggestProfilePhoto
    | Raw.MessageActionRequestedPeer
    | Raw.MessageActionSetChatWallPaper
    | Raw.MessageActionSetSameChatWallPaper
    | Raw.MessageActionGiftCode
    | Raw.MessageActionGiveawayLaunch;
  export type TypeMessageReactions = Raw.MessageReactions;
  export type TypeMessageReplies = Raw.MessageReplies;
  export type TypeReplyMarkup =
    | Raw.ReplyKeyboardHide
    | Raw.ReplyKeyboardForceReply
    | Raw.ReplyKeyboardMarkup
    | Raw.ReplyInlineMarkup;
  export type TypeMessageMedia =
    | Raw.MessageMediaEmpty
    | Raw.MessageMediaPhoto
    | Raw.MessageMediaGeo
    | Raw.MessageMediaContact
    | Raw.MessageMediaUnsupported
    | Raw.MessageMediaDocument
    | Raw.MessageMediaWebPage
    | Raw.MessageMediaVenue
    | Raw.MessageMediaGame
    | Raw.MessageMediaInvoice
    | Raw.MessageMediaGeoLive
    | Raw.MessageMediaPoll
    | Raw.MessageMediaDice
    | Raw.MessageMediaStory
    | Raw.MessageMediaGiveaway;
  export type TypeMessageReplyHeader = Raw.MessageReplyHeader | Raw.MessageReplyStoryHeader;
  export type TypeMessageFwdHeader = Raw.MessageFwdHeader;
  export type TypeChatParticipant =
    | Raw.ChatParticipant
    | Raw.ChatParticipantCreator
    | Raw.ChatParticipantAdmin;
  export type TypePeerStories = Raw.PeerStories;
  export type TypeChannelLocation = Raw.ChannelLocationEmpty | Raw.ChannelLocation;
  export type TypeStickerSet = Raw.StickerSet;
  export type TypeChatReactions =
    | Raw.ChatReactionsNone
    | Raw.ChatReactionsAll
    | Raw.ChatReactionsSome;
  export type TypePeer = Raw.PeerUser | Raw.PeerChat | Raw.PeerChannel;
  export type TypeBotInfo = Raw.BotInfo;
  export type TypeExportedChatInvite = Raw.ChatInviteExported | Raw.ChatInvitePublicJoinRequests;
  export type TypePeerNotifySettings = Raw.PeerNotifySettings;
  export type TypePhoto = Raw.PhotoEmpty | Raw.Photo;
  export type TypeChatParticipants = Raw.ChatParticipantsForbidden | Raw.ChatParticipants;
  export type TypeChatBannedRights = Raw.ChatBannedRights;
  export type TypeChatAdminRights = Raw.ChatAdminRights;
  export type TypeInputChannel =
    | Raw.InputChannelEmpty
    | Raw.InputChannel
    | Raw.InputChannelFromMessage;
  export type TypeChatPhoto = Raw.ChatPhotoEmpty | Raw.ChatPhoto;
  export type TypeUsername = Raw.Username;
  export type TypeEmojiStatus = Raw.EmojiStatusEmpty | Raw.EmojiStatus | Raw.EmojiStatusUntil;
  export type TypeRestrictionReason = Raw.RestrictionReason;
  export type TypeUserStatus =
    | Raw.UserStatusEmpty
    | Raw.UserStatusOnline
    | Raw.UserStatusOffline
    | Raw.UserStatusRecently
    | Raw.UserStatusLastWeek
    | Raw.UserStatusLastMonth;
  export type TypeUserProfilePhoto = Raw.UserProfilePhotoEmpty | Raw.UserProfilePhoto;
  export type TypeInputGroupCall = Raw.InputGroupCall;
  export type TypeInputStickerSet =
    | Raw.InputStickerSetEmpty
    | Raw.InputStickerSetID
    | Raw.InputStickerSetShortName
    | Raw.InputStickerSetAnimatedEmoji
    | Raw.InputStickerSetDice
    | Raw.InputStickerSetAnimatedEmojiAnimations
    | Raw.InputStickerSetPremiumGifts
    | Raw.InputStickerSetEmojiGenericAnimations
    | Raw.InputStickerSetEmojiDefaultStatuses
    | Raw.InputStickerSetEmojiDefaultTopicIcons;
  export type TypeVideoSize = Raw.VideoSize | Raw.VideoSizeEmojiMarkup | Raw.VideoSizeStickerMarkup;
  export type TypeMessageEntity =
    | Raw.MessageEntityUnknown
    | Raw.MessageEntityMention
    | Raw.MessageEntityHashtag
    | Raw.MessageEntityBotCommand
    | Raw.MessageEntityUrl
    | Raw.MessageEntityEmail
    | Raw.MessageEntityBold
    | Raw.MessageEntityItalic
    | Raw.MessageEntityCode
    | Raw.MessageEntityPre
    | Raw.MessageEntityTextUrl
    | Raw.MessageEntityMentionName
    | Raw.InputMessageEntityMentionName
    | Raw.MessageEntityPhone
    | Raw.MessageEntityCashtag
    | Raw.MessageEntityUnderline
    | Raw.MessageEntityStrike
    | Raw.MessageEntityBankCard
    | Raw.MessageEntitySpoiler
    | Raw.MessageEntityCustomEmoji
    | Raw.MessageEntityBlockquote;
  export type TypePoll = Raw.Poll;
  export type TypeInputMedia =
    | Raw.InputMediaEmpty
    | Raw.InputMediaUploadedPhoto
    | Raw.InputMediaPhoto
    | Raw.InputMediaGeoPoint
    | Raw.InputMediaContact
    | Raw.InputMediaUploadedDocument
    | Raw.InputMediaDocument
    | Raw.InputMediaVenue
    | Raw.InputMediaPhotoExternal
    | Raw.InputMediaDocumentExternal
    | Raw.InputMediaGame
    | Raw.InputMediaInvoice
    | Raw.InputMediaGeoLive
    | Raw.InputMediaPoll
    | Raw.InputMediaDice
    | Raw.InputMediaStory
    | Raw.InputMediaWebPage;
  export type TypeDataJSON = Raw.DataJSON;
  export type TypeInvoice = Raw.Invoice;
  export type TypeInputWebDocument = Raw.InputWebDocument;
  export type TypeInputGame = Raw.InputGameID | Raw.InputGameShortName;
  export type TypeDocumentAttribute =
    | Raw.DocumentAttributeImageSize
    | Raw.DocumentAttributeAnimated
    | Raw.DocumentAttributeSticker
    | Raw.DocumentAttributeVideo
    | Raw.DocumentAttributeAudio
    | Raw.DocumentAttributeFilename
    | Raw.DocumentAttributeHasStickers
    | Raw.DocumentAttributeCustomEmoji
    | Raw.DocumentAttributeSticker23
    | Raw.DocumentAttributeVideo23
    | Raw.DocumentAttributeAudio23
    | Raw.DocumentAttributeSticker45
    | Raw.DocumentAttributeAudio45
    | Raw.DocumentAttributeVideo66;
  export type TypeInputGeoPoint = Raw.InputGeoPointEmpty | Raw.InputGeoPoint;
  export type TypeInputPhoto = Raw.InputPhotoEmpty | Raw.InputPhoto;
  export type TypeInputDocument = Raw.InputDocumentEmpty | Raw.InputDocument;
  export type TypeInputFile = Raw.InputFile | Raw.InputFileBig;
  export type TypeInputPeer =
    | Raw.InputPeerEmpty
    | Raw.InputPeerSelf
    | Raw.InputPeerChat
    | Raw.InputPeerUser
    | Raw.InputPeerChannel
    | Raw.InputPeerUserFromMessage
    | Raw.InputPeerChannelFromMessage;
  export type TypeDestroySessionRes = Raw.DestroySessionOk | Raw.DestroySessionNone;
  export type TypePong = Raw.Pong;
  export type TypeFutureSalts = Raw.FutureSalts;
  export type TypeRpcDropAnswer =
    | Raw.RpcAnswerUnknown
    | Raw.RpcAnswerDroppedRunning
    | Raw.RpcAnswerDropped;
  export type TypeAccessPointRule = Raw.AccessPointRule;
  export type TypeIpPort = Raw.IpPort | Raw.IpPortSecret;
  export type TypeFutureSalt = Raw.FutureSalt;
  export type TypeDestroyAuthKeyRes =
    | Raw.DestroyAuthKeyOk
    | Raw.DestroyAuthKeyNone
    | Raw.DestroyAuthKeyFail;
  export type TypeSetClientDhParamsAnswer = Raw.DhGenOk | Raw.DhGenRetry | Raw.DhGenFail;
  export type TypeServerDhParams = Raw.ServerDhParamsFail | Raw.ServerDhParamsOk;
  export type TypeResPQ = Raw.ResPQ;
  export class ResPQ extends TLObject {
    nonce!: int128;
    serverNonce!: int128;
    pq!: bytes;
    serverPublicKeyFingerprints!: Vector<long>;

    constructor(params: {
      nonce: int128;
      serverNonce: int128;
      pq: bytes;
      serverPublicKeyFingerprints: Vector<long>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ResPQ';
      this.constructorId = 0x05162463;
      this.subclassOfId = 0x786986b8;
      this._slots = ['nonce', 'serverNonce', 'pq', 'serverPublicKeyFingerprints'];
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.pq = params.pq;
      this.serverPublicKeyFingerprints = params.serverPublicKeyFingerprints;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ResPQ> {
      // no flags

      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let pq = await Primitive.Bytes.read(b);
      let serverPublicKeyFingerprints = await TLObject.read(b, Primitive.Long);
      return new Raw.ResPQ({
        nonce: nonce,
        serverNonce: serverNonce,
        pq: pq,
        serverPublicKeyFingerprints: serverPublicKeyFingerprints,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.pq !== undefined) {
        b.write(Primitive.Bytes.write(this.pq) as unknown as Buffer);
      }
      if (this.serverPublicKeyFingerprints) {
        b.write(
          Primitive.Vector.write(
            this.serverPublicKeyFingerprints,
            Primitive.Long,
          ) as unknown as Buffer,
        );
      }
      return b.buffer;
    }
  }
  export class PQInnerData extends TLObject {
    pq!: bytes;
    p!: bytes;
    q!: bytes;
    nonce!: int128;
    serverNonce!: int128;
    newNonce!: int256;

    constructor(params: {
      pq: bytes;
      p: bytes;
      q: bytes;
      nonce: int128;
      serverNonce: int128;
      newNonce: int256;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PQInnerData';
      this.constructorId = 0x83c95aec;
      this.subclassOfId = 0x41701377;
      this._slots = ['pq', 'p', 'q', 'nonce', 'serverNonce', 'newNonce'];
      this.pq = params.pq;
      this.p = params.p;
      this.q = params.q;
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.newNonce = params.newNonce;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PQInnerData> {
      // no flags

      let pq = await Primitive.Bytes.read(b);
      let p = await Primitive.Bytes.read(b);
      let q = await Primitive.Bytes.read(b);
      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let newNonce = await Primitive.Int256.read(b);
      return new Raw.PQInnerData({
        pq: pq,
        p: p,
        q: q,
        nonce: nonce,
        serverNonce: serverNonce,
        newNonce: newNonce,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.pq !== undefined) {
        b.write(Primitive.Bytes.write(this.pq) as unknown as Buffer);
      }
      if (this.p !== undefined) {
        b.write(Primitive.Bytes.write(this.p) as unknown as Buffer);
      }
      if (this.q !== undefined) {
        b.write(Primitive.Bytes.write(this.q) as unknown as Buffer);
      }
      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.newNonce !== undefined) {
        b.write(Primitive.Int256.write(this.newNonce) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PQInnerDataDc extends TLObject {
    pq!: bytes;
    p!: bytes;
    q!: bytes;
    nonce!: int128;
    serverNonce!: int128;
    newNonce!: int256;
    dc!: int;

    constructor(params: {
      pq: bytes;
      p: bytes;
      q: bytes;
      nonce: int128;
      serverNonce: int128;
      newNonce: int256;
      dc: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PQInnerDataDc';
      this.constructorId = 0xa9f55f95;
      this.subclassOfId = 0x41701377;
      this._slots = ['pq', 'p', 'q', 'nonce', 'serverNonce', 'newNonce', 'dc'];
      this.pq = params.pq;
      this.p = params.p;
      this.q = params.q;
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.newNonce = params.newNonce;
      this.dc = params.dc;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PQInnerDataDc> {
      // no flags

      let pq = await Primitive.Bytes.read(b);
      let p = await Primitive.Bytes.read(b);
      let q = await Primitive.Bytes.read(b);
      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let newNonce = await Primitive.Int256.read(b);
      let dc = await Primitive.Int.read(b);
      return new Raw.PQInnerDataDc({
        pq: pq,
        p: p,
        q: q,
        nonce: nonce,
        serverNonce: serverNonce,
        newNonce: newNonce,
        dc: dc,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.pq !== undefined) {
        b.write(Primitive.Bytes.write(this.pq) as unknown as Buffer);
      }
      if (this.p !== undefined) {
        b.write(Primitive.Bytes.write(this.p) as unknown as Buffer);
      }
      if (this.q !== undefined) {
        b.write(Primitive.Bytes.write(this.q) as unknown as Buffer);
      }
      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.newNonce !== undefined) {
        b.write(Primitive.Int256.write(this.newNonce) as unknown as Buffer);
      }
      if (this.dc !== undefined) {
        b.write(Primitive.Int.write(this.dc) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PQInnerDataTemp extends TLObject {
    pq!: bytes;
    p!: bytes;
    q!: bytes;
    nonce!: int128;
    serverNonce!: int128;
    newNonce!: int256;
    expiresIn!: int;

    constructor(params: {
      pq: bytes;
      p: bytes;
      q: bytes;
      nonce: int128;
      serverNonce: int128;
      newNonce: int256;
      expiresIn: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PQInnerDataTemp';
      this.constructorId = 0x3c6a84d4;
      this.subclassOfId = 0x41701377;
      this._slots = ['pq', 'p', 'q', 'nonce', 'serverNonce', 'newNonce', 'expiresIn'];
      this.pq = params.pq;
      this.p = params.p;
      this.q = params.q;
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.newNonce = params.newNonce;
      this.expiresIn = params.expiresIn;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PQInnerDataTemp> {
      // no flags

      let pq = await Primitive.Bytes.read(b);
      let p = await Primitive.Bytes.read(b);
      let q = await Primitive.Bytes.read(b);
      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let newNonce = await Primitive.Int256.read(b);
      let expiresIn = await Primitive.Int.read(b);
      return new Raw.PQInnerDataTemp({
        pq: pq,
        p: p,
        q: q,
        nonce: nonce,
        serverNonce: serverNonce,
        newNonce: newNonce,
        expiresIn: expiresIn,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.pq !== undefined) {
        b.write(Primitive.Bytes.write(this.pq) as unknown as Buffer);
      }
      if (this.p !== undefined) {
        b.write(Primitive.Bytes.write(this.p) as unknown as Buffer);
      }
      if (this.q !== undefined) {
        b.write(Primitive.Bytes.write(this.q) as unknown as Buffer);
      }
      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.newNonce !== undefined) {
        b.write(Primitive.Int256.write(this.newNonce) as unknown as Buffer);
      }
      if (this.expiresIn !== undefined) {
        b.write(Primitive.Int.write(this.expiresIn) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PQInnerDataTempDc extends TLObject {
    pq!: bytes;
    p!: bytes;
    q!: bytes;
    nonce!: int128;
    serverNonce!: int128;
    newNonce!: int256;
    dc!: int;
    expiresIn!: int;

    constructor(params: {
      pq: bytes;
      p: bytes;
      q: bytes;
      nonce: int128;
      serverNonce: int128;
      newNonce: int256;
      dc: int;
      expiresIn: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PQInnerDataTempDc';
      this.constructorId = 0x56fddf88;
      this.subclassOfId = 0x41701377;
      this._slots = ['pq', 'p', 'q', 'nonce', 'serverNonce', 'newNonce', 'dc', 'expiresIn'];
      this.pq = params.pq;
      this.p = params.p;
      this.q = params.q;
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.newNonce = params.newNonce;
      this.dc = params.dc;
      this.expiresIn = params.expiresIn;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PQInnerDataTempDc> {
      // no flags

      let pq = await Primitive.Bytes.read(b);
      let p = await Primitive.Bytes.read(b);
      let q = await Primitive.Bytes.read(b);
      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let newNonce = await Primitive.Int256.read(b);
      let dc = await Primitive.Int.read(b);
      let expiresIn = await Primitive.Int.read(b);
      return new Raw.PQInnerDataTempDc({
        pq: pq,
        p: p,
        q: q,
        nonce: nonce,
        serverNonce: serverNonce,
        newNonce: newNonce,
        dc: dc,
        expiresIn: expiresIn,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.pq !== undefined) {
        b.write(Primitive.Bytes.write(this.pq) as unknown as Buffer);
      }
      if (this.p !== undefined) {
        b.write(Primitive.Bytes.write(this.p) as unknown as Buffer);
      }
      if (this.q !== undefined) {
        b.write(Primitive.Bytes.write(this.q) as unknown as Buffer);
      }
      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.newNonce !== undefined) {
        b.write(Primitive.Int256.write(this.newNonce) as unknown as Buffer);
      }
      if (this.dc !== undefined) {
        b.write(Primitive.Int.write(this.dc) as unknown as Buffer);
      }
      if (this.expiresIn !== undefined) {
        b.write(Primitive.Int.write(this.expiresIn) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BindAuthKeyInner extends TLObject {
    nonce!: long;
    tempAuthKeyId!: long;
    permAuthKeyId!: long;
    tempSessionId!: long;
    expiresAt!: int;

    constructor(params: {
      nonce: long;
      tempAuthKeyId: long;
      permAuthKeyId: long;
      tempSessionId: long;
      expiresAt: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'BindAuthKeyInner';
      this.constructorId = 0x75a3f765;
      this.subclassOfId = 0x2f099171;
      this._slots = ['nonce', 'tempAuthKeyId', 'permAuthKeyId', 'tempSessionId', 'expiresAt'];
      this.nonce = params.nonce;
      this.tempAuthKeyId = params.tempAuthKeyId;
      this.permAuthKeyId = params.permAuthKeyId;
      this.tempSessionId = params.tempSessionId;
      this.expiresAt = params.expiresAt;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BindAuthKeyInner> {
      // no flags

      let nonce = await Primitive.Long.read(b);
      let tempAuthKeyId = await Primitive.Long.read(b);
      let permAuthKeyId = await Primitive.Long.read(b);
      let tempSessionId = await Primitive.Long.read(b);
      let expiresAt = await Primitive.Int.read(b);
      return new Raw.BindAuthKeyInner({
        nonce: nonce,
        tempAuthKeyId: tempAuthKeyId,
        permAuthKeyId: permAuthKeyId,
        tempSessionId: tempSessionId,
        expiresAt: expiresAt,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Long.write(this.nonce) as unknown as Buffer);
      }
      if (this.tempAuthKeyId !== undefined) {
        b.write(Primitive.Long.write(this.tempAuthKeyId) as unknown as Buffer);
      }
      if (this.permAuthKeyId !== undefined) {
        b.write(Primitive.Long.write(this.permAuthKeyId) as unknown as Buffer);
      }
      if (this.tempSessionId !== undefined) {
        b.write(Primitive.Long.write(this.tempSessionId) as unknown as Buffer);
      }
      if (this.expiresAt !== undefined) {
        b.write(Primitive.Int.write(this.expiresAt) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ServerDhParamsFail extends TLObject {
    nonce!: int128;
    serverNonce!: int128;
    newNonceHash!: int128;

    constructor(params: { nonce: int128; serverNonce: int128; newNonceHash: int128 }) {
      super();
      this.classType = 'types';
      this.className = 'ServerDhParamsFail';
      this.constructorId = 0x79cb045d;
      this.subclassOfId = 0xa6188d9e;
      this._slots = ['nonce', 'serverNonce', 'newNonceHash'];
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.newNonceHash = params.newNonceHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ServerDhParamsFail> {
      // no flags

      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let newNonceHash = await Primitive.Int128.read(b);
      return new Raw.ServerDhParamsFail({
        nonce: nonce,
        serverNonce: serverNonce,
        newNonceHash: newNonceHash,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.newNonceHash !== undefined) {
        b.write(Primitive.Int128.write(this.newNonceHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ServerDhParamsOk extends TLObject {
    nonce!: int128;
    serverNonce!: int128;
    encryptedAnswer!: bytes;

    constructor(params: { nonce: int128; serverNonce: int128; encryptedAnswer: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'ServerDhParamsOk';
      this.constructorId = 0xd0e8075c;
      this.subclassOfId = 0xa6188d9e;
      this._slots = ['nonce', 'serverNonce', 'encryptedAnswer'];
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.encryptedAnswer = params.encryptedAnswer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ServerDhParamsOk> {
      // no flags

      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let encryptedAnswer = await Primitive.Bytes.read(b);
      return new Raw.ServerDhParamsOk({
        nonce: nonce,
        serverNonce: serverNonce,
        encryptedAnswer: encryptedAnswer,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.encryptedAnswer !== undefined) {
        b.write(Primitive.Bytes.write(this.encryptedAnswer) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ServerDhInnerData extends TLObject {
    nonce!: int128;
    serverNonce!: int128;
    g!: int;
    dhPrime!: bytes;
    gA!: bytes;
    serverTime!: int;

    constructor(params: {
      nonce: int128;
      serverNonce: int128;
      g: int;
      dhPrime: bytes;
      gA: bytes;
      serverTime: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ServerDhInnerData';
      this.constructorId = 0xb5890dba;
      this.subclassOfId = 0xc69a67bc;
      this._slots = ['nonce', 'serverNonce', 'g', 'dhPrime', 'gA', 'serverTime'];
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.g = params.g;
      this.dhPrime = params.dhPrime;
      this.gA = params.gA;
      this.serverTime = params.serverTime;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ServerDhInnerData> {
      // no flags

      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let g = await Primitive.Int.read(b);
      let dhPrime = await Primitive.Bytes.read(b);
      let gA = await Primitive.Bytes.read(b);
      let serverTime = await Primitive.Int.read(b);
      return new Raw.ServerDhInnerData({
        nonce: nonce,
        serverNonce: serverNonce,
        g: g,
        dhPrime: dhPrime,
        gA: gA,
        serverTime: serverTime,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.g !== undefined) {
        b.write(Primitive.Int.write(this.g) as unknown as Buffer);
      }
      if (this.dhPrime !== undefined) {
        b.write(Primitive.Bytes.write(this.dhPrime) as unknown as Buffer);
      }
      if (this.gA !== undefined) {
        b.write(Primitive.Bytes.write(this.gA) as unknown as Buffer);
      }
      if (this.serverTime !== undefined) {
        b.write(Primitive.Int.write(this.serverTime) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ClientDhInnerData extends TLObject {
    nonce!: int128;
    serverNonce!: int128;
    retryId!: long;
    gB!: bytes;

    constructor(params: { nonce: int128; serverNonce: int128; retryId: long; gB: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'ClientDhInnerData';
      this.constructorId = 0x6643b654;
      this.subclassOfId = 0xf8eeef6a;
      this._slots = ['nonce', 'serverNonce', 'retryId', 'gB'];
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.retryId = params.retryId;
      this.gB = params.gB;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ClientDhInnerData> {
      // no flags

      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let retryId = await Primitive.Long.read(b);
      let gB = await Primitive.Bytes.read(b);
      return new Raw.ClientDhInnerData({
        nonce: nonce,
        serverNonce: serverNonce,
        retryId: retryId,
        gB: gB,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.retryId !== undefined) {
        b.write(Primitive.Long.write(this.retryId) as unknown as Buffer);
      }
      if (this.gB !== undefined) {
        b.write(Primitive.Bytes.write(this.gB) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DhGenOk extends TLObject {
    nonce!: int128;
    serverNonce!: int128;
    newNonceHash1!: int128;

    constructor(params: { nonce: int128; serverNonce: int128; newNonceHash1: int128 }) {
      super();
      this.classType = 'types';
      this.className = 'DhGenOk';
      this.constructorId = 0x3bcbf734;
      this.subclassOfId = 0x55dd6cdb;
      this._slots = ['nonce', 'serverNonce', 'newNonceHash1'];
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.newNonceHash1 = params.newNonceHash1;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DhGenOk> {
      // no flags

      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let newNonceHash1 = await Primitive.Int128.read(b);
      return new Raw.DhGenOk({
        nonce: nonce,
        serverNonce: serverNonce,
        newNonceHash1: newNonceHash1,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.newNonceHash1 !== undefined) {
        b.write(Primitive.Int128.write(this.newNonceHash1) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DhGenRetry extends TLObject {
    nonce!: int128;
    serverNonce!: int128;
    newNonceHash2!: int128;

    constructor(params: { nonce: int128; serverNonce: int128; newNonceHash2: int128 }) {
      super();
      this.classType = 'types';
      this.className = 'DhGenRetry';
      this.constructorId = 0x46dc1fb9;
      this.subclassOfId = 0x55dd6cdb;
      this._slots = ['nonce', 'serverNonce', 'newNonceHash2'];
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.newNonceHash2 = params.newNonceHash2;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DhGenRetry> {
      // no flags

      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let newNonceHash2 = await Primitive.Int128.read(b);
      return new Raw.DhGenRetry({
        nonce: nonce,
        serverNonce: serverNonce,
        newNonceHash2: newNonceHash2,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.newNonceHash2 !== undefined) {
        b.write(Primitive.Int128.write(this.newNonceHash2) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DhGenFail extends TLObject {
    nonce!: int128;
    serverNonce!: int128;
    newNonceHash3!: int128;

    constructor(params: { nonce: int128; serverNonce: int128; newNonceHash3: int128 }) {
      super();
      this.classType = 'types';
      this.className = 'DhGenFail';
      this.constructorId = 0xa69dae02;
      this.subclassOfId = 0x55dd6cdb;
      this._slots = ['nonce', 'serverNonce', 'newNonceHash3'];
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.newNonceHash3 = params.newNonceHash3;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DhGenFail> {
      // no flags

      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let newNonceHash3 = await Primitive.Int128.read(b);
      return new Raw.DhGenFail({
        nonce: nonce,
        serverNonce: serverNonce,
        newNonceHash3: newNonceHash3,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.newNonceHash3 !== undefined) {
        b.write(Primitive.Int128.write(this.newNonceHash3) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DestroyAuthKeyOk extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'DestroyAuthKeyOk';
      this.constructorId = 0xf660e1d4;
      this.subclassOfId = 0x8291e68e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DestroyAuthKeyOk> {
      // no flags

      return new Raw.DestroyAuthKeyOk();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class DestroyAuthKeyNone extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'DestroyAuthKeyNone';
      this.constructorId = 0x0a9f2259;
      this.subclassOfId = 0x8291e68e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DestroyAuthKeyNone> {
      // no flags

      return new Raw.DestroyAuthKeyNone();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class DestroyAuthKeyFail extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'DestroyAuthKeyFail';
      this.constructorId = 0xea109b13;
      this.subclassOfId = 0x8291e68e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DestroyAuthKeyFail> {
      // no flags

      return new Raw.DestroyAuthKeyFail();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ReqPq extends TLObject {
    __response__!: Raw.TypeResPQ;
    nonce!: int128;

    constructor(params: { nonce: int128 }) {
      super();
      this.classType = 'functions';
      this.className = 'ReqPq';
      this.constructorId = 0x60469778;
      this.subclassOfId = 0x786986b8;
      this._slots = ['nonce'];
      this.nonce = params.nonce;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReqPq> {
      // no flags

      let nonce = await Primitive.Int128.read(b);
      return new Raw.ReqPq({ nonce: nonce });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ReqPqMulti extends TLObject {
    __response__!: Raw.TypeResPQ;
    nonce!: int128;

    constructor(params: { nonce: int128 }) {
      super();
      this.classType = 'functions';
      this.className = 'ReqPqMulti';
      this.constructorId = 0xbe7e8ef1;
      this.subclassOfId = 0x786986b8;
      this._slots = ['nonce'];
      this.nonce = params.nonce;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReqPqMulti> {
      // no flags

      let nonce = await Primitive.Int128.read(b);
      return new Raw.ReqPqMulti({ nonce: nonce });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ReqDhParams extends TLObject {
    __response__!: Raw.TypeServerDhParams;
    nonce!: int128;
    serverNonce!: int128;
    p!: bytes;
    q!: bytes;
    publicKeyFingerprint!: long;
    encryptedData!: bytes;

    constructor(params: {
      nonce: int128;
      serverNonce: int128;
      p: bytes;
      q: bytes;
      publicKeyFingerprint: long;
      encryptedData: bytes;
    }) {
      super();
      this.classType = 'functions';
      this.className = 'ReqDhParams';
      this.constructorId = 0xd712e4be;
      this.subclassOfId = 0xa6188d9e;
      this._slots = ['nonce', 'serverNonce', 'p', 'q', 'publicKeyFingerprint', 'encryptedData'];
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.p = params.p;
      this.q = params.q;
      this.publicKeyFingerprint = params.publicKeyFingerprint;
      this.encryptedData = params.encryptedData;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReqDhParams> {
      // no flags

      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let p = await Primitive.Bytes.read(b);
      let q = await Primitive.Bytes.read(b);
      let publicKeyFingerprint = await Primitive.Long.read(b);
      let encryptedData = await Primitive.Bytes.read(b);
      return new Raw.ReqDhParams({
        nonce: nonce,
        serverNonce: serverNonce,
        p: p,
        q: q,
        publicKeyFingerprint: publicKeyFingerprint,
        encryptedData: encryptedData,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.p !== undefined) {
        b.write(Primitive.Bytes.write(this.p) as unknown as Buffer);
      }
      if (this.q !== undefined) {
        b.write(Primitive.Bytes.write(this.q) as unknown as Buffer);
      }
      if (this.publicKeyFingerprint !== undefined) {
        b.write(Primitive.Long.write(this.publicKeyFingerprint) as unknown as Buffer);
      }
      if (this.encryptedData !== undefined) {
        b.write(Primitive.Bytes.write(this.encryptedData) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SetClientDhParams extends TLObject {
    __response__!: Raw.TypeSetClientDhParamsAnswer;
    nonce!: int128;
    serverNonce!: int128;
    encryptedData!: bytes;

    constructor(params: { nonce: int128; serverNonce: int128; encryptedData: bytes }) {
      super();
      this.classType = 'functions';
      this.className = 'SetClientDhParams';
      this.constructorId = 0xf5045f1f;
      this.subclassOfId = 0x55dd6cdb;
      this._slots = ['nonce', 'serverNonce', 'encryptedData'];
      this.nonce = params.nonce;
      this.serverNonce = params.serverNonce;
      this.encryptedData = params.encryptedData;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SetClientDhParams> {
      // no flags

      let nonce = await Primitive.Int128.read(b);
      let serverNonce = await Primitive.Int128.read(b);
      let encryptedData = await Primitive.Bytes.read(b);
      return new Raw.SetClientDhParams({
        nonce: nonce,
        serverNonce: serverNonce,
        encryptedData: encryptedData,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.nonce !== undefined) {
        b.write(Primitive.Int128.write(this.nonce) as unknown as Buffer);
      }
      if (this.serverNonce !== undefined) {
        b.write(Primitive.Int128.write(this.serverNonce) as unknown as Buffer);
      }
      if (this.encryptedData !== undefined) {
        b.write(Primitive.Bytes.write(this.encryptedData) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DestroyAuthKey extends TLObject {
    __response__!: Raw.TypeDestroyAuthKeyRes;

    constructor() {
      super();
      this.classType = 'functions';
      this.className = 'DestroyAuthKey';
      this.constructorId = 0xd1435160;
      this.subclassOfId = 0x8291e68e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DestroyAuthKey> {
      // no flags

      return new Raw.DestroyAuthKey();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class MsgsAck extends TLObject {
    msgIds!: Vector<long>;

    constructor(params: { msgIds: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'MsgsAck';
      this.constructorId = 0x62d6b459;
      this.subclassOfId = 0x827677c4;
      this._slots = ['msgIds'];
      this.msgIds = params.msgIds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MsgsAck> {
      // no flags

      let msgIds = await TLObject.read(b, Primitive.Long);
      return new Raw.MsgsAck({ msgIds: msgIds });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.msgIds) {
        b.write(Primitive.Vector.write(this.msgIds, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BadMsgNotification extends TLObject {
    badMsgId!: long;
    badMsgSeqno!: int;
    errorCode!: int;

    constructor(params: { badMsgId: long; badMsgSeqno: int; errorCode: int }) {
      super();
      this.classType = 'types';
      this.className = 'BadMsgNotification';
      this.constructorId = 0xa7eff811;
      this.subclassOfId = 0xcebaa157;
      this._slots = ['badMsgId', 'badMsgSeqno', 'errorCode'];
      this.badMsgId = params.badMsgId;
      this.badMsgSeqno = params.badMsgSeqno;
      this.errorCode = params.errorCode;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BadMsgNotification> {
      // no flags

      let badMsgId = await Primitive.Long.read(b);
      let badMsgSeqno = await Primitive.Int.read(b);
      let errorCode = await Primitive.Int.read(b);
      return new Raw.BadMsgNotification({
        badMsgId: badMsgId,
        badMsgSeqno: badMsgSeqno,
        errorCode: errorCode,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.badMsgId !== undefined) {
        b.write(Primitive.Long.write(this.badMsgId) as unknown as Buffer);
      }
      if (this.badMsgSeqno !== undefined) {
        b.write(Primitive.Int.write(this.badMsgSeqno) as unknown as Buffer);
      }
      if (this.errorCode !== undefined) {
        b.write(Primitive.Int.write(this.errorCode) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BadServerSalt extends TLObject {
    badMsgId!: long;
    badMsgSeqno!: int;
    errorCode!: int;
    newServerSalt!: long;

    constructor(params: { badMsgId: long; badMsgSeqno: int; errorCode: int; newServerSalt: long }) {
      super();
      this.classType = 'types';
      this.className = 'BadServerSalt';
      this.constructorId = 0xedab447b;
      this.subclassOfId = 0xcebaa157;
      this._slots = ['badMsgId', 'badMsgSeqno', 'errorCode', 'newServerSalt'];
      this.badMsgId = params.badMsgId;
      this.badMsgSeqno = params.badMsgSeqno;
      this.errorCode = params.errorCode;
      this.newServerSalt = params.newServerSalt;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BadServerSalt> {
      // no flags

      let badMsgId = await Primitive.Long.read(b);
      let badMsgSeqno = await Primitive.Int.read(b);
      let errorCode = await Primitive.Int.read(b);
      let newServerSalt = await Primitive.Long.read(b);
      return new Raw.BadServerSalt({
        badMsgId: badMsgId,
        badMsgSeqno: badMsgSeqno,
        errorCode: errorCode,
        newServerSalt: newServerSalt,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.badMsgId !== undefined) {
        b.write(Primitive.Long.write(this.badMsgId) as unknown as Buffer);
      }
      if (this.badMsgSeqno !== undefined) {
        b.write(Primitive.Int.write(this.badMsgSeqno) as unknown as Buffer);
      }
      if (this.errorCode !== undefined) {
        b.write(Primitive.Int.write(this.errorCode) as unknown as Buffer);
      }
      if (this.newServerSalt !== undefined) {
        b.write(Primitive.Long.write(this.newServerSalt) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MsgsStateReq extends TLObject {
    msgIds!: Vector<long>;

    constructor(params: { msgIds: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'MsgsStateReq';
      this.constructorId = 0xda69fb52;
      this.subclassOfId = 0x18f01dd0;
      this._slots = ['msgIds'];
      this.msgIds = params.msgIds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MsgsStateReq> {
      // no flags

      let msgIds = await TLObject.read(b, Primitive.Long);
      return new Raw.MsgsStateReq({ msgIds: msgIds });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.msgIds) {
        b.write(Primitive.Vector.write(this.msgIds, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MsgsStateInfo extends TLObject {
    reqMsgId!: long;
    info!: string;

    constructor(params: { reqMsgId: long; info: string }) {
      super();
      this.classType = 'types';
      this.className = 'MsgsStateInfo';
      this.constructorId = 0x04deb57d;
      this.subclassOfId = 0x70a0a64;
      this._slots = ['reqMsgId', 'info'];
      this.reqMsgId = params.reqMsgId;
      this.info = params.info;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MsgsStateInfo> {
      // no flags

      let reqMsgId = await Primitive.Long.read(b);
      let info = await Primitive.String.read(b);
      return new Raw.MsgsStateInfo({ reqMsgId: reqMsgId, info: info });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.reqMsgId !== undefined) {
        b.write(Primitive.Long.write(this.reqMsgId) as unknown as Buffer);
      }
      if (this.info !== undefined) {
        b.write(Primitive.String.write(this.info) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MsgsAllInfo extends TLObject {
    msgIds!: Vector<long>;
    info!: string;

    constructor(params: { msgIds: Vector<long>; info: string }) {
      super();
      this.classType = 'types';
      this.className = 'MsgsAllInfo';
      this.constructorId = 0x8cc0d131;
      this.subclassOfId = 0xfa8fcb54;
      this._slots = ['msgIds', 'info'];
      this.msgIds = params.msgIds;
      this.info = params.info;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MsgsAllInfo> {
      // no flags

      let msgIds = await TLObject.read(b, Primitive.Long);
      let info = await Primitive.String.read(b);
      return new Raw.MsgsAllInfo({ msgIds: msgIds, info: info });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.msgIds) {
        b.write(Primitive.Vector.write(this.msgIds, Primitive.Long) as unknown as Buffer);
      }
      if (this.info !== undefined) {
        b.write(Primitive.String.write(this.info) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MsgDetailedInfo extends TLObject {
    msgId!: long;
    answerMsgId!: long;
    bytes!: int;
    status!: int;

    constructor(params: { msgId: long; answerMsgId: long; bytes: int; status: int }) {
      super();
      this.classType = 'types';
      this.className = 'MsgDetailedInfo';
      this.constructorId = 0x276d3ec6;
      this.subclassOfId = 0x5f32d5ee;
      this._slots = ['msgId', 'answerMsgId', 'bytes', 'status'];
      this.msgId = params.msgId;
      this.answerMsgId = params.answerMsgId;
      this.bytes = params.bytes;
      this.status = params.status;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MsgDetailedInfo> {
      // no flags

      let msgId = await Primitive.Long.read(b);
      let answerMsgId = await Primitive.Long.read(b);
      let bytes = await Primitive.Int.read(b);
      let status = await Primitive.Int.read(b);
      return new Raw.MsgDetailedInfo({
        msgId: msgId,
        answerMsgId: answerMsgId,
        bytes: bytes,
        status: status,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.msgId !== undefined) {
        b.write(Primitive.Long.write(this.msgId) as unknown as Buffer);
      }
      if (this.answerMsgId !== undefined) {
        b.write(Primitive.Long.write(this.answerMsgId) as unknown as Buffer);
      }
      if (this.bytes !== undefined) {
        b.write(Primitive.Int.write(this.bytes) as unknown as Buffer);
      }
      if (this.status !== undefined) {
        b.write(Primitive.Int.write(this.status) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MsgNewDetailedInfo extends TLObject {
    answerMsgId!: long;
    bytes!: int;
    status!: int;

    constructor(params: { answerMsgId: long; bytes: int; status: int }) {
      super();
      this.classType = 'types';
      this.className = 'MsgNewDetailedInfo';
      this.constructorId = 0x809db6df;
      this.subclassOfId = 0x5f32d5ee;
      this._slots = ['answerMsgId', 'bytes', 'status'];
      this.answerMsgId = params.answerMsgId;
      this.bytes = params.bytes;
      this.status = params.status;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MsgNewDetailedInfo> {
      // no flags

      let answerMsgId = await Primitive.Long.read(b);
      let bytes = await Primitive.Int.read(b);
      let status = await Primitive.Int.read(b);
      return new Raw.MsgNewDetailedInfo({ answerMsgId: answerMsgId, bytes: bytes, status: status });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.answerMsgId !== undefined) {
        b.write(Primitive.Long.write(this.answerMsgId) as unknown as Buffer);
      }
      if (this.bytes !== undefined) {
        b.write(Primitive.Int.write(this.bytes) as unknown as Buffer);
      }
      if (this.status !== undefined) {
        b.write(Primitive.Int.write(this.status) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MsgResendReq extends TLObject {
    msgIds!: Vector<long>;

    constructor(params: { msgIds: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'MsgResendReq';
      this.constructorId = 0x7d861a08;
      this.subclassOfId = 0x2024514;
      this._slots = ['msgIds'];
      this.msgIds = params.msgIds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MsgResendReq> {
      // no flags

      let msgIds = await TLObject.read(b, Primitive.Long);
      return new Raw.MsgResendReq({ msgIds: msgIds });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.msgIds) {
        b.write(Primitive.Vector.write(this.msgIds, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RpcResult extends TLObject {
    reqMsgId!: long;
    result!: any;

    constructor(params: { reqMsgId: long; result: any }) {
      super();
      this.classType = 'types';
      this.className = 'RpcResult';
      this.constructorId = 0xf35c6d01;
      this.subclassOfId = 0x9a7df30;
      this._slots = ['reqMsgId', 'result'];
      this.reqMsgId = params.reqMsgId;
      this.result = params.result;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RpcResult> {
      // no flags

      let reqMsgId = await Primitive.Long.read(b);
      let result = await TLObject.read(b);
      return new Raw.RpcResult({ reqMsgId: reqMsgId, result: result });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.reqMsgId !== undefined) {
        b.write(Primitive.Long.write(this.reqMsgId) as unknown as Buffer);
      }
      if (this.result !== undefined) {
        b.write(this.result.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RpcError extends TLObject {
    errorCode!: int;
    errorMessage!: string;

    constructor(params: { errorCode: int; errorMessage: string }) {
      super();
      this.classType = 'types';
      this.className = 'RpcError';
      this.constructorId = 0x2144ca19;
      this.subclassOfId = 0x4a17e265;
      this._slots = ['errorCode', 'errorMessage'];
      this.errorCode = params.errorCode;
      this.errorMessage = params.errorMessage;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RpcError> {
      // no flags

      let errorCode = await Primitive.Int.read(b);
      let errorMessage = await Primitive.String.read(b);
      return new Raw.RpcError({ errorCode: errorCode, errorMessage: errorMessage });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.errorCode !== undefined) {
        b.write(Primitive.Int.write(this.errorCode) as unknown as Buffer);
      }
      if (this.errorMessage !== undefined) {
        b.write(Primitive.String.write(this.errorMessage) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RpcAnswerUnknown extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'RpcAnswerUnknown';
      this.constructorId = 0x5e2ad36e;
      this.subclassOfId = 0x4bca7570;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RpcAnswerUnknown> {
      // no flags

      return new Raw.RpcAnswerUnknown();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class RpcAnswerDroppedRunning extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'RpcAnswerDroppedRunning';
      this.constructorId = 0xcd78e586;
      this.subclassOfId = 0x4bca7570;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RpcAnswerDroppedRunning> {
      // no flags

      return new Raw.RpcAnswerDroppedRunning();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class RpcAnswerDropped extends TLObject {
    msgId!: long;
    seqNo!: int;
    bytes!: int;

    constructor(params: { msgId: long; seqNo: int; bytes: int }) {
      super();
      this.classType = 'types';
      this.className = 'RpcAnswerDropped';
      this.constructorId = 0xa43ad8b7;
      this.subclassOfId = 0x4bca7570;
      this._slots = ['msgId', 'seqNo', 'bytes'];
      this.msgId = params.msgId;
      this.seqNo = params.seqNo;
      this.bytes = params.bytes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RpcAnswerDropped> {
      // no flags

      let msgId = await Primitive.Long.read(b);
      let seqNo = await Primitive.Int.read(b);
      let bytes = await Primitive.Int.read(b);
      return new Raw.RpcAnswerDropped({ msgId: msgId, seqNo: seqNo, bytes: bytes });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.msgId !== undefined) {
        b.write(Primitive.Long.write(this.msgId) as unknown as Buffer);
      }
      if (this.seqNo !== undefined) {
        b.write(Primitive.Int.write(this.seqNo) as unknown as Buffer);
      }
      if (this.bytes !== undefined) {
        b.write(Primitive.Int.write(this.bytes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class FutureSalt extends TLObject {
    validSince!: int;
    validUntil!: int;
    salt!: long;

    constructor(params: { validSince: int; validUntil: int; salt: long }) {
      super();
      this.classType = 'types';
      this.className = 'FutureSalt';
      this.constructorId = 0x0949d9dc;
      this.subclassOfId = 0x45e53dcf;
      this._slots = ['validSince', 'validUntil', 'salt'];
      this.validSince = params.validSince;
      this.validUntil = params.validUntil;
      this.salt = params.salt;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.FutureSalt> {
      // no flags

      let validSince = await Primitive.Int.read(b);
      let validUntil = await Primitive.Int.read(b);
      let salt = await Primitive.Long.read(b);
      return new Raw.FutureSalt({ validSince: validSince, validUntil: validUntil, salt: salt });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.validSince !== undefined) {
        b.write(Primitive.Int.write(this.validSince) as unknown as Buffer);
      }
      if (this.validUntil !== undefined) {
        b.write(Primitive.Int.write(this.validUntil) as unknown as Buffer);
      }
      if (this.salt !== undefined) {
        b.write(Primitive.Long.write(this.salt) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class FutureSalts extends TLObject {
    reqMsgId!: long;
    now!: int;
    salts!: Vector<Raw.TypeFutureSalt>;

    constructor(params: { reqMsgId: long; now: int; salts: Vector<Raw.TypeFutureSalt> }) {
      super();
      this.classType = 'types';
      this.className = 'FutureSalts';
      this.constructorId = 0xae500895;
      this.subclassOfId = 0x1090f517;
      this._slots = ['reqMsgId', 'now', 'salts'];
      this.reqMsgId = params.reqMsgId;
      this.now = params.now;
      this.salts = params.salts;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.FutureSalts> {
      // no flags

      let reqMsgId = await Primitive.Long.read(b);
      let now = await Primitive.Int.read(b);
      let salts = await TLObject.read(b);
      return new Raw.FutureSalts({ reqMsgId: reqMsgId, now: now, salts: salts });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.reqMsgId !== undefined) {
        b.write(Primitive.Long.write(this.reqMsgId) as unknown as Buffer);
      }
      if (this.now !== undefined) {
        b.write(Primitive.Int.write(this.now) as unknown as Buffer);
      }
      if (this.salts) {
        b.write(Primitive.Vector.write(this.salts) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Pong extends TLObject {
    msgId!: long;
    pingId!: long;

    constructor(params: { msgId: long; pingId: long }) {
      super();
      this.classType = 'types';
      this.className = 'Pong';
      this.constructorId = 0x347773c5;
      this.subclassOfId = 0x816aee71;
      this._slots = ['msgId', 'pingId'];
      this.msgId = params.msgId;
      this.pingId = params.pingId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Pong> {
      // no flags

      let msgId = await Primitive.Long.read(b);
      let pingId = await Primitive.Long.read(b);
      return new Raw.Pong({ msgId: msgId, pingId: pingId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.msgId !== undefined) {
        b.write(Primitive.Long.write(this.msgId) as unknown as Buffer);
      }
      if (this.pingId !== undefined) {
        b.write(Primitive.Long.write(this.pingId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DestroySessionOk extends TLObject {
    sessionId!: long;

    constructor(params: { sessionId: long }) {
      super();
      this.classType = 'types';
      this.className = 'DestroySessionOk';
      this.constructorId = 0xe22045fc;
      this.subclassOfId = 0xaf0ce7bd;
      this._slots = ['sessionId'];
      this.sessionId = params.sessionId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DestroySessionOk> {
      // no flags

      let sessionId = await Primitive.Long.read(b);
      return new Raw.DestroySessionOk({ sessionId: sessionId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.sessionId !== undefined) {
        b.write(Primitive.Long.write(this.sessionId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DestroySessionNone extends TLObject {
    sessionId!: long;

    constructor(params: { sessionId: long }) {
      super();
      this.classType = 'types';
      this.className = 'DestroySessionNone';
      this.constructorId = 0x62d350c9;
      this.subclassOfId = 0xaf0ce7bd;
      this._slots = ['sessionId'];
      this.sessionId = params.sessionId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DestroySessionNone> {
      // no flags

      let sessionId = await Primitive.Long.read(b);
      return new Raw.DestroySessionNone({ sessionId: sessionId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.sessionId !== undefined) {
        b.write(Primitive.Long.write(this.sessionId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class NewSessionCreated extends TLObject {
    firstMsgId!: long;
    uniqueId!: long;
    serverSalt!: long;

    constructor(params: { firstMsgId: long; uniqueId: long; serverSalt: long }) {
      super();
      this.classType = 'types';
      this.className = 'NewSessionCreated';
      this.constructorId = 0x9ec20908;
      this.subclassOfId = 0x510d3031;
      this._slots = ['firstMsgId', 'uniqueId', 'serverSalt'];
      this.firstMsgId = params.firstMsgId;
      this.uniqueId = params.uniqueId;
      this.serverSalt = params.serverSalt;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.NewSessionCreated> {
      // no flags

      let firstMsgId = await Primitive.Long.read(b);
      let uniqueId = await Primitive.Long.read(b);
      let serverSalt = await Primitive.Long.read(b);
      return new Raw.NewSessionCreated({
        firstMsgId: firstMsgId,
        uniqueId: uniqueId,
        serverSalt: serverSalt,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.firstMsgId !== undefined) {
        b.write(Primitive.Long.write(this.firstMsgId) as unknown as Buffer);
      }
      if (this.uniqueId !== undefined) {
        b.write(Primitive.Long.write(this.uniqueId) as unknown as Buffer);
      }
      if (this.serverSalt !== undefined) {
        b.write(Primitive.Long.write(this.serverSalt) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class HttpWait extends TLObject {
    maxDelay!: int;
    waitAfter!: int;
    maxWait!: int;

    constructor(params: { maxDelay: int; waitAfter: int; maxWait: int }) {
      super();
      this.classType = 'types';
      this.className = 'HttpWait';
      this.constructorId = 0x9299359f;
      this.subclassOfId = 0x1284aed6;
      this._slots = ['maxDelay', 'waitAfter', 'maxWait'];
      this.maxDelay = params.maxDelay;
      this.waitAfter = params.waitAfter;
      this.maxWait = params.maxWait;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.HttpWait> {
      // no flags

      let maxDelay = await Primitive.Int.read(b);
      let waitAfter = await Primitive.Int.read(b);
      let maxWait = await Primitive.Int.read(b);
      return new Raw.HttpWait({ maxDelay: maxDelay, waitAfter: waitAfter, maxWait: maxWait });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.maxDelay !== undefined) {
        b.write(Primitive.Int.write(this.maxDelay) as unknown as Buffer);
      }
      if (this.waitAfter !== undefined) {
        b.write(Primitive.Int.write(this.waitAfter) as unknown as Buffer);
      }
      if (this.maxWait !== undefined) {
        b.write(Primitive.Int.write(this.maxWait) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class IpPort extends TLObject {
    ipv4!: int;
    port!: int;

    constructor(params: { ipv4: int; port: int }) {
      super();
      this.classType = 'types';
      this.className = 'IpPort';
      this.constructorId = 0xd433ad73;
      this.subclassOfId = 0xa2a03726;
      this._slots = ['ipv4', 'port'];
      this.ipv4 = params.ipv4;
      this.port = params.port;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.IpPort> {
      // no flags

      let ipv4 = await Primitive.Int.read(b);
      let port = await Primitive.Int.read(b);
      return new Raw.IpPort({ ipv4: ipv4, port: port });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.ipv4 !== undefined) {
        b.write(Primitive.Int.write(this.ipv4) as unknown as Buffer);
      }
      if (this.port !== undefined) {
        b.write(Primitive.Int.write(this.port) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class IpPortSecret extends TLObject {
    ipv4!: int;
    port!: int;
    secret!: bytes;

    constructor(params: { ipv4: int; port: int; secret: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'IpPortSecret';
      this.constructorId = 0x37982646;
      this.subclassOfId = 0xa2a03726;
      this._slots = ['ipv4', 'port', 'secret'];
      this.ipv4 = params.ipv4;
      this.port = params.port;
      this.secret = params.secret;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.IpPortSecret> {
      // no flags

      let ipv4 = await Primitive.Int.read(b);
      let port = await Primitive.Int.read(b);
      let secret = await Primitive.Bytes.read(b);
      return new Raw.IpPortSecret({ ipv4: ipv4, port: port, secret: secret });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.ipv4 !== undefined) {
        b.write(Primitive.Int.write(this.ipv4) as unknown as Buffer);
      }
      if (this.port !== undefined) {
        b.write(Primitive.Int.write(this.port) as unknown as Buffer);
      }
      if (this.secret !== undefined) {
        b.write(Primitive.Bytes.write(this.secret) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class AccessPointRule extends TLObject {
    phonePrefixRules!: string;
    dcId!: int;
    ips!: Vector<Raw.TypeIpPort>;

    constructor(params: { phonePrefixRules: string; dcId: int; ips: Vector<Raw.TypeIpPort> }) {
      super();
      this.classType = 'types';
      this.className = 'AccessPointRule';
      this.constructorId = 0x4679b65f;
      this.subclassOfId = 0xb1aca0fd;
      this._slots = ['phonePrefixRules', 'dcId', 'ips'];
      this.phonePrefixRules = params.phonePrefixRules;
      this.dcId = params.dcId;
      this.ips = params.ips;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AccessPointRule> {
      // no flags

      let phonePrefixRules = await Primitive.String.read(b);
      let dcId = await Primitive.Int.read(b);
      let ips = await TLObject.read(b);
      return new Raw.AccessPointRule({ phonePrefixRules: phonePrefixRules, dcId: dcId, ips: ips });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.phonePrefixRules !== undefined) {
        b.write(Primitive.String.write(this.phonePrefixRules) as unknown as Buffer);
      }
      if (this.dcId !== undefined) {
        b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
      }
      if (this.ips) {
        b.write(Primitive.Vector.write(this.ips) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RpcDropAnswer extends TLObject {
    __response__!: Raw.TypeRpcDropAnswer;
    reqMsgId!: long;

    constructor(params: { reqMsgId: long }) {
      super();
      this.classType = 'functions';
      this.className = 'RpcDropAnswer';
      this.constructorId = 0x58e4a740;
      this.subclassOfId = 0x4bca7570;
      this._slots = ['reqMsgId'];
      this.reqMsgId = params.reqMsgId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RpcDropAnswer> {
      // no flags

      let reqMsgId = await Primitive.Long.read(b);
      return new Raw.RpcDropAnswer({ reqMsgId: reqMsgId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.reqMsgId !== undefined) {
        b.write(Primitive.Long.write(this.reqMsgId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class GetFutureSalts extends TLObject {
    __response__!: Raw.TypeFutureSalts;
    num!: int;

    constructor(params: { num: int }) {
      super();
      this.classType = 'functions';
      this.className = 'GetFutureSalts';
      this.constructorId = 0xb921bd04;
      this.subclassOfId = 0x1090f517;
      this._slots = ['num'];
      this.num = params.num;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.GetFutureSalts> {
      // no flags

      let num = await Primitive.Int.read(b);
      return new Raw.GetFutureSalts({ num: num });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.num !== undefined) {
        b.write(Primitive.Int.write(this.num) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Ping extends TLObject {
    __response__!: Raw.TypePong;
    pingId!: long;

    constructor(params: { pingId: long }) {
      super();
      this.classType = 'functions';
      this.className = 'Ping';
      this.constructorId = 0x7abe77ec;
      this.subclassOfId = 0x816aee71;
      this._slots = ['pingId'];
      this.pingId = params.pingId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Ping> {
      // no flags

      let pingId = await Primitive.Long.read(b);
      return new Raw.Ping({ pingId: pingId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.pingId !== undefined) {
        b.write(Primitive.Long.write(this.pingId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PingDelayDisconnect extends TLObject {
    __response__!: Raw.TypePong;
    pingId!: long;
    disconnectDelay!: int;

    constructor(params: { pingId: long; disconnectDelay: int }) {
      super();
      this.classType = 'functions';
      this.className = 'PingDelayDisconnect';
      this.constructorId = 0xf3427b8c;
      this.subclassOfId = 0x816aee71;
      this._slots = ['pingId', 'disconnectDelay'];
      this.pingId = params.pingId;
      this.disconnectDelay = params.disconnectDelay;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PingDelayDisconnect> {
      // no flags

      let pingId = await Primitive.Long.read(b);
      let disconnectDelay = await Primitive.Int.read(b);
      return new Raw.PingDelayDisconnect({ pingId: pingId, disconnectDelay: disconnectDelay });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.pingId !== undefined) {
        b.write(Primitive.Long.write(this.pingId) as unknown as Buffer);
      }
      if (this.disconnectDelay !== undefined) {
        b.write(Primitive.Int.write(this.disconnectDelay) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DestroySession extends TLObject {
    __response__!: Raw.TypeDestroySessionRes;
    sessionId!: long;

    constructor(params: { sessionId: long }) {
      super();
      this.classType = 'functions';
      this.className = 'DestroySession';
      this.constructorId = 0xe7512126;
      this.subclassOfId = 0xaf0ce7bd;
      this._slots = ['sessionId'];
      this.sessionId = params.sessionId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DestroySession> {
      // no flags

      let sessionId = await Primitive.Long.read(b);
      return new Raw.DestroySession({ sessionId: sessionId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.sessionId !== undefined) {
        b.write(Primitive.Long.write(this.sessionId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPeerEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPeerEmpty';
      this.constructorId = 0x7f3b18ea;
      this.subclassOfId = 0xc91c90b6;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPeerEmpty> {
      // no flags

      return new Raw.InputPeerEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPeerSelf extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPeerSelf';
      this.constructorId = 0x7da07ec9;
      this.subclassOfId = 0xc91c90b6;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPeerSelf> {
      // no flags

      return new Raw.InputPeerSelf();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPeerChat extends TLObject {
    chatId!: long;

    constructor(params: { chatId: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputPeerChat';
      this.constructorId = 0x35a95cb9;
      this.subclassOfId = 0xc91c90b6;
      this._slots = ['chatId'];
      this.chatId = params.chatId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPeerChat> {
      // no flags

      let chatId = await Primitive.Long.read(b);
      return new Raw.InputPeerChat({ chatId: chatId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPeerUser extends TLObject {
    userId!: long;
    accessHash!: long;

    constructor(params: { userId: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputPeerUser';
      this.constructorId = 0xdde8a54c;
      this.subclassOfId = 0xc91c90b6;
      this._slots = ['userId', 'accessHash'];
      this.userId = params.userId;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPeerUser> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputPeerUser({ userId: userId, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPeerChannel extends TLObject {
    channelId!: long;
    accessHash!: long;

    constructor(params: { channelId: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputPeerChannel';
      this.constructorId = 0x27bcbbfc;
      this.subclassOfId = 0xc91c90b6;
      this._slots = ['channelId', 'accessHash'];
      this.channelId = params.channelId;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPeerChannel> {
      // no flags

      let channelId = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputPeerChannel({ channelId: channelId, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPeerUserFromMessage extends TLObject {
    peer!: Raw.TypeInputPeer;
    msgId!: int;
    userId!: long;

    constructor(params: { peer: Raw.TypeInputPeer; msgId: int; userId: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputPeerUserFromMessage';
      this.constructorId = 0xa87b0a1c;
      this.subclassOfId = 0xc91c90b6;
      this._slots = ['peer', 'msgId', 'userId'];
      this.peer = params.peer;
      this.msgId = params.msgId;
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPeerUserFromMessage> {
      // no flags

      let peer = await TLObject.read(b);
      let msgId = await Primitive.Int.read(b);
      let userId = await Primitive.Long.read(b);
      return new Raw.InputPeerUserFromMessage({ peer: peer, msgId: msgId, userId: userId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPeerChannelFromMessage extends TLObject {
    peer!: Raw.TypeInputPeer;
    msgId!: int;
    channelId!: long;

    constructor(params: { peer: Raw.TypeInputPeer; msgId: int; channelId: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputPeerChannelFromMessage';
      this.constructorId = 0xbd2a0840;
      this.subclassOfId = 0xc91c90b6;
      this._slots = ['peer', 'msgId', 'channelId'];
      this.peer = params.peer;
      this.msgId = params.msgId;
      this.channelId = params.channelId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPeerChannelFromMessage> {
      // no flags

      let peer = await TLObject.read(b);
      let msgId = await Primitive.Int.read(b);
      let channelId = await Primitive.Long.read(b);
      return new Raw.InputPeerChannelFromMessage({
        peer: peer,
        msgId: msgId,
        channelId: channelId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputUserEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputUserEmpty';
      this.constructorId = 0xb98886cf;
      this.subclassOfId = 0xe669bf46;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputUserEmpty> {
      // no flags

      return new Raw.InputUserEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputUserSelf extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputUserSelf';
      this.constructorId = 0xf7c1b13f;
      this.subclassOfId = 0xe669bf46;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputUserSelf> {
      // no flags

      return new Raw.InputUserSelf();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputUser extends TLObject {
    userId!: long;
    accessHash!: long;

    constructor(params: { userId: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputUser';
      this.constructorId = 0xf21158c6;
      this.subclassOfId = 0xe669bf46;
      this._slots = ['userId', 'accessHash'];
      this.userId = params.userId;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputUser> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputUser({ userId: userId, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputUserFromMessage extends TLObject {
    peer!: Raw.TypeInputPeer;
    msgId!: int;
    userId!: long;

    constructor(params: { peer: Raw.TypeInputPeer; msgId: int; userId: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputUserFromMessage';
      this.constructorId = 0x1da448e2;
      this.subclassOfId = 0xe669bf46;
      this._slots = ['peer', 'msgId', 'userId'];
      this.peer = params.peer;
      this.msgId = params.msgId;
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputUserFromMessage> {
      // no flags

      let peer = await TLObject.read(b);
      let msgId = await Primitive.Int.read(b);
      let userId = await Primitive.Long.read(b);
      return new Raw.InputUserFromMessage({ peer: peer, msgId: msgId, userId: userId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPhoneContact extends TLObject {
    clientId!: long;
    phone!: string;
    firstName!: string;
    lastName!: string;

    constructor(params: { clientId: long; phone: string; firstName: string; lastName: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputPhoneContact';
      this.constructorId = 0xf392b7f4;
      this.subclassOfId = 0xae696a82;
      this._slots = ['clientId', 'phone', 'firstName', 'lastName'];
      this.clientId = params.clientId;
      this.phone = params.phone;
      this.firstName = params.firstName;
      this.lastName = params.lastName;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPhoneContact> {
      // no flags

      let clientId = await Primitive.Long.read(b);
      let phone = await Primitive.String.read(b);
      let firstName = await Primitive.String.read(b);
      let lastName = await Primitive.String.read(b);
      return new Raw.InputPhoneContact({
        clientId: clientId,
        phone: phone,
        firstName: firstName,
        lastName: lastName,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.clientId !== undefined) {
        b.write(Primitive.Long.write(this.clientId) as unknown as Buffer);
      }
      if (this.phone !== undefined) {
        b.write(Primitive.String.write(this.phone) as unknown as Buffer);
      }
      if (this.firstName !== undefined) {
        b.write(Primitive.String.write(this.firstName) as unknown as Buffer);
      }
      if (this.lastName !== undefined) {
        b.write(Primitive.String.write(this.lastName) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputFile extends TLObject {
    id!: long;
    parts!: int;
    name!: string;
    md5Checksum!: string;

    constructor(params: { id: long; parts: int; name: string; md5Checksum: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputFile';
      this.constructorId = 0xf52ff27f;
      this.subclassOfId = 0xe7655f1f;
      this._slots = ['id', 'parts', 'name', 'md5Checksum'];
      this.id = params.id;
      this.parts = params.parts;
      this.name = params.name;
      this.md5Checksum = params.md5Checksum;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputFile> {
      // no flags

      let id = await Primitive.Long.read(b);
      let parts = await Primitive.Int.read(b);
      let name = await Primitive.String.read(b);
      let md5Checksum = await Primitive.String.read(b);
      return new Raw.InputFile({ id: id, parts: parts, name: name, md5Checksum: md5Checksum });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.parts !== undefined) {
        b.write(Primitive.Int.write(this.parts) as unknown as Buffer);
      }
      if (this.name !== undefined) {
        b.write(Primitive.String.write(this.name) as unknown as Buffer);
      }
      if (this.md5Checksum !== undefined) {
        b.write(Primitive.String.write(this.md5Checksum) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputFileBig extends TLObject {
    id!: long;
    parts!: int;
    name!: string;

    constructor(params: { id: long; parts: int; name: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputFileBig';
      this.constructorId = 0xfa4f0bb5;
      this.subclassOfId = 0xe7655f1f;
      this._slots = ['id', 'parts', 'name'];
      this.id = params.id;
      this.parts = params.parts;
      this.name = params.name;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputFileBig> {
      // no flags

      let id = await Primitive.Long.read(b);
      let parts = await Primitive.Int.read(b);
      let name = await Primitive.String.read(b);
      return new Raw.InputFileBig({ id: id, parts: parts, name: name });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.parts !== undefined) {
        b.write(Primitive.Int.write(this.parts) as unknown as Buffer);
      }
      if (this.name !== undefined) {
        b.write(Primitive.String.write(this.name) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMediaEmpty';
      this.constructorId = 0x9664f57f;
      this.subclassOfId = 0xfaf846f4;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaEmpty> {
      // no flags

      return new Raw.InputMediaEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMediaUploadedPhoto extends TLObject {
    spoiler?: boolean;
    file!: Raw.TypeInputFile;
    stickers?: Vector<Raw.TypeInputDocument>;
    ttlSeconds?: int;

    constructor(params: {
      spoiler?: boolean;
      file: Raw.TypeInputFile;
      stickers?: Vector<Raw.TypeInputDocument>;
      ttlSeconds?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaUploadedPhoto';
      this.constructorId = 0x1e287d04;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['spoiler', 'file', 'stickers', 'ttlSeconds'];
      this.spoiler = params.spoiler;
      this.file = params.file;
      this.stickers = params.stickers;
      this.ttlSeconds = params.ttlSeconds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaUploadedPhoto> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let spoiler = flags & (1 << 2) ? true : false;
      let file = await TLObject.read(b);
      let stickers = flags & (1 << 0) ? await TLObject.read(b) : [];
      let ttlSeconds = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      return new Raw.InputMediaUploadedPhoto({
        spoiler: spoiler,
        file: file,
        stickers: stickers,
        ttlSeconds: ttlSeconds,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.spoiler ? 1 << 2 : 0;
      flags |= this.stickers ? 1 << 0 : 0;
      flags |= this.ttlSeconds !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.file !== undefined) {
        b.write(this.file.write() as unknown as Buffer);
      }
      if (this.stickers) {
        b.write(Primitive.Vector.write(this.stickers) as unknown as Buffer);
      }
      if (this.ttlSeconds !== undefined) {
        b.write(Primitive.Int.write(this.ttlSeconds) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaPhoto extends TLObject {
    spoiler?: boolean;
    id!: Raw.TypeInputPhoto;
    ttlSeconds?: int;

    constructor(params: { spoiler?: boolean; id: Raw.TypeInputPhoto; ttlSeconds?: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaPhoto';
      this.constructorId = 0xb3ba0635;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['spoiler', 'id', 'ttlSeconds'];
      this.spoiler = params.spoiler;
      this.id = params.id;
      this.ttlSeconds = params.ttlSeconds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaPhoto> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let spoiler = flags & (1 << 1) ? true : false;
      let id = await TLObject.read(b);
      let ttlSeconds = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.InputMediaPhoto({ spoiler: spoiler, id: id, ttlSeconds: ttlSeconds });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.spoiler ? 1 << 1 : 0;
      flags |= this.ttlSeconds !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(this.id.write() as unknown as Buffer);
      }
      if (this.ttlSeconds !== undefined) {
        b.write(Primitive.Int.write(this.ttlSeconds) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaGeoPoint extends TLObject {
    geoPoint!: Raw.TypeInputGeoPoint;

    constructor(params: { geoPoint: Raw.TypeInputGeoPoint }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaGeoPoint';
      this.constructorId = 0xf9c44144;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['geoPoint'];
      this.geoPoint = params.geoPoint;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaGeoPoint> {
      // no flags

      let geoPoint = await TLObject.read(b);
      return new Raw.InputMediaGeoPoint({ geoPoint: geoPoint });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.geoPoint !== undefined) {
        b.write(this.geoPoint.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaContact extends TLObject {
    phoneNumber!: string;
    firstName!: string;
    lastName!: string;
    vcard!: string;

    constructor(params: {
      phoneNumber: string;
      firstName: string;
      lastName: string;
      vcard: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaContact';
      this.constructorId = 0xf8ab7dfb;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['phoneNumber', 'firstName', 'lastName', 'vcard'];
      this.phoneNumber = params.phoneNumber;
      this.firstName = params.firstName;
      this.lastName = params.lastName;
      this.vcard = params.vcard;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaContact> {
      // no flags

      let phoneNumber = await Primitive.String.read(b);
      let firstName = await Primitive.String.read(b);
      let lastName = await Primitive.String.read(b);
      let vcard = await Primitive.String.read(b);
      return new Raw.InputMediaContact({
        phoneNumber: phoneNumber,
        firstName: firstName,
        lastName: lastName,
        vcard: vcard,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.phoneNumber !== undefined) {
        b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
      }
      if (this.firstName !== undefined) {
        b.write(Primitive.String.write(this.firstName) as unknown as Buffer);
      }
      if (this.lastName !== undefined) {
        b.write(Primitive.String.write(this.lastName) as unknown as Buffer);
      }
      if (this.vcard !== undefined) {
        b.write(Primitive.String.write(this.vcard) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaUploadedDocument extends TLObject {
    nosoundVideo?: boolean;
    forceFile?: boolean;
    spoiler?: boolean;
    file!: Raw.TypeInputFile;
    thumb?: Raw.TypeInputFile;
    mimeType!: string;
    attributes!: Vector<Raw.TypeDocumentAttribute>;
    stickers?: Vector<Raw.TypeInputDocument>;
    ttlSeconds?: int;

    constructor(params: {
      nosoundVideo?: boolean;
      forceFile?: boolean;
      spoiler?: boolean;
      file: Raw.TypeInputFile;
      thumb?: Raw.TypeInputFile;
      mimeType: string;
      attributes: Vector<Raw.TypeDocumentAttribute>;
      stickers?: Vector<Raw.TypeInputDocument>;
      ttlSeconds?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaUploadedDocument';
      this.constructorId = 0x5b38c6c1;
      this.subclassOfId = 0xfaf846f4;
      this._slots = [
        'nosoundVideo',
        'forceFile',
        'spoiler',
        'file',
        'thumb',
        'mimeType',
        'attributes',
        'stickers',
        'ttlSeconds',
      ];
      this.nosoundVideo = params.nosoundVideo;
      this.forceFile = params.forceFile;
      this.spoiler = params.spoiler;
      this.file = params.file;
      this.thumb = params.thumb;
      this.mimeType = params.mimeType;
      this.attributes = params.attributes;
      this.stickers = params.stickers;
      this.ttlSeconds = params.ttlSeconds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaUploadedDocument> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let nosoundVideo = flags & (1 << 3) ? true : false;
      let forceFile = flags & (1 << 4) ? true : false;
      let spoiler = flags & (1 << 5) ? true : false;
      let file = await TLObject.read(b);
      let thumb = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      let mimeType = await Primitive.String.read(b);
      let attributes = await TLObject.read(b);
      let stickers = flags & (1 << 0) ? await TLObject.read(b) : [];
      let ttlSeconds = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      return new Raw.InputMediaUploadedDocument({
        nosoundVideo: nosoundVideo,
        forceFile: forceFile,
        spoiler: spoiler,
        file: file,
        thumb: thumb,
        mimeType: mimeType,
        attributes: attributes,
        stickers: stickers,
        ttlSeconds: ttlSeconds,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.nosoundVideo ? 1 << 3 : 0;
      flags |= this.forceFile ? 1 << 4 : 0;
      flags |= this.spoiler ? 1 << 5 : 0;
      flags |= this.thumb !== undefined ? 1 << 2 : 0;
      flags |= this.stickers ? 1 << 0 : 0;
      flags |= this.ttlSeconds !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.file !== undefined) {
        b.write(this.file.write() as unknown as Buffer);
      }
      if (this.thumb !== undefined) {
        b.write(this.thumb.write() as unknown as Buffer);
      }
      if (this.mimeType !== undefined) {
        b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
      }
      if (this.attributes) {
        b.write(Primitive.Vector.write(this.attributes) as unknown as Buffer);
      }
      if (this.stickers) {
        b.write(Primitive.Vector.write(this.stickers) as unknown as Buffer);
      }
      if (this.ttlSeconds !== undefined) {
        b.write(Primitive.Int.write(this.ttlSeconds) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaDocument extends TLObject {
    spoiler?: boolean;
    id!: Raw.TypeInputDocument;
    ttlSeconds?: int;
    query?: string;

    constructor(params: {
      spoiler?: boolean;
      id: Raw.TypeInputDocument;
      ttlSeconds?: int;
      query?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaDocument';
      this.constructorId = 0x33473058;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['spoiler', 'id', 'ttlSeconds', 'query'];
      this.spoiler = params.spoiler;
      this.id = params.id;
      this.ttlSeconds = params.ttlSeconds;
      this.query = params.query;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaDocument> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let spoiler = flags & (1 << 2) ? true : false;
      let id = await TLObject.read(b);
      let ttlSeconds = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let query = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      return new Raw.InputMediaDocument({
        spoiler: spoiler,
        id: id,
        ttlSeconds: ttlSeconds,
        query: query,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.spoiler ? 1 << 2 : 0;
      flags |= this.ttlSeconds !== undefined ? 1 << 0 : 0;
      flags |= this.query !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(this.id.write() as unknown as Buffer);
      }
      if (this.ttlSeconds !== undefined) {
        b.write(Primitive.Int.write(this.ttlSeconds) as unknown as Buffer);
      }
      if (this.query !== undefined) {
        b.write(Primitive.String.write(this.query) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaVenue extends TLObject {
    geoPoint!: Raw.TypeInputGeoPoint;
    title!: string;
    address!: string;
    provider!: string;
    venueId!: string;
    venueType!: string;

    constructor(params: {
      geoPoint: Raw.TypeInputGeoPoint;
      title: string;
      address: string;
      provider: string;
      venueId: string;
      venueType: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaVenue';
      this.constructorId = 0xc13d1c11;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['geoPoint', 'title', 'address', 'provider', 'venueId', 'venueType'];
      this.geoPoint = params.geoPoint;
      this.title = params.title;
      this.address = params.address;
      this.provider = params.provider;
      this.venueId = params.venueId;
      this.venueType = params.venueType;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaVenue> {
      // no flags

      let geoPoint = await TLObject.read(b);
      let title = await Primitive.String.read(b);
      let address = await Primitive.String.read(b);
      let provider = await Primitive.String.read(b);
      let venueId = await Primitive.String.read(b);
      let venueType = await Primitive.String.read(b);
      return new Raw.InputMediaVenue({
        geoPoint: geoPoint,
        title: title,
        address: address,
        provider: provider,
        venueId: venueId,
        venueType: venueType,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.geoPoint !== undefined) {
        b.write(this.geoPoint.write() as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.address !== undefined) {
        b.write(Primitive.String.write(this.address) as unknown as Buffer);
      }
      if (this.provider !== undefined) {
        b.write(Primitive.String.write(this.provider) as unknown as Buffer);
      }
      if (this.venueId !== undefined) {
        b.write(Primitive.String.write(this.venueId) as unknown as Buffer);
      }
      if (this.venueType !== undefined) {
        b.write(Primitive.String.write(this.venueType) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaPhotoExternal extends TLObject {
    spoiler?: boolean;
    url!: string;
    ttlSeconds?: int;

    constructor(params: { spoiler?: boolean; url: string; ttlSeconds?: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaPhotoExternal';
      this.constructorId = 0xe5bbfe1a;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['spoiler', 'url', 'ttlSeconds'];
      this.spoiler = params.spoiler;
      this.url = params.url;
      this.ttlSeconds = params.ttlSeconds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaPhotoExternal> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let spoiler = flags & (1 << 1) ? true : false;
      let url = await Primitive.String.read(b);
      let ttlSeconds = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.InputMediaPhotoExternal({
        spoiler: spoiler,
        url: url,
        ttlSeconds: ttlSeconds,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.spoiler ? 1 << 1 : 0;
      flags |= this.ttlSeconds !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.ttlSeconds !== undefined) {
        b.write(Primitive.Int.write(this.ttlSeconds) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaDocumentExternal extends TLObject {
    spoiler?: boolean;
    url!: string;
    ttlSeconds?: int;

    constructor(params: { spoiler?: boolean; url: string; ttlSeconds?: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaDocumentExternal';
      this.constructorId = 0xfb52dc99;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['spoiler', 'url', 'ttlSeconds'];
      this.spoiler = params.spoiler;
      this.url = params.url;
      this.ttlSeconds = params.ttlSeconds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaDocumentExternal> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let spoiler = flags & (1 << 1) ? true : false;
      let url = await Primitive.String.read(b);
      let ttlSeconds = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.InputMediaDocumentExternal({
        spoiler: spoiler,
        url: url,
        ttlSeconds: ttlSeconds,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.spoiler ? 1 << 1 : 0;
      flags |= this.ttlSeconds !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.ttlSeconds !== undefined) {
        b.write(Primitive.Int.write(this.ttlSeconds) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaGame extends TLObject {
    id!: Raw.TypeInputGame;

    constructor(params: { id: Raw.TypeInputGame }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaGame';
      this.constructorId = 0xd33f43f3;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaGame> {
      // no flags

      let id = await TLObject.read(b);
      return new Raw.InputMediaGame({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(this.id.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaInvoice extends TLObject {
    title!: string;
    description!: string;
    photo?: Raw.TypeInputWebDocument;
    invoice!: Raw.TypeInvoice;
    payload!: bytes;
    provider!: string;
    providerData!: Raw.TypeDataJSON;
    startParam?: string;
    extendedMedia?: Raw.TypeInputMedia;

    constructor(params: {
      title: string;
      description: string;
      photo?: Raw.TypeInputWebDocument;
      invoice: Raw.TypeInvoice;
      payload: bytes;
      provider: string;
      providerData: Raw.TypeDataJSON;
      startParam?: string;
      extendedMedia?: Raw.TypeInputMedia;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaInvoice';
      this.constructorId = 0x8eb5a6d5;
      this.subclassOfId = 0xfaf846f4;
      this._slots = [
        'title',
        'description',
        'photo',
        'invoice',
        'payload',
        'provider',
        'providerData',
        'startParam',
        'extendedMedia',
      ];
      this.title = params.title;
      this.description = params.description;
      this.photo = params.photo;
      this.invoice = params.invoice;
      this.payload = params.payload;
      this.provider = params.provider;
      this.providerData = params.providerData;
      this.startParam = params.startParam;
      this.extendedMedia = params.extendedMedia;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaInvoice> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let title = await Primitive.String.read(b);
      let description = await Primitive.String.read(b);
      let photo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let invoice = await TLObject.read(b);
      let payload = await Primitive.Bytes.read(b);
      let provider = await Primitive.String.read(b);
      let providerData = await TLObject.read(b);
      let startParam = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let extendedMedia = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.InputMediaInvoice({
        title: title,
        description: description,
        photo: photo,
        invoice: invoice,
        payload: payload,
        provider: provider,
        providerData: providerData,
        startParam: startParam,
        extendedMedia: extendedMedia,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.photo !== undefined ? 1 << 0 : 0;
      flags |= this.startParam !== undefined ? 1 << 1 : 0;
      flags |= this.extendedMedia !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.invoice !== undefined) {
        b.write(this.invoice.write() as unknown as Buffer);
      }
      if (this.payload !== undefined) {
        b.write(Primitive.Bytes.write(this.payload) as unknown as Buffer);
      }
      if (this.provider !== undefined) {
        b.write(Primitive.String.write(this.provider) as unknown as Buffer);
      }
      if (this.providerData !== undefined) {
        b.write(this.providerData.write() as unknown as Buffer);
      }
      if (this.startParam !== undefined) {
        b.write(Primitive.String.write(this.startParam) as unknown as Buffer);
      }
      if (this.extendedMedia !== undefined) {
        b.write(this.extendedMedia.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaGeoLive extends TLObject {
    stopped?: boolean;
    geoPoint!: Raw.TypeInputGeoPoint;
    heading?: int;
    period?: int;
    proximityNotificationRadius?: int;

    constructor(params: {
      stopped?: boolean;
      geoPoint: Raw.TypeInputGeoPoint;
      heading?: int;
      period?: int;
      proximityNotificationRadius?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaGeoLive';
      this.constructorId = 0x971fa843;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['stopped', 'geoPoint', 'heading', 'period', 'proximityNotificationRadius'];
      this.stopped = params.stopped;
      this.geoPoint = params.geoPoint;
      this.heading = params.heading;
      this.period = params.period;
      this.proximityNotificationRadius = params.proximityNotificationRadius;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaGeoLive> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let stopped = flags & (1 << 0) ? true : false;
      let geoPoint = await TLObject.read(b);
      let heading = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let period = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      let proximityNotificationRadius = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
      return new Raw.InputMediaGeoLive({
        stopped: stopped,
        geoPoint: geoPoint,
        heading: heading,
        period: period,
        proximityNotificationRadius: proximityNotificationRadius,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.stopped ? 1 << 0 : 0;
      flags |= this.heading !== undefined ? 1 << 2 : 0;
      flags |= this.period !== undefined ? 1 << 1 : 0;
      flags |= this.proximityNotificationRadius !== undefined ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.geoPoint !== undefined) {
        b.write(this.geoPoint.write() as unknown as Buffer);
      }
      if (this.heading !== undefined) {
        b.write(Primitive.Int.write(this.heading) as unknown as Buffer);
      }
      if (this.period !== undefined) {
        b.write(Primitive.Int.write(this.period) as unknown as Buffer);
      }
      if (this.proximityNotificationRadius !== undefined) {
        b.write(Primitive.Int.write(this.proximityNotificationRadius) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaPoll extends TLObject {
    poll!: Raw.TypePoll;
    correctAnswers?: Vector<bytes>;
    solution?: string;
    solutionEntities?: Vector<Raw.TypeMessageEntity>;

    constructor(params: {
      poll: Raw.TypePoll;
      correctAnswers?: Vector<bytes>;
      solution?: string;
      solutionEntities?: Vector<Raw.TypeMessageEntity>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaPoll';
      this.constructorId = 0xf94e5f1;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['poll', 'correctAnswers', 'solution', 'solutionEntities'];
      this.poll = params.poll;
      this.correctAnswers = params.correctAnswers;
      this.solution = params.solution;
      this.solutionEntities = params.solutionEntities;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaPoll> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let poll = await TLObject.read(b);
      let correctAnswers = flags & (1 << 0) ? await TLObject.read(b, Primitive.Bytes) : [];
      let solution = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let solutionEntities = flags & (1 << 1) ? await TLObject.read(b) : [];
      return new Raw.InputMediaPoll({
        poll: poll,
        correctAnswers: correctAnswers,
        solution: solution,
        solutionEntities: solutionEntities,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.correctAnswers ? 1 << 0 : 0;
      flags |= this.solution !== undefined ? 1 << 1 : 0;
      flags |= this.solutionEntities ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.poll !== undefined) {
        b.write(this.poll.write() as unknown as Buffer);
      }
      if (this.correctAnswers) {
        b.write(Primitive.Vector.write(this.correctAnswers, Primitive.Bytes) as unknown as Buffer);
      }
      if (this.solution !== undefined) {
        b.write(Primitive.String.write(this.solution) as unknown as Buffer);
      }
      if (this.solutionEntities) {
        b.write(Primitive.Vector.write(this.solutionEntities) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaDice extends TLObject {
    emoticon!: string;

    constructor(params: { emoticon: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaDice';
      this.constructorId = 0xe66fbf7b;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['emoticon'];
      this.emoticon = params.emoticon;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaDice> {
      // no flags

      let emoticon = await Primitive.String.read(b);
      return new Raw.InputMediaDice({ emoticon: emoticon });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.emoticon !== undefined) {
        b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaStory extends TLObject {
    peer!: Raw.TypeInputPeer;
    id!: int;

    constructor(params: { peer: Raw.TypeInputPeer; id: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaStory';
      this.constructorId = 0x89fdd778;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['peer', 'id'];
      this.peer = params.peer;
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaStory> {
      // no flags

      let peer = await TLObject.read(b);
      let id = await Primitive.Int.read(b);
      return new Raw.InputMediaStory({ peer: peer, id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaWebPage extends TLObject {
    forceLargeMedia?: boolean;
    forceSmallMedia?: boolean;
    optional?: boolean;
    url!: string;

    constructor(params: {
      forceLargeMedia?: boolean;
      forceSmallMedia?: boolean;
      optional?: boolean;
      url: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaWebPage';
      this.constructorId = 0xc21b8849;
      this.subclassOfId = 0xfaf846f4;
      this._slots = ['forceLargeMedia', 'forceSmallMedia', 'optional', 'url'];
      this.forceLargeMedia = params.forceLargeMedia;
      this.forceSmallMedia = params.forceSmallMedia;
      this.optional = params.optional;
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaWebPage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let forceLargeMedia = flags & (1 << 0) ? true : false;
      let forceSmallMedia = flags & (1 << 1) ? true : false;
      let optional = flags & (1 << 2) ? true : false;
      let url = await Primitive.String.read(b);
      return new Raw.InputMediaWebPage({
        forceLargeMedia: forceLargeMedia,
        forceSmallMedia: forceSmallMedia,
        optional: optional,
        url: url,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.forceLargeMedia ? 1 << 0 : 0;
      flags |= this.forceSmallMedia ? 1 << 1 : 0;
      flags |= this.optional ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputChatPhotoEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputChatPhotoEmpty';
      this.constructorId = 0x1ca48f57;
      this.subclassOfId = 0xd4eb2d74;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputChatPhotoEmpty> {
      // no flags

      return new Raw.InputChatPhotoEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputChatUploadedPhoto extends TLObject {
    file?: Raw.TypeInputFile;
    video?: Raw.TypeInputFile;
    videoStartTs?: double;
    videoEmojiMarkup?: Raw.TypeVideoSize;

    constructor(params: {
      file?: Raw.TypeInputFile;
      video?: Raw.TypeInputFile;
      videoStartTs?: double;
      videoEmojiMarkup?: Raw.TypeVideoSize;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputChatUploadedPhoto';
      this.constructorId = 0xbdcdaec0;
      this.subclassOfId = 0xd4eb2d74;
      this._slots = ['file', 'video', 'videoStartTs', 'videoEmojiMarkup'];
      this.file = params.file;
      this.video = params.video;
      this.videoStartTs = params.videoStartTs;
      this.videoEmojiMarkup = params.videoEmojiMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputChatUploadedPhoto> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let file = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let video = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let videoStartTs = flags & (1 << 2) ? await Primitive.Double.read(b) : undefined;
      let videoEmojiMarkup = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      return new Raw.InputChatUploadedPhoto({
        file: file,
        video: video,
        videoStartTs: videoStartTs,
        videoEmojiMarkup: videoEmojiMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.file !== undefined ? 1 << 0 : 0;
      flags |= this.video !== undefined ? 1 << 1 : 0;
      flags |= this.videoStartTs !== undefined ? 1 << 2 : 0;
      flags |= this.videoEmojiMarkup !== undefined ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.file !== undefined) {
        b.write(this.file.write() as unknown as Buffer);
      }
      if (this.video !== undefined) {
        b.write(this.video.write() as unknown as Buffer);
      }
      if (this.videoStartTs !== undefined) {
        b.write(Primitive.Double.write(this.videoStartTs) as unknown as Buffer);
      }
      if (this.videoEmojiMarkup !== undefined) {
        b.write(this.videoEmojiMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputChatPhoto extends TLObject {
    id!: Raw.TypeInputPhoto;

    constructor(params: { id: Raw.TypeInputPhoto }) {
      super();
      this.classType = 'types';
      this.className = 'InputChatPhoto';
      this.constructorId = 0x8953ad37;
      this.subclassOfId = 0xd4eb2d74;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputChatPhoto> {
      // no flags

      let id = await TLObject.read(b);
      return new Raw.InputChatPhoto({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(this.id.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputGeoPointEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputGeoPointEmpty';
      this.constructorId = 0xe4c123d6;
      this.subclassOfId = 0x430d225;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputGeoPointEmpty> {
      // no flags

      return new Raw.InputGeoPointEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputGeoPoint extends TLObject {
    lat!: double;
    long!: double;
    accuracyRadius?: int;

    constructor(params: { lat: double; long: double; accuracyRadius?: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputGeoPoint';
      this.constructorId = 0x48222faf;
      this.subclassOfId = 0x430d225;
      this._slots = ['lat', 'long', 'accuracyRadius'];
      this.lat = params.lat;
      this.long = params.long;
      this.accuracyRadius = params.accuracyRadius;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputGeoPoint> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let lat = await Primitive.Double.read(b);
      let long = await Primitive.Double.read(b);
      let accuracyRadius = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.InputGeoPoint({ lat: lat, long: long, accuracyRadius: accuracyRadius });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.accuracyRadius !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.lat !== undefined) {
        b.write(Primitive.Double.write(this.lat) as unknown as Buffer);
      }
      if (this.long !== undefined) {
        b.write(Primitive.Double.write(this.long) as unknown as Buffer);
      }
      if (this.accuracyRadius !== undefined) {
        b.write(Primitive.Int.write(this.accuracyRadius) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPhotoEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPhotoEmpty';
      this.constructorId = 0x1cd7bf0d;
      this.subclassOfId = 0x846363e0;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPhotoEmpty> {
      // no flags

      return new Raw.InputPhotoEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPhoto extends TLObject {
    id!: long;
    accessHash!: long;
    fileReference!: bytes;

    constructor(params: { id: long; accessHash: long; fileReference: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'InputPhoto';
      this.constructorId = 0x3bb3b94a;
      this.subclassOfId = 0x846363e0;
      this._slots = ['id', 'accessHash', 'fileReference'];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.fileReference = params.fileReference;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPhoto> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let fileReference = await Primitive.Bytes.read(b);
      return new Raw.InputPhoto({ id: id, accessHash: accessHash, fileReference: fileReference });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.fileReference !== undefined) {
        b.write(Primitive.Bytes.write(this.fileReference) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputFileLocation extends TLObject {
    volumeId!: long;
    localId!: int;
    secret!: long;
    fileReference!: bytes;

    constructor(params: { volumeId: long; localId: int; secret: long; fileReference: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'InputFileLocation';
      this.constructorId = 0xdfdaabe1;
      this.subclassOfId = 0x1523d462;
      this._slots = ['volumeId', 'localId', 'secret', 'fileReference'];
      this.volumeId = params.volumeId;
      this.localId = params.localId;
      this.secret = params.secret;
      this.fileReference = params.fileReference;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputFileLocation> {
      // no flags

      let volumeId = await Primitive.Long.read(b);
      let localId = await Primitive.Int.read(b);
      let secret = await Primitive.Long.read(b);
      let fileReference = await Primitive.Bytes.read(b);
      return new Raw.InputFileLocation({
        volumeId: volumeId,
        localId: localId,
        secret: secret,
        fileReference: fileReference,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.volumeId !== undefined) {
        b.write(Primitive.Long.write(this.volumeId) as unknown as Buffer);
      }
      if (this.localId !== undefined) {
        b.write(Primitive.Int.write(this.localId) as unknown as Buffer);
      }
      if (this.secret !== undefined) {
        b.write(Primitive.Long.write(this.secret) as unknown as Buffer);
      }
      if (this.fileReference !== undefined) {
        b.write(Primitive.Bytes.write(this.fileReference) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputEncryptedFileLocation extends TLObject {
    id!: long;
    accessHash!: long;

    constructor(params: { id: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputEncryptedFileLocation';
      this.constructorId = 0xf5235d55;
      this.subclassOfId = 0x1523d462;
      this._slots = ['id', 'accessHash'];
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputEncryptedFileLocation> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputEncryptedFileLocation({ id: id, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputDocumentFileLocation extends TLObject {
    id!: long;
    accessHash!: long;
    fileReference!: bytes;
    thumbSize!: string;

    constructor(params: { id: long; accessHash: long; fileReference: bytes; thumbSize: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputDocumentFileLocation';
      this.constructorId = 0xbad07584;
      this.subclassOfId = 0x1523d462;
      this._slots = ['id', 'accessHash', 'fileReference', 'thumbSize'];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.fileReference = params.fileReference;
      this.thumbSize = params.thumbSize;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputDocumentFileLocation> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let fileReference = await Primitive.Bytes.read(b);
      let thumbSize = await Primitive.String.read(b);
      return new Raw.InputDocumentFileLocation({
        id: id,
        accessHash: accessHash,
        fileReference: fileReference,
        thumbSize: thumbSize,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.fileReference !== undefined) {
        b.write(Primitive.Bytes.write(this.fileReference) as unknown as Buffer);
      }
      if (this.thumbSize !== undefined) {
        b.write(Primitive.String.write(this.thumbSize) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputSecureFileLocation extends TLObject {
    id!: long;
    accessHash!: long;

    constructor(params: { id: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputSecureFileLocation';
      this.constructorId = 0xcbc7ee28;
      this.subclassOfId = 0x1523d462;
      this._slots = ['id', 'accessHash'];
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputSecureFileLocation> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputSecureFileLocation({ id: id, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputTakeoutFileLocation extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputTakeoutFileLocation';
      this.constructorId = 0x29be5899;
      this.subclassOfId = 0x1523d462;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputTakeoutFileLocation> {
      // no flags

      return new Raw.InputTakeoutFileLocation();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPhotoFileLocation extends TLObject {
    id!: long;
    accessHash!: long;
    fileReference!: bytes;
    thumbSize!: string;

    constructor(params: { id: long; accessHash: long; fileReference: bytes; thumbSize: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputPhotoFileLocation';
      this.constructorId = 0x40181ffe;
      this.subclassOfId = 0x1523d462;
      this._slots = ['id', 'accessHash', 'fileReference', 'thumbSize'];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.fileReference = params.fileReference;
      this.thumbSize = params.thumbSize;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPhotoFileLocation> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let fileReference = await Primitive.Bytes.read(b);
      let thumbSize = await Primitive.String.read(b);
      return new Raw.InputPhotoFileLocation({
        id: id,
        accessHash: accessHash,
        fileReference: fileReference,
        thumbSize: thumbSize,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.fileReference !== undefined) {
        b.write(Primitive.Bytes.write(this.fileReference) as unknown as Buffer);
      }
      if (this.thumbSize !== undefined) {
        b.write(Primitive.String.write(this.thumbSize) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPhotoLegacyFileLocation extends TLObject {
    id!: long;
    accessHash!: long;
    fileReference!: bytes;
    volumeId!: long;
    localId!: int;
    secret!: long;

    constructor(params: {
      id: long;
      accessHash: long;
      fileReference: bytes;
      volumeId: long;
      localId: int;
      secret: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputPhotoLegacyFileLocation';
      this.constructorId = 0xd83466f3;
      this.subclassOfId = 0x1523d462;
      this._slots = ['id', 'accessHash', 'fileReference', 'volumeId', 'localId', 'secret'];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.fileReference = params.fileReference;
      this.volumeId = params.volumeId;
      this.localId = params.localId;
      this.secret = params.secret;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPhotoLegacyFileLocation> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let fileReference = await Primitive.Bytes.read(b);
      let volumeId = await Primitive.Long.read(b);
      let localId = await Primitive.Int.read(b);
      let secret = await Primitive.Long.read(b);
      return new Raw.InputPhotoLegacyFileLocation({
        id: id,
        accessHash: accessHash,
        fileReference: fileReference,
        volumeId: volumeId,
        localId: localId,
        secret: secret,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.fileReference !== undefined) {
        b.write(Primitive.Bytes.write(this.fileReference) as unknown as Buffer);
      }
      if (this.volumeId !== undefined) {
        b.write(Primitive.Long.write(this.volumeId) as unknown as Buffer);
      }
      if (this.localId !== undefined) {
        b.write(Primitive.Int.write(this.localId) as unknown as Buffer);
      }
      if (this.secret !== undefined) {
        b.write(Primitive.Long.write(this.secret) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPeerPhotoFileLocation extends TLObject {
    big?: boolean;
    peer!: Raw.TypeInputPeer;
    photoId!: long;

    constructor(params: { big?: boolean; peer: Raw.TypeInputPeer; photoId: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputPeerPhotoFileLocation';
      this.constructorId = 0x37257e99;
      this.subclassOfId = 0x1523d462;
      this._slots = ['big', 'peer', 'photoId'];
      this.big = params.big;
      this.peer = params.peer;
      this.photoId = params.photoId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPeerPhotoFileLocation> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let big = flags & (1 << 0) ? true : false;
      let peer = await TLObject.read(b);
      let photoId = await Primitive.Long.read(b);
      return new Raw.InputPeerPhotoFileLocation({ big: big, peer: peer, photoId: photoId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.big ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.photoId !== undefined) {
        b.write(Primitive.Long.write(this.photoId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputStickerSetThumb extends TLObject {
    stickerset!: Raw.TypeInputStickerSet;
    thumbVersion!: int;

    constructor(params: { stickerset: Raw.TypeInputStickerSet; thumbVersion: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputStickerSetThumb';
      this.constructorId = 0x9d84f3db;
      this.subclassOfId = 0x1523d462;
      this._slots = ['stickerset', 'thumbVersion'];
      this.stickerset = params.stickerset;
      this.thumbVersion = params.thumbVersion;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputStickerSetThumb> {
      // no flags

      let stickerset = await TLObject.read(b);
      let thumbVersion = await Primitive.Int.read(b);
      return new Raw.InputStickerSetThumb({ stickerset: stickerset, thumbVersion: thumbVersion });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.stickerset !== undefined) {
        b.write(this.stickerset.write() as unknown as Buffer);
      }
      if (this.thumbVersion !== undefined) {
        b.write(Primitive.Int.write(this.thumbVersion) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputGroupCallStream extends TLObject {
    call!: Raw.TypeInputGroupCall;
    timeMs!: long;
    scale!: int;
    videoChannel?: int;
    videoQuality?: int;

    constructor(params: {
      call: Raw.TypeInputGroupCall;
      timeMs: long;
      scale: int;
      videoChannel?: int;
      videoQuality?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputGroupCallStream';
      this.constructorId = 0x598a92a;
      this.subclassOfId = 0x1523d462;
      this._slots = ['call', 'timeMs', 'scale', 'videoChannel', 'videoQuality'];
      this.call = params.call;
      this.timeMs = params.timeMs;
      this.scale = params.scale;
      this.videoChannel = params.videoChannel;
      this.videoQuality = params.videoQuality;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputGroupCallStream> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let call = await TLObject.read(b);
      let timeMs = await Primitive.Long.read(b);
      let scale = await Primitive.Int.read(b);
      let videoChannel = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let videoQuality = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.InputGroupCallStream({
        call: call,
        timeMs: timeMs,
        scale: scale,
        videoChannel: videoChannel,
        videoQuality: videoQuality,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.videoChannel !== undefined ? 1 << 0 : 0;
      flags |= this.videoQuality !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.call !== undefined) {
        b.write(this.call.write() as unknown as Buffer);
      }
      if (this.timeMs !== undefined) {
        b.write(Primitive.Long.write(this.timeMs) as unknown as Buffer);
      }
      if (this.scale !== undefined) {
        b.write(Primitive.Int.write(this.scale) as unknown as Buffer);
      }
      if (this.videoChannel !== undefined) {
        b.write(Primitive.Int.write(this.videoChannel) as unknown as Buffer);
      }
      if (this.videoQuality !== undefined) {
        b.write(Primitive.Int.write(this.videoQuality) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PeerUser extends TLObject {
    userId!: long;

    constructor(params: { userId: long }) {
      super();
      this.classType = 'types';
      this.className = 'PeerUser';
      this.constructorId = 0x59511722;
      this.subclassOfId = 0x2d45687;
      this._slots = ['userId'];
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PeerUser> {
      // no flags

      let userId = await Primitive.Long.read(b);
      return new Raw.PeerUser({ userId: userId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PeerChat extends TLObject {
    chatId!: long;

    constructor(params: { chatId: long }) {
      super();
      this.classType = 'types';
      this.className = 'PeerChat';
      this.constructorId = 0x36c6019a;
      this.subclassOfId = 0x2d45687;
      this._slots = ['chatId'];
      this.chatId = params.chatId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PeerChat> {
      // no flags

      let chatId = await Primitive.Long.read(b);
      return new Raw.PeerChat({ chatId: chatId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PeerChannel extends TLObject {
    channelId!: long;

    constructor(params: { channelId: long }) {
      super();
      this.classType = 'types';
      this.className = 'PeerChannel';
      this.constructorId = 0xa2a5371e;
      this.subclassOfId = 0x2d45687;
      this._slots = ['channelId'];
      this.channelId = params.channelId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PeerChannel> {
      // no flags

      let channelId = await Primitive.Long.read(b);
      return new Raw.PeerChannel({ channelId: channelId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UserEmpty extends TLObject {
    id!: long;

    constructor(params: { id: long }) {
      super();
      this.classType = 'types';
      this.className = 'UserEmpty';
      this.constructorId = 0xd3bc4b7a;
      this.subclassOfId = 0x2da17977;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UserEmpty> {
      // no flags

      let id = await Primitive.Long.read(b);
      return new Raw.UserEmpty({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class User extends TLObject {
    self?: boolean;
    contact?: boolean;
    mutualContact?: boolean;
    deleted?: boolean;
    bot?: boolean;
    botChatHistory?: boolean;
    botNochats?: boolean;
    verified?: boolean;
    restricted?: boolean;
    min?: boolean;
    botInlineGeo?: boolean;
    support?: boolean;
    scam?: boolean;
    applyMinPhoto?: boolean;
    fake?: boolean;
    botAttachMenu?: boolean;
    premium?: boolean;
    attachMenuEnabled?: boolean;
    botCanEdit?: boolean;
    closeFriend?: boolean;
    storiesHidden?: boolean;
    storiesUnavailable?: boolean;
    id!: long;
    accessHash?: long;
    firstName?: string;
    lastName?: string;
    username?: string;
    phone?: string;
    photo?: Raw.TypeUserProfilePhoto;
    status?: Raw.TypeUserStatus;
    botInfoVersion?: int;
    restrictionReason?: Vector<Raw.TypeRestrictionReason>;
    botInlinePlaceholder?: string;
    langCode?: string;
    emojiStatus?: Raw.TypeEmojiStatus;
    usernames?: Vector<Raw.TypeUsername>;
    storiesMaxId?: int;
    color?: int;
    backgroundEmojiId?: long;

    constructor(params: {
      self?: boolean;
      contact?: boolean;
      mutualContact?: boolean;
      deleted?: boolean;
      bot?: boolean;
      botChatHistory?: boolean;
      botNochats?: boolean;
      verified?: boolean;
      restricted?: boolean;
      min?: boolean;
      botInlineGeo?: boolean;
      support?: boolean;
      scam?: boolean;
      applyMinPhoto?: boolean;
      fake?: boolean;
      botAttachMenu?: boolean;
      premium?: boolean;
      attachMenuEnabled?: boolean;
      botCanEdit?: boolean;
      closeFriend?: boolean;
      storiesHidden?: boolean;
      storiesUnavailable?: boolean;
      id: long;
      accessHash?: long;
      firstName?: string;
      lastName?: string;
      username?: string;
      phone?: string;
      photo?: Raw.TypeUserProfilePhoto;
      status?: Raw.TypeUserStatus;
      botInfoVersion?: int;
      restrictionReason?: Vector<Raw.TypeRestrictionReason>;
      botInlinePlaceholder?: string;
      langCode?: string;
      emojiStatus?: Raw.TypeEmojiStatus;
      usernames?: Vector<Raw.TypeUsername>;
      storiesMaxId?: int;
      color?: int;
      backgroundEmojiId?: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'User';
      this.constructorId = 0xeb602f25;
      this.subclassOfId = 0x2da17977;
      this._slots = [
        'self',
        'contact',
        'mutualContact',
        'deleted',
        'bot',
        'botChatHistory',
        'botNochats',
        'verified',
        'restricted',
        'min',
        'botInlineGeo',
        'support',
        'scam',
        'applyMinPhoto',
        'fake',
        'botAttachMenu',
        'premium',
        'attachMenuEnabled',
        'botCanEdit',
        'closeFriend',
        'storiesHidden',
        'storiesUnavailable',
        'id',
        'accessHash',
        'firstName',
        'lastName',
        'username',
        'phone',
        'photo',
        'status',
        'botInfoVersion',
        'restrictionReason',
        'botInlinePlaceholder',
        'langCode',
        'emojiStatus',
        'usernames',
        'storiesMaxId',
        'color',
        'backgroundEmojiId',
      ];
      this.self = params.self;
      this.contact = params.contact;
      this.mutualContact = params.mutualContact;
      this.deleted = params.deleted;
      this.bot = params.bot;
      this.botChatHistory = params.botChatHistory;
      this.botNochats = params.botNochats;
      this.verified = params.verified;
      this.restricted = params.restricted;
      this.min = params.min;
      this.botInlineGeo = params.botInlineGeo;
      this.support = params.support;
      this.scam = params.scam;
      this.applyMinPhoto = params.applyMinPhoto;
      this.fake = params.fake;
      this.botAttachMenu = params.botAttachMenu;
      this.premium = params.premium;
      this.attachMenuEnabled = params.attachMenuEnabled;
      this.botCanEdit = params.botCanEdit;
      this.closeFriend = params.closeFriend;
      this.storiesHidden = params.storiesHidden;
      this.storiesUnavailable = params.storiesUnavailable;
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.firstName = params.firstName;
      this.lastName = params.lastName;
      this.username = params.username;
      this.phone = params.phone;
      this.photo = params.photo;
      this.status = params.status;
      this.botInfoVersion = params.botInfoVersion;
      this.restrictionReason = params.restrictionReason;
      this.botInlinePlaceholder = params.botInlinePlaceholder;
      this.langCode = params.langCode;
      this.emojiStatus = params.emojiStatus;
      this.usernames = params.usernames;
      this.storiesMaxId = params.storiesMaxId;
      this.color = params.color;
      this.backgroundEmojiId = params.backgroundEmojiId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.User> {
      let flags = await Primitive.Int.read(b);

      let self = flags & (1 << 10) ? true : false;
      let contact = flags & (1 << 11) ? true : false;
      let mutualContact = flags & (1 << 12) ? true : false;
      let deleted = flags & (1 << 13) ? true : false;
      let bot = flags & (1 << 14) ? true : false;
      let botChatHistory = flags & (1 << 15) ? true : false;
      let botNochats = flags & (1 << 16) ? true : false;
      let verified = flags & (1 << 17) ? true : false;
      let restricted = flags & (1 << 18) ? true : false;
      let min = flags & (1 << 20) ? true : false;
      let botInlineGeo = flags & (1 << 21) ? true : false;
      let support = flags & (1 << 23) ? true : false;
      let scam = flags & (1 << 24) ? true : false;
      let applyMinPhoto = flags & (1 << 25) ? true : false;
      let fake = flags & (1 << 26) ? true : false;
      let botAttachMenu = flags & (1 << 27) ? true : false;
      let premium = flags & (1 << 28) ? true : false;
      let attachMenuEnabled = flags & (1 << 29) ? true : false;
      let flags2 = await Primitive.Int.read(b);

      let botCanEdit = flags2 & (1 << 1) ? true : false;
      let closeFriend = flags2 & (1 << 2) ? true : false;
      let storiesHidden = flags2 & (1 << 3) ? true : false;
      let storiesUnavailable = flags2 & (1 << 4) ? true : false;
      let id = await Primitive.Long.read(b);
      let accessHash = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
      let firstName = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let lastName = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      let username = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
      let phone = flags & (1 << 4) ? await Primitive.String.read(b) : undefined;
      let photo = flags & (1 << 5) ? await TLObject.read(b) : undefined;
      let status = flags & (1 << 6) ? await TLObject.read(b) : undefined;
      let botInfoVersion = flags & (1 << 14) ? await Primitive.Int.read(b) : undefined;
      let restrictionReason = flags & (1 << 18) ? await TLObject.read(b) : [];
      let botInlinePlaceholder = flags & (1 << 19) ? await Primitive.String.read(b) : undefined;
      let langCode = flags & (1 << 22) ? await Primitive.String.read(b) : undefined;
      let emojiStatus = flags & (1 << 30) ? await TLObject.read(b) : undefined;
      let usernames = flags2 & (1 << 0) ? await TLObject.read(b) : [];
      let storiesMaxId = flags2 & (1 << 5) ? await Primitive.Int.read(b) : undefined;
      let color = flags2 & (1 << 7) ? await Primitive.Int.read(b) : undefined;
      let backgroundEmojiId = flags2 & (1 << 6) ? await Primitive.Long.read(b) : undefined;
      return new Raw.User({
        self: self,
        contact: contact,
        mutualContact: mutualContact,
        deleted: deleted,
        bot: bot,
        botChatHistory: botChatHistory,
        botNochats: botNochats,
        verified: verified,
        restricted: restricted,
        min: min,
        botInlineGeo: botInlineGeo,
        support: support,
        scam: scam,
        applyMinPhoto: applyMinPhoto,
        fake: fake,
        botAttachMenu: botAttachMenu,
        premium: premium,
        attachMenuEnabled: attachMenuEnabled,
        botCanEdit: botCanEdit,
        closeFriend: closeFriend,
        storiesHidden: storiesHidden,
        storiesUnavailable: storiesUnavailable,
        id: id,
        accessHash: accessHash,
        firstName: firstName,
        lastName: lastName,
        username: username,
        phone: phone,
        photo: photo,
        status: status,
        botInfoVersion: botInfoVersion,
        restrictionReason: restrictionReason,
        botInlinePlaceholder: botInlinePlaceholder,
        langCode: langCode,
        emojiStatus: emojiStatus,
        usernames: usernames,
        storiesMaxId: storiesMaxId,
        color: color,
        backgroundEmojiId: backgroundEmojiId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);

      let flags = 0;
      flags |= this.self ? 1 << 10 : 0;
      flags |= this.contact ? 1 << 11 : 0;
      flags |= this.mutualContact ? 1 << 12 : 0;
      flags |= this.deleted ? 1 << 13 : 0;
      flags |= this.bot ? 1 << 14 : 0;
      flags |= this.botChatHistory ? 1 << 15 : 0;
      flags |= this.botNochats ? 1 << 16 : 0;
      flags |= this.verified ? 1 << 17 : 0;
      flags |= this.restricted ? 1 << 18 : 0;
      flags |= this.min ? 1 << 20 : 0;
      flags |= this.botInlineGeo ? 1 << 21 : 0;
      flags |= this.support ? 1 << 23 : 0;
      flags |= this.scam ? 1 << 24 : 0;
      flags |= this.applyMinPhoto ? 1 << 25 : 0;
      flags |= this.fake ? 1 << 26 : 0;
      flags |= this.botAttachMenu ? 1 << 27 : 0;
      flags |= this.premium ? 1 << 28 : 0;
      flags |= this.attachMenuEnabled ? 1 << 29 : 0;
      flags |= this.accessHash !== undefined ? 1 << 0 : 0;
      flags |= this.firstName !== undefined ? 1 << 1 : 0;
      flags |= this.lastName !== undefined ? 1 << 2 : 0;
      flags |= this.username !== undefined ? 1 << 3 : 0;
      flags |= this.phone !== undefined ? 1 << 4 : 0;
      flags |= this.photo !== undefined ? 1 << 5 : 0;
      flags |= this.status !== undefined ? 1 << 6 : 0;
      flags |= this.botInfoVersion !== undefined ? 1 << 14 : 0;
      flags |= this.restrictionReason ? 1 << 18 : 0;
      flags |= this.botInlinePlaceholder !== undefined ? 1 << 19 : 0;
      flags |= this.langCode !== undefined ? 1 << 22 : 0;
      flags |= this.emojiStatus !== undefined ? 1 << 30 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      let flags2 = 0;
      flags2 |= this.botCanEdit ? 1 << 1 : 0;
      flags2 |= this.closeFriend ? 1 << 2 : 0;
      flags2 |= this.storiesHidden ? 1 << 3 : 0;
      flags2 |= this.storiesUnavailable ? 1 << 4 : 0;
      flags2 |= this.usernames ? 1 << 0 : 0;
      flags2 |= this.storiesMaxId !== undefined ? 1 << 5 : 0;
      flags2 |= this.color !== undefined ? 1 << 7 : 0;
      flags2 |= this.backgroundEmojiId !== undefined ? 1 << 6 : 0;
      b.write(Primitive.Int.write(flags2) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.firstName !== undefined) {
        b.write(Primitive.String.write(this.firstName) as unknown as Buffer);
      }
      if (this.lastName !== undefined) {
        b.write(Primitive.String.write(this.lastName) as unknown as Buffer);
      }
      if (this.username !== undefined) {
        b.write(Primitive.String.write(this.username) as unknown as Buffer);
      }
      if (this.phone !== undefined) {
        b.write(Primitive.String.write(this.phone) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.status !== undefined) {
        b.write(this.status.write() as unknown as Buffer);
      }
      if (this.botInfoVersion !== undefined) {
        b.write(Primitive.Int.write(this.botInfoVersion) as unknown as Buffer);
      }
      if (this.restrictionReason) {
        b.write(Primitive.Vector.write(this.restrictionReason) as unknown as Buffer);
      }
      if (this.botInlinePlaceholder !== undefined) {
        b.write(Primitive.String.write(this.botInlinePlaceholder) as unknown as Buffer);
      }
      if (this.langCode !== undefined) {
        b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
      }
      if (this.emojiStatus !== undefined) {
        b.write(this.emojiStatus.write() as unknown as Buffer);
      }
      if (this.usernames) {
        b.write(Primitive.Vector.write(this.usernames) as unknown as Buffer);
      }
      if (this.storiesMaxId !== undefined) {
        b.write(Primitive.Int.write(this.storiesMaxId) as unknown as Buffer);
      }
      if (this.color !== undefined) {
        b.write(Primitive.Int.write(this.color) as unknown as Buffer);
      }
      if (this.backgroundEmojiId !== undefined) {
        b.write(Primitive.Long.write(this.backgroundEmojiId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UserProfilePhotoEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UserProfilePhotoEmpty';
      this.constructorId = 0x4f11bae1;
      this.subclassOfId = 0xc6338f7d;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UserProfilePhotoEmpty> {
      // no flags

      return new Raw.UserProfilePhotoEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UserProfilePhoto extends TLObject {
    hasVideo?: boolean;
    personal?: boolean;
    photoId!: long;
    strippedThumb?: bytes;
    dcId!: int;

    constructor(params: {
      hasVideo?: boolean;
      personal?: boolean;
      photoId: long;
      strippedThumb?: bytes;
      dcId: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UserProfilePhoto';
      this.constructorId = 0x82d1f706;
      this.subclassOfId = 0xc6338f7d;
      this._slots = ['hasVideo', 'personal', 'photoId', 'strippedThumb', 'dcId'];
      this.hasVideo = params.hasVideo;
      this.personal = params.personal;
      this.photoId = params.photoId;
      this.strippedThumb = params.strippedThumb;
      this.dcId = params.dcId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UserProfilePhoto> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let hasVideo = flags & (1 << 0) ? true : false;
      let personal = flags & (1 << 2) ? true : false;
      let photoId = await Primitive.Long.read(b);
      let strippedThumb = flags & (1 << 1) ? await Primitive.Bytes.read(b) : undefined;
      let dcId = await Primitive.Int.read(b);
      return new Raw.UserProfilePhoto({
        hasVideo: hasVideo,
        personal: personal,
        photoId: photoId,
        strippedThumb: strippedThumb,
        dcId: dcId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.hasVideo ? 1 << 0 : 0;
      flags |= this.personal ? 1 << 2 : 0;
      flags |= this.strippedThumb !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.photoId !== undefined) {
        b.write(Primitive.Long.write(this.photoId) as unknown as Buffer);
      }
      if (this.strippedThumb !== undefined) {
        b.write(Primitive.Bytes.write(this.strippedThumb) as unknown as Buffer);
      }
      if (this.dcId !== undefined) {
        b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UserStatusEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UserStatusEmpty';
      this.constructorId = 0x9d05049;
      this.subclassOfId = 0x5b0b743e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UserStatusEmpty> {
      // no flags

      return new Raw.UserStatusEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UserStatusOnline extends TLObject {
    expires!: int;

    constructor(params: { expires: int }) {
      super();
      this.classType = 'types';
      this.className = 'UserStatusOnline';
      this.constructorId = 0xedb93949;
      this.subclassOfId = 0x5b0b743e;
      this._slots = ['expires'];
      this.expires = params.expires;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UserStatusOnline> {
      // no flags

      let expires = await Primitive.Int.read(b);
      return new Raw.UserStatusOnline({ expires: expires });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.expires !== undefined) {
        b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UserStatusOffline extends TLObject {
    wasOnline!: int;

    constructor(params: { wasOnline: int }) {
      super();
      this.classType = 'types';
      this.className = 'UserStatusOffline';
      this.constructorId = 0x8c703f;
      this.subclassOfId = 0x5b0b743e;
      this._slots = ['wasOnline'];
      this.wasOnline = params.wasOnline;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UserStatusOffline> {
      // no flags

      let wasOnline = await Primitive.Int.read(b);
      return new Raw.UserStatusOffline({ wasOnline: wasOnline });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.wasOnline !== undefined) {
        b.write(Primitive.Int.write(this.wasOnline) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UserStatusRecently extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UserStatusRecently';
      this.constructorId = 0xe26f42f1;
      this.subclassOfId = 0x5b0b743e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UserStatusRecently> {
      // no flags

      return new Raw.UserStatusRecently();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UserStatusLastWeek extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UserStatusLastWeek';
      this.constructorId = 0x7bf09fc;
      this.subclassOfId = 0x5b0b743e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UserStatusLastWeek> {
      // no flags

      return new Raw.UserStatusLastWeek();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UserStatusLastMonth extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UserStatusLastMonth';
      this.constructorId = 0x77ebc742;
      this.subclassOfId = 0x5b0b743e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UserStatusLastMonth> {
      // no flags

      return new Raw.UserStatusLastMonth();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChatEmpty extends TLObject {
    id!: long;

    constructor(params: { id: long }) {
      super();
      this.classType = 'types';
      this.className = 'ChatEmpty';
      this.constructorId = 0x29562865;
      this.subclassOfId = 0xc5af5d94;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatEmpty> {
      // no flags

      let id = await Primitive.Long.read(b);
      return new Raw.ChatEmpty({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Chat extends TLObject {
    creator?: boolean;
    left?: boolean;
    deactivated?: boolean;
    callActive?: boolean;
    callNotEmpty?: boolean;
    noforwards?: boolean;
    id!: long;
    title!: string;
    photo!: Raw.TypeChatPhoto;
    participantsCount!: int;
    date!: int;
    version!: int;
    migratedTo?: Raw.TypeInputChannel;
    adminRights?: Raw.TypeChatAdminRights;
    defaultBannedRights?: Raw.TypeChatBannedRights;

    constructor(params: {
      creator?: boolean;
      left?: boolean;
      deactivated?: boolean;
      callActive?: boolean;
      callNotEmpty?: boolean;
      noforwards?: boolean;
      id: long;
      title: string;
      photo: Raw.TypeChatPhoto;
      participantsCount: int;
      date: int;
      version: int;
      migratedTo?: Raw.TypeInputChannel;
      adminRights?: Raw.TypeChatAdminRights;
      defaultBannedRights?: Raw.TypeChatBannedRights;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Chat';
      this.constructorId = 0x41cbf256;
      this.subclassOfId = 0xc5af5d94;
      this._slots = [
        'creator',
        'left',
        'deactivated',
        'callActive',
        'callNotEmpty',
        'noforwards',
        'id',
        'title',
        'photo',
        'participantsCount',
        'date',
        'version',
        'migratedTo',
        'adminRights',
        'defaultBannedRights',
      ];
      this.creator = params.creator;
      this.left = params.left;
      this.deactivated = params.deactivated;
      this.callActive = params.callActive;
      this.callNotEmpty = params.callNotEmpty;
      this.noforwards = params.noforwards;
      this.id = params.id;
      this.title = params.title;
      this.photo = params.photo;
      this.participantsCount = params.participantsCount;
      this.date = params.date;
      this.version = params.version;
      this.migratedTo = params.migratedTo;
      this.adminRights = params.adminRights;
      this.defaultBannedRights = params.defaultBannedRights;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Chat> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let creator = flags & (1 << 0) ? true : false;
      let left = flags & (1 << 2) ? true : false;
      let deactivated = flags & (1 << 5) ? true : false;
      let callActive = flags & (1 << 23) ? true : false;
      let callNotEmpty = flags & (1 << 24) ? true : false;
      let noforwards = flags & (1 << 25) ? true : false;
      let id = await Primitive.Long.read(b);
      let title = await Primitive.String.read(b);
      let photo = await TLObject.read(b);
      let participantsCount = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      let version = await Primitive.Int.read(b);
      let migratedTo = flags & (1 << 6) ? await TLObject.read(b) : undefined;
      let adminRights = flags & (1 << 14) ? await TLObject.read(b) : undefined;
      let defaultBannedRights = flags & (1 << 18) ? await TLObject.read(b) : undefined;
      return new Raw.Chat({
        creator: creator,
        left: left,
        deactivated: deactivated,
        callActive: callActive,
        callNotEmpty: callNotEmpty,
        noforwards: noforwards,
        id: id,
        title: title,
        photo: photo,
        participantsCount: participantsCount,
        date: date,
        version: version,
        migratedTo: migratedTo,
        adminRights: adminRights,
        defaultBannedRights: defaultBannedRights,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.creator ? 1 << 0 : 0;
      flags |= this.left ? 1 << 2 : 0;
      flags |= this.deactivated ? 1 << 5 : 0;
      flags |= this.callActive ? 1 << 23 : 0;
      flags |= this.callNotEmpty ? 1 << 24 : 0;
      flags |= this.noforwards ? 1 << 25 : 0;
      flags |= this.migratedTo !== undefined ? 1 << 6 : 0;
      flags |= this.adminRights !== undefined ? 1 << 14 : 0;
      flags |= this.defaultBannedRights !== undefined ? 1 << 18 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.participantsCount !== undefined) {
        b.write(Primitive.Int.write(this.participantsCount) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.version !== undefined) {
        b.write(Primitive.Int.write(this.version) as unknown as Buffer);
      }
      if (this.migratedTo !== undefined) {
        b.write(this.migratedTo.write() as unknown as Buffer);
      }
      if (this.adminRights !== undefined) {
        b.write(this.adminRights.write() as unknown as Buffer);
      }
      if (this.defaultBannedRights !== undefined) {
        b.write(this.defaultBannedRights.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatForbidden extends TLObject {
    id!: long;
    title!: string;

    constructor(params: { id: long; title: string }) {
      super();
      this.classType = 'types';
      this.className = 'ChatForbidden';
      this.constructorId = 0x6592a1a7;
      this.subclassOfId = 0xc5af5d94;
      this._slots = ['id', 'title'];
      this.id = params.id;
      this.title = params.title;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatForbidden> {
      // no flags

      let id = await Primitive.Long.read(b);
      let title = await Primitive.String.read(b);
      return new Raw.ChatForbidden({ id: id, title: title });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Channel extends TLObject {
    creator?: boolean;
    left?: boolean;
    broadcast?: boolean;
    verified?: boolean;
    megagroup?: boolean;
    restricted?: boolean;
    signatures?: boolean;
    min?: boolean;
    scam?: boolean;
    hasLink?: boolean;
    hasGeo?: boolean;
    slowmodeEnabled?: boolean;
    callActive?: boolean;
    callNotEmpty?: boolean;
    fake?: boolean;
    gigagroup?: boolean;
    noforwards?: boolean;
    joinToSend?: boolean;
    joinRequest?: boolean;
    forum?: boolean;
    storiesHidden?: boolean;
    storiesHiddenMin?: boolean;
    storiesUnavailable?: boolean;
    id!: long;
    accessHash?: long;
    title!: string;
    username?: string;
    photo!: Raw.TypeChatPhoto;
    date!: int;
    restrictionReason?: Vector<Raw.TypeRestrictionReason>;
    adminRights?: Raw.TypeChatAdminRights;
    bannedRights?: Raw.TypeChatBannedRights;
    defaultBannedRights?: Raw.TypeChatBannedRights;
    participantsCount?: int;
    usernames?: Vector<Raw.TypeUsername>;
    storiesMaxId?: int;
    color?: int;
    backgroundEmojiId?: long;

    constructor(params: {
      creator?: boolean;
      left?: boolean;
      broadcast?: boolean;
      verified?: boolean;
      megagroup?: boolean;
      restricted?: boolean;
      signatures?: boolean;
      min?: boolean;
      scam?: boolean;
      hasLink?: boolean;
      hasGeo?: boolean;
      slowmodeEnabled?: boolean;
      callActive?: boolean;
      callNotEmpty?: boolean;
      fake?: boolean;
      gigagroup?: boolean;
      noforwards?: boolean;
      joinToSend?: boolean;
      joinRequest?: boolean;
      forum?: boolean;
      storiesHidden?: boolean;
      storiesHiddenMin?: boolean;
      storiesUnavailable?: boolean;
      id: long;
      accessHash?: long;
      title: string;
      username?: string;
      photo: Raw.TypeChatPhoto;
      date: int;
      restrictionReason?: Vector<Raw.TypeRestrictionReason>;
      adminRights?: Raw.TypeChatAdminRights;
      bannedRights?: Raw.TypeChatBannedRights;
      defaultBannedRights?: Raw.TypeChatBannedRights;
      participantsCount?: int;
      usernames?: Vector<Raw.TypeUsername>;
      storiesMaxId?: int;
      color?: int;
      backgroundEmojiId?: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Channel';
      this.constructorId = 0x1981ea7e;
      this.subclassOfId = 0xc5af5d94;
      this._slots = [
        'creator',
        'left',
        'broadcast',
        'verified',
        'megagroup',
        'restricted',
        'signatures',
        'min',
        'scam',
        'hasLink',
        'hasGeo',
        'slowmodeEnabled',
        'callActive',
        'callNotEmpty',
        'fake',
        'gigagroup',
        'noforwards',
        'joinToSend',
        'joinRequest',
        'forum',
        'storiesHidden',
        'storiesHiddenMin',
        'storiesUnavailable',
        'id',
        'accessHash',
        'title',
        'username',
        'photo',
        'date',
        'restrictionReason',
        'adminRights',
        'bannedRights',
        'defaultBannedRights',
        'participantsCount',
        'usernames',
        'storiesMaxId',
        'color',
        'backgroundEmojiId',
      ];
      this.creator = params.creator;
      this.left = params.left;
      this.broadcast = params.broadcast;
      this.verified = params.verified;
      this.megagroup = params.megagroup;
      this.restricted = params.restricted;
      this.signatures = params.signatures;
      this.min = params.min;
      this.scam = params.scam;
      this.hasLink = params.hasLink;
      this.hasGeo = params.hasGeo;
      this.slowmodeEnabled = params.slowmodeEnabled;
      this.callActive = params.callActive;
      this.callNotEmpty = params.callNotEmpty;
      this.fake = params.fake;
      this.gigagroup = params.gigagroup;
      this.noforwards = params.noforwards;
      this.joinToSend = params.joinToSend;
      this.joinRequest = params.joinRequest;
      this.forum = params.forum;
      this.storiesHidden = params.storiesHidden;
      this.storiesHiddenMin = params.storiesHiddenMin;
      this.storiesUnavailable = params.storiesUnavailable;
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.title = params.title;
      this.username = params.username;
      this.photo = params.photo;
      this.date = params.date;
      this.restrictionReason = params.restrictionReason;
      this.adminRights = params.adminRights;
      this.bannedRights = params.bannedRights;
      this.defaultBannedRights = params.defaultBannedRights;
      this.participantsCount = params.participantsCount;
      this.usernames = params.usernames;
      this.storiesMaxId = params.storiesMaxId;
      this.color = params.color;
      this.backgroundEmojiId = params.backgroundEmojiId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Channel> {
      let flags = await Primitive.Int.read(b);

      let creator = flags & (1 << 0) ? true : false;
      let left = flags & (1 << 2) ? true : false;
      let broadcast = flags & (1 << 5) ? true : false;
      let verified = flags & (1 << 7) ? true : false;
      let megagroup = flags & (1 << 8) ? true : false;
      let restricted = flags & (1 << 9) ? true : false;
      let signatures = flags & (1 << 11) ? true : false;
      let min = flags & (1 << 12) ? true : false;
      let scam = flags & (1 << 19) ? true : false;
      let hasLink = flags & (1 << 20) ? true : false;
      let hasGeo = flags & (1 << 21) ? true : false;
      let slowmodeEnabled = flags & (1 << 22) ? true : false;
      let callActive = flags & (1 << 23) ? true : false;
      let callNotEmpty = flags & (1 << 24) ? true : false;
      let fake = flags & (1 << 25) ? true : false;
      let gigagroup = flags & (1 << 26) ? true : false;
      let noforwards = flags & (1 << 27) ? true : false;
      let joinToSend = flags & (1 << 28) ? true : false;
      let joinRequest = flags & (1 << 29) ? true : false;
      let forum = flags & (1 << 30) ? true : false;
      let flags2 = await Primitive.Int.read(b);

      let storiesHidden = flags2 & (1 << 1) ? true : false;
      let storiesHiddenMin = flags2 & (1 << 2) ? true : false;
      let storiesUnavailable = flags2 & (1 << 3) ? true : false;
      let id = await Primitive.Long.read(b);
      let accessHash = flags & (1 << 13) ? await Primitive.Long.read(b) : undefined;
      let title = await Primitive.String.read(b);
      let username = flags & (1 << 6) ? await Primitive.String.read(b) : undefined;
      let photo = await TLObject.read(b);
      let date = await Primitive.Int.read(b);
      let restrictionReason = flags & (1 << 9) ? await TLObject.read(b) : [];
      let adminRights = flags & (1 << 14) ? await TLObject.read(b) : undefined;
      let bannedRights = flags & (1 << 15) ? await TLObject.read(b) : undefined;
      let defaultBannedRights = flags & (1 << 18) ? await TLObject.read(b) : undefined;
      let participantsCount = flags & (1 << 17) ? await Primitive.Int.read(b) : undefined;
      let usernames = flags2 & (1 << 0) ? await TLObject.read(b) : [];
      let storiesMaxId = flags2 & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      let color = flags2 & (1 << 6) ? await Primitive.Int.read(b) : undefined;
      let backgroundEmojiId = flags2 & (1 << 5) ? await Primitive.Long.read(b) : undefined;
      return new Raw.Channel({
        creator: creator,
        left: left,
        broadcast: broadcast,
        verified: verified,
        megagroup: megagroup,
        restricted: restricted,
        signatures: signatures,
        min: min,
        scam: scam,
        hasLink: hasLink,
        hasGeo: hasGeo,
        slowmodeEnabled: slowmodeEnabled,
        callActive: callActive,
        callNotEmpty: callNotEmpty,
        fake: fake,
        gigagroup: gigagroup,
        noforwards: noforwards,
        joinToSend: joinToSend,
        joinRequest: joinRequest,
        forum: forum,
        storiesHidden: storiesHidden,
        storiesHiddenMin: storiesHiddenMin,
        storiesUnavailable: storiesUnavailable,
        id: id,
        accessHash: accessHash,
        title: title,
        username: username,
        photo: photo,
        date: date,
        restrictionReason: restrictionReason,
        adminRights: adminRights,
        bannedRights: bannedRights,
        defaultBannedRights: defaultBannedRights,
        participantsCount: participantsCount,
        usernames: usernames,
        storiesMaxId: storiesMaxId,
        color: color,
        backgroundEmojiId: backgroundEmojiId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);

      let flags = 0;
      flags |= this.creator ? 1 << 0 : 0;
      flags |= this.left ? 1 << 2 : 0;
      flags |= this.broadcast ? 1 << 5 : 0;
      flags |= this.verified ? 1 << 7 : 0;
      flags |= this.megagroup ? 1 << 8 : 0;
      flags |= this.restricted ? 1 << 9 : 0;
      flags |= this.signatures ? 1 << 11 : 0;
      flags |= this.min ? 1 << 12 : 0;
      flags |= this.scam ? 1 << 19 : 0;
      flags |= this.hasLink ? 1 << 20 : 0;
      flags |= this.hasGeo ? 1 << 21 : 0;
      flags |= this.slowmodeEnabled ? 1 << 22 : 0;
      flags |= this.callActive ? 1 << 23 : 0;
      flags |= this.callNotEmpty ? 1 << 24 : 0;
      flags |= this.fake ? 1 << 25 : 0;
      flags |= this.gigagroup ? 1 << 26 : 0;
      flags |= this.noforwards ? 1 << 27 : 0;
      flags |= this.joinToSend ? 1 << 28 : 0;
      flags |= this.joinRequest ? 1 << 29 : 0;
      flags |= this.forum ? 1 << 30 : 0;
      flags |= this.accessHash !== undefined ? 1 << 13 : 0;
      flags |= this.username !== undefined ? 1 << 6 : 0;
      flags |= this.restrictionReason ? 1 << 9 : 0;
      flags |= this.adminRights !== undefined ? 1 << 14 : 0;
      flags |= this.bannedRights !== undefined ? 1 << 15 : 0;
      flags |= this.defaultBannedRights !== undefined ? 1 << 18 : 0;
      flags |= this.participantsCount !== undefined ? 1 << 17 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      let flags2 = 0;
      flags2 |= this.storiesHidden ? 1 << 1 : 0;
      flags2 |= this.storiesHiddenMin ? 1 << 2 : 0;
      flags2 |= this.storiesUnavailable ? 1 << 3 : 0;
      flags2 |= this.usernames ? 1 << 0 : 0;
      flags2 |= this.storiesMaxId !== undefined ? 1 << 4 : 0;
      flags2 |= this.color !== undefined ? 1 << 6 : 0;
      flags2 |= this.backgroundEmojiId !== undefined ? 1 << 5 : 0;
      b.write(Primitive.Int.write(flags2) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.username !== undefined) {
        b.write(Primitive.String.write(this.username) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.restrictionReason) {
        b.write(Primitive.Vector.write(this.restrictionReason) as unknown as Buffer);
      }
      if (this.adminRights !== undefined) {
        b.write(this.adminRights.write() as unknown as Buffer);
      }
      if (this.bannedRights !== undefined) {
        b.write(this.bannedRights.write() as unknown as Buffer);
      }
      if (this.defaultBannedRights !== undefined) {
        b.write(this.defaultBannedRights.write() as unknown as Buffer);
      }
      if (this.participantsCount !== undefined) {
        b.write(Primitive.Int.write(this.participantsCount) as unknown as Buffer);
      }
      if (this.usernames) {
        b.write(Primitive.Vector.write(this.usernames) as unknown as Buffer);
      }
      if (this.storiesMaxId !== undefined) {
        b.write(Primitive.Int.write(this.storiesMaxId) as unknown as Buffer);
      }
      if (this.color !== undefined) {
        b.write(Primitive.Int.write(this.color) as unknown as Buffer);
      }
      if (this.backgroundEmojiId !== undefined) {
        b.write(Primitive.Long.write(this.backgroundEmojiId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelForbidden extends TLObject {
    broadcast?: boolean;
    megagroup?: boolean;
    id!: long;
    accessHash!: long;
    title!: string;
    untilDate?: int;

    constructor(params: {
      broadcast?: boolean;
      megagroup?: boolean;
      id: long;
      accessHash: long;
      title: string;
      untilDate?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelForbidden';
      this.constructorId = 0x17d493d5;
      this.subclassOfId = 0xc5af5d94;
      this._slots = ['broadcast', 'megagroup', 'id', 'accessHash', 'title', 'untilDate'];
      this.broadcast = params.broadcast;
      this.megagroup = params.megagroup;
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.title = params.title;
      this.untilDate = params.untilDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelForbidden> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let broadcast = flags & (1 << 5) ? true : false;
      let megagroup = flags & (1 << 8) ? true : false;
      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let title = await Primitive.String.read(b);
      let untilDate = flags & (1 << 16) ? await Primitive.Int.read(b) : undefined;
      return new Raw.ChannelForbidden({
        broadcast: broadcast,
        megagroup: megagroup,
        id: id,
        accessHash: accessHash,
        title: title,
        untilDate: untilDate,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.broadcast ? 1 << 5 : 0;
      flags |= this.megagroup ? 1 << 8 : 0;
      flags |= this.untilDate !== undefined ? 1 << 16 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.untilDate !== undefined) {
        b.write(Primitive.Int.write(this.untilDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatFull extends TLObject {
    canSetUsername?: boolean;
    hasScheduled?: boolean;
    translationsDisabled?: boolean;
    id!: long;
    about!: string;
    participants!: Raw.TypeChatParticipants;
    chatPhoto?: Raw.TypePhoto;
    notifySettings!: Raw.TypePeerNotifySettings;
    exportedInvite?: Raw.TypeExportedChatInvite;
    botInfo?: Vector<Raw.TypeBotInfo>;
    pinnedMsgId?: int;
    folderId?: int;
    call?: Raw.TypeInputGroupCall;
    ttlPeriod?: int;
    groupcallDefaultJoinAs?: Raw.TypePeer;
    themeEmoticon?: string;
    requestsPending?: int;
    recentRequesters?: Vector<long>;
    availableReactions?: Raw.TypeChatReactions;

    constructor(params: {
      canSetUsername?: boolean;
      hasScheduled?: boolean;
      translationsDisabled?: boolean;
      id: long;
      about: string;
      participants: Raw.TypeChatParticipants;
      chatPhoto?: Raw.TypePhoto;
      notifySettings: Raw.TypePeerNotifySettings;
      exportedInvite?: Raw.TypeExportedChatInvite;
      botInfo?: Vector<Raw.TypeBotInfo>;
      pinnedMsgId?: int;
      folderId?: int;
      call?: Raw.TypeInputGroupCall;
      ttlPeriod?: int;
      groupcallDefaultJoinAs?: Raw.TypePeer;
      themeEmoticon?: string;
      requestsPending?: int;
      recentRequesters?: Vector<long>;
      availableReactions?: Raw.TypeChatReactions;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChatFull';
      this.constructorId = 0xc9d31138;
      this.subclassOfId = 0xd49a2697;
      this._slots = [
        'canSetUsername',
        'hasScheduled',
        'translationsDisabled',
        'id',
        'about',
        'participants',
        'chatPhoto',
        'notifySettings',
        'exportedInvite',
        'botInfo',
        'pinnedMsgId',
        'folderId',
        'call',
        'ttlPeriod',
        'groupcallDefaultJoinAs',
        'themeEmoticon',
        'requestsPending',
        'recentRequesters',
        'availableReactions',
      ];
      this.canSetUsername = params.canSetUsername;
      this.hasScheduled = params.hasScheduled;
      this.translationsDisabled = params.translationsDisabled;
      this.id = params.id;
      this.about = params.about;
      this.participants = params.participants;
      this.chatPhoto = params.chatPhoto;
      this.notifySettings = params.notifySettings;
      this.exportedInvite = params.exportedInvite;
      this.botInfo = params.botInfo;
      this.pinnedMsgId = params.pinnedMsgId;
      this.folderId = params.folderId;
      this.call = params.call;
      this.ttlPeriod = params.ttlPeriod;
      this.groupcallDefaultJoinAs = params.groupcallDefaultJoinAs;
      this.themeEmoticon = params.themeEmoticon;
      this.requestsPending = params.requestsPending;
      this.recentRequesters = params.recentRequesters;
      this.availableReactions = params.availableReactions;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatFull> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let canSetUsername = flags & (1 << 7) ? true : false;
      let hasScheduled = flags & (1 << 8) ? true : false;
      let translationsDisabled = flags & (1 << 19) ? true : false;
      let id = await Primitive.Long.read(b);
      let about = await Primitive.String.read(b);
      let participants = await TLObject.read(b);
      let chatPhoto = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      let notifySettings = await TLObject.read(b);
      let exportedInvite = flags & (1 << 13) ? await TLObject.read(b) : undefined;
      let botInfo = flags & (1 << 3) ? await TLObject.read(b) : [];
      let pinnedMsgId = flags & (1 << 6) ? await Primitive.Int.read(b) : undefined;
      let folderId = flags & (1 << 11) ? await Primitive.Int.read(b) : undefined;
      let call = flags & (1 << 12) ? await TLObject.read(b) : undefined;
      let ttlPeriod = flags & (1 << 14) ? await Primitive.Int.read(b) : undefined;
      let groupcallDefaultJoinAs = flags & (1 << 15) ? await TLObject.read(b) : undefined;
      let themeEmoticon = flags & (1 << 16) ? await Primitive.String.read(b) : undefined;
      let requestsPending = flags & (1 << 17) ? await Primitive.Int.read(b) : undefined;
      let recentRequesters = flags & (1 << 17) ? await TLObject.read(b, Primitive.Long) : [];
      let availableReactions = flags & (1 << 18) ? await TLObject.read(b) : undefined;
      return new Raw.ChatFull({
        canSetUsername: canSetUsername,
        hasScheduled: hasScheduled,
        translationsDisabled: translationsDisabled,
        id: id,
        about: about,
        participants: participants,
        chatPhoto: chatPhoto,
        notifySettings: notifySettings,
        exportedInvite: exportedInvite,
        botInfo: botInfo,
        pinnedMsgId: pinnedMsgId,
        folderId: folderId,
        call: call,
        ttlPeriod: ttlPeriod,
        groupcallDefaultJoinAs: groupcallDefaultJoinAs,
        themeEmoticon: themeEmoticon,
        requestsPending: requestsPending,
        recentRequesters: recentRequesters,
        availableReactions: availableReactions,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.canSetUsername ? 1 << 7 : 0;
      flags |= this.hasScheduled ? 1 << 8 : 0;
      flags |= this.translationsDisabled ? 1 << 19 : 0;
      flags |= this.chatPhoto !== undefined ? 1 << 2 : 0;
      flags |= this.exportedInvite !== undefined ? 1 << 13 : 0;
      flags |= this.botInfo ? 1 << 3 : 0;
      flags |= this.pinnedMsgId !== undefined ? 1 << 6 : 0;
      flags |= this.folderId !== undefined ? 1 << 11 : 0;
      flags |= this.call !== undefined ? 1 << 12 : 0;
      flags |= this.ttlPeriod !== undefined ? 1 << 14 : 0;
      flags |= this.groupcallDefaultJoinAs !== undefined ? 1 << 15 : 0;
      flags |= this.themeEmoticon !== undefined ? 1 << 16 : 0;
      flags |= this.requestsPending !== undefined ? 1 << 17 : 0;
      flags |= this.recentRequesters ? 1 << 17 : 0;
      flags |= this.availableReactions !== undefined ? 1 << 18 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.about !== undefined) {
        b.write(Primitive.String.write(this.about) as unknown as Buffer);
      }
      if (this.participants !== undefined) {
        b.write(this.participants.write() as unknown as Buffer);
      }
      if (this.chatPhoto !== undefined) {
        b.write(this.chatPhoto.write() as unknown as Buffer);
      }
      if (this.notifySettings !== undefined) {
        b.write(this.notifySettings.write() as unknown as Buffer);
      }
      if (this.exportedInvite !== undefined) {
        b.write(this.exportedInvite.write() as unknown as Buffer);
      }
      if (this.botInfo) {
        b.write(Primitive.Vector.write(this.botInfo) as unknown as Buffer);
      }
      if (this.pinnedMsgId !== undefined) {
        b.write(Primitive.Int.write(this.pinnedMsgId) as unknown as Buffer);
      }
      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      if (this.call !== undefined) {
        b.write(this.call.write() as unknown as Buffer);
      }
      if (this.ttlPeriod !== undefined) {
        b.write(Primitive.Int.write(this.ttlPeriod) as unknown as Buffer);
      }
      if (this.groupcallDefaultJoinAs !== undefined) {
        b.write(this.groupcallDefaultJoinAs.write() as unknown as Buffer);
      }
      if (this.themeEmoticon !== undefined) {
        b.write(Primitive.String.write(this.themeEmoticon) as unknown as Buffer);
      }
      if (this.requestsPending !== undefined) {
        b.write(Primitive.Int.write(this.requestsPending) as unknown as Buffer);
      }
      if (this.recentRequesters) {
        b.write(Primitive.Vector.write(this.recentRequesters, Primitive.Long) as unknown as Buffer);
      }
      if (this.availableReactions !== undefined) {
        b.write(this.availableReactions.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelFull extends TLObject {
    canViewParticipants?: boolean;
    canSetUsername?: boolean;
    canSetStickers?: boolean;
    hiddenPrehistory?: boolean;
    canSetLocation?: boolean;
    hasScheduled?: boolean;
    canViewStats?: boolean;
    blocked?: boolean;
    canDeleteChannel?: boolean;
    antispam?: boolean;
    participantsHidden?: boolean;
    translationsDisabled?: boolean;
    storiesPinnedAvailable?: boolean;
    id!: long;
    about!: string;
    participantsCount?: int;
    adminsCount?: int;
    kickedCount?: int;
    bannedCount?: int;
    onlineCount?: int;
    readInboxMaxId!: int;
    readOutboxMaxId!: int;
    unreadCount!: int;
    chatPhoto!: Raw.TypePhoto;
    notifySettings!: Raw.TypePeerNotifySettings;
    exportedInvite?: Raw.TypeExportedChatInvite;
    botInfo!: Vector<Raw.TypeBotInfo>;
    migratedFromChatId?: long;
    migratedFromMaxId?: int;
    pinnedMsgId?: int;
    stickerset?: Raw.TypeStickerSet;
    availableMinId?: int;
    folderId?: int;
    linkedChatId?: long;
    location?: Raw.TypeChannelLocation;
    slowmodeSeconds?: int;
    slowmodeNextSendDate?: int;
    statsDc?: int;
    pts!: int;
    call?: Raw.TypeInputGroupCall;
    ttlPeriod?: int;
    pendingSuggestions?: Vector<string>;
    groupcallDefaultJoinAs?: Raw.TypePeer;
    themeEmoticon?: string;
    requestsPending?: int;
    recentRequesters?: Vector<long>;
    defaultSendAs?: Raw.TypePeer;
    availableReactions?: Raw.TypeChatReactions;
    stories?: Raw.TypePeerStories;

    constructor(params: {
      canViewParticipants?: boolean;
      canSetUsername?: boolean;
      canSetStickers?: boolean;
      hiddenPrehistory?: boolean;
      canSetLocation?: boolean;
      hasScheduled?: boolean;
      canViewStats?: boolean;
      blocked?: boolean;
      canDeleteChannel?: boolean;
      antispam?: boolean;
      participantsHidden?: boolean;
      translationsDisabled?: boolean;
      storiesPinnedAvailable?: boolean;
      id: long;
      about: string;
      participantsCount?: int;
      adminsCount?: int;
      kickedCount?: int;
      bannedCount?: int;
      onlineCount?: int;
      readInboxMaxId: int;
      readOutboxMaxId: int;
      unreadCount: int;
      chatPhoto: Raw.TypePhoto;
      notifySettings: Raw.TypePeerNotifySettings;
      exportedInvite?: Raw.TypeExportedChatInvite;
      botInfo: Vector<Raw.TypeBotInfo>;
      migratedFromChatId?: long;
      migratedFromMaxId?: int;
      pinnedMsgId?: int;
      stickerset?: Raw.TypeStickerSet;
      availableMinId?: int;
      folderId?: int;
      linkedChatId?: long;
      location?: Raw.TypeChannelLocation;
      slowmodeSeconds?: int;
      slowmodeNextSendDate?: int;
      statsDc?: int;
      pts: int;
      call?: Raw.TypeInputGroupCall;
      ttlPeriod?: int;
      pendingSuggestions?: Vector<string>;
      groupcallDefaultJoinAs?: Raw.TypePeer;
      themeEmoticon?: string;
      requestsPending?: int;
      recentRequesters?: Vector<long>;
      defaultSendAs?: Raw.TypePeer;
      availableReactions?: Raw.TypeChatReactions;
      stories?: Raw.TypePeerStories;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelFull';
      this.constructorId = 0x723027bd;
      this.subclassOfId = 0xd49a2697;
      this._slots = [
        'canViewParticipants',
        'canSetUsername',
        'canSetStickers',
        'hiddenPrehistory',
        'canSetLocation',
        'hasScheduled',
        'canViewStats',
        'blocked',
        'canDeleteChannel',
        'antispam',
        'participantsHidden',
        'translationsDisabled',
        'storiesPinnedAvailable',
        'id',
        'about',
        'participantsCount',
        'adminsCount',
        'kickedCount',
        'bannedCount',
        'onlineCount',
        'readInboxMaxId',
        'readOutboxMaxId',
        'unreadCount',
        'chatPhoto',
        'notifySettings',
        'exportedInvite',
        'botInfo',
        'migratedFromChatId',
        'migratedFromMaxId',
        'pinnedMsgId',
        'stickerset',
        'availableMinId',
        'folderId',
        'linkedChatId',
        'location',
        'slowmodeSeconds',
        'slowmodeNextSendDate',
        'statsDc',
        'pts',
        'call',
        'ttlPeriod',
        'pendingSuggestions',
        'groupcallDefaultJoinAs',
        'themeEmoticon',
        'requestsPending',
        'recentRequesters',
        'defaultSendAs',
        'availableReactions',
        'stories',
      ];
      this.canViewParticipants = params.canViewParticipants;
      this.canSetUsername = params.canSetUsername;
      this.canSetStickers = params.canSetStickers;
      this.hiddenPrehistory = params.hiddenPrehistory;
      this.canSetLocation = params.canSetLocation;
      this.hasScheduled = params.hasScheduled;
      this.canViewStats = params.canViewStats;
      this.blocked = params.blocked;
      this.canDeleteChannel = params.canDeleteChannel;
      this.antispam = params.antispam;
      this.participantsHidden = params.participantsHidden;
      this.translationsDisabled = params.translationsDisabled;
      this.storiesPinnedAvailable = params.storiesPinnedAvailable;
      this.id = params.id;
      this.about = params.about;
      this.participantsCount = params.participantsCount;
      this.adminsCount = params.adminsCount;
      this.kickedCount = params.kickedCount;
      this.bannedCount = params.bannedCount;
      this.onlineCount = params.onlineCount;
      this.readInboxMaxId = params.readInboxMaxId;
      this.readOutboxMaxId = params.readOutboxMaxId;
      this.unreadCount = params.unreadCount;
      this.chatPhoto = params.chatPhoto;
      this.notifySettings = params.notifySettings;
      this.exportedInvite = params.exportedInvite;
      this.botInfo = params.botInfo;
      this.migratedFromChatId = params.migratedFromChatId;
      this.migratedFromMaxId = params.migratedFromMaxId;
      this.pinnedMsgId = params.pinnedMsgId;
      this.stickerset = params.stickerset;
      this.availableMinId = params.availableMinId;
      this.folderId = params.folderId;
      this.linkedChatId = params.linkedChatId;
      this.location = params.location;
      this.slowmodeSeconds = params.slowmodeSeconds;
      this.slowmodeNextSendDate = params.slowmodeNextSendDate;
      this.statsDc = params.statsDc;
      this.pts = params.pts;
      this.call = params.call;
      this.ttlPeriod = params.ttlPeriod;
      this.pendingSuggestions = params.pendingSuggestions;
      this.groupcallDefaultJoinAs = params.groupcallDefaultJoinAs;
      this.themeEmoticon = params.themeEmoticon;
      this.requestsPending = params.requestsPending;
      this.recentRequesters = params.recentRequesters;
      this.defaultSendAs = params.defaultSendAs;
      this.availableReactions = params.availableReactions;
      this.stories = params.stories;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelFull> {
      let flags = await Primitive.Int.read(b);

      let canViewParticipants = flags & (1 << 3) ? true : false;
      let canSetUsername = flags & (1 << 6) ? true : false;
      let canSetStickers = flags & (1 << 7) ? true : false;
      let hiddenPrehistory = flags & (1 << 10) ? true : false;
      let canSetLocation = flags & (1 << 16) ? true : false;
      let hasScheduled = flags & (1 << 19) ? true : false;
      let canViewStats = flags & (1 << 20) ? true : false;
      let blocked = flags & (1 << 22) ? true : false;
      let flags2 = await Primitive.Int.read(b);

      let canDeleteChannel = flags2 & (1 << 0) ? true : false;
      let antispam = flags2 & (1 << 1) ? true : false;
      let participantsHidden = flags2 & (1 << 2) ? true : false;
      let translationsDisabled = flags2 & (1 << 3) ? true : false;
      let storiesPinnedAvailable = flags2 & (1 << 5) ? true : false;
      let id = await Primitive.Long.read(b);
      let about = await Primitive.String.read(b);
      let participantsCount = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let adminsCount = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      let kickedCount = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let bannedCount = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let onlineCount = flags & (1 << 13) ? await Primitive.Int.read(b) : undefined;
      let readInboxMaxId = await Primitive.Int.read(b);
      let readOutboxMaxId = await Primitive.Int.read(b);
      let unreadCount = await Primitive.Int.read(b);
      let chatPhoto = await TLObject.read(b);
      let notifySettings = await TLObject.read(b);
      let exportedInvite = flags & (1 << 23) ? await TLObject.read(b) : undefined;
      let botInfo = await TLObject.read(b);
      let migratedFromChatId = flags & (1 << 4) ? await Primitive.Long.read(b) : undefined;
      let migratedFromMaxId = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      let pinnedMsgId = flags & (1 << 5) ? await Primitive.Int.read(b) : undefined;
      let stickerset = flags & (1 << 8) ? await TLObject.read(b) : undefined;
      let availableMinId = flags & (1 << 9) ? await Primitive.Int.read(b) : undefined;
      let folderId = flags & (1 << 11) ? await Primitive.Int.read(b) : undefined;
      let linkedChatId = flags & (1 << 14) ? await Primitive.Long.read(b) : undefined;
      let location = flags & (1 << 15) ? await TLObject.read(b) : undefined;
      let slowmodeSeconds = flags & (1 << 17) ? await Primitive.Int.read(b) : undefined;
      let slowmodeNextSendDate = flags & (1 << 18) ? await Primitive.Int.read(b) : undefined;
      let statsDc = flags & (1 << 12) ? await Primitive.Int.read(b) : undefined;
      let pts = await Primitive.Int.read(b);
      let call = flags & (1 << 21) ? await TLObject.read(b) : undefined;
      let ttlPeriod = flags & (1 << 24) ? await Primitive.Int.read(b) : undefined;
      let pendingSuggestions = flags & (1 << 25) ? await TLObject.read(b, Primitive.String) : [];
      let groupcallDefaultJoinAs = flags & (1 << 26) ? await TLObject.read(b) : undefined;
      let themeEmoticon = flags & (1 << 27) ? await Primitive.String.read(b) : undefined;
      let requestsPending = flags & (1 << 28) ? await Primitive.Int.read(b) : undefined;
      let recentRequesters = flags & (1 << 28) ? await TLObject.read(b, Primitive.Long) : [];
      let defaultSendAs = flags & (1 << 29) ? await TLObject.read(b) : undefined;
      let availableReactions = flags & (1 << 30) ? await TLObject.read(b) : undefined;
      let stories = flags2 & (1 << 4) ? await TLObject.read(b) : undefined;
      return new Raw.ChannelFull({
        canViewParticipants: canViewParticipants,
        canSetUsername: canSetUsername,
        canSetStickers: canSetStickers,
        hiddenPrehistory: hiddenPrehistory,
        canSetLocation: canSetLocation,
        hasScheduled: hasScheduled,
        canViewStats: canViewStats,
        blocked: blocked,
        canDeleteChannel: canDeleteChannel,
        antispam: antispam,
        participantsHidden: participantsHidden,
        translationsDisabled: translationsDisabled,
        storiesPinnedAvailable: storiesPinnedAvailable,
        id: id,
        about: about,
        participantsCount: participantsCount,
        adminsCount: adminsCount,
        kickedCount: kickedCount,
        bannedCount: bannedCount,
        onlineCount: onlineCount,
        readInboxMaxId: readInboxMaxId,
        readOutboxMaxId: readOutboxMaxId,
        unreadCount: unreadCount,
        chatPhoto: chatPhoto,
        notifySettings: notifySettings,
        exportedInvite: exportedInvite,
        botInfo: botInfo,
        migratedFromChatId: migratedFromChatId,
        migratedFromMaxId: migratedFromMaxId,
        pinnedMsgId: pinnedMsgId,
        stickerset: stickerset,
        availableMinId: availableMinId,
        folderId: folderId,
        linkedChatId: linkedChatId,
        location: location,
        slowmodeSeconds: slowmodeSeconds,
        slowmodeNextSendDate: slowmodeNextSendDate,
        statsDc: statsDc,
        pts: pts,
        call: call,
        ttlPeriod: ttlPeriod,
        pendingSuggestions: pendingSuggestions,
        groupcallDefaultJoinAs: groupcallDefaultJoinAs,
        themeEmoticon: themeEmoticon,
        requestsPending: requestsPending,
        recentRequesters: recentRequesters,
        defaultSendAs: defaultSendAs,
        availableReactions: availableReactions,
        stories: stories,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);

      let flags = 0;
      flags |= this.canViewParticipants ? 1 << 3 : 0;
      flags |= this.canSetUsername ? 1 << 6 : 0;
      flags |= this.canSetStickers ? 1 << 7 : 0;
      flags |= this.hiddenPrehistory ? 1 << 10 : 0;
      flags |= this.canSetLocation ? 1 << 16 : 0;
      flags |= this.hasScheduled ? 1 << 19 : 0;
      flags |= this.canViewStats ? 1 << 20 : 0;
      flags |= this.blocked ? 1 << 22 : 0;
      flags |= this.participantsCount !== undefined ? 1 << 0 : 0;
      flags |= this.adminsCount !== undefined ? 1 << 1 : 0;
      flags |= this.kickedCount !== undefined ? 1 << 2 : 0;
      flags |= this.bannedCount !== undefined ? 1 << 2 : 0;
      flags |= this.onlineCount !== undefined ? 1 << 13 : 0;
      flags |= this.exportedInvite !== undefined ? 1 << 23 : 0;
      flags |= this.migratedFromChatId !== undefined ? 1 << 4 : 0;
      flags |= this.migratedFromMaxId !== undefined ? 1 << 4 : 0;
      flags |= this.pinnedMsgId !== undefined ? 1 << 5 : 0;
      flags |= this.stickerset !== undefined ? 1 << 8 : 0;
      flags |= this.availableMinId !== undefined ? 1 << 9 : 0;
      flags |= this.folderId !== undefined ? 1 << 11 : 0;
      flags |= this.linkedChatId !== undefined ? 1 << 14 : 0;
      flags |= this.location !== undefined ? 1 << 15 : 0;
      flags |= this.slowmodeSeconds !== undefined ? 1 << 17 : 0;
      flags |= this.slowmodeNextSendDate !== undefined ? 1 << 18 : 0;
      flags |= this.statsDc !== undefined ? 1 << 12 : 0;
      flags |= this.call !== undefined ? 1 << 21 : 0;
      flags |= this.ttlPeriod !== undefined ? 1 << 24 : 0;
      flags |= this.pendingSuggestions ? 1 << 25 : 0;
      flags |= this.groupcallDefaultJoinAs !== undefined ? 1 << 26 : 0;
      flags |= this.themeEmoticon !== undefined ? 1 << 27 : 0;
      flags |= this.requestsPending !== undefined ? 1 << 28 : 0;
      flags |= this.recentRequesters ? 1 << 28 : 0;
      flags |= this.defaultSendAs !== undefined ? 1 << 29 : 0;
      flags |= this.availableReactions !== undefined ? 1 << 30 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      let flags2 = 0;
      flags2 |= this.canDeleteChannel ? 1 << 0 : 0;
      flags2 |= this.antispam ? 1 << 1 : 0;
      flags2 |= this.participantsHidden ? 1 << 2 : 0;
      flags2 |= this.translationsDisabled ? 1 << 3 : 0;
      flags2 |= this.storiesPinnedAvailable ? 1 << 5 : 0;
      flags2 |= this.stories !== undefined ? 1 << 4 : 0;
      b.write(Primitive.Int.write(flags2) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.about !== undefined) {
        b.write(Primitive.String.write(this.about) as unknown as Buffer);
      }
      if (this.participantsCount !== undefined) {
        b.write(Primitive.Int.write(this.participantsCount) as unknown as Buffer);
      }
      if (this.adminsCount !== undefined) {
        b.write(Primitive.Int.write(this.adminsCount) as unknown as Buffer);
      }
      if (this.kickedCount !== undefined) {
        b.write(Primitive.Int.write(this.kickedCount) as unknown as Buffer);
      }
      if (this.bannedCount !== undefined) {
        b.write(Primitive.Int.write(this.bannedCount) as unknown as Buffer);
      }
      if (this.onlineCount !== undefined) {
        b.write(Primitive.Int.write(this.onlineCount) as unknown as Buffer);
      }
      if (this.readInboxMaxId !== undefined) {
        b.write(Primitive.Int.write(this.readInboxMaxId) as unknown as Buffer);
      }
      if (this.readOutboxMaxId !== undefined) {
        b.write(Primitive.Int.write(this.readOutboxMaxId) as unknown as Buffer);
      }
      if (this.unreadCount !== undefined) {
        b.write(Primitive.Int.write(this.unreadCount) as unknown as Buffer);
      }
      if (this.chatPhoto !== undefined) {
        b.write(this.chatPhoto.write() as unknown as Buffer);
      }
      if (this.notifySettings !== undefined) {
        b.write(this.notifySettings.write() as unknown as Buffer);
      }
      if (this.exportedInvite !== undefined) {
        b.write(this.exportedInvite.write() as unknown as Buffer);
      }
      if (this.botInfo) {
        b.write(Primitive.Vector.write(this.botInfo) as unknown as Buffer);
      }
      if (this.migratedFromChatId !== undefined) {
        b.write(Primitive.Long.write(this.migratedFromChatId) as unknown as Buffer);
      }
      if (this.migratedFromMaxId !== undefined) {
        b.write(Primitive.Int.write(this.migratedFromMaxId) as unknown as Buffer);
      }
      if (this.pinnedMsgId !== undefined) {
        b.write(Primitive.Int.write(this.pinnedMsgId) as unknown as Buffer);
      }
      if (this.stickerset !== undefined) {
        b.write(this.stickerset.write() as unknown as Buffer);
      }
      if (this.availableMinId !== undefined) {
        b.write(Primitive.Int.write(this.availableMinId) as unknown as Buffer);
      }
      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      if (this.linkedChatId !== undefined) {
        b.write(Primitive.Long.write(this.linkedChatId) as unknown as Buffer);
      }
      if (this.location !== undefined) {
        b.write(this.location.write() as unknown as Buffer);
      }
      if (this.slowmodeSeconds !== undefined) {
        b.write(Primitive.Int.write(this.slowmodeSeconds) as unknown as Buffer);
      }
      if (this.slowmodeNextSendDate !== undefined) {
        b.write(Primitive.Int.write(this.slowmodeNextSendDate) as unknown as Buffer);
      }
      if (this.statsDc !== undefined) {
        b.write(Primitive.Int.write(this.statsDc) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.call !== undefined) {
        b.write(this.call.write() as unknown as Buffer);
      }
      if (this.ttlPeriod !== undefined) {
        b.write(Primitive.Int.write(this.ttlPeriod) as unknown as Buffer);
      }
      if (this.pendingSuggestions) {
        b.write(
          Primitive.Vector.write(this.pendingSuggestions, Primitive.String) as unknown as Buffer,
        );
      }
      if (this.groupcallDefaultJoinAs !== undefined) {
        b.write(this.groupcallDefaultJoinAs.write() as unknown as Buffer);
      }
      if (this.themeEmoticon !== undefined) {
        b.write(Primitive.String.write(this.themeEmoticon) as unknown as Buffer);
      }
      if (this.requestsPending !== undefined) {
        b.write(Primitive.Int.write(this.requestsPending) as unknown as Buffer);
      }
      if (this.recentRequesters) {
        b.write(Primitive.Vector.write(this.recentRequesters, Primitive.Long) as unknown as Buffer);
      }
      if (this.defaultSendAs !== undefined) {
        b.write(this.defaultSendAs.write() as unknown as Buffer);
      }
      if (this.availableReactions !== undefined) {
        b.write(this.availableReactions.write() as unknown as Buffer);
      }
      if (this.stories !== undefined) {
        b.write(this.stories.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatParticipant extends TLObject {
    userId!: long;
    inviterId!: long;
    date!: int;

    constructor(params: { userId: long; inviterId: long; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'ChatParticipant';
      this.constructorId = 0xc02d4007;
      this.subclassOfId = 0x7d7c6f86;
      this._slots = ['userId', 'inviterId', 'date'];
      this.userId = params.userId;
      this.inviterId = params.inviterId;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatParticipant> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let inviterId = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.ChatParticipant({ userId: userId, inviterId: inviterId, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.inviterId !== undefined) {
        b.write(Primitive.Long.write(this.inviterId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatParticipantCreator extends TLObject {
    userId!: long;

    constructor(params: { userId: long }) {
      super();
      this.classType = 'types';
      this.className = 'ChatParticipantCreator';
      this.constructorId = 0xe46bcee4;
      this.subclassOfId = 0x7d7c6f86;
      this._slots = ['userId'];
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatParticipantCreator> {
      // no flags

      let userId = await Primitive.Long.read(b);
      return new Raw.ChatParticipantCreator({ userId: userId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatParticipantAdmin extends TLObject {
    userId!: long;
    inviterId!: long;
    date!: int;

    constructor(params: { userId: long; inviterId: long; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'ChatParticipantAdmin';
      this.constructorId = 0xa0933f5b;
      this.subclassOfId = 0x7d7c6f86;
      this._slots = ['userId', 'inviterId', 'date'];
      this.userId = params.userId;
      this.inviterId = params.inviterId;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatParticipantAdmin> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let inviterId = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.ChatParticipantAdmin({ userId: userId, inviterId: inviterId, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.inviterId !== undefined) {
        b.write(Primitive.Long.write(this.inviterId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatParticipantsForbidden extends TLObject {
    chatId!: long;
    selfParticipant?: Raw.TypeChatParticipant;

    constructor(params: { chatId: long; selfParticipant?: Raw.TypeChatParticipant }) {
      super();
      this.classType = 'types';
      this.className = 'ChatParticipantsForbidden';
      this.constructorId = 0x8763d3e1;
      this.subclassOfId = 0x1fa89571;
      this._slots = ['chatId', 'selfParticipant'];
      this.chatId = params.chatId;
      this.selfParticipant = params.selfParticipant;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatParticipantsForbidden> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let chatId = await Primitive.Long.read(b);
      let selfParticipant = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      return new Raw.ChatParticipantsForbidden({
        chatId: chatId,
        selfParticipant: selfParticipant,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.selfParticipant !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      if (this.selfParticipant !== undefined) {
        b.write(this.selfParticipant.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatParticipants extends TLObject {
    chatId!: long;
    participants!: Vector<Raw.TypeChatParticipant>;
    version!: int;

    constructor(params: {
      chatId: long;
      participants: Vector<Raw.TypeChatParticipant>;
      version: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChatParticipants';
      this.constructorId = 0x3cbc93f8;
      this.subclassOfId = 0x1fa89571;
      this._slots = ['chatId', 'participants', 'version'];
      this.chatId = params.chatId;
      this.participants = params.participants;
      this.version = params.version;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatParticipants> {
      // no flags

      let chatId = await Primitive.Long.read(b);
      let participants = await TLObject.read(b);
      let version = await Primitive.Int.read(b);
      return new Raw.ChatParticipants({
        chatId: chatId,
        participants: participants,
        version: version,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      if (this.participants) {
        b.write(Primitive.Vector.write(this.participants) as unknown as Buffer);
      }
      if (this.version !== undefined) {
        b.write(Primitive.Int.write(this.version) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatPhotoEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'ChatPhotoEmpty';
      this.constructorId = 0x37c1011c;
      this.subclassOfId = 0xac3ec4e5;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatPhotoEmpty> {
      // no flags

      return new Raw.ChatPhotoEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChatPhoto extends TLObject {
    hasVideo?: boolean;
    photoId!: long;
    strippedThumb?: bytes;
    dcId!: int;

    constructor(params: { hasVideo?: boolean; photoId: long; strippedThumb?: bytes; dcId: int }) {
      super();
      this.classType = 'types';
      this.className = 'ChatPhoto';
      this.constructorId = 0x1c6e1c11;
      this.subclassOfId = 0xac3ec4e5;
      this._slots = ['hasVideo', 'photoId', 'strippedThumb', 'dcId'];
      this.hasVideo = params.hasVideo;
      this.photoId = params.photoId;
      this.strippedThumb = params.strippedThumb;
      this.dcId = params.dcId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatPhoto> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let hasVideo = flags & (1 << 0) ? true : false;
      let photoId = await Primitive.Long.read(b);
      let strippedThumb = flags & (1 << 1) ? await Primitive.Bytes.read(b) : undefined;
      let dcId = await Primitive.Int.read(b);
      return new Raw.ChatPhoto({
        hasVideo: hasVideo,
        photoId: photoId,
        strippedThumb: strippedThumb,
        dcId: dcId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.hasVideo ? 1 << 0 : 0;
      flags |= this.strippedThumb !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.photoId !== undefined) {
        b.write(Primitive.Long.write(this.photoId) as unknown as Buffer);
      }
      if (this.strippedThumb !== undefined) {
        b.write(Primitive.Bytes.write(this.strippedThumb) as unknown as Buffer);
      }
      if (this.dcId !== undefined) {
        b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEmpty extends TLObject {
    id!: int;
    peerId?: Raw.TypePeer;

    constructor(params: { id: int; peerId?: Raw.TypePeer }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEmpty';
      this.constructorId = 0x90a6ca84;
      this.subclassOfId = 0x790009e3;
      this._slots = ['id', 'peerId'];
      this.id = params.id;
      this.peerId = params.peerId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEmpty> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let id = await Primitive.Int.read(b);
      let peerId = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      return new Raw.MessageEmpty({ id: id, peerId: peerId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.peerId !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.peerId !== undefined) {
        b.write(this.peerId.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Message extends TLObject {
    out?: boolean;
    mentioned?: boolean;
    mediaUnread?: boolean;
    silent?: boolean;
    post?: boolean;
    fromScheduled?: boolean;
    legacy?: boolean;
    editHide?: boolean;
    pinned?: boolean;
    noforwards?: boolean;
    invertMedia?: boolean;
    id!: int;
    fromId?: Raw.TypePeer;
    peerId!: Raw.TypePeer;
    fwdFrom?: Raw.TypeMessageFwdHeader;
    viaBotId?: long;
    replyTo?: Raw.TypeMessageReplyHeader;
    date!: int;
    message!: string;
    media?: Raw.TypeMessageMedia;
    replyMarkup?: Raw.TypeReplyMarkup;
    entities?: Vector<Raw.TypeMessageEntity>;
    views?: int;
    forwards?: int;
    replies?: Raw.TypeMessageReplies;
    editDate?: int;
    postAuthor?: string;
    groupedId?: long;
    reactions?: Raw.TypeMessageReactions;
    restrictionReason?: Vector<Raw.TypeRestrictionReason>;
    ttlPeriod?: int;

    constructor(params: {
      out?: boolean;
      mentioned?: boolean;
      mediaUnread?: boolean;
      silent?: boolean;
      post?: boolean;
      fromScheduled?: boolean;
      legacy?: boolean;
      editHide?: boolean;
      pinned?: boolean;
      noforwards?: boolean;
      invertMedia?: boolean;
      id: int;
      fromId?: Raw.TypePeer;
      peerId: Raw.TypePeer;
      fwdFrom?: Raw.TypeMessageFwdHeader;
      viaBotId?: long;
      replyTo?: Raw.TypeMessageReplyHeader;
      date: int;
      message: string;
      media?: Raw.TypeMessageMedia;
      replyMarkup?: Raw.TypeReplyMarkup;
      entities?: Vector<Raw.TypeMessageEntity>;
      views?: int;
      forwards?: int;
      replies?: Raw.TypeMessageReplies;
      editDate?: int;
      postAuthor?: string;
      groupedId?: long;
      reactions?: Raw.TypeMessageReactions;
      restrictionReason?: Vector<Raw.TypeRestrictionReason>;
      ttlPeriod?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Message';
      this.constructorId = 0x38116ee0;
      this.subclassOfId = 0x790009e3;
      this._slots = [
        'out',
        'mentioned',
        'mediaUnread',
        'silent',
        'post',
        'fromScheduled',
        'legacy',
        'editHide',
        'pinned',
        'noforwards',
        'invertMedia',
        'id',
        'fromId',
        'peerId',
        'fwdFrom',
        'viaBotId',
        'replyTo',
        'date',
        'message',
        'media',
        'replyMarkup',
        'entities',
        'views',
        'forwards',
        'replies',
        'editDate',
        'postAuthor',
        'groupedId',
        'reactions',
        'restrictionReason',
        'ttlPeriod',
      ];
      this.out = params.out;
      this.mentioned = params.mentioned;
      this.mediaUnread = params.mediaUnread;
      this.silent = params.silent;
      this.post = params.post;
      this.fromScheduled = params.fromScheduled;
      this.legacy = params.legacy;
      this.editHide = params.editHide;
      this.pinned = params.pinned;
      this.noforwards = params.noforwards;
      this.invertMedia = params.invertMedia;
      this.id = params.id;
      this.fromId = params.fromId;
      this.peerId = params.peerId;
      this.fwdFrom = params.fwdFrom;
      this.viaBotId = params.viaBotId;
      this.replyTo = params.replyTo;
      this.date = params.date;
      this.message = params.message;
      this.media = params.media;
      this.replyMarkup = params.replyMarkup;
      this.entities = params.entities;
      this.views = params.views;
      this.forwards = params.forwards;
      this.replies = params.replies;
      this.editDate = params.editDate;
      this.postAuthor = params.postAuthor;
      this.groupedId = params.groupedId;
      this.reactions = params.reactions;
      this.restrictionReason = params.restrictionReason;
      this.ttlPeriod = params.ttlPeriod;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Message> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let out = flags & (1 << 1) ? true : false;
      let mentioned = flags & (1 << 4) ? true : false;
      let mediaUnread = flags & (1 << 5) ? true : false;
      let silent = flags & (1 << 13) ? true : false;
      let post = flags & (1 << 14) ? true : false;
      let fromScheduled = flags & (1 << 18) ? true : false;
      let legacy = flags & (1 << 19) ? true : false;
      let editHide = flags & (1 << 21) ? true : false;
      let pinned = flags & (1 << 24) ? true : false;
      let noforwards = flags & (1 << 26) ? true : false;
      let invertMedia = flags & (1 << 27) ? true : false;
      let id = await Primitive.Int.read(b);
      let fromId = flags & (1 << 8) ? await TLObject.read(b) : undefined;
      let peerId = await TLObject.read(b);
      let fwdFrom = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      let viaBotId = flags & (1 << 11) ? await Primitive.Long.read(b) : undefined;
      let replyTo = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      let date = await Primitive.Int.read(b);
      let message = await Primitive.String.read(b);
      let media = flags & (1 << 9) ? await TLObject.read(b) : undefined;
      let replyMarkup = flags & (1 << 6) ? await TLObject.read(b) : undefined;
      let entities = flags & (1 << 7) ? await TLObject.read(b) : [];
      let views = flags & (1 << 10) ? await Primitive.Int.read(b) : undefined;
      let forwards = flags & (1 << 10) ? await Primitive.Int.read(b) : undefined;
      let replies = flags & (1 << 23) ? await TLObject.read(b) : undefined;
      let editDate = flags & (1 << 15) ? await Primitive.Int.read(b) : undefined;
      let postAuthor = flags & (1 << 16) ? await Primitive.String.read(b) : undefined;
      let groupedId = flags & (1 << 17) ? await Primitive.Long.read(b) : undefined;
      let reactions = flags & (1 << 20) ? await TLObject.read(b) : undefined;
      let restrictionReason = flags & (1 << 22) ? await TLObject.read(b) : [];
      let ttlPeriod = flags & (1 << 25) ? await Primitive.Int.read(b) : undefined;
      return new Raw.Message({
        out: out,
        mentioned: mentioned,
        mediaUnread: mediaUnread,
        silent: silent,
        post: post,
        fromScheduled: fromScheduled,
        legacy: legacy,
        editHide: editHide,
        pinned: pinned,
        noforwards: noforwards,
        invertMedia: invertMedia,
        id: id,
        fromId: fromId,
        peerId: peerId,
        fwdFrom: fwdFrom,
        viaBotId: viaBotId,
        replyTo: replyTo,
        date: date,
        message: message,
        media: media,
        replyMarkup: replyMarkup,
        entities: entities,
        views: views,
        forwards: forwards,
        replies: replies,
        editDate: editDate,
        postAuthor: postAuthor,
        groupedId: groupedId,
        reactions: reactions,
        restrictionReason: restrictionReason,
        ttlPeriod: ttlPeriod,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.out ? 1 << 1 : 0;
      flags |= this.mentioned ? 1 << 4 : 0;
      flags |= this.mediaUnread ? 1 << 5 : 0;
      flags |= this.silent ? 1 << 13 : 0;
      flags |= this.post ? 1 << 14 : 0;
      flags |= this.fromScheduled ? 1 << 18 : 0;
      flags |= this.legacy ? 1 << 19 : 0;
      flags |= this.editHide ? 1 << 21 : 0;
      flags |= this.pinned ? 1 << 24 : 0;
      flags |= this.noforwards ? 1 << 26 : 0;
      flags |= this.invertMedia ? 1 << 27 : 0;
      flags |= this.fromId !== undefined ? 1 << 8 : 0;
      flags |= this.fwdFrom !== undefined ? 1 << 2 : 0;
      flags |= this.viaBotId !== undefined ? 1 << 11 : 0;
      flags |= this.replyTo !== undefined ? 1 << 3 : 0;
      flags |= this.media !== undefined ? 1 << 9 : 0;
      flags |= this.replyMarkup !== undefined ? 1 << 6 : 0;
      flags |= this.entities ? 1 << 7 : 0;
      flags |= this.views !== undefined ? 1 << 10 : 0;
      flags |= this.forwards !== undefined ? 1 << 10 : 0;
      flags |= this.replies !== undefined ? 1 << 23 : 0;
      flags |= this.editDate !== undefined ? 1 << 15 : 0;
      flags |= this.postAuthor !== undefined ? 1 << 16 : 0;
      flags |= this.groupedId !== undefined ? 1 << 17 : 0;
      flags |= this.reactions !== undefined ? 1 << 20 : 0;
      flags |= this.restrictionReason ? 1 << 22 : 0;
      flags |= this.ttlPeriod !== undefined ? 1 << 25 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.fromId !== undefined) {
        b.write(this.fromId.write() as unknown as Buffer);
      }
      if (this.peerId !== undefined) {
        b.write(this.peerId.write() as unknown as Buffer);
      }
      if (this.fwdFrom !== undefined) {
        b.write(this.fwdFrom.write() as unknown as Buffer);
      }
      if (this.viaBotId !== undefined) {
        b.write(Primitive.Long.write(this.viaBotId) as unknown as Buffer);
      }
      if (this.replyTo !== undefined) {
        b.write(this.replyTo.write() as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.media !== undefined) {
        b.write(this.media.write() as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.views !== undefined) {
        b.write(Primitive.Int.write(this.views) as unknown as Buffer);
      }
      if (this.forwards !== undefined) {
        b.write(Primitive.Int.write(this.forwards) as unknown as Buffer);
      }
      if (this.replies !== undefined) {
        b.write(this.replies.write() as unknown as Buffer);
      }
      if (this.editDate !== undefined) {
        b.write(Primitive.Int.write(this.editDate) as unknown as Buffer);
      }
      if (this.postAuthor !== undefined) {
        b.write(Primitive.String.write(this.postAuthor) as unknown as Buffer);
      }
      if (this.groupedId !== undefined) {
        b.write(Primitive.Long.write(this.groupedId) as unknown as Buffer);
      }
      if (this.reactions !== undefined) {
        b.write(this.reactions.write() as unknown as Buffer);
      }
      if (this.restrictionReason) {
        b.write(Primitive.Vector.write(this.restrictionReason) as unknown as Buffer);
      }
      if (this.ttlPeriod !== undefined) {
        b.write(Primitive.Int.write(this.ttlPeriod) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageService extends TLObject {
    out?: boolean;
    mentioned?: boolean;
    mediaUnread?: boolean;
    silent?: boolean;
    post?: boolean;
    legacy?: boolean;
    id!: int;
    fromId?: Raw.TypePeer;
    peerId!: Raw.TypePeer;
    replyTo?: Raw.TypeMessageReplyHeader;
    date!: int;
    action!: Raw.TypeMessageAction;
    ttlPeriod?: int;

    constructor(params: {
      out?: boolean;
      mentioned?: boolean;
      mediaUnread?: boolean;
      silent?: boolean;
      post?: boolean;
      legacy?: boolean;
      id: int;
      fromId?: Raw.TypePeer;
      peerId: Raw.TypePeer;
      replyTo?: Raw.TypeMessageReplyHeader;
      date: int;
      action: Raw.TypeMessageAction;
      ttlPeriod?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageService';
      this.constructorId = 0x2b085862;
      this.subclassOfId = 0x790009e3;
      this._slots = [
        'out',
        'mentioned',
        'mediaUnread',
        'silent',
        'post',
        'legacy',
        'id',
        'fromId',
        'peerId',
        'replyTo',
        'date',
        'action',
        'ttlPeriod',
      ];
      this.out = params.out;
      this.mentioned = params.mentioned;
      this.mediaUnread = params.mediaUnread;
      this.silent = params.silent;
      this.post = params.post;
      this.legacy = params.legacy;
      this.id = params.id;
      this.fromId = params.fromId;
      this.peerId = params.peerId;
      this.replyTo = params.replyTo;
      this.date = params.date;
      this.action = params.action;
      this.ttlPeriod = params.ttlPeriod;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageService> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let out = flags & (1 << 1) ? true : false;
      let mentioned = flags & (1 << 4) ? true : false;
      let mediaUnread = flags & (1 << 5) ? true : false;
      let silent = flags & (1 << 13) ? true : false;
      let post = flags & (1 << 14) ? true : false;
      let legacy = flags & (1 << 19) ? true : false;
      let id = await Primitive.Int.read(b);
      let fromId = flags & (1 << 8) ? await TLObject.read(b) : undefined;
      let peerId = await TLObject.read(b);
      let replyTo = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      let date = await Primitive.Int.read(b);
      let action = await TLObject.read(b);
      let ttlPeriod = flags & (1 << 25) ? await Primitive.Int.read(b) : undefined;
      return new Raw.MessageService({
        out: out,
        mentioned: mentioned,
        mediaUnread: mediaUnread,
        silent: silent,
        post: post,
        legacy: legacy,
        id: id,
        fromId: fromId,
        peerId: peerId,
        replyTo: replyTo,
        date: date,
        action: action,
        ttlPeriod: ttlPeriod,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.out ? 1 << 1 : 0;
      flags |= this.mentioned ? 1 << 4 : 0;
      flags |= this.mediaUnread ? 1 << 5 : 0;
      flags |= this.silent ? 1 << 13 : 0;
      flags |= this.post ? 1 << 14 : 0;
      flags |= this.legacy ? 1 << 19 : 0;
      flags |= this.fromId !== undefined ? 1 << 8 : 0;
      flags |= this.replyTo !== undefined ? 1 << 3 : 0;
      flags |= this.ttlPeriod !== undefined ? 1 << 25 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.fromId !== undefined) {
        b.write(this.fromId.write() as unknown as Buffer);
      }
      if (this.peerId !== undefined) {
        b.write(this.peerId.write() as unknown as Buffer);
      }
      if (this.replyTo !== undefined) {
        b.write(this.replyTo.write() as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.action !== undefined) {
        b.write(this.action.write() as unknown as Buffer);
      }
      if (this.ttlPeriod !== undefined) {
        b.write(Primitive.Int.write(this.ttlPeriod) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaEmpty';
      this.constructorId = 0x3ded6320;
      this.subclassOfId = 0x476cbe32;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaEmpty> {
      // no flags

      return new Raw.MessageMediaEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class MessageMediaPhoto extends TLObject {
    spoiler?: boolean;
    photo?: Raw.TypePhoto;
    ttlSeconds?: int;

    constructor(params: { spoiler?: boolean; photo?: Raw.TypePhoto; ttlSeconds?: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaPhoto';
      this.constructorId = 0x695150d7;
      this.subclassOfId = 0x476cbe32;
      this._slots = ['spoiler', 'photo', 'ttlSeconds'];
      this.spoiler = params.spoiler;
      this.photo = params.photo;
      this.ttlSeconds = params.ttlSeconds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaPhoto> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let spoiler = flags & (1 << 3) ? true : false;
      let photo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let ttlSeconds = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      return new Raw.MessageMediaPhoto({ spoiler: spoiler, photo: photo, ttlSeconds: ttlSeconds });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.spoiler ? 1 << 3 : 0;
      flags |= this.photo !== undefined ? 1 << 0 : 0;
      flags |= this.ttlSeconds !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.ttlSeconds !== undefined) {
        b.write(Primitive.Int.write(this.ttlSeconds) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaGeo extends TLObject {
    geo!: Raw.TypeGeoPoint;

    constructor(params: { geo: Raw.TypeGeoPoint }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaGeo';
      this.constructorId = 0x56e0d474;
      this.subclassOfId = 0x476cbe32;
      this._slots = ['geo'];
      this.geo = params.geo;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaGeo> {
      // no flags

      let geo = await TLObject.read(b);
      return new Raw.MessageMediaGeo({ geo: geo });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.geo !== undefined) {
        b.write(this.geo.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaContact extends TLObject {
    phoneNumber!: string;
    firstName!: string;
    lastName!: string;
    vcard!: string;
    userId!: long;

    constructor(params: {
      phoneNumber: string;
      firstName: string;
      lastName: string;
      vcard: string;
      userId: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaContact';
      this.constructorId = 0x70322949;
      this.subclassOfId = 0x476cbe32;
      this._slots = ['phoneNumber', 'firstName', 'lastName', 'vcard', 'userId'];
      this.phoneNumber = params.phoneNumber;
      this.firstName = params.firstName;
      this.lastName = params.lastName;
      this.vcard = params.vcard;
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaContact> {
      // no flags

      let phoneNumber = await Primitive.String.read(b);
      let firstName = await Primitive.String.read(b);
      let lastName = await Primitive.String.read(b);
      let vcard = await Primitive.String.read(b);
      let userId = await Primitive.Long.read(b);
      return new Raw.MessageMediaContact({
        phoneNumber: phoneNumber,
        firstName: firstName,
        lastName: lastName,
        vcard: vcard,
        userId: userId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.phoneNumber !== undefined) {
        b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
      }
      if (this.firstName !== undefined) {
        b.write(Primitive.String.write(this.firstName) as unknown as Buffer);
      }
      if (this.lastName !== undefined) {
        b.write(Primitive.String.write(this.lastName) as unknown as Buffer);
      }
      if (this.vcard !== undefined) {
        b.write(Primitive.String.write(this.vcard) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaUnsupported extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaUnsupported';
      this.constructorId = 0x9f84f49e;
      this.subclassOfId = 0x476cbe32;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaUnsupported> {
      // no flags

      return new Raw.MessageMediaUnsupported();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class MessageMediaDocument extends TLObject {
    nopremium?: boolean;
    spoiler?: boolean;
    document?: Raw.TypeDocument;
    altDocument?: Raw.TypeDocument;
    ttlSeconds?: int;

    constructor(params: {
      nopremium?: boolean;
      spoiler?: boolean;
      document?: Raw.TypeDocument;
      altDocument?: Raw.TypeDocument;
      ttlSeconds?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaDocument';
      this.constructorId = 0x4cf4d72d;
      this.subclassOfId = 0x476cbe32;
      this._slots = ['nopremium', 'spoiler', 'document', 'altDocument', 'ttlSeconds'];
      this.nopremium = params.nopremium;
      this.spoiler = params.spoiler;
      this.document = params.document;
      this.altDocument = params.altDocument;
      this.ttlSeconds = params.ttlSeconds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaDocument> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let nopremium = flags & (1 << 3) ? true : false;
      let spoiler = flags & (1 << 4) ? true : false;
      let document = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let altDocument = flags & (1 << 5) ? await TLObject.read(b) : undefined;
      let ttlSeconds = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      return new Raw.MessageMediaDocument({
        nopremium: nopremium,
        spoiler: spoiler,
        document: document,
        altDocument: altDocument,
        ttlSeconds: ttlSeconds,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.nopremium ? 1 << 3 : 0;
      flags |= this.spoiler ? 1 << 4 : 0;
      flags |= this.document !== undefined ? 1 << 0 : 0;
      flags |= this.altDocument !== undefined ? 1 << 5 : 0;
      flags |= this.ttlSeconds !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.document !== undefined) {
        b.write(this.document.write() as unknown as Buffer);
      }
      if (this.altDocument !== undefined) {
        b.write(this.altDocument.write() as unknown as Buffer);
      }
      if (this.ttlSeconds !== undefined) {
        b.write(Primitive.Int.write(this.ttlSeconds) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaWebPage extends TLObject {
    forceLargeMedia?: boolean;
    forceSmallMedia?: boolean;
    manual?: boolean;
    safe?: boolean;
    webpage!: Raw.TypeWebPage;

    constructor(params: {
      forceLargeMedia?: boolean;
      forceSmallMedia?: boolean;
      manual?: boolean;
      safe?: boolean;
      webpage: Raw.TypeWebPage;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaWebPage';
      this.constructorId = 0xddf10c3b;
      this.subclassOfId = 0x476cbe32;
      this._slots = ['forceLargeMedia', 'forceSmallMedia', 'manual', 'safe', 'webpage'];
      this.forceLargeMedia = params.forceLargeMedia;
      this.forceSmallMedia = params.forceSmallMedia;
      this.manual = params.manual;
      this.safe = params.safe;
      this.webpage = params.webpage;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaWebPage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let forceLargeMedia = flags & (1 << 0) ? true : false;
      let forceSmallMedia = flags & (1 << 1) ? true : false;
      let manual = flags & (1 << 3) ? true : false;
      let safe = flags & (1 << 4) ? true : false;
      let webpage = await TLObject.read(b);
      return new Raw.MessageMediaWebPage({
        forceLargeMedia: forceLargeMedia,
        forceSmallMedia: forceSmallMedia,
        manual: manual,
        safe: safe,
        webpage: webpage,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.forceLargeMedia ? 1 << 0 : 0;
      flags |= this.forceSmallMedia ? 1 << 1 : 0;
      flags |= this.manual ? 1 << 3 : 0;
      flags |= this.safe ? 1 << 4 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.webpage !== undefined) {
        b.write(this.webpage.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaVenue extends TLObject {
    geo!: Raw.TypeGeoPoint;
    title!: string;
    address!: string;
    provider!: string;
    venueId!: string;
    venueType!: string;

    constructor(params: {
      geo: Raw.TypeGeoPoint;
      title: string;
      address: string;
      provider: string;
      venueId: string;
      venueType: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaVenue';
      this.constructorId = 0x2ec0533f;
      this.subclassOfId = 0x476cbe32;
      this._slots = ['geo', 'title', 'address', 'provider', 'venueId', 'venueType'];
      this.geo = params.geo;
      this.title = params.title;
      this.address = params.address;
      this.provider = params.provider;
      this.venueId = params.venueId;
      this.venueType = params.venueType;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaVenue> {
      // no flags

      let geo = await TLObject.read(b);
      let title = await Primitive.String.read(b);
      let address = await Primitive.String.read(b);
      let provider = await Primitive.String.read(b);
      let venueId = await Primitive.String.read(b);
      let venueType = await Primitive.String.read(b);
      return new Raw.MessageMediaVenue({
        geo: geo,
        title: title,
        address: address,
        provider: provider,
        venueId: venueId,
        venueType: venueType,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.geo !== undefined) {
        b.write(this.geo.write() as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.address !== undefined) {
        b.write(Primitive.String.write(this.address) as unknown as Buffer);
      }
      if (this.provider !== undefined) {
        b.write(Primitive.String.write(this.provider) as unknown as Buffer);
      }
      if (this.venueId !== undefined) {
        b.write(Primitive.String.write(this.venueId) as unknown as Buffer);
      }
      if (this.venueType !== undefined) {
        b.write(Primitive.String.write(this.venueType) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaGame extends TLObject {
    game!: Raw.TypeGame;

    constructor(params: { game: Raw.TypeGame }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaGame';
      this.constructorId = 0xfdb19008;
      this.subclassOfId = 0x476cbe32;
      this._slots = ['game'];
      this.game = params.game;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaGame> {
      // no flags

      let game = await TLObject.read(b);
      return new Raw.MessageMediaGame({ game: game });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.game !== undefined) {
        b.write(this.game.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaInvoice extends TLObject {
    shippingAddressRequested?: boolean;
    test?: boolean;
    title!: string;
    description!: string;
    photo?: Raw.TypeWebDocument;
    receiptMsgId?: int;
    currency!: string;
    totalAmount!: long;
    startParam!: string;
    extendedMedia?: Raw.TypeMessageExtendedMedia;

    constructor(params: {
      shippingAddressRequested?: boolean;
      test?: boolean;
      title: string;
      description: string;
      photo?: Raw.TypeWebDocument;
      receiptMsgId?: int;
      currency: string;
      totalAmount: long;
      startParam: string;
      extendedMedia?: Raw.TypeMessageExtendedMedia;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaInvoice';
      this.constructorId = 0xf6a548d3;
      this.subclassOfId = 0x476cbe32;
      this._slots = [
        'shippingAddressRequested',
        'test',
        'title',
        'description',
        'photo',
        'receiptMsgId',
        'currency',
        'totalAmount',
        'startParam',
        'extendedMedia',
      ];
      this.shippingAddressRequested = params.shippingAddressRequested;
      this.test = params.test;
      this.title = params.title;
      this.description = params.description;
      this.photo = params.photo;
      this.receiptMsgId = params.receiptMsgId;
      this.currency = params.currency;
      this.totalAmount = params.totalAmount;
      this.startParam = params.startParam;
      this.extendedMedia = params.extendedMedia;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaInvoice> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let shippingAddressRequested = flags & (1 << 1) ? true : false;
      let test = flags & (1 << 3) ? true : false;
      let title = await Primitive.String.read(b);
      let description = await Primitive.String.read(b);
      let photo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let receiptMsgId = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let currency = await Primitive.String.read(b);
      let totalAmount = await Primitive.Long.read(b);
      let startParam = await Primitive.String.read(b);
      let extendedMedia = flags & (1 << 4) ? await TLObject.read(b) : undefined;
      return new Raw.MessageMediaInvoice({
        shippingAddressRequested: shippingAddressRequested,
        test: test,
        title: title,
        description: description,
        photo: photo,
        receiptMsgId: receiptMsgId,
        currency: currency,
        totalAmount: totalAmount,
        startParam: startParam,
        extendedMedia: extendedMedia,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.shippingAddressRequested ? 1 << 1 : 0;
      flags |= this.test ? 1 << 3 : 0;
      flags |= this.photo !== undefined ? 1 << 0 : 0;
      flags |= this.receiptMsgId !== undefined ? 1 << 2 : 0;
      flags |= this.extendedMedia !== undefined ? 1 << 4 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.receiptMsgId !== undefined) {
        b.write(Primitive.Int.write(this.receiptMsgId) as unknown as Buffer);
      }
      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.totalAmount !== undefined) {
        b.write(Primitive.Long.write(this.totalAmount) as unknown as Buffer);
      }
      if (this.startParam !== undefined) {
        b.write(Primitive.String.write(this.startParam) as unknown as Buffer);
      }
      if (this.extendedMedia !== undefined) {
        b.write(this.extendedMedia.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaGeoLive extends TLObject {
    geo!: Raw.TypeGeoPoint;
    heading?: int;
    period!: int;
    proximityNotificationRadius?: int;

    constructor(params: {
      geo: Raw.TypeGeoPoint;
      heading?: int;
      period: int;
      proximityNotificationRadius?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaGeoLive';
      this.constructorId = 0xb940c666;
      this.subclassOfId = 0x476cbe32;
      this._slots = ['geo', 'heading', 'period', 'proximityNotificationRadius'];
      this.geo = params.geo;
      this.heading = params.heading;
      this.period = params.period;
      this.proximityNotificationRadius = params.proximityNotificationRadius;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaGeoLive> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let geo = await TLObject.read(b);
      let heading = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let period = await Primitive.Int.read(b);
      let proximityNotificationRadius = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      return new Raw.MessageMediaGeoLive({
        geo: geo,
        heading: heading,
        period: period,
        proximityNotificationRadius: proximityNotificationRadius,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.heading !== undefined ? 1 << 0 : 0;
      flags |= this.proximityNotificationRadius !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.geo !== undefined) {
        b.write(this.geo.write() as unknown as Buffer);
      }
      if (this.heading !== undefined) {
        b.write(Primitive.Int.write(this.heading) as unknown as Buffer);
      }
      if (this.period !== undefined) {
        b.write(Primitive.Int.write(this.period) as unknown as Buffer);
      }
      if (this.proximityNotificationRadius !== undefined) {
        b.write(Primitive.Int.write(this.proximityNotificationRadius) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaPoll extends TLObject {
    poll!: Raw.TypePoll;
    results!: Raw.TypePollResults;

    constructor(params: { poll: Raw.TypePoll; results: Raw.TypePollResults }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaPoll';
      this.constructorId = 0x4bd6e798;
      this.subclassOfId = 0x476cbe32;
      this._slots = ['poll', 'results'];
      this.poll = params.poll;
      this.results = params.results;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaPoll> {
      // no flags

      let poll = await TLObject.read(b);
      let results = await TLObject.read(b);
      return new Raw.MessageMediaPoll({ poll: poll, results: results });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.poll !== undefined) {
        b.write(this.poll.write() as unknown as Buffer);
      }
      if (this.results !== undefined) {
        b.write(this.results.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaDice extends TLObject {
    value!: int;
    emoticon!: string;

    constructor(params: { value: int; emoticon: string }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaDice';
      this.constructorId = 0x3f7ee58b;
      this.subclassOfId = 0x476cbe32;
      this._slots = ['value', 'emoticon'];
      this.value = params.value;
      this.emoticon = params.emoticon;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaDice> {
      // no flags

      let value = await Primitive.Int.read(b);
      let emoticon = await Primitive.String.read(b);
      return new Raw.MessageMediaDice({ value: value, emoticon: emoticon });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.value !== undefined) {
        b.write(Primitive.Int.write(this.value) as unknown as Buffer);
      }
      if (this.emoticon !== undefined) {
        b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaStory extends TLObject {
    viaMention?: boolean;
    peer!: Raw.TypePeer;
    id!: int;
    story?: Raw.TypeStoryItem;

    constructor(params: {
      viaMention?: boolean;
      peer: Raw.TypePeer;
      id: int;
      story?: Raw.TypeStoryItem;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaStory';
      this.constructorId = 0x68cb6283;
      this.subclassOfId = 0x476cbe32;
      this._slots = ['viaMention', 'peer', 'id', 'story'];
      this.viaMention = params.viaMention;
      this.peer = params.peer;
      this.id = params.id;
      this.story = params.story;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaStory> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let viaMention = flags & (1 << 1) ? true : false;
      let peer = await TLObject.read(b);
      let id = await Primitive.Int.read(b);
      let story = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      return new Raw.MessageMediaStory({
        viaMention: viaMention,
        peer: peer,
        id: id,
        story: story,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.viaMention ? 1 << 1 : 0;
      flags |= this.story !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.story !== undefined) {
        b.write(this.story.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageMediaGiveaway extends TLObject {
    onlyNewSubscribers?: boolean;
    channels!: Vector<long>;
    countriesIso2?: Vector<string>;
    quantity!: int;
    months!: int;
    untilDate!: int;

    constructor(params: {
      onlyNewSubscribers?: boolean;
      channels: Vector<long>;
      countriesIso2?: Vector<string>;
      quantity: int;
      months: int;
      untilDate: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageMediaGiveaway';
      this.constructorId = 0x58260664;
      this.subclassOfId = 0x476cbe32;
      this._slots = [
        'onlyNewSubscribers',
        'channels',
        'countriesIso2',
        'quantity',
        'months',
        'untilDate',
      ];
      this.onlyNewSubscribers = params.onlyNewSubscribers;
      this.channels = params.channels;
      this.countriesIso2 = params.countriesIso2;
      this.quantity = params.quantity;
      this.months = params.months;
      this.untilDate = params.untilDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageMediaGiveaway> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let onlyNewSubscribers = flags & (1 << 0) ? true : false;
      let channels = await TLObject.read(b, Primitive.Long);
      let countriesIso2 = flags & (1 << 1) ? await TLObject.read(b, Primitive.String) : [];
      let quantity = await Primitive.Int.read(b);
      let months = await Primitive.Int.read(b);
      let untilDate = await Primitive.Int.read(b);
      return new Raw.MessageMediaGiveaway({
        onlyNewSubscribers: onlyNewSubscribers,
        channels: channels,
        countriesIso2: countriesIso2,
        quantity: quantity,
        months: months,
        untilDate: untilDate,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.onlyNewSubscribers ? 1 << 0 : 0;
      flags |= this.countriesIso2 ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.channels) {
        b.write(Primitive.Vector.write(this.channels, Primitive.Long) as unknown as Buffer);
      }
      if (this.countriesIso2) {
        b.write(Primitive.Vector.write(this.countriesIso2, Primitive.String) as unknown as Buffer);
      }
      if (this.quantity !== undefined) {
        b.write(Primitive.Int.write(this.quantity) as unknown as Buffer);
      }
      if (this.months !== undefined) {
        b.write(Primitive.Int.write(this.months) as unknown as Buffer);
      }
      if (this.untilDate !== undefined) {
        b.write(Primitive.Int.write(this.untilDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'MessageActionEmpty';
      this.constructorId = 0xb6aef7b0;
      this.subclassOfId = 0x8680d126;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionEmpty> {
      // no flags

      return new Raw.MessageActionEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class MessageActionChatCreate extends TLObject {
    title!: string;
    users!: Vector<long>;

    constructor(params: { title: string; users: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionChatCreate';
      this.constructorId = 0xbd47cbad;
      this.subclassOfId = 0x8680d126;
      this._slots = ['title', 'users'];
      this.title = params.title;
      this.users = params.users;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionChatCreate> {
      // no flags

      let title = await Primitive.String.read(b);
      let users = await TLObject.read(b, Primitive.Long);
      return new Raw.MessageActionChatCreate({ title: title, users: users });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.users) {
        b.write(Primitive.Vector.write(this.users, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionChatEditTitle extends TLObject {
    title!: string;

    constructor(params: { title: string }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionChatEditTitle';
      this.constructorId = 0xb5a1ce5a;
      this.subclassOfId = 0x8680d126;
      this._slots = ['title'];
      this.title = params.title;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionChatEditTitle> {
      // no flags

      let title = await Primitive.String.read(b);
      return new Raw.MessageActionChatEditTitle({ title: title });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionChatEditPhoto extends TLObject {
    photo!: Raw.TypePhoto;

    constructor(params: { photo: Raw.TypePhoto }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionChatEditPhoto';
      this.constructorId = 0x7fcb13a8;
      this.subclassOfId = 0x8680d126;
      this._slots = ['photo'];
      this.photo = params.photo;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionChatEditPhoto> {
      // no flags

      let photo = await TLObject.read(b);
      return new Raw.MessageActionChatEditPhoto({ photo: photo });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionChatDeletePhoto extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'MessageActionChatDeletePhoto';
      this.constructorId = 0x95e3fbef;
      this.subclassOfId = 0x8680d126;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionChatDeletePhoto> {
      // no flags

      return new Raw.MessageActionChatDeletePhoto();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class MessageActionChatAddUser extends TLObject {
    users!: Vector<long>;

    constructor(params: { users: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionChatAddUser';
      this.constructorId = 0x15cefd00;
      this.subclassOfId = 0x8680d126;
      this._slots = ['users'];
      this.users = params.users;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionChatAddUser> {
      // no flags

      let users = await TLObject.read(b, Primitive.Long);
      return new Raw.MessageActionChatAddUser({ users: users });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.users) {
        b.write(Primitive.Vector.write(this.users, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionChatDeleteUser extends TLObject {
    userId!: long;

    constructor(params: { userId: long }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionChatDeleteUser';
      this.constructorId = 0xa43f30cc;
      this.subclassOfId = 0x8680d126;
      this._slots = ['userId'];
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionChatDeleteUser> {
      // no flags

      let userId = await Primitive.Long.read(b);
      return new Raw.MessageActionChatDeleteUser({ userId: userId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionChatJoinedByLink extends TLObject {
    inviterId!: long;

    constructor(params: { inviterId: long }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionChatJoinedByLink';
      this.constructorId = 0x31224c3;
      this.subclassOfId = 0x8680d126;
      this._slots = ['inviterId'];
      this.inviterId = params.inviterId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionChatJoinedByLink> {
      // no flags

      let inviterId = await Primitive.Long.read(b);
      return new Raw.MessageActionChatJoinedByLink({ inviterId: inviterId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.inviterId !== undefined) {
        b.write(Primitive.Long.write(this.inviterId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionChannelCreate extends TLObject {
    title!: string;

    constructor(params: { title: string }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionChannelCreate';
      this.constructorId = 0x95d2ac92;
      this.subclassOfId = 0x8680d126;
      this._slots = ['title'];
      this.title = params.title;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionChannelCreate> {
      // no flags

      let title = await Primitive.String.read(b);
      return new Raw.MessageActionChannelCreate({ title: title });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionChatMigrateTo extends TLObject {
    channelId!: long;

    constructor(params: { channelId: long }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionChatMigrateTo';
      this.constructorId = 0xe1037f92;
      this.subclassOfId = 0x8680d126;
      this._slots = ['channelId'];
      this.channelId = params.channelId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionChatMigrateTo> {
      // no flags

      let channelId = await Primitive.Long.read(b);
      return new Raw.MessageActionChatMigrateTo({ channelId: channelId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionChannelMigrateFrom extends TLObject {
    title!: string;
    chatId!: long;

    constructor(params: { title: string; chatId: long }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionChannelMigrateFrom';
      this.constructorId = 0xea3948e9;
      this.subclassOfId = 0x8680d126;
      this._slots = ['title', 'chatId'];
      this.title = params.title;
      this.chatId = params.chatId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.MessageActionChannelMigrateFrom> {
      // no flags

      let title = await Primitive.String.read(b);
      let chatId = await Primitive.Long.read(b);
      return new Raw.MessageActionChannelMigrateFrom({ title: title, chatId: chatId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionPinMessage extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'MessageActionPinMessage';
      this.constructorId = 0x94bd38ed;
      this.subclassOfId = 0x8680d126;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionPinMessage> {
      // no flags

      return new Raw.MessageActionPinMessage();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class MessageActionHistoryClear extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'MessageActionHistoryClear';
      this.constructorId = 0x9fbab604;
      this.subclassOfId = 0x8680d126;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionHistoryClear> {
      // no flags

      return new Raw.MessageActionHistoryClear();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class MessageActionGameScore extends TLObject {
    gameId!: long;
    score!: int;

    constructor(params: { gameId: long; score: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionGameScore';
      this.constructorId = 0x92a72876;
      this.subclassOfId = 0x8680d126;
      this._slots = ['gameId', 'score'];
      this.gameId = params.gameId;
      this.score = params.score;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionGameScore> {
      // no flags

      let gameId = await Primitive.Long.read(b);
      let score = await Primitive.Int.read(b);
      return new Raw.MessageActionGameScore({ gameId: gameId, score: score });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.gameId !== undefined) {
        b.write(Primitive.Long.write(this.gameId) as unknown as Buffer);
      }
      if (this.score !== undefined) {
        b.write(Primitive.Int.write(this.score) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionPaymentSentMe extends TLObject {
    recurringInit?: boolean;
    recurringUsed?: boolean;
    currency!: string;
    totalAmount!: long;
    payload!: bytes;
    info?: Raw.TypePaymentRequestedInfo;
    shippingOptionId?: string;
    charge!: Raw.TypePaymentCharge;

    constructor(params: {
      recurringInit?: boolean;
      recurringUsed?: boolean;
      currency: string;
      totalAmount: long;
      payload: bytes;
      info?: Raw.TypePaymentRequestedInfo;
      shippingOptionId?: string;
      charge: Raw.TypePaymentCharge;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionPaymentSentMe';
      this.constructorId = 0x8f31b327;
      this.subclassOfId = 0x8680d126;
      this._slots = [
        'recurringInit',
        'recurringUsed',
        'currency',
        'totalAmount',
        'payload',
        'info',
        'shippingOptionId',
        'charge',
      ];
      this.recurringInit = params.recurringInit;
      this.recurringUsed = params.recurringUsed;
      this.currency = params.currency;
      this.totalAmount = params.totalAmount;
      this.payload = params.payload;
      this.info = params.info;
      this.shippingOptionId = params.shippingOptionId;
      this.charge = params.charge;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionPaymentSentMe> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let recurringInit = flags & (1 << 2) ? true : false;
      let recurringUsed = flags & (1 << 3) ? true : false;
      let currency = await Primitive.String.read(b);
      let totalAmount = await Primitive.Long.read(b);
      let payload = await Primitive.Bytes.read(b);
      let info = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let shippingOptionId = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let charge = await TLObject.read(b);
      return new Raw.MessageActionPaymentSentMe({
        recurringInit: recurringInit,
        recurringUsed: recurringUsed,
        currency: currency,
        totalAmount: totalAmount,
        payload: payload,
        info: info,
        shippingOptionId: shippingOptionId,
        charge: charge,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.recurringInit ? 1 << 2 : 0;
      flags |= this.recurringUsed ? 1 << 3 : 0;
      flags |= this.info !== undefined ? 1 << 0 : 0;
      flags |= this.shippingOptionId !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.totalAmount !== undefined) {
        b.write(Primitive.Long.write(this.totalAmount) as unknown as Buffer);
      }
      if (this.payload !== undefined) {
        b.write(Primitive.Bytes.write(this.payload) as unknown as Buffer);
      }
      if (this.info !== undefined) {
        b.write(this.info.write() as unknown as Buffer);
      }
      if (this.shippingOptionId !== undefined) {
        b.write(Primitive.String.write(this.shippingOptionId) as unknown as Buffer);
      }
      if (this.charge !== undefined) {
        b.write(this.charge.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionPaymentSent extends TLObject {
    recurringInit?: boolean;
    recurringUsed?: boolean;
    currency!: string;
    totalAmount!: long;
    invoiceSlug?: string;

    constructor(params: {
      recurringInit?: boolean;
      recurringUsed?: boolean;
      currency: string;
      totalAmount: long;
      invoiceSlug?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionPaymentSent';
      this.constructorId = 0x96163f56;
      this.subclassOfId = 0x8680d126;
      this._slots = ['recurringInit', 'recurringUsed', 'currency', 'totalAmount', 'invoiceSlug'];
      this.recurringInit = params.recurringInit;
      this.recurringUsed = params.recurringUsed;
      this.currency = params.currency;
      this.totalAmount = params.totalAmount;
      this.invoiceSlug = params.invoiceSlug;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionPaymentSent> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let recurringInit = flags & (1 << 2) ? true : false;
      let recurringUsed = flags & (1 << 3) ? true : false;
      let currency = await Primitive.String.read(b);
      let totalAmount = await Primitive.Long.read(b);
      let invoiceSlug = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      return new Raw.MessageActionPaymentSent({
        recurringInit: recurringInit,
        recurringUsed: recurringUsed,
        currency: currency,
        totalAmount: totalAmount,
        invoiceSlug: invoiceSlug,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.recurringInit ? 1 << 2 : 0;
      flags |= this.recurringUsed ? 1 << 3 : 0;
      flags |= this.invoiceSlug !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.totalAmount !== undefined) {
        b.write(Primitive.Long.write(this.totalAmount) as unknown as Buffer);
      }
      if (this.invoiceSlug !== undefined) {
        b.write(Primitive.String.write(this.invoiceSlug) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionPhoneCall extends TLObject {
    video?: boolean;
    callId!: long;
    reason?: Raw.TypePhoneCallDiscardReason;
    duration?: int;

    constructor(params: {
      video?: boolean;
      callId: long;
      reason?: Raw.TypePhoneCallDiscardReason;
      duration?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionPhoneCall';
      this.constructorId = 0x80e11a7f;
      this.subclassOfId = 0x8680d126;
      this._slots = ['video', 'callId', 'reason', 'duration'];
      this.video = params.video;
      this.callId = params.callId;
      this.reason = params.reason;
      this.duration = params.duration;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionPhoneCall> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let video = flags & (1 << 2) ? true : false;
      let callId = await Primitive.Long.read(b);
      let reason = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let duration = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      return new Raw.MessageActionPhoneCall({
        video: video,
        callId: callId,
        reason: reason,
        duration: duration,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.video ? 1 << 2 : 0;
      flags |= this.reason !== undefined ? 1 << 0 : 0;
      flags |= this.duration !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.callId !== undefined) {
        b.write(Primitive.Long.write(this.callId) as unknown as Buffer);
      }
      if (this.reason !== undefined) {
        b.write(this.reason.write() as unknown as Buffer);
      }
      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionScreenshotTaken extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'MessageActionScreenshotTaken';
      this.constructorId = 0x4792929b;
      this.subclassOfId = 0x8680d126;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionScreenshotTaken> {
      // no flags

      return new Raw.MessageActionScreenshotTaken();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class MessageActionCustomAction extends TLObject {
    message!: string;

    constructor(params: { message: string }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionCustomAction';
      this.constructorId = 0xfae69f56;
      this.subclassOfId = 0x8680d126;
      this._slots = ['message'];
      this.message = params.message;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionCustomAction> {
      // no flags

      let message = await Primitive.String.read(b);
      return new Raw.MessageActionCustomAction({ message: message });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionBotAllowed extends TLObject {
    attachMenu?: boolean;
    fromRequest?: boolean;
    domain?: string;
    app?: Raw.TypeBotApp;

    constructor(params: {
      attachMenu?: boolean;
      fromRequest?: boolean;
      domain?: string;
      app?: Raw.TypeBotApp;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionBotAllowed';
      this.constructorId = 0xc516d679;
      this.subclassOfId = 0x8680d126;
      this._slots = ['attachMenu', 'fromRequest', 'domain', 'app'];
      this.attachMenu = params.attachMenu;
      this.fromRequest = params.fromRequest;
      this.domain = params.domain;
      this.app = params.app;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionBotAllowed> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let attachMenu = flags & (1 << 1) ? true : false;
      let fromRequest = flags & (1 << 3) ? true : false;
      let domain = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let app = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.MessageActionBotAllowed({
        attachMenu: attachMenu,
        fromRequest: fromRequest,
        domain: domain,
        app: app,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.attachMenu ? 1 << 1 : 0;
      flags |= this.fromRequest ? 1 << 3 : 0;
      flags |= this.domain !== undefined ? 1 << 0 : 0;
      flags |= this.app !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.domain !== undefined) {
        b.write(Primitive.String.write(this.domain) as unknown as Buffer);
      }
      if (this.app !== undefined) {
        b.write(this.app.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionSecureValuesSentMe extends TLObject {
    values!: Vector<Raw.TypeSecureValue>;
    credentials!: Raw.TypeSecureCredentialsEncrypted;

    constructor(params: {
      values: Vector<Raw.TypeSecureValue>;
      credentials: Raw.TypeSecureCredentialsEncrypted;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionSecureValuesSentMe';
      this.constructorId = 0x1b287353;
      this.subclassOfId = 0x8680d126;
      this._slots = ['values', 'credentials'];
      this.values = params.values;
      this.credentials = params.credentials;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.MessageActionSecureValuesSentMe> {
      // no flags

      let values = await TLObject.read(b);
      let credentials = await TLObject.read(b);
      return new Raw.MessageActionSecureValuesSentMe({ values: values, credentials: credentials });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.values) {
        b.write(Primitive.Vector.write(this.values) as unknown as Buffer);
      }
      if (this.credentials !== undefined) {
        b.write(this.credentials.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionSecureValuesSent extends TLObject {
    types!: Vector<Raw.TypeSecureValueType>;

    constructor(params: { types: Vector<Raw.TypeSecureValueType> }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionSecureValuesSent';
      this.constructorId = 0xd95c6154;
      this.subclassOfId = 0x8680d126;
      this._slots = ['types'];
      this.types = params.types;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionSecureValuesSent> {
      // no flags

      let types = await TLObject.read(b);
      return new Raw.MessageActionSecureValuesSent({ types: types });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.types) {
        b.write(Primitive.Vector.write(this.types) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionContactSignUp extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'MessageActionContactSignUp';
      this.constructorId = 0xf3f25f76;
      this.subclassOfId = 0x8680d126;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionContactSignUp> {
      // no flags

      return new Raw.MessageActionContactSignUp();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class MessageActionGeoProximityReached extends TLObject {
    fromId!: Raw.TypePeer;
    toId!: Raw.TypePeer;
    distance!: int;

    constructor(params: { fromId: Raw.TypePeer; toId: Raw.TypePeer; distance: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionGeoProximityReached';
      this.constructorId = 0x98e0d697;
      this.subclassOfId = 0x8680d126;
      this._slots = ['fromId', 'toId', 'distance'];
      this.fromId = params.fromId;
      this.toId = params.toId;
      this.distance = params.distance;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.MessageActionGeoProximityReached> {
      // no flags

      let fromId = await TLObject.read(b);
      let toId = await TLObject.read(b);
      let distance = await Primitive.Int.read(b);
      return new Raw.MessageActionGeoProximityReached({
        fromId: fromId,
        toId: toId,
        distance: distance,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.fromId !== undefined) {
        b.write(this.fromId.write() as unknown as Buffer);
      }
      if (this.toId !== undefined) {
        b.write(this.toId.write() as unknown as Buffer);
      }
      if (this.distance !== undefined) {
        b.write(Primitive.Int.write(this.distance) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionGroupCall extends TLObject {
    call!: Raw.TypeInputGroupCall;
    duration?: int;

    constructor(params: { call: Raw.TypeInputGroupCall; duration?: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionGroupCall';
      this.constructorId = 0x7a0d7f42;
      this.subclassOfId = 0x8680d126;
      this._slots = ['call', 'duration'];
      this.call = params.call;
      this.duration = params.duration;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionGroupCall> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let call = await TLObject.read(b);
      let duration = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.MessageActionGroupCall({ call: call, duration: duration });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.duration !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.call !== undefined) {
        b.write(this.call.write() as unknown as Buffer);
      }
      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionInviteToGroupCall extends TLObject {
    call!: Raw.TypeInputGroupCall;
    users!: Vector<long>;

    constructor(params: { call: Raw.TypeInputGroupCall; users: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionInviteToGroupCall';
      this.constructorId = 0x502f92f7;
      this.subclassOfId = 0x8680d126;
      this._slots = ['call', 'users'];
      this.call = params.call;
      this.users = params.users;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.MessageActionInviteToGroupCall> {
      // no flags

      let call = await TLObject.read(b);
      let users = await TLObject.read(b, Primitive.Long);
      return new Raw.MessageActionInviteToGroupCall({ call: call, users: users });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.call !== undefined) {
        b.write(this.call.write() as unknown as Buffer);
      }
      if (this.users) {
        b.write(Primitive.Vector.write(this.users, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionSetMessagesTTL extends TLObject {
    period!: int;
    autoSettingFrom?: long;

    constructor(params: { period: int; autoSettingFrom?: long }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionSetMessagesTTL';
      this.constructorId = 0x3c134d7b;
      this.subclassOfId = 0x8680d126;
      this._slots = ['period', 'autoSettingFrom'];
      this.period = params.period;
      this.autoSettingFrom = params.autoSettingFrom;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionSetMessagesTTL> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let period = await Primitive.Int.read(b);
      let autoSettingFrom = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
      return new Raw.MessageActionSetMessagesTTL({
        period: period,
        autoSettingFrom: autoSettingFrom,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.autoSettingFrom !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.period !== undefined) {
        b.write(Primitive.Int.write(this.period) as unknown as Buffer);
      }
      if (this.autoSettingFrom !== undefined) {
        b.write(Primitive.Long.write(this.autoSettingFrom) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionGroupCallScheduled extends TLObject {
    call!: Raw.TypeInputGroupCall;
    scheduleDate!: int;

    constructor(params: { call: Raw.TypeInputGroupCall; scheduleDate: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionGroupCallScheduled';
      this.constructorId = 0xb3a07661;
      this.subclassOfId = 0x8680d126;
      this._slots = ['call', 'scheduleDate'];
      this.call = params.call;
      this.scheduleDate = params.scheduleDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.MessageActionGroupCallScheduled> {
      // no flags

      let call = await TLObject.read(b);
      let scheduleDate = await Primitive.Int.read(b);
      return new Raw.MessageActionGroupCallScheduled({ call: call, scheduleDate: scheduleDate });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.call !== undefined) {
        b.write(this.call.write() as unknown as Buffer);
      }
      if (this.scheduleDate !== undefined) {
        b.write(Primitive.Int.write(this.scheduleDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionSetChatTheme extends TLObject {
    emoticon!: string;

    constructor(params: { emoticon: string }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionSetChatTheme';
      this.constructorId = 0xaa786345;
      this.subclassOfId = 0x8680d126;
      this._slots = ['emoticon'];
      this.emoticon = params.emoticon;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionSetChatTheme> {
      // no flags

      let emoticon = await Primitive.String.read(b);
      return new Raw.MessageActionSetChatTheme({ emoticon: emoticon });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.emoticon !== undefined) {
        b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionChatJoinedByRequest extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'MessageActionChatJoinedByRequest';
      this.constructorId = 0xebbca3cb;
      this.subclassOfId = 0x8680d126;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.MessageActionChatJoinedByRequest> {
      // no flags

      return new Raw.MessageActionChatJoinedByRequest();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class MessageActionWebViewDataSentMe extends TLObject {
    text!: string;
    data!: string;

    constructor(params: { text: string; data: string }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionWebViewDataSentMe';
      this.constructorId = 0x47dd8079;
      this.subclassOfId = 0x8680d126;
      this._slots = ['text', 'data'];
      this.text = params.text;
      this.data = params.data;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.MessageActionWebViewDataSentMe> {
      // no flags

      let text = await Primitive.String.read(b);
      let data = await Primitive.String.read(b);
      return new Raw.MessageActionWebViewDataSentMe({ text: text, data: data });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.data !== undefined) {
        b.write(Primitive.String.write(this.data) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionWebViewDataSent extends TLObject {
    text!: string;

    constructor(params: { text: string }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionWebViewDataSent';
      this.constructorId = 0xb4c38cb5;
      this.subclassOfId = 0x8680d126;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionWebViewDataSent> {
      // no flags

      let text = await Primitive.String.read(b);
      return new Raw.MessageActionWebViewDataSent({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionGiftPremium extends TLObject {
    currency!: string;
    amount!: long;
    months!: int;
    cryptoCurrency?: string;
    cryptoAmount?: long;

    constructor(params: {
      currency: string;
      amount: long;
      months: int;
      cryptoCurrency?: string;
      cryptoAmount?: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionGiftPremium';
      this.constructorId = 0xc83d6aec;
      this.subclassOfId = 0x8680d126;
      this._slots = ['currency', 'amount', 'months', 'cryptoCurrency', 'cryptoAmount'];
      this.currency = params.currency;
      this.amount = params.amount;
      this.months = params.months;
      this.cryptoCurrency = params.cryptoCurrency;
      this.cryptoAmount = params.cryptoAmount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionGiftPremium> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let currency = await Primitive.String.read(b);
      let amount = await Primitive.Long.read(b);
      let months = await Primitive.Int.read(b);
      let cryptoCurrency = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let cryptoAmount = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
      return new Raw.MessageActionGiftPremium({
        currency: currency,
        amount: amount,
        months: months,
        cryptoCurrency: cryptoCurrency,
        cryptoAmount: cryptoAmount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.cryptoCurrency !== undefined ? 1 << 0 : 0;
      flags |= this.cryptoAmount !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.amount !== undefined) {
        b.write(Primitive.Long.write(this.amount) as unknown as Buffer);
      }
      if (this.months !== undefined) {
        b.write(Primitive.Int.write(this.months) as unknown as Buffer);
      }
      if (this.cryptoCurrency !== undefined) {
        b.write(Primitive.String.write(this.cryptoCurrency) as unknown as Buffer);
      }
      if (this.cryptoAmount !== undefined) {
        b.write(Primitive.Long.write(this.cryptoAmount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionTopicCreate extends TLObject {
    title!: string;
    iconColor!: int;
    iconEmojiId?: long;

    constructor(params: { title: string; iconColor: int; iconEmojiId?: long }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionTopicCreate';
      this.constructorId = 0xd999256;
      this.subclassOfId = 0x8680d126;
      this._slots = ['title', 'iconColor', 'iconEmojiId'];
      this.title = params.title;
      this.iconColor = params.iconColor;
      this.iconEmojiId = params.iconEmojiId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionTopicCreate> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let title = await Primitive.String.read(b);
      let iconColor = await Primitive.Int.read(b);
      let iconEmojiId = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
      return new Raw.MessageActionTopicCreate({
        title: title,
        iconColor: iconColor,
        iconEmojiId: iconEmojiId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.iconEmojiId !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.iconColor !== undefined) {
        b.write(Primitive.Int.write(this.iconColor) as unknown as Buffer);
      }
      if (this.iconEmojiId !== undefined) {
        b.write(Primitive.Long.write(this.iconEmojiId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionTopicEdit extends TLObject {
    title?: string;
    iconEmojiId?: long;
    closed?: Bool;
    hidden?: Bool;

    constructor(params: { title?: string; iconEmojiId?: long; closed?: Bool; hidden?: Bool }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionTopicEdit';
      this.constructorId = 0xc0944820;
      this.subclassOfId = 0x8680d126;
      this._slots = ['title', 'iconEmojiId', 'closed', 'hidden'];
      this.title = params.title;
      this.iconEmojiId = params.iconEmojiId;
      this.closed = params.closed;
      this.hidden = params.hidden;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionTopicEdit> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let title = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let iconEmojiId = flags & (1 << 1) ? await Primitive.Long.read(b) : undefined;
      let closed = flags & (1 << 2) ? await Primitive.Bool.read(b) : undefined;
      let hidden = flags & (1 << 3) ? await Primitive.Bool.read(b) : undefined;
      return new Raw.MessageActionTopicEdit({
        title: title,
        iconEmojiId: iconEmojiId,
        closed: closed,
        hidden: hidden,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.title !== undefined ? 1 << 0 : 0;
      flags |= this.iconEmojiId !== undefined ? 1 << 1 : 0;
      flags |= this.closed !== undefined ? 1 << 2 : 0;
      flags |= this.hidden !== undefined ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.iconEmojiId !== undefined) {
        b.write(Primitive.Long.write(this.iconEmojiId) as unknown as Buffer);
      }
      if (this.closed !== undefined) {
        b.write(Primitive.Bool.write(this.closed) as unknown as Buffer);
      }
      if (this.hidden !== undefined) {
        b.write(Primitive.Bool.write(this.hidden) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionSuggestProfilePhoto extends TLObject {
    photo!: Raw.TypePhoto;

    constructor(params: { photo: Raw.TypePhoto }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionSuggestProfilePhoto';
      this.constructorId = 0x57de635e;
      this.subclassOfId = 0x8680d126;
      this._slots = ['photo'];
      this.photo = params.photo;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.MessageActionSuggestProfilePhoto> {
      // no flags

      let photo = await TLObject.read(b);
      return new Raw.MessageActionSuggestProfilePhoto({ photo: photo });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionRequestedPeer extends TLObject {
    buttonId!: int;
    peer!: Raw.TypePeer;

    constructor(params: { buttonId: int; peer: Raw.TypePeer }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionRequestedPeer';
      this.constructorId = 0xfe77345d;
      this.subclassOfId = 0x8680d126;
      this._slots = ['buttonId', 'peer'];
      this.buttonId = params.buttonId;
      this.peer = params.peer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionRequestedPeer> {
      // no flags

      let buttonId = await Primitive.Int.read(b);
      let peer = await TLObject.read(b);
      return new Raw.MessageActionRequestedPeer({ buttonId: buttonId, peer: peer });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.buttonId !== undefined) {
        b.write(Primitive.Int.write(this.buttonId) as unknown as Buffer);
      }
      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionSetChatWallPaper extends TLObject {
    wallpaper!: Raw.TypeWallPaper;

    constructor(params: { wallpaper: Raw.TypeWallPaper }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionSetChatWallPaper';
      this.constructorId = 0xbc44a927;
      this.subclassOfId = 0x8680d126;
      this._slots = ['wallpaper'];
      this.wallpaper = params.wallpaper;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionSetChatWallPaper> {
      // no flags

      let wallpaper = await TLObject.read(b);
      return new Raw.MessageActionSetChatWallPaper({ wallpaper: wallpaper });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.wallpaper !== undefined) {
        b.write(this.wallpaper.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionSetSameChatWallPaper extends TLObject {
    wallpaper!: Raw.TypeWallPaper;

    constructor(params: { wallpaper: Raw.TypeWallPaper }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionSetSameChatWallPaper';
      this.constructorId = 0xc0787d6d;
      this.subclassOfId = 0x8680d126;
      this._slots = ['wallpaper'];
      this.wallpaper = params.wallpaper;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.MessageActionSetSameChatWallPaper> {
      // no flags

      let wallpaper = await TLObject.read(b);
      return new Raw.MessageActionSetSameChatWallPaper({ wallpaper: wallpaper });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.wallpaper !== undefined) {
        b.write(this.wallpaper.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionGiftCode extends TLObject {
    viaGiveaway?: boolean;
    unclaimed?: boolean;
    boostPeer?: Raw.TypePeer;
    months!: int;
    slug!: string;

    constructor(params: {
      viaGiveaway?: boolean;
      unclaimed?: boolean;
      boostPeer?: Raw.TypePeer;
      months: int;
      slug: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageActionGiftCode';
      this.constructorId = 0xd2cfdb0e;
      this.subclassOfId = 0x8680d126;
      this._slots = ['viaGiveaway', 'unclaimed', 'boostPeer', 'months', 'slug'];
      this.viaGiveaway = params.viaGiveaway;
      this.unclaimed = params.unclaimed;
      this.boostPeer = params.boostPeer;
      this.months = params.months;
      this.slug = params.slug;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionGiftCode> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let viaGiveaway = flags & (1 << 0) ? true : false;
      let unclaimed = flags & (1 << 2) ? true : false;
      let boostPeer = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let months = await Primitive.Int.read(b);
      let slug = await Primitive.String.read(b);
      return new Raw.MessageActionGiftCode({
        viaGiveaway: viaGiveaway,
        unclaimed: unclaimed,
        boostPeer: boostPeer,
        months: months,
        slug: slug,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.viaGiveaway ? 1 << 0 : 0;
      flags |= this.unclaimed ? 1 << 2 : 0;
      flags |= this.boostPeer !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.boostPeer !== undefined) {
        b.write(this.boostPeer.write() as unknown as Buffer);
      }
      if (this.months !== undefined) {
        b.write(Primitive.Int.write(this.months) as unknown as Buffer);
      }
      if (this.slug !== undefined) {
        b.write(Primitive.String.write(this.slug) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageActionGiveawayLaunch extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'MessageActionGiveawayLaunch';
      this.constructorId = 0x332ba9ed;
      this.subclassOfId = 0x8680d126;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageActionGiveawayLaunch> {
      // no flags

      return new Raw.MessageActionGiveawayLaunch();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class Dialog extends TLObject {
    pinned?: boolean;
    unreadMark?: boolean;
    peer!: Raw.TypePeer;
    topMessage!: int;
    readInboxMaxId!: int;
    readOutboxMaxId!: int;
    unreadCount!: int;
    unreadMentionsCount!: int;
    unreadReactionsCount!: int;
    notifySettings!: Raw.TypePeerNotifySettings;
    pts?: int;
    draft?: Raw.TypeDraftMessage;
    folderId?: int;
    ttlPeriod?: int;

    constructor(params: {
      pinned?: boolean;
      unreadMark?: boolean;
      peer: Raw.TypePeer;
      topMessage: int;
      readInboxMaxId: int;
      readOutboxMaxId: int;
      unreadCount: int;
      unreadMentionsCount: int;
      unreadReactionsCount: int;
      notifySettings: Raw.TypePeerNotifySettings;
      pts?: int;
      draft?: Raw.TypeDraftMessage;
      folderId?: int;
      ttlPeriod?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Dialog';
      this.constructorId = 0xd58a08c6;
      this.subclassOfId = 0x42cddd54;
      this._slots = [
        'pinned',
        'unreadMark',
        'peer',
        'topMessage',
        'readInboxMaxId',
        'readOutboxMaxId',
        'unreadCount',
        'unreadMentionsCount',
        'unreadReactionsCount',
        'notifySettings',
        'pts',
        'draft',
        'folderId',
        'ttlPeriod',
      ];
      this.pinned = params.pinned;
      this.unreadMark = params.unreadMark;
      this.peer = params.peer;
      this.topMessage = params.topMessage;
      this.readInboxMaxId = params.readInboxMaxId;
      this.readOutboxMaxId = params.readOutboxMaxId;
      this.unreadCount = params.unreadCount;
      this.unreadMentionsCount = params.unreadMentionsCount;
      this.unreadReactionsCount = params.unreadReactionsCount;
      this.notifySettings = params.notifySettings;
      this.pts = params.pts;
      this.draft = params.draft;
      this.folderId = params.folderId;
      this.ttlPeriod = params.ttlPeriod;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Dialog> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let pinned = flags & (1 << 2) ? true : false;
      let unreadMark = flags & (1 << 3) ? true : false;
      let peer = await TLObject.read(b);
      let topMessage = await Primitive.Int.read(b);
      let readInboxMaxId = await Primitive.Int.read(b);
      let readOutboxMaxId = await Primitive.Int.read(b);
      let unreadCount = await Primitive.Int.read(b);
      let unreadMentionsCount = await Primitive.Int.read(b);
      let unreadReactionsCount = await Primitive.Int.read(b);
      let notifySettings = await TLObject.read(b);
      let pts = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let draft = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let folderId = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      let ttlPeriod = flags & (1 << 5) ? await Primitive.Int.read(b) : undefined;
      return new Raw.Dialog({
        pinned: pinned,
        unreadMark: unreadMark,
        peer: peer,
        topMessage: topMessage,
        readInboxMaxId: readInboxMaxId,
        readOutboxMaxId: readOutboxMaxId,
        unreadCount: unreadCount,
        unreadMentionsCount: unreadMentionsCount,
        unreadReactionsCount: unreadReactionsCount,
        notifySettings: notifySettings,
        pts: pts,
        draft: draft,
        folderId: folderId,
        ttlPeriod: ttlPeriod,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.pinned ? 1 << 2 : 0;
      flags |= this.unreadMark ? 1 << 3 : 0;
      flags |= this.pts !== undefined ? 1 << 0 : 0;
      flags |= this.draft !== undefined ? 1 << 1 : 0;
      flags |= this.folderId !== undefined ? 1 << 4 : 0;
      flags |= this.ttlPeriod !== undefined ? 1 << 5 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.topMessage !== undefined) {
        b.write(Primitive.Int.write(this.topMessage) as unknown as Buffer);
      }
      if (this.readInboxMaxId !== undefined) {
        b.write(Primitive.Int.write(this.readInboxMaxId) as unknown as Buffer);
      }
      if (this.readOutboxMaxId !== undefined) {
        b.write(Primitive.Int.write(this.readOutboxMaxId) as unknown as Buffer);
      }
      if (this.unreadCount !== undefined) {
        b.write(Primitive.Int.write(this.unreadCount) as unknown as Buffer);
      }
      if (this.unreadMentionsCount !== undefined) {
        b.write(Primitive.Int.write(this.unreadMentionsCount) as unknown as Buffer);
      }
      if (this.unreadReactionsCount !== undefined) {
        b.write(Primitive.Int.write(this.unreadReactionsCount) as unknown as Buffer);
      }
      if (this.notifySettings !== undefined) {
        b.write(this.notifySettings.write() as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.draft !== undefined) {
        b.write(this.draft.write() as unknown as Buffer);
      }
      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      if (this.ttlPeriod !== undefined) {
        b.write(Primitive.Int.write(this.ttlPeriod) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DialogFolder extends TLObject {
    pinned?: boolean;
    folder!: Raw.TypeFolder;
    peer!: Raw.TypePeer;
    topMessage!: int;
    unreadMutedPeersCount!: int;
    unreadUnmutedPeersCount!: int;
    unreadMutedMessagesCount!: int;
    unreadUnmutedMessagesCount!: int;

    constructor(params: {
      pinned?: boolean;
      folder: Raw.TypeFolder;
      peer: Raw.TypePeer;
      topMessage: int;
      unreadMutedPeersCount: int;
      unreadUnmutedPeersCount: int;
      unreadMutedMessagesCount: int;
      unreadUnmutedMessagesCount: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DialogFolder';
      this.constructorId = 0x71bd134c;
      this.subclassOfId = 0x42cddd54;
      this._slots = [
        'pinned',
        'folder',
        'peer',
        'topMessage',
        'unreadMutedPeersCount',
        'unreadUnmutedPeersCount',
        'unreadMutedMessagesCount',
        'unreadUnmutedMessagesCount',
      ];
      this.pinned = params.pinned;
      this.folder = params.folder;
      this.peer = params.peer;
      this.topMessage = params.topMessage;
      this.unreadMutedPeersCount = params.unreadMutedPeersCount;
      this.unreadUnmutedPeersCount = params.unreadUnmutedPeersCount;
      this.unreadMutedMessagesCount = params.unreadMutedMessagesCount;
      this.unreadUnmutedMessagesCount = params.unreadUnmutedMessagesCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DialogFolder> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let pinned = flags & (1 << 2) ? true : false;
      let folder = await TLObject.read(b);
      let peer = await TLObject.read(b);
      let topMessage = await Primitive.Int.read(b);
      let unreadMutedPeersCount = await Primitive.Int.read(b);
      let unreadUnmutedPeersCount = await Primitive.Int.read(b);
      let unreadMutedMessagesCount = await Primitive.Int.read(b);
      let unreadUnmutedMessagesCount = await Primitive.Int.read(b);
      return new Raw.DialogFolder({
        pinned: pinned,
        folder: folder,
        peer: peer,
        topMessage: topMessage,
        unreadMutedPeersCount: unreadMutedPeersCount,
        unreadUnmutedPeersCount: unreadUnmutedPeersCount,
        unreadMutedMessagesCount: unreadMutedMessagesCount,
        unreadUnmutedMessagesCount: unreadUnmutedMessagesCount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.pinned ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.folder !== undefined) {
        b.write(this.folder.write() as unknown as Buffer);
      }
      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.topMessage !== undefined) {
        b.write(Primitive.Int.write(this.topMessage) as unknown as Buffer);
      }
      if (this.unreadMutedPeersCount !== undefined) {
        b.write(Primitive.Int.write(this.unreadMutedPeersCount) as unknown as Buffer);
      }
      if (this.unreadUnmutedPeersCount !== undefined) {
        b.write(Primitive.Int.write(this.unreadUnmutedPeersCount) as unknown as Buffer);
      }
      if (this.unreadMutedMessagesCount !== undefined) {
        b.write(Primitive.Int.write(this.unreadMutedMessagesCount) as unknown as Buffer);
      }
      if (this.unreadUnmutedMessagesCount !== undefined) {
        b.write(Primitive.Int.write(this.unreadUnmutedMessagesCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhotoEmpty extends TLObject {
    id!: long;

    constructor(params: { id: long }) {
      super();
      this.classType = 'types';
      this.className = 'PhotoEmpty';
      this.constructorId = 0x2331b22d;
      this.subclassOfId = 0xd576ab1c;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhotoEmpty> {
      // no flags

      let id = await Primitive.Long.read(b);
      return new Raw.PhotoEmpty({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Photo extends TLObject {
    hasStickers?: boolean;
    id!: long;
    accessHash!: long;
    fileReference!: bytes;
    date!: int;
    sizes!: Vector<Raw.TypePhotoSize>;
    videoSizes?: Vector<Raw.TypeVideoSize>;
    dcId!: int;

    constructor(params: {
      hasStickers?: boolean;
      id: long;
      accessHash: long;
      fileReference: bytes;
      date: int;
      sizes: Vector<Raw.TypePhotoSize>;
      videoSizes?: Vector<Raw.TypeVideoSize>;
      dcId: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Photo';
      this.constructorId = 0xfb197a65;
      this.subclassOfId = 0xd576ab1c;
      this._slots = [
        'hasStickers',
        'id',
        'accessHash',
        'fileReference',
        'date',
        'sizes',
        'videoSizes',
        'dcId',
      ];
      this.hasStickers = params.hasStickers;
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.fileReference = params.fileReference;
      this.date = params.date;
      this.sizes = params.sizes;
      this.videoSizes = params.videoSizes;
      this.dcId = params.dcId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Photo> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let hasStickers = flags & (1 << 0) ? true : false;
      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let fileReference = await Primitive.Bytes.read(b);
      let date = await Primitive.Int.read(b);
      let sizes = await TLObject.read(b);
      let videoSizes = flags & (1 << 1) ? await TLObject.read(b) : [];
      let dcId = await Primitive.Int.read(b);
      return new Raw.Photo({
        hasStickers: hasStickers,
        id: id,
        accessHash: accessHash,
        fileReference: fileReference,
        date: date,
        sizes: sizes,
        videoSizes: videoSizes,
        dcId: dcId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.hasStickers ? 1 << 0 : 0;
      flags |= this.videoSizes ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.fileReference !== undefined) {
        b.write(Primitive.Bytes.write(this.fileReference) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.sizes) {
        b.write(Primitive.Vector.write(this.sizes) as unknown as Buffer);
      }
      if (this.videoSizes) {
        b.write(Primitive.Vector.write(this.videoSizes) as unknown as Buffer);
      }
      if (this.dcId !== undefined) {
        b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhotoSizeEmpty extends TLObject {
    type!: string;

    constructor(params: { type: string }) {
      super();
      this.classType = 'types';
      this.className = 'PhotoSizeEmpty';
      this.constructorId = 0xe17e23c;
      this.subclassOfId = 0x17cc29d9;
      this._slots = ['type'];
      this.type = params.type;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhotoSizeEmpty> {
      // no flags

      let type = await Primitive.String.read(b);
      return new Raw.PhotoSizeEmpty({ type: type });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhotoSize extends TLObject {
    type!: string;
    w!: int;
    h!: int;
    size!: int;

    constructor(params: { type: string; w: int; h: int; size: int }) {
      super();
      this.classType = 'types';
      this.className = 'PhotoSize';
      this.constructorId = 0x75c78e60;
      this.subclassOfId = 0x17cc29d9;
      this._slots = ['type', 'w', 'h', 'size'];
      this.type = params.type;
      this.w = params.w;
      this.h = params.h;
      this.size = params.size;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhotoSize> {
      // no flags

      let type = await Primitive.String.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let size = await Primitive.Int.read(b);
      return new Raw.PhotoSize({ type: type, w: w, h: h, size: size });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhotoCachedSize extends TLObject {
    type!: string;
    w!: int;
    h!: int;
    bytes!: bytes;

    constructor(params: { type: string; w: int; h: int; bytes: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'PhotoCachedSize';
      this.constructorId = 0x21e1ad6;
      this.subclassOfId = 0x17cc29d9;
      this._slots = ['type', 'w', 'h', 'bytes'];
      this.type = params.type;
      this.w = params.w;
      this.h = params.h;
      this.bytes = params.bytes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhotoCachedSize> {
      // no flags

      let type = await Primitive.String.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let bytes = await Primitive.Bytes.read(b);
      return new Raw.PhotoCachedSize({ type: type, w: w, h: h, bytes: bytes });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.bytes !== undefined) {
        b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhotoStrippedSize extends TLObject {
    type!: string;
    bytes!: bytes;

    constructor(params: { type: string; bytes: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'PhotoStrippedSize';
      this.constructorId = 0xe0b0bc2e;
      this.subclassOfId = 0x17cc29d9;
      this._slots = ['type', 'bytes'];
      this.type = params.type;
      this.bytes = params.bytes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhotoStrippedSize> {
      // no flags

      let type = await Primitive.String.read(b);
      let bytes = await Primitive.Bytes.read(b);
      return new Raw.PhotoStrippedSize({ type: type, bytes: bytes });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.bytes !== undefined) {
        b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhotoSizeProgressive extends TLObject {
    type!: string;
    w!: int;
    h!: int;
    sizes!: Vector<int>;

    constructor(params: { type: string; w: int; h: int; sizes: Vector<int> }) {
      super();
      this.classType = 'types';
      this.className = 'PhotoSizeProgressive';
      this.constructorId = 0xfa3efb95;
      this.subclassOfId = 0x17cc29d9;
      this._slots = ['type', 'w', 'h', 'sizes'];
      this.type = params.type;
      this.w = params.w;
      this.h = params.h;
      this.sizes = params.sizes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhotoSizeProgressive> {
      // no flags

      let type = await Primitive.String.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let sizes = await TLObject.read(b, Primitive.Int);
      return new Raw.PhotoSizeProgressive({ type: type, w: w, h: h, sizes: sizes });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.sizes) {
        b.write(Primitive.Vector.write(this.sizes, Primitive.Int) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhotoPathSize extends TLObject {
    type!: string;
    bytes!: bytes;

    constructor(params: { type: string; bytes: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'PhotoPathSize';
      this.constructorId = 0xd8214d41;
      this.subclassOfId = 0x17cc29d9;
      this._slots = ['type', 'bytes'];
      this.type = params.type;
      this.bytes = params.bytes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhotoPathSize> {
      // no flags

      let type = await Primitive.String.read(b);
      let bytes = await Primitive.Bytes.read(b);
      return new Raw.PhotoPathSize({ type: type, bytes: bytes });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.bytes !== undefined) {
        b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class GeoPointEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'GeoPointEmpty';
      this.constructorId = 0x1117dd5f;
      this.subclassOfId = 0xd610e16d;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.GeoPointEmpty> {
      // no flags

      return new Raw.GeoPointEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class GeoPoint extends TLObject {
    long!: double;
    lat!: double;
    accessHash!: long;
    accuracyRadius?: int;

    constructor(params: { long: double; lat: double; accessHash: long; accuracyRadius?: int }) {
      super();
      this.classType = 'types';
      this.className = 'GeoPoint';
      this.constructorId = 0xb2a2f663;
      this.subclassOfId = 0xd610e16d;
      this._slots = ['long', 'lat', 'accessHash', 'accuracyRadius'];
      this.long = params.long;
      this.lat = params.lat;
      this.accessHash = params.accessHash;
      this.accuracyRadius = params.accuracyRadius;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.GeoPoint> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let long = await Primitive.Double.read(b);
      let lat = await Primitive.Double.read(b);
      let accessHash = await Primitive.Long.read(b);
      let accuracyRadius = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.GeoPoint({
        long: long,
        lat: lat,
        accessHash: accessHash,
        accuracyRadius: accuracyRadius,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.accuracyRadius !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.long !== undefined) {
        b.write(Primitive.Double.write(this.long) as unknown as Buffer);
      }
      if (this.lat !== undefined) {
        b.write(Primitive.Double.write(this.lat) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.accuracyRadius !== undefined) {
        b.write(Primitive.Int.write(this.accuracyRadius) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputNotifyPeer extends TLObject {
    peer!: Raw.TypeInputPeer;

    constructor(params: { peer: Raw.TypeInputPeer }) {
      super();
      this.classType = 'types';
      this.className = 'InputNotifyPeer';
      this.constructorId = 0xb8bc5b0c;
      this.subclassOfId = 0x58981615;
      this._slots = ['peer'];
      this.peer = params.peer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputNotifyPeer> {
      // no flags

      let peer = await TLObject.read(b);
      return new Raw.InputNotifyPeer({ peer: peer });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputNotifyUsers extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputNotifyUsers';
      this.constructorId = 0x193b4417;
      this.subclassOfId = 0x58981615;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputNotifyUsers> {
      // no flags

      return new Raw.InputNotifyUsers();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputNotifyChats extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputNotifyChats';
      this.constructorId = 0x4a95e84e;
      this.subclassOfId = 0x58981615;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputNotifyChats> {
      // no flags

      return new Raw.InputNotifyChats();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputNotifyBroadcasts extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputNotifyBroadcasts';
      this.constructorId = 0xb1db7c7e;
      this.subclassOfId = 0x58981615;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputNotifyBroadcasts> {
      // no flags

      return new Raw.InputNotifyBroadcasts();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputNotifyForumTopic extends TLObject {
    peer!: Raw.TypeInputPeer;
    topMsgId!: int;

    constructor(params: { peer: Raw.TypeInputPeer; topMsgId: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputNotifyForumTopic';
      this.constructorId = 0x5c467992;
      this.subclassOfId = 0x58981615;
      this._slots = ['peer', 'topMsgId'];
      this.peer = params.peer;
      this.topMsgId = params.topMsgId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputNotifyForumTopic> {
      // no flags

      let peer = await TLObject.read(b);
      let topMsgId = await Primitive.Int.read(b);
      return new Raw.InputNotifyForumTopic({ peer: peer, topMsgId: topMsgId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.topMsgId !== undefined) {
        b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPeerNotifySettings extends TLObject {
    showPreviews?: Bool;
    silent?: Bool;
    muteUntil?: int;
    sound?: Raw.TypeNotificationSound;
    storiesMuted?: Bool;
    storiesHideSender?: Bool;
    storiesSound?: Raw.TypeNotificationSound;

    constructor(params: {
      showPreviews?: Bool;
      silent?: Bool;
      muteUntil?: int;
      sound?: Raw.TypeNotificationSound;
      storiesMuted?: Bool;
      storiesHideSender?: Bool;
      storiesSound?: Raw.TypeNotificationSound;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputPeerNotifySettings';
      this.constructorId = 0xcacb6ae2;
      this.subclassOfId = 0x90db0b0d;
      this._slots = [
        'showPreviews',
        'silent',
        'muteUntil',
        'sound',
        'storiesMuted',
        'storiesHideSender',
        'storiesSound',
      ];
      this.showPreviews = params.showPreviews;
      this.silent = params.silent;
      this.muteUntil = params.muteUntil;
      this.sound = params.sound;
      this.storiesMuted = params.storiesMuted;
      this.storiesHideSender = params.storiesHideSender;
      this.storiesSound = params.storiesSound;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPeerNotifySettings> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let showPreviews = flags & (1 << 0) ? await Primitive.Bool.read(b) : undefined;
      let silent = flags & (1 << 1) ? await Primitive.Bool.read(b) : undefined;
      let muteUntil = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let sound = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      let storiesMuted = flags & (1 << 6) ? await Primitive.Bool.read(b) : undefined;
      let storiesHideSender = flags & (1 << 7) ? await Primitive.Bool.read(b) : undefined;
      let storiesSound = flags & (1 << 8) ? await TLObject.read(b) : undefined;
      return new Raw.InputPeerNotifySettings({
        showPreviews: showPreviews,
        silent: silent,
        muteUntil: muteUntil,
        sound: sound,
        storiesMuted: storiesMuted,
        storiesHideSender: storiesHideSender,
        storiesSound: storiesSound,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.showPreviews !== undefined ? 1 << 0 : 0;
      flags |= this.silent !== undefined ? 1 << 1 : 0;
      flags |= this.muteUntil !== undefined ? 1 << 2 : 0;
      flags |= this.sound !== undefined ? 1 << 3 : 0;
      flags |= this.storiesMuted !== undefined ? 1 << 6 : 0;
      flags |= this.storiesHideSender !== undefined ? 1 << 7 : 0;
      flags |= this.storiesSound !== undefined ? 1 << 8 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.showPreviews !== undefined) {
        b.write(Primitive.Bool.write(this.showPreviews) as unknown as Buffer);
      }
      if (this.silent !== undefined) {
        b.write(Primitive.Bool.write(this.silent) as unknown as Buffer);
      }
      if (this.muteUntil !== undefined) {
        b.write(Primitive.Int.write(this.muteUntil) as unknown as Buffer);
      }
      if (this.sound !== undefined) {
        b.write(this.sound.write() as unknown as Buffer);
      }
      if (this.storiesMuted !== undefined) {
        b.write(Primitive.Bool.write(this.storiesMuted) as unknown as Buffer);
      }
      if (this.storiesHideSender !== undefined) {
        b.write(Primitive.Bool.write(this.storiesHideSender) as unknown as Buffer);
      }
      if (this.storiesSound !== undefined) {
        b.write(this.storiesSound.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PeerNotifySettings extends TLObject {
    showPreviews?: Bool;
    silent?: Bool;
    muteUntil?: int;
    iosSound?: Raw.TypeNotificationSound;
    androidSound?: Raw.TypeNotificationSound;
    otherSound?: Raw.TypeNotificationSound;
    storiesMuted?: Bool;
    storiesHideSender?: Bool;
    storiesIosSound?: Raw.TypeNotificationSound;
    storiesAndroidSound?: Raw.TypeNotificationSound;
    storiesOtherSound?: Raw.TypeNotificationSound;

    constructor(params: {
      showPreviews?: Bool;
      silent?: Bool;
      muteUntil?: int;
      iosSound?: Raw.TypeNotificationSound;
      androidSound?: Raw.TypeNotificationSound;
      otherSound?: Raw.TypeNotificationSound;
      storiesMuted?: Bool;
      storiesHideSender?: Bool;
      storiesIosSound?: Raw.TypeNotificationSound;
      storiesAndroidSound?: Raw.TypeNotificationSound;
      storiesOtherSound?: Raw.TypeNotificationSound;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PeerNotifySettings';
      this.constructorId = 0x99622c0c;
      this.subclassOfId = 0xcf20c074;
      this._slots = [
        'showPreviews',
        'silent',
        'muteUntil',
        'iosSound',
        'androidSound',
        'otherSound',
        'storiesMuted',
        'storiesHideSender',
        'storiesIosSound',
        'storiesAndroidSound',
        'storiesOtherSound',
      ];
      this.showPreviews = params.showPreviews;
      this.silent = params.silent;
      this.muteUntil = params.muteUntil;
      this.iosSound = params.iosSound;
      this.androidSound = params.androidSound;
      this.otherSound = params.otherSound;
      this.storiesMuted = params.storiesMuted;
      this.storiesHideSender = params.storiesHideSender;
      this.storiesIosSound = params.storiesIosSound;
      this.storiesAndroidSound = params.storiesAndroidSound;
      this.storiesOtherSound = params.storiesOtherSound;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PeerNotifySettings> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let showPreviews = flags & (1 << 0) ? await Primitive.Bool.read(b) : undefined;
      let silent = flags & (1 << 1) ? await Primitive.Bool.read(b) : undefined;
      let muteUntil = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let iosSound = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      let androidSound = flags & (1 << 4) ? await TLObject.read(b) : undefined;
      let otherSound = flags & (1 << 5) ? await TLObject.read(b) : undefined;
      let storiesMuted = flags & (1 << 6) ? await Primitive.Bool.read(b) : undefined;
      let storiesHideSender = flags & (1 << 7) ? await Primitive.Bool.read(b) : undefined;
      let storiesIosSound = flags & (1 << 8) ? await TLObject.read(b) : undefined;
      let storiesAndroidSound = flags & (1 << 9) ? await TLObject.read(b) : undefined;
      let storiesOtherSound = flags & (1 << 10) ? await TLObject.read(b) : undefined;
      return new Raw.PeerNotifySettings({
        showPreviews: showPreviews,
        silent: silent,
        muteUntil: muteUntil,
        iosSound: iosSound,
        androidSound: androidSound,
        otherSound: otherSound,
        storiesMuted: storiesMuted,
        storiesHideSender: storiesHideSender,
        storiesIosSound: storiesIosSound,
        storiesAndroidSound: storiesAndroidSound,
        storiesOtherSound: storiesOtherSound,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.showPreviews !== undefined ? 1 << 0 : 0;
      flags |= this.silent !== undefined ? 1 << 1 : 0;
      flags |= this.muteUntil !== undefined ? 1 << 2 : 0;
      flags |= this.iosSound !== undefined ? 1 << 3 : 0;
      flags |= this.androidSound !== undefined ? 1 << 4 : 0;
      flags |= this.otherSound !== undefined ? 1 << 5 : 0;
      flags |= this.storiesMuted !== undefined ? 1 << 6 : 0;
      flags |= this.storiesHideSender !== undefined ? 1 << 7 : 0;
      flags |= this.storiesIosSound !== undefined ? 1 << 8 : 0;
      flags |= this.storiesAndroidSound !== undefined ? 1 << 9 : 0;
      flags |= this.storiesOtherSound !== undefined ? 1 << 10 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.showPreviews !== undefined) {
        b.write(Primitive.Bool.write(this.showPreviews) as unknown as Buffer);
      }
      if (this.silent !== undefined) {
        b.write(Primitive.Bool.write(this.silent) as unknown as Buffer);
      }
      if (this.muteUntil !== undefined) {
        b.write(Primitive.Int.write(this.muteUntil) as unknown as Buffer);
      }
      if (this.iosSound !== undefined) {
        b.write(this.iosSound.write() as unknown as Buffer);
      }
      if (this.androidSound !== undefined) {
        b.write(this.androidSound.write() as unknown as Buffer);
      }
      if (this.otherSound !== undefined) {
        b.write(this.otherSound.write() as unknown as Buffer);
      }
      if (this.storiesMuted !== undefined) {
        b.write(Primitive.Bool.write(this.storiesMuted) as unknown as Buffer);
      }
      if (this.storiesHideSender !== undefined) {
        b.write(Primitive.Bool.write(this.storiesHideSender) as unknown as Buffer);
      }
      if (this.storiesIosSound !== undefined) {
        b.write(this.storiesIosSound.write() as unknown as Buffer);
      }
      if (this.storiesAndroidSound !== undefined) {
        b.write(this.storiesAndroidSound.write() as unknown as Buffer);
      }
      if (this.storiesOtherSound !== undefined) {
        b.write(this.storiesOtherSound.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PeerSettings extends TLObject {
    reportSpam?: boolean;
    addContact?: boolean;
    blockContact?: boolean;
    shareContact?: boolean;
    needContactsException?: boolean;
    reportGeo?: boolean;
    autoarchived?: boolean;
    inviteMembers?: boolean;
    requestChatBroadcast?: boolean;
    geoDistance?: int;
    requestChatTitle?: string;
    requestChatDate?: int;

    constructor(params: {
      reportSpam?: boolean;
      addContact?: boolean;
      blockContact?: boolean;
      shareContact?: boolean;
      needContactsException?: boolean;
      reportGeo?: boolean;
      autoarchived?: boolean;
      inviteMembers?: boolean;
      requestChatBroadcast?: boolean;
      geoDistance?: int;
      requestChatTitle?: string;
      requestChatDate?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PeerSettings';
      this.constructorId = 0xa518110d;
      this.subclassOfId = 0xf6a79f84;
      this._slots = [
        'reportSpam',
        'addContact',
        'blockContact',
        'shareContact',
        'needContactsException',
        'reportGeo',
        'autoarchived',
        'inviteMembers',
        'requestChatBroadcast',
        'geoDistance',
        'requestChatTitle',
        'requestChatDate',
      ];
      this.reportSpam = params.reportSpam;
      this.addContact = params.addContact;
      this.blockContact = params.blockContact;
      this.shareContact = params.shareContact;
      this.needContactsException = params.needContactsException;
      this.reportGeo = params.reportGeo;
      this.autoarchived = params.autoarchived;
      this.inviteMembers = params.inviteMembers;
      this.requestChatBroadcast = params.requestChatBroadcast;
      this.geoDistance = params.geoDistance;
      this.requestChatTitle = params.requestChatTitle;
      this.requestChatDate = params.requestChatDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PeerSettings> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let reportSpam = flags & (1 << 0) ? true : false;
      let addContact = flags & (1 << 1) ? true : false;
      let blockContact = flags & (1 << 2) ? true : false;
      let shareContact = flags & (1 << 3) ? true : false;
      let needContactsException = flags & (1 << 4) ? true : false;
      let reportGeo = flags & (1 << 5) ? true : false;
      let autoarchived = flags & (1 << 7) ? true : false;
      let inviteMembers = flags & (1 << 8) ? true : false;
      let requestChatBroadcast = flags & (1 << 10) ? true : false;
      let geoDistance = flags & (1 << 6) ? await Primitive.Int.read(b) : undefined;
      let requestChatTitle = flags & (1 << 9) ? await Primitive.String.read(b) : undefined;
      let requestChatDate = flags & (1 << 9) ? await Primitive.Int.read(b) : undefined;
      return new Raw.PeerSettings({
        reportSpam: reportSpam,
        addContact: addContact,
        blockContact: blockContact,
        shareContact: shareContact,
        needContactsException: needContactsException,
        reportGeo: reportGeo,
        autoarchived: autoarchived,
        inviteMembers: inviteMembers,
        requestChatBroadcast: requestChatBroadcast,
        geoDistance: geoDistance,
        requestChatTitle: requestChatTitle,
        requestChatDate: requestChatDate,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.reportSpam ? 1 << 0 : 0;
      flags |= this.addContact ? 1 << 1 : 0;
      flags |= this.blockContact ? 1 << 2 : 0;
      flags |= this.shareContact ? 1 << 3 : 0;
      flags |= this.needContactsException ? 1 << 4 : 0;
      flags |= this.reportGeo ? 1 << 5 : 0;
      flags |= this.autoarchived ? 1 << 7 : 0;
      flags |= this.inviteMembers ? 1 << 8 : 0;
      flags |= this.requestChatBroadcast ? 1 << 10 : 0;
      flags |= this.geoDistance !== undefined ? 1 << 6 : 0;
      flags |= this.requestChatTitle !== undefined ? 1 << 9 : 0;
      flags |= this.requestChatDate !== undefined ? 1 << 9 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.geoDistance !== undefined) {
        b.write(Primitive.Int.write(this.geoDistance) as unknown as Buffer);
      }
      if (this.requestChatTitle !== undefined) {
        b.write(Primitive.String.write(this.requestChatTitle) as unknown as Buffer);
      }
      if (this.requestChatDate !== undefined) {
        b.write(Primitive.Int.write(this.requestChatDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WallPaper extends TLObject {
    id!: long;
    creator?: boolean;
    default?: boolean;
    pattern?: boolean;
    dark?: boolean;
    accessHash!: long;
    slug!: string;
    document!: Raw.TypeDocument;
    settings?: Raw.TypeWallPaperSettings;

    constructor(params: {
      id: long;
      creator?: boolean;
      default?: boolean;
      pattern?: boolean;
      dark?: boolean;
      accessHash: long;
      slug: string;
      document: Raw.TypeDocument;
      settings?: Raw.TypeWallPaperSettings;
    }) {
      super();
      this.classType = 'types';
      this.className = 'WallPaper';
      this.constructorId = 0xa437c3ed;
      this.subclassOfId = 0x96a2c98b;
      this._slots = [
        'id',
        'creator',
        'default',
        'pattern',
        'dark',
        'accessHash',
        'slug',
        'document',
        'settings',
      ];
      this.id = params.id;
      this.creator = params.creator;
      this.default = params.default;
      this.pattern = params.pattern;
      this.dark = params.dark;
      this.accessHash = params.accessHash;
      this.slug = params.slug;
      this.document = params.document;
      this.settings = params.settings;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WallPaper> {
      // no flags

      let id = await Primitive.Long.read(b);
      let flags = await Primitive.Int.read(b);

      let creator = flags & (1 << 0) ? true : false;
      let _default = flags & (1 << 1) ? true : false;
      let pattern = flags & (1 << 3) ? true : false;
      let dark = flags & (1 << 4) ? true : false;
      let accessHash = await Primitive.Long.read(b);
      let slug = await Primitive.String.read(b);
      let document = await TLObject.read(b);
      let settings = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.WallPaper({
        id: id,
        creator: creator,
        default: _default,
        pattern: pattern,
        dark: dark,
        accessHash: accessHash,
        slug: slug,
        document: document,
        settings: settings,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      let flags = 0;
      flags |= this.creator ? 1 << 0 : 0;
      flags |= this.default ? 1 << 1 : 0;
      flags |= this.pattern ? 1 << 3 : 0;
      flags |= this.dark ? 1 << 4 : 0;
      flags |= this.settings !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.slug !== undefined) {
        b.write(Primitive.String.write(this.slug) as unknown as Buffer);
      }
      if (this.document !== undefined) {
        b.write(this.document.write() as unknown as Buffer);
      }
      if (this.settings !== undefined) {
        b.write(this.settings.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WallPaperNoFile extends TLObject {
    id!: long;
    default?: boolean;
    dark?: boolean;
    settings?: Raw.TypeWallPaperSettings;

    constructor(params: {
      id: long;
      default?: boolean;
      dark?: boolean;
      settings?: Raw.TypeWallPaperSettings;
    }) {
      super();
      this.classType = 'types';
      this.className = 'WallPaperNoFile';
      this.constructorId = 0xe0804116;
      this.subclassOfId = 0x96a2c98b;
      this._slots = ['id', 'default', 'dark', 'settings'];
      this.id = params.id;
      this.default = params.default;
      this.dark = params.dark;
      this.settings = params.settings;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WallPaperNoFile> {
      // no flags

      let id = await Primitive.Long.read(b);
      let flags = await Primitive.Int.read(b);

      let _default = flags & (1 << 1) ? true : false;
      let dark = flags & (1 << 4) ? true : false;
      let settings = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.WallPaperNoFile({ id: id, default: _default, dark: dark, settings: settings });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      let flags = 0;
      flags |= this.default ? 1 << 1 : 0;
      flags |= this.dark ? 1 << 4 : 0;
      flags |= this.settings !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.settings !== undefined) {
        b.write(this.settings.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputReportReasonSpam extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputReportReasonSpam';
      this.constructorId = 0x58dbcab8;
      this.subclassOfId = 0x8401bd27;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputReportReasonSpam> {
      // no flags

      return new Raw.InputReportReasonSpam();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputReportReasonViolence extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputReportReasonViolence';
      this.constructorId = 0x1e22c78d;
      this.subclassOfId = 0x8401bd27;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputReportReasonViolence> {
      // no flags

      return new Raw.InputReportReasonViolence();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputReportReasonPornography extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputReportReasonPornography';
      this.constructorId = 0x2e59d922;
      this.subclassOfId = 0x8401bd27;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputReportReasonPornography> {
      // no flags

      return new Raw.InputReportReasonPornography();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputReportReasonChildAbuse extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputReportReasonChildAbuse';
      this.constructorId = 0xadf44ee3;
      this.subclassOfId = 0x8401bd27;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputReportReasonChildAbuse> {
      // no flags

      return new Raw.InputReportReasonChildAbuse();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputReportReasonOther extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputReportReasonOther';
      this.constructorId = 0xc1e4a2b1;
      this.subclassOfId = 0x8401bd27;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputReportReasonOther> {
      // no flags

      return new Raw.InputReportReasonOther();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputReportReasonCopyright extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputReportReasonCopyright';
      this.constructorId = 0x9b89f93a;
      this.subclassOfId = 0x8401bd27;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputReportReasonCopyright> {
      // no flags

      return new Raw.InputReportReasonCopyright();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputReportReasonGeoIrrelevant extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputReportReasonGeoIrrelevant';
      this.constructorId = 0xdbd4feed;
      this.subclassOfId = 0x8401bd27;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputReportReasonGeoIrrelevant> {
      // no flags

      return new Raw.InputReportReasonGeoIrrelevant();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputReportReasonFake extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputReportReasonFake';
      this.constructorId = 0xf5ddd6e7;
      this.subclassOfId = 0x8401bd27;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputReportReasonFake> {
      // no flags

      return new Raw.InputReportReasonFake();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputReportReasonIllegalDrugs extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputReportReasonIllegalDrugs';
      this.constructorId = 0xa8eb2be;
      this.subclassOfId = 0x8401bd27;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputReportReasonIllegalDrugs> {
      // no flags

      return new Raw.InputReportReasonIllegalDrugs();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputReportReasonPersonalDetails extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputReportReasonPersonalDetails';
      this.constructorId = 0x9ec7863d;
      this.subclassOfId = 0x8401bd27;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputReportReasonPersonalDetails> {
      // no flags

      return new Raw.InputReportReasonPersonalDetails();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UserFull extends TLObject {
    blocked?: boolean;
    phoneCallsAvailable?: boolean;
    phoneCallsPrivate?: boolean;
    canPinMessage?: boolean;
    hasScheduled?: boolean;
    videoCallsAvailable?: boolean;
    voiceMessagesForbidden?: boolean;
    translationsDisabled?: boolean;
    storiesPinnedAvailable?: boolean;
    blockedMyStoriesFrom?: boolean;
    id!: long;
    about?: string;
    settings!: Raw.TypePeerSettings;
    personalPhoto?: Raw.TypePhoto;
    profilePhoto?: Raw.TypePhoto;
    fallbackPhoto?: Raw.TypePhoto;
    notifySettings!: Raw.TypePeerNotifySettings;
    botInfo?: Raw.TypeBotInfo;
    pinnedMsgId?: int;
    commonChatsCount!: int;
    folderId?: int;
    ttlPeriod?: int;
    themeEmoticon?: string;
    privateForwardName?: string;
    botGroupAdminRights?: Raw.TypeChatAdminRights;
    botBroadcastAdminRights?: Raw.TypeChatAdminRights;
    premiumGifts?: Vector<Raw.TypePremiumGiftOption>;
    wallpaper?: Raw.TypeWallPaper;
    stories?: Raw.TypePeerStories;

    constructor(params: {
      blocked?: boolean;
      phoneCallsAvailable?: boolean;
      phoneCallsPrivate?: boolean;
      canPinMessage?: boolean;
      hasScheduled?: boolean;
      videoCallsAvailable?: boolean;
      voiceMessagesForbidden?: boolean;
      translationsDisabled?: boolean;
      storiesPinnedAvailable?: boolean;
      blockedMyStoriesFrom?: boolean;
      id: long;
      about?: string;
      settings: Raw.TypePeerSettings;
      personalPhoto?: Raw.TypePhoto;
      profilePhoto?: Raw.TypePhoto;
      fallbackPhoto?: Raw.TypePhoto;
      notifySettings: Raw.TypePeerNotifySettings;
      botInfo?: Raw.TypeBotInfo;
      pinnedMsgId?: int;
      commonChatsCount: int;
      folderId?: int;
      ttlPeriod?: int;
      themeEmoticon?: string;
      privateForwardName?: string;
      botGroupAdminRights?: Raw.TypeChatAdminRights;
      botBroadcastAdminRights?: Raw.TypeChatAdminRights;
      premiumGifts?: Vector<Raw.TypePremiumGiftOption>;
      wallpaper?: Raw.TypeWallPaper;
      stories?: Raw.TypePeerStories;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UserFull';
      this.constructorId = 0xb9b12c6c;
      this.subclassOfId = 0x1f4661b9;
      this._slots = [
        'blocked',
        'phoneCallsAvailable',
        'phoneCallsPrivate',
        'canPinMessage',
        'hasScheduled',
        'videoCallsAvailable',
        'voiceMessagesForbidden',
        'translationsDisabled',
        'storiesPinnedAvailable',
        'blockedMyStoriesFrom',
        'id',
        'about',
        'settings',
        'personalPhoto',
        'profilePhoto',
        'fallbackPhoto',
        'notifySettings',
        'botInfo',
        'pinnedMsgId',
        'commonChatsCount',
        'folderId',
        'ttlPeriod',
        'themeEmoticon',
        'privateForwardName',
        'botGroupAdminRights',
        'botBroadcastAdminRights',
        'premiumGifts',
        'wallpaper',
        'stories',
      ];
      this.blocked = params.blocked;
      this.phoneCallsAvailable = params.phoneCallsAvailable;
      this.phoneCallsPrivate = params.phoneCallsPrivate;
      this.canPinMessage = params.canPinMessage;
      this.hasScheduled = params.hasScheduled;
      this.videoCallsAvailable = params.videoCallsAvailable;
      this.voiceMessagesForbidden = params.voiceMessagesForbidden;
      this.translationsDisabled = params.translationsDisabled;
      this.storiesPinnedAvailable = params.storiesPinnedAvailable;
      this.blockedMyStoriesFrom = params.blockedMyStoriesFrom;
      this.id = params.id;
      this.about = params.about;
      this.settings = params.settings;
      this.personalPhoto = params.personalPhoto;
      this.profilePhoto = params.profilePhoto;
      this.fallbackPhoto = params.fallbackPhoto;
      this.notifySettings = params.notifySettings;
      this.botInfo = params.botInfo;
      this.pinnedMsgId = params.pinnedMsgId;
      this.commonChatsCount = params.commonChatsCount;
      this.folderId = params.folderId;
      this.ttlPeriod = params.ttlPeriod;
      this.themeEmoticon = params.themeEmoticon;
      this.privateForwardName = params.privateForwardName;
      this.botGroupAdminRights = params.botGroupAdminRights;
      this.botBroadcastAdminRights = params.botBroadcastAdminRights;
      this.premiumGifts = params.premiumGifts;
      this.wallpaper = params.wallpaper;
      this.stories = params.stories;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UserFull> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let blocked = flags & (1 << 0) ? true : false;
      let phoneCallsAvailable = flags & (1 << 4) ? true : false;
      let phoneCallsPrivate = flags & (1 << 5) ? true : false;
      let canPinMessage = flags & (1 << 7) ? true : false;
      let hasScheduled = flags & (1 << 12) ? true : false;
      let videoCallsAvailable = flags & (1 << 13) ? true : false;
      let voiceMessagesForbidden = flags & (1 << 20) ? true : false;
      let translationsDisabled = flags & (1 << 23) ? true : false;
      let storiesPinnedAvailable = flags & (1 << 26) ? true : false;
      let blockedMyStoriesFrom = flags & (1 << 27) ? true : false;
      let id = await Primitive.Long.read(b);
      let about = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let settings = await TLObject.read(b);
      let personalPhoto = flags & (1 << 21) ? await TLObject.read(b) : undefined;
      let profilePhoto = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      let fallbackPhoto = flags & (1 << 22) ? await TLObject.read(b) : undefined;
      let notifySettings = await TLObject.read(b);
      let botInfo = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      let pinnedMsgId = flags & (1 << 6) ? await Primitive.Int.read(b) : undefined;
      let commonChatsCount = await Primitive.Int.read(b);
      let folderId = flags & (1 << 11) ? await Primitive.Int.read(b) : undefined;
      let ttlPeriod = flags & (1 << 14) ? await Primitive.Int.read(b) : undefined;
      let themeEmoticon = flags & (1 << 15) ? await Primitive.String.read(b) : undefined;
      let privateForwardName = flags & (1 << 16) ? await Primitive.String.read(b) : undefined;
      let botGroupAdminRights = flags & (1 << 17) ? await TLObject.read(b) : undefined;
      let botBroadcastAdminRights = flags & (1 << 18) ? await TLObject.read(b) : undefined;
      let premiumGifts = flags & (1 << 19) ? await TLObject.read(b) : [];
      let wallpaper = flags & (1 << 24) ? await TLObject.read(b) : undefined;
      let stories = flags & (1 << 25) ? await TLObject.read(b) : undefined;
      return new Raw.UserFull({
        blocked: blocked,
        phoneCallsAvailable: phoneCallsAvailable,
        phoneCallsPrivate: phoneCallsPrivate,
        canPinMessage: canPinMessage,
        hasScheduled: hasScheduled,
        videoCallsAvailable: videoCallsAvailable,
        voiceMessagesForbidden: voiceMessagesForbidden,
        translationsDisabled: translationsDisabled,
        storiesPinnedAvailable: storiesPinnedAvailable,
        blockedMyStoriesFrom: blockedMyStoriesFrom,
        id: id,
        about: about,
        settings: settings,
        personalPhoto: personalPhoto,
        profilePhoto: profilePhoto,
        fallbackPhoto: fallbackPhoto,
        notifySettings: notifySettings,
        botInfo: botInfo,
        pinnedMsgId: pinnedMsgId,
        commonChatsCount: commonChatsCount,
        folderId: folderId,
        ttlPeriod: ttlPeriod,
        themeEmoticon: themeEmoticon,
        privateForwardName: privateForwardName,
        botGroupAdminRights: botGroupAdminRights,
        botBroadcastAdminRights: botBroadcastAdminRights,
        premiumGifts: premiumGifts,
        wallpaper: wallpaper,
        stories: stories,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.blocked ? 1 << 0 : 0;
      flags |= this.phoneCallsAvailable ? 1 << 4 : 0;
      flags |= this.phoneCallsPrivate ? 1 << 5 : 0;
      flags |= this.canPinMessage ? 1 << 7 : 0;
      flags |= this.hasScheduled ? 1 << 12 : 0;
      flags |= this.videoCallsAvailable ? 1 << 13 : 0;
      flags |= this.voiceMessagesForbidden ? 1 << 20 : 0;
      flags |= this.translationsDisabled ? 1 << 23 : 0;
      flags |= this.storiesPinnedAvailable ? 1 << 26 : 0;
      flags |= this.blockedMyStoriesFrom ? 1 << 27 : 0;
      flags |= this.about !== undefined ? 1 << 1 : 0;
      flags |= this.personalPhoto !== undefined ? 1 << 21 : 0;
      flags |= this.profilePhoto !== undefined ? 1 << 2 : 0;
      flags |= this.fallbackPhoto !== undefined ? 1 << 22 : 0;
      flags |= this.botInfo !== undefined ? 1 << 3 : 0;
      flags |= this.pinnedMsgId !== undefined ? 1 << 6 : 0;
      flags |= this.folderId !== undefined ? 1 << 11 : 0;
      flags |= this.ttlPeriod !== undefined ? 1 << 14 : 0;
      flags |= this.themeEmoticon !== undefined ? 1 << 15 : 0;
      flags |= this.privateForwardName !== undefined ? 1 << 16 : 0;
      flags |= this.botGroupAdminRights !== undefined ? 1 << 17 : 0;
      flags |= this.botBroadcastAdminRights !== undefined ? 1 << 18 : 0;
      flags |= this.premiumGifts ? 1 << 19 : 0;
      flags |= this.wallpaper !== undefined ? 1 << 24 : 0;
      flags |= this.stories !== undefined ? 1 << 25 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.about !== undefined) {
        b.write(Primitive.String.write(this.about) as unknown as Buffer);
      }
      if (this.settings !== undefined) {
        b.write(this.settings.write() as unknown as Buffer);
      }
      if (this.personalPhoto !== undefined) {
        b.write(this.personalPhoto.write() as unknown as Buffer);
      }
      if (this.profilePhoto !== undefined) {
        b.write(this.profilePhoto.write() as unknown as Buffer);
      }
      if (this.fallbackPhoto !== undefined) {
        b.write(this.fallbackPhoto.write() as unknown as Buffer);
      }
      if (this.notifySettings !== undefined) {
        b.write(this.notifySettings.write() as unknown as Buffer);
      }
      if (this.botInfo !== undefined) {
        b.write(this.botInfo.write() as unknown as Buffer);
      }
      if (this.pinnedMsgId !== undefined) {
        b.write(Primitive.Int.write(this.pinnedMsgId) as unknown as Buffer);
      }
      if (this.commonChatsCount !== undefined) {
        b.write(Primitive.Int.write(this.commonChatsCount) as unknown as Buffer);
      }
      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      if (this.ttlPeriod !== undefined) {
        b.write(Primitive.Int.write(this.ttlPeriod) as unknown as Buffer);
      }
      if (this.themeEmoticon !== undefined) {
        b.write(Primitive.String.write(this.themeEmoticon) as unknown as Buffer);
      }
      if (this.privateForwardName !== undefined) {
        b.write(Primitive.String.write(this.privateForwardName) as unknown as Buffer);
      }
      if (this.botGroupAdminRights !== undefined) {
        b.write(this.botGroupAdminRights.write() as unknown as Buffer);
      }
      if (this.botBroadcastAdminRights !== undefined) {
        b.write(this.botBroadcastAdminRights.write() as unknown as Buffer);
      }
      if (this.premiumGifts) {
        b.write(Primitive.Vector.write(this.premiumGifts) as unknown as Buffer);
      }
      if (this.wallpaper !== undefined) {
        b.write(this.wallpaper.write() as unknown as Buffer);
      }
      if (this.stories !== undefined) {
        b.write(this.stories.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Contact extends TLObject {
    userId!: long;
    mutual!: Bool;

    constructor(params: { userId: long; mutual: Bool }) {
      super();
      this.classType = 'types';
      this.className = 'Contact';
      this.constructorId = 0x145ade0b;
      this.subclassOfId = 0x83dfdfa4;
      this._slots = ['userId', 'mutual'];
      this.userId = params.userId;
      this.mutual = params.mutual;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Contact> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let mutual = await Primitive.Bool.read(b);
      return new Raw.Contact({ userId: userId, mutual: mutual });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.mutual !== undefined) {
        b.write(Primitive.Bool.write(this.mutual) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ImportedContact extends TLObject {
    userId!: long;
    clientId!: long;

    constructor(params: { userId: long; clientId: long }) {
      super();
      this.classType = 'types';
      this.className = 'ImportedContact';
      this.constructorId = 0xc13e3c50;
      this.subclassOfId = 0xb545bbda;
      this._slots = ['userId', 'clientId'];
      this.userId = params.userId;
      this.clientId = params.clientId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ImportedContact> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let clientId = await Primitive.Long.read(b);
      return new Raw.ImportedContact({ userId: userId, clientId: clientId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.clientId !== undefined) {
        b.write(Primitive.Long.write(this.clientId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ContactStatus extends TLObject {
    userId!: long;
    status!: Raw.TypeUserStatus;

    constructor(params: { userId: long; status: Raw.TypeUserStatus }) {
      super();
      this.classType = 'types';
      this.className = 'ContactStatus';
      this.constructorId = 0x16d9703b;
      this.subclassOfId = 0x68c0d74c;
      this._slots = ['userId', 'status'];
      this.userId = params.userId;
      this.status = params.status;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ContactStatus> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let status = await TLObject.read(b);
      return new Raw.ContactStatus({ userId: userId, status: status });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.status !== undefined) {
        b.write(this.status.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMessagesFilterEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterEmpty';
      this.constructorId = 0x57e2f66c;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterEmpty> {
      // no flags

      return new Raw.InputMessagesFilterEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterPhotos extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterPhotos';
      this.constructorId = 0x9609a51c;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterPhotos> {
      // no flags

      return new Raw.InputMessagesFilterPhotos();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterVideo extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterVideo';
      this.constructorId = 0x9fc00e65;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterVideo> {
      // no flags

      return new Raw.InputMessagesFilterVideo();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterPhotoVideo extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterPhotoVideo';
      this.constructorId = 0x56e9f0e4;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterPhotoVideo> {
      // no flags

      return new Raw.InputMessagesFilterPhotoVideo();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterDocument extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterDocument';
      this.constructorId = 0x9eddf188;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterDocument> {
      // no flags

      return new Raw.InputMessagesFilterDocument();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterUrl extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterUrl';
      this.constructorId = 0x7ef0dd87;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterUrl> {
      // no flags

      return new Raw.InputMessagesFilterUrl();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterGif extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterGif';
      this.constructorId = 0xffc86587;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterGif> {
      // no flags

      return new Raw.InputMessagesFilterGif();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterVoice extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterVoice';
      this.constructorId = 0x50f5c392;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterVoice> {
      // no flags

      return new Raw.InputMessagesFilterVoice();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterMusic extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterMusic';
      this.constructorId = 0x3751b49e;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterMusic> {
      // no flags

      return new Raw.InputMessagesFilterMusic();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterChatPhotos extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterChatPhotos';
      this.constructorId = 0x3a20ecb8;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterChatPhotos> {
      // no flags

      return new Raw.InputMessagesFilterChatPhotos();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterPhoneCalls extends TLObject {
    missed?: boolean;

    constructor(params: { missed?: boolean }) {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterPhoneCalls';
      this.constructorId = 0x80c99768;
      this.subclassOfId = 0x8a36ec14;
      this._slots = ['missed'];
      this.missed = params.missed;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterPhoneCalls> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let missed = flags & (1 << 0) ? true : false;
      return new Raw.InputMessagesFilterPhoneCalls({ missed: missed });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.missed ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      return b.buffer;
    }
  }
  export class InputMessagesFilterRoundVoice extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterRoundVoice';
      this.constructorId = 0x7a7c17a4;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterRoundVoice> {
      // no flags

      return new Raw.InputMessagesFilterRoundVoice();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterRoundVideo extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterRoundVideo';
      this.constructorId = 0xb549da53;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterRoundVideo> {
      // no flags

      return new Raw.InputMessagesFilterRoundVideo();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterMyMentions extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterMyMentions';
      this.constructorId = 0xc1f8e69a;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterMyMentions> {
      // no flags

      return new Raw.InputMessagesFilterMyMentions();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterGeo extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterGeo';
      this.constructorId = 0xe7026d0d;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterGeo> {
      // no flags

      return new Raw.InputMessagesFilterGeo();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterContacts extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterContacts';
      this.constructorId = 0xe062db83;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterContacts> {
      // no flags

      return new Raw.InputMessagesFilterContacts();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessagesFilterPinned extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagesFilterPinned';
      this.constructorId = 0x1bb00451;
      this.subclassOfId = 0x8a36ec14;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagesFilterPinned> {
      // no flags

      return new Raw.InputMessagesFilterPinned();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateNewMessage extends TLObject {
    message!: Raw.TypeMessage;
    pts!: int;
    ptsCount!: int;

    constructor(params: { message: Raw.TypeMessage; pts: int; ptsCount: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateNewMessage';
      this.constructorId = 0x1f2b0afd;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['message', 'pts', 'ptsCount'];
      this.message = params.message;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateNewMessage> {
      // no flags

      let message = await TLObject.read(b);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdateNewMessage({ message: message, pts: pts, ptsCount: ptsCount });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.message !== undefined) {
        b.write(this.message.write() as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateMessageID extends TLObject {
    id!: int;
    randomId!: long;

    constructor(params: { id: int; randomId: long }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateMessageID';
      this.constructorId = 0x4e90bfd6;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['id', 'randomId'];
      this.id = params.id;
      this.randomId = params.randomId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateMessageID> {
      // no flags

      let id = await Primitive.Int.read(b);
      let randomId = await Primitive.Long.read(b);
      return new Raw.UpdateMessageID({ id: id, randomId: randomId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.randomId !== undefined) {
        b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateDeleteMessages extends TLObject {
    messages!: Vector<int>;
    pts!: int;
    ptsCount!: int;

    constructor(params: { messages: Vector<int>; pts: int; ptsCount: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateDeleteMessages';
      this.constructorId = 0xa20db0e5;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['messages', 'pts', 'ptsCount'];
      this.messages = params.messages;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateDeleteMessages> {
      // no flags

      let messages = await TLObject.read(b, Primitive.Int);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdateDeleteMessages({ messages: messages, pts: pts, ptsCount: ptsCount });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.messages) {
        b.write(Primitive.Vector.write(this.messages, Primitive.Int) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateUserTyping extends TLObject {
    userId!: long;
    action!: Raw.TypeSendMessageAction;

    constructor(params: { userId: long; action: Raw.TypeSendMessageAction }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateUserTyping';
      this.constructorId = 0xc01e857f;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['userId', 'action'];
      this.userId = params.userId;
      this.action = params.action;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateUserTyping> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let action = await TLObject.read(b);
      return new Raw.UpdateUserTyping({ userId: userId, action: action });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.action !== undefined) {
        b.write(this.action.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChatUserTyping extends TLObject {
    chatId!: long;
    fromId!: Raw.TypePeer;
    action!: Raw.TypeSendMessageAction;

    constructor(params: { chatId: long; fromId: Raw.TypePeer; action: Raw.TypeSendMessageAction }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChatUserTyping';
      this.constructorId = 0x83487af0;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['chatId', 'fromId', 'action'];
      this.chatId = params.chatId;
      this.fromId = params.fromId;
      this.action = params.action;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChatUserTyping> {
      // no flags

      let chatId = await Primitive.Long.read(b);
      let fromId = await TLObject.read(b);
      let action = await TLObject.read(b);
      return new Raw.UpdateChatUserTyping({ chatId: chatId, fromId: fromId, action: action });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      if (this.fromId !== undefined) {
        b.write(this.fromId.write() as unknown as Buffer);
      }
      if (this.action !== undefined) {
        b.write(this.action.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChatParticipants extends TLObject {
    participants!: Raw.TypeChatParticipants;

    constructor(params: { participants: Raw.TypeChatParticipants }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChatParticipants';
      this.constructorId = 0x7761198;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['participants'];
      this.participants = params.participants;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChatParticipants> {
      // no flags

      let participants = await TLObject.read(b);
      return new Raw.UpdateChatParticipants({ participants: participants });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.participants !== undefined) {
        b.write(this.participants.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateUserStatus extends TLObject {
    userId!: long;
    status!: Raw.TypeUserStatus;

    constructor(params: { userId: long; status: Raw.TypeUserStatus }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateUserStatus';
      this.constructorId = 0xe5bdf8de;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['userId', 'status'];
      this.userId = params.userId;
      this.status = params.status;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateUserStatus> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let status = await TLObject.read(b);
      return new Raw.UpdateUserStatus({ userId: userId, status: status });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.status !== undefined) {
        b.write(this.status.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateUserName extends TLObject {
    userId!: long;
    firstName!: string;
    lastName!: string;
    usernames!: Vector<Raw.TypeUsername>;

    constructor(params: {
      userId: long;
      firstName: string;
      lastName: string;
      usernames: Vector<Raw.TypeUsername>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateUserName';
      this.constructorId = 0xa7848924;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['userId', 'firstName', 'lastName', 'usernames'];
      this.userId = params.userId;
      this.firstName = params.firstName;
      this.lastName = params.lastName;
      this.usernames = params.usernames;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateUserName> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let firstName = await Primitive.String.read(b);
      let lastName = await Primitive.String.read(b);
      let usernames = await TLObject.read(b);
      return new Raw.UpdateUserName({
        userId: userId,
        firstName: firstName,
        lastName: lastName,
        usernames: usernames,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.firstName !== undefined) {
        b.write(Primitive.String.write(this.firstName) as unknown as Buffer);
      }
      if (this.lastName !== undefined) {
        b.write(Primitive.String.write(this.lastName) as unknown as Buffer);
      }
      if (this.usernames) {
        b.write(Primitive.Vector.write(this.usernames) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateNewAuthorization extends TLObject {
    unconfirmed?: boolean;
    hash!: long;
    date?: int;
    device?: string;
    location?: string;

    constructor(params: {
      unconfirmed?: boolean;
      hash: long;
      date?: int;
      device?: string;
      location?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateNewAuthorization';
      this.constructorId = 0x8951abef;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['unconfirmed', 'hash', 'date', 'device', 'location'];
      this.unconfirmed = params.unconfirmed;
      this.hash = params.hash;
      this.date = params.date;
      this.device = params.device;
      this.location = params.location;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateNewAuthorization> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let unconfirmed = flags & (1 << 0) ? true : false;
      let hash = await Primitive.Long.read(b);
      let date = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let device = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let location = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      return new Raw.UpdateNewAuthorization({
        unconfirmed: unconfirmed,
        hash: hash,
        date: date,
        device: device,
        location: location,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.unconfirmed ? 1 << 0 : 0;
      flags |= this.date !== undefined ? 1 << 0 : 0;
      flags |= this.device !== undefined ? 1 << 0 : 0;
      flags |= this.location !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.hash !== undefined) {
        b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.device !== undefined) {
        b.write(Primitive.String.write(this.device) as unknown as Buffer);
      }
      if (this.location !== undefined) {
        b.write(Primitive.String.write(this.location) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateNewEncryptedMessage extends TLObject {
    message!: Raw.TypeEncryptedMessage;
    qts!: int;

    constructor(params: { message: Raw.TypeEncryptedMessage; qts: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateNewEncryptedMessage';
      this.constructorId = 0x12bcbd9a;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['message', 'qts'];
      this.message = params.message;
      this.qts = params.qts;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateNewEncryptedMessage> {
      // no flags

      let message = await TLObject.read(b);
      let qts = await Primitive.Int.read(b);
      return new Raw.UpdateNewEncryptedMessage({ message: message, qts: qts });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.message !== undefined) {
        b.write(this.message.write() as unknown as Buffer);
      }
      if (this.qts !== undefined) {
        b.write(Primitive.Int.write(this.qts) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateEncryptedChatTyping extends TLObject {
    chatId!: int;

    constructor(params: { chatId: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateEncryptedChatTyping';
      this.constructorId = 0x1710f156;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['chatId'];
      this.chatId = params.chatId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateEncryptedChatTyping> {
      // no flags

      let chatId = await Primitive.Int.read(b);
      return new Raw.UpdateEncryptedChatTyping({ chatId: chatId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chatId !== undefined) {
        b.write(Primitive.Int.write(this.chatId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateEncryption extends TLObject {
    chat!: Raw.TypeEncryptedChat;
    date!: int;

    constructor(params: { chat: Raw.TypeEncryptedChat; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateEncryption';
      this.constructorId = 0xb4a2e88d;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['chat', 'date'];
      this.chat = params.chat;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateEncryption> {
      // no flags

      let chat = await TLObject.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.UpdateEncryption({ chat: chat, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chat !== undefined) {
        b.write(this.chat.write() as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateEncryptedMessagesRead extends TLObject {
    chatId!: int;
    maxDate!: int;
    date!: int;

    constructor(params: { chatId: int; maxDate: int; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateEncryptedMessagesRead';
      this.constructorId = 0x38fe25b7;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['chatId', 'maxDate', 'date'];
      this.chatId = params.chatId;
      this.maxDate = params.maxDate;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateEncryptedMessagesRead> {
      // no flags

      let chatId = await Primitive.Int.read(b);
      let maxDate = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.UpdateEncryptedMessagesRead({ chatId: chatId, maxDate: maxDate, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chatId !== undefined) {
        b.write(Primitive.Int.write(this.chatId) as unknown as Buffer);
      }
      if (this.maxDate !== undefined) {
        b.write(Primitive.Int.write(this.maxDate) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChatParticipantAdd extends TLObject {
    chatId!: long;
    userId!: long;
    inviterId!: long;
    date!: int;
    version!: int;

    constructor(params: { chatId: long; userId: long; inviterId: long; date: int; version: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChatParticipantAdd';
      this.constructorId = 0x3dda5451;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['chatId', 'userId', 'inviterId', 'date', 'version'];
      this.chatId = params.chatId;
      this.userId = params.userId;
      this.inviterId = params.inviterId;
      this.date = params.date;
      this.version = params.version;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChatParticipantAdd> {
      // no flags

      let chatId = await Primitive.Long.read(b);
      let userId = await Primitive.Long.read(b);
      let inviterId = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let version = await Primitive.Int.read(b);
      return new Raw.UpdateChatParticipantAdd({
        chatId: chatId,
        userId: userId,
        inviterId: inviterId,
        date: date,
        version: version,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.inviterId !== undefined) {
        b.write(Primitive.Long.write(this.inviterId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.version !== undefined) {
        b.write(Primitive.Int.write(this.version) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChatParticipantDelete extends TLObject {
    chatId!: long;
    userId!: long;
    version!: int;

    constructor(params: { chatId: long; userId: long; version: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChatParticipantDelete';
      this.constructorId = 0xe32f3d77;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['chatId', 'userId', 'version'];
      this.chatId = params.chatId;
      this.userId = params.userId;
      this.version = params.version;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChatParticipantDelete> {
      // no flags

      let chatId = await Primitive.Long.read(b);
      let userId = await Primitive.Long.read(b);
      let version = await Primitive.Int.read(b);
      return new Raw.UpdateChatParticipantDelete({
        chatId: chatId,
        userId: userId,
        version: version,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.version !== undefined) {
        b.write(Primitive.Int.write(this.version) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateDcOptions extends TLObject {
    dcOptions!: Vector<Raw.TypeDcOption>;

    constructor(params: { dcOptions: Vector<Raw.TypeDcOption> }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateDcOptions';
      this.constructorId = 0x8e5e9873;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['dcOptions'];
      this.dcOptions = params.dcOptions;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateDcOptions> {
      // no flags

      let dcOptions = await TLObject.read(b);
      return new Raw.UpdateDcOptions({ dcOptions: dcOptions });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.dcOptions) {
        b.write(Primitive.Vector.write(this.dcOptions) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateNotifySettings extends TLObject {
    peer!: Raw.TypeNotifyPeer;
    notifySettings!: Raw.TypePeerNotifySettings;

    constructor(params: { peer: Raw.TypeNotifyPeer; notifySettings: Raw.TypePeerNotifySettings }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateNotifySettings';
      this.constructorId = 0xbec268ef;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'notifySettings'];
      this.peer = params.peer;
      this.notifySettings = params.notifySettings;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateNotifySettings> {
      // no flags

      let peer = await TLObject.read(b);
      let notifySettings = await TLObject.read(b);
      return new Raw.UpdateNotifySettings({ peer: peer, notifySettings: notifySettings });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.notifySettings !== undefined) {
        b.write(this.notifySettings.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateServiceNotification extends TLObject {
    popup?: boolean;
    invertMedia?: boolean;
    inboxDate?: int;
    type!: string;
    message!: string;
    media!: Raw.TypeMessageMedia;
    entities!: Vector<Raw.TypeMessageEntity>;

    constructor(params: {
      popup?: boolean;
      invertMedia?: boolean;
      inboxDate?: int;
      type: string;
      message: string;
      media: Raw.TypeMessageMedia;
      entities: Vector<Raw.TypeMessageEntity>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateServiceNotification';
      this.constructorId = 0xebe46819;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['popup', 'invertMedia', 'inboxDate', 'type', 'message', 'media', 'entities'];
      this.popup = params.popup;
      this.invertMedia = params.invertMedia;
      this.inboxDate = params.inboxDate;
      this.type = params.type;
      this.message = params.message;
      this.media = params.media;
      this.entities = params.entities;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateServiceNotification> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let popup = flags & (1 << 0) ? true : false;
      let invertMedia = flags & (1 << 2) ? true : false;
      let inboxDate = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      let type = await Primitive.String.read(b);
      let message = await Primitive.String.read(b);
      let media = await TLObject.read(b);
      let entities = await TLObject.read(b);
      return new Raw.UpdateServiceNotification({
        popup: popup,
        invertMedia: invertMedia,
        inboxDate: inboxDate,
        type: type,
        message: message,
        media: media,
        entities: entities,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.popup ? 1 << 0 : 0;
      flags |= this.invertMedia ? 1 << 2 : 0;
      flags |= this.inboxDate !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.inboxDate !== undefined) {
        b.write(Primitive.Int.write(this.inboxDate) as unknown as Buffer);
      }
      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.media !== undefined) {
        b.write(this.media.write() as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdatePrivacy extends TLObject {
    key!: Raw.TypePrivacyKey;
    rules!: Vector<Raw.TypePrivacyRule>;

    constructor(params: { key: Raw.TypePrivacyKey; rules: Vector<Raw.TypePrivacyRule> }) {
      super();
      this.classType = 'types';
      this.className = 'UpdatePrivacy';
      this.constructorId = 0xee3b272a;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['key', 'rules'];
      this.key = params.key;
      this.rules = params.rules;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatePrivacy> {
      // no flags

      let key = await TLObject.read(b);
      let rules = await TLObject.read(b);
      return new Raw.UpdatePrivacy({ key: key, rules: rules });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.key !== undefined) {
        b.write(this.key.write() as unknown as Buffer);
      }
      if (this.rules) {
        b.write(Primitive.Vector.write(this.rules) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateUserPhone extends TLObject {
    userId!: long;
    phone!: string;

    constructor(params: { userId: long; phone: string }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateUserPhone';
      this.constructorId = 0x5492a13;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['userId', 'phone'];
      this.userId = params.userId;
      this.phone = params.phone;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateUserPhone> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let phone = await Primitive.String.read(b);
      return new Raw.UpdateUserPhone({ userId: userId, phone: phone });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.phone !== undefined) {
        b.write(Primitive.String.write(this.phone) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateReadHistoryInbox extends TLObject {
    folderId?: int;
    peer!: Raw.TypePeer;
    maxId!: int;
    stillUnreadCount!: int;
    pts!: int;
    ptsCount!: int;

    constructor(params: {
      folderId?: int;
      peer: Raw.TypePeer;
      maxId: int;
      stillUnreadCount: int;
      pts: int;
      ptsCount: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateReadHistoryInbox';
      this.constructorId = 0x9c974fdf;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['folderId', 'peer', 'maxId', 'stillUnreadCount', 'pts', 'ptsCount'];
      this.folderId = params.folderId;
      this.peer = params.peer;
      this.maxId = params.maxId;
      this.stillUnreadCount = params.stillUnreadCount;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateReadHistoryInbox> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let folderId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let peer = await TLObject.read(b);
      let maxId = await Primitive.Int.read(b);
      let stillUnreadCount = await Primitive.Int.read(b);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdateReadHistoryInbox({
        folderId: folderId,
        peer: peer,
        maxId: maxId,
        stillUnreadCount: stillUnreadCount,
        pts: pts,
        ptsCount: ptsCount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.folderId !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.maxId !== undefined) {
        b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
      }
      if (this.stillUnreadCount !== undefined) {
        b.write(Primitive.Int.write(this.stillUnreadCount) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateReadHistoryOutbox extends TLObject {
    peer!: Raw.TypePeer;
    maxId!: int;
    pts!: int;
    ptsCount!: int;

    constructor(params: { peer: Raw.TypePeer; maxId: int; pts: int; ptsCount: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateReadHistoryOutbox';
      this.constructorId = 0x2f2f21bf;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'maxId', 'pts', 'ptsCount'];
      this.peer = params.peer;
      this.maxId = params.maxId;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateReadHistoryOutbox> {
      // no flags

      let peer = await TLObject.read(b);
      let maxId = await Primitive.Int.read(b);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdateReadHistoryOutbox({
        peer: peer,
        maxId: maxId,
        pts: pts,
        ptsCount: ptsCount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.maxId !== undefined) {
        b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateWebPage extends TLObject {
    webpage!: Raw.TypeWebPage;
    pts!: int;
    ptsCount!: int;

    constructor(params: { webpage: Raw.TypeWebPage; pts: int; ptsCount: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateWebPage';
      this.constructorId = 0x7f891213;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['webpage', 'pts', 'ptsCount'];
      this.webpage = params.webpage;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateWebPage> {
      // no flags

      let webpage = await TLObject.read(b);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdateWebPage({ webpage: webpage, pts: pts, ptsCount: ptsCount });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.webpage !== undefined) {
        b.write(this.webpage.write() as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateReadMessagesContents extends TLObject {
    messages!: Vector<int>;
    pts!: int;
    ptsCount!: int;
    date?: int;

    constructor(params: { messages: Vector<int>; pts: int; ptsCount: int; date?: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateReadMessagesContents';
      this.constructorId = 0xf8227181;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['messages', 'pts', 'ptsCount', 'date'];
      this.messages = params.messages;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateReadMessagesContents> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let messages = await TLObject.read(b, Primitive.Int);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      let date = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.UpdateReadMessagesContents({
        messages: messages,
        pts: pts,
        ptsCount: ptsCount,
        date: date,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.date !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.messages) {
        b.write(Primitive.Vector.write(this.messages, Primitive.Int) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChannelTooLong extends TLObject {
    channelId!: long;
    pts?: int;

    constructor(params: { channelId: long; pts?: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChannelTooLong';
      this.constructorId = 0x108d941f;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId', 'pts'];
      this.channelId = params.channelId;
      this.pts = params.pts;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChannelTooLong> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let channelId = await Primitive.Long.read(b);
      let pts = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.UpdateChannelTooLong({ channelId: channelId, pts: pts });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.pts !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChannel extends TLObject {
    channelId!: long;

    constructor(params: { channelId: long }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChannel';
      this.constructorId = 0x635b4c09;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId'];
      this.channelId = params.channelId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChannel> {
      // no flags

      let channelId = await Primitive.Long.read(b);
      return new Raw.UpdateChannel({ channelId: channelId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateNewChannelMessage extends TLObject {
    message!: Raw.TypeMessage;
    pts!: int;
    ptsCount!: int;

    constructor(params: { message: Raw.TypeMessage; pts: int; ptsCount: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateNewChannelMessage';
      this.constructorId = 0x62ba04d9;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['message', 'pts', 'ptsCount'];
      this.message = params.message;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateNewChannelMessage> {
      // no flags

      let message = await TLObject.read(b);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdateNewChannelMessage({ message: message, pts: pts, ptsCount: ptsCount });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.message !== undefined) {
        b.write(this.message.write() as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateReadChannelInbox extends TLObject {
    folderId?: int;
    channelId!: long;
    maxId!: int;
    stillUnreadCount!: int;
    pts!: int;

    constructor(params: {
      folderId?: int;
      channelId: long;
      maxId: int;
      stillUnreadCount: int;
      pts: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateReadChannelInbox';
      this.constructorId = 0x922e6e10;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['folderId', 'channelId', 'maxId', 'stillUnreadCount', 'pts'];
      this.folderId = params.folderId;
      this.channelId = params.channelId;
      this.maxId = params.maxId;
      this.stillUnreadCount = params.stillUnreadCount;
      this.pts = params.pts;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateReadChannelInbox> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let folderId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let channelId = await Primitive.Long.read(b);
      let maxId = await Primitive.Int.read(b);
      let stillUnreadCount = await Primitive.Int.read(b);
      let pts = await Primitive.Int.read(b);
      return new Raw.UpdateReadChannelInbox({
        folderId: folderId,
        channelId: channelId,
        maxId: maxId,
        stillUnreadCount: stillUnreadCount,
        pts: pts,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.folderId !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.maxId !== undefined) {
        b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
      }
      if (this.stillUnreadCount !== undefined) {
        b.write(Primitive.Int.write(this.stillUnreadCount) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateDeleteChannelMessages extends TLObject {
    channelId!: long;
    messages!: Vector<int>;
    pts!: int;
    ptsCount!: int;

    constructor(params: { channelId: long; messages: Vector<int>; pts: int; ptsCount: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateDeleteChannelMessages';
      this.constructorId = 0xc32d5b12;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId', 'messages', 'pts', 'ptsCount'];
      this.channelId = params.channelId;
      this.messages = params.messages;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateDeleteChannelMessages> {
      // no flags

      let channelId = await Primitive.Long.read(b);
      let messages = await TLObject.read(b, Primitive.Int);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdateDeleteChannelMessages({
        channelId: channelId,
        messages: messages,
        pts: pts,
        ptsCount: ptsCount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.messages) {
        b.write(Primitive.Vector.write(this.messages, Primitive.Int) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChannelMessageViews extends TLObject {
    channelId!: long;
    id!: int;
    views!: int;

    constructor(params: { channelId: long; id: int; views: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChannelMessageViews';
      this.constructorId = 0xf226ac08;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId', 'id', 'views'];
      this.channelId = params.channelId;
      this.id = params.id;
      this.views = params.views;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChannelMessageViews> {
      // no flags

      let channelId = await Primitive.Long.read(b);
      let id = await Primitive.Int.read(b);
      let views = await Primitive.Int.read(b);
      return new Raw.UpdateChannelMessageViews({ channelId: channelId, id: id, views: views });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.views !== undefined) {
        b.write(Primitive.Int.write(this.views) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChatParticipantAdmin extends TLObject {
    chatId!: long;
    userId!: long;
    isAdmin!: Bool;
    version!: int;

    constructor(params: { chatId: long; userId: long; isAdmin: Bool; version: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChatParticipantAdmin';
      this.constructorId = 0xd7ca61a2;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['chatId', 'userId', 'isAdmin', 'version'];
      this.chatId = params.chatId;
      this.userId = params.userId;
      this.isAdmin = params.isAdmin;
      this.version = params.version;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChatParticipantAdmin> {
      // no flags

      let chatId = await Primitive.Long.read(b);
      let userId = await Primitive.Long.read(b);
      let isAdmin = await Primitive.Bool.read(b);
      let version = await Primitive.Int.read(b);
      return new Raw.UpdateChatParticipantAdmin({
        chatId: chatId,
        userId: userId,
        isAdmin: isAdmin,
        version: version,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.isAdmin !== undefined) {
        b.write(Primitive.Bool.write(this.isAdmin) as unknown as Buffer);
      }
      if (this.version !== undefined) {
        b.write(Primitive.Int.write(this.version) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateNewStickerSet extends TLObject {
    stickerset!: Raw.messages.TypeStickerSet;

    constructor(params: { stickerset: Raw.messages.TypeStickerSet }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateNewStickerSet';
      this.constructorId = 0x688a30aa;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['stickerset'];
      this.stickerset = params.stickerset;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateNewStickerSet> {
      // no flags

      let stickerset = await TLObject.read(b);
      return new Raw.UpdateNewStickerSet({ stickerset: stickerset });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.stickerset !== undefined) {
        b.write(this.stickerset.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateStickerSetsOrder extends TLObject {
    masks?: boolean;
    emojis?: boolean;
    order!: Vector<long>;

    constructor(params: { masks?: boolean; emojis?: boolean; order: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateStickerSetsOrder';
      this.constructorId = 0xbb2d201;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['masks', 'emojis', 'order'];
      this.masks = params.masks;
      this.emojis = params.emojis;
      this.order = params.order;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateStickerSetsOrder> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let masks = flags & (1 << 0) ? true : false;
      let emojis = flags & (1 << 1) ? true : false;
      let order = await TLObject.read(b, Primitive.Long);
      return new Raw.UpdateStickerSetsOrder({ masks: masks, emojis: emojis, order: order });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.masks ? 1 << 0 : 0;
      flags |= this.emojis ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.order) {
        b.write(Primitive.Vector.write(this.order, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateStickerSets extends TLObject {
    masks?: boolean;
    emojis?: boolean;

    constructor(params: { masks?: boolean; emojis?: boolean }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateStickerSets';
      this.constructorId = 0x31c24808;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['masks', 'emojis'];
      this.masks = params.masks;
      this.emojis = params.emojis;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateStickerSets> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let masks = flags & (1 << 0) ? true : false;
      let emojis = flags & (1 << 1) ? true : false;
      return new Raw.UpdateStickerSets({ masks: masks, emojis: emojis });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.masks ? 1 << 0 : 0;
      flags |= this.emojis ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      return b.buffer;
    }
  }
  export class UpdateSavedGifs extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateSavedGifs';
      this.constructorId = 0x9375341e;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateSavedGifs> {
      // no flags

      return new Raw.UpdateSavedGifs();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateBotInlineQuery extends TLObject {
    queryId!: long;
    userId!: long;
    query!: string;
    geo?: Raw.TypeGeoPoint;
    peerType?: Raw.TypeInlineQueryPeerType;
    offset!: string;

    constructor(params: {
      queryId: long;
      userId: long;
      query: string;
      geo?: Raw.TypeGeoPoint;
      peerType?: Raw.TypeInlineQueryPeerType;
      offset: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateBotInlineQuery';
      this.constructorId = 0x496f379c;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['queryId', 'userId', 'query', 'geo', 'peerType', 'offset'];
      this.queryId = params.queryId;
      this.userId = params.userId;
      this.query = params.query;
      this.geo = params.geo;
      this.peerType = params.peerType;
      this.offset = params.offset;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateBotInlineQuery> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let queryId = await Primitive.Long.read(b);
      let userId = await Primitive.Long.read(b);
      let query = await Primitive.String.read(b);
      let geo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let peerType = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let offset = await Primitive.String.read(b);
      return new Raw.UpdateBotInlineQuery({
        queryId: queryId,
        userId: userId,
        query: query,
        geo: geo,
        peerType: peerType,
        offset: offset,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.geo !== undefined ? 1 << 0 : 0;
      flags |= this.peerType !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.queryId !== undefined) {
        b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.query !== undefined) {
        b.write(Primitive.String.write(this.query) as unknown as Buffer);
      }
      if (this.geo !== undefined) {
        b.write(this.geo.write() as unknown as Buffer);
      }
      if (this.peerType !== undefined) {
        b.write(this.peerType.write() as unknown as Buffer);
      }
      if (this.offset !== undefined) {
        b.write(Primitive.String.write(this.offset) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateBotInlineSend extends TLObject {
    userId!: long;
    query!: string;
    geo?: Raw.TypeGeoPoint;
    id!: string;
    msgId?: Raw.TypeInputBotInlineMessageID;

    constructor(params: {
      userId: long;
      query: string;
      geo?: Raw.TypeGeoPoint;
      id: string;
      msgId?: Raw.TypeInputBotInlineMessageID;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateBotInlineSend';
      this.constructorId = 0x12f12a07;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['userId', 'query', 'geo', 'id', 'msgId'];
      this.userId = params.userId;
      this.query = params.query;
      this.geo = params.geo;
      this.id = params.id;
      this.msgId = params.msgId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateBotInlineSend> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let userId = await Primitive.Long.read(b);
      let query = await Primitive.String.read(b);
      let geo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let id = await Primitive.String.read(b);
      let msgId = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      return new Raw.UpdateBotInlineSend({
        userId: userId,
        query: query,
        geo: geo,
        id: id,
        msgId: msgId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.geo !== undefined ? 1 << 0 : 0;
      flags |= this.msgId !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.query !== undefined) {
        b.write(Primitive.String.write(this.query) as unknown as Buffer);
      }
      if (this.geo !== undefined) {
        b.write(this.geo.write() as unknown as Buffer);
      }
      if (this.id !== undefined) {
        b.write(Primitive.String.write(this.id) as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(this.msgId.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateEditChannelMessage extends TLObject {
    message!: Raw.TypeMessage;
    pts!: int;
    ptsCount!: int;

    constructor(params: { message: Raw.TypeMessage; pts: int; ptsCount: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateEditChannelMessage';
      this.constructorId = 0x1b3f4df7;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['message', 'pts', 'ptsCount'];
      this.message = params.message;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateEditChannelMessage> {
      // no flags

      let message = await TLObject.read(b);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdateEditChannelMessage({ message: message, pts: pts, ptsCount: ptsCount });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.message !== undefined) {
        b.write(this.message.write() as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateBotCallbackQuery extends TLObject {
    queryId!: long;
    userId!: long;
    peer!: Raw.TypePeer;
    msgId!: int;
    chatInstance!: long;
    data?: bytes;
    gameShortName?: string;

    constructor(params: {
      queryId: long;
      userId: long;
      peer: Raw.TypePeer;
      msgId: int;
      chatInstance: long;
      data?: bytes;
      gameShortName?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateBotCallbackQuery';
      this.constructorId = 0xb9cfc48d;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['queryId', 'userId', 'peer', 'msgId', 'chatInstance', 'data', 'gameShortName'];
      this.queryId = params.queryId;
      this.userId = params.userId;
      this.peer = params.peer;
      this.msgId = params.msgId;
      this.chatInstance = params.chatInstance;
      this.data = params.data;
      this.gameShortName = params.gameShortName;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateBotCallbackQuery> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let queryId = await Primitive.Long.read(b);
      let userId = await Primitive.Long.read(b);
      let peer = await TLObject.read(b);
      let msgId = await Primitive.Int.read(b);
      let chatInstance = await Primitive.Long.read(b);
      let data = flags & (1 << 0) ? await Primitive.Bytes.read(b) : undefined;
      let gameShortName = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      return new Raw.UpdateBotCallbackQuery({
        queryId: queryId,
        userId: userId,
        peer: peer,
        msgId: msgId,
        chatInstance: chatInstance,
        data: data,
        gameShortName: gameShortName,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.data !== undefined ? 1 << 0 : 0;
      flags |= this.gameShortName !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.queryId !== undefined) {
        b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      if (this.chatInstance !== undefined) {
        b.write(Primitive.Long.write(this.chatInstance) as unknown as Buffer);
      }
      if (this.data !== undefined) {
        b.write(Primitive.Bytes.write(this.data) as unknown as Buffer);
      }
      if (this.gameShortName !== undefined) {
        b.write(Primitive.String.write(this.gameShortName) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateEditMessage extends TLObject {
    message!: Raw.TypeMessage;
    pts!: int;
    ptsCount!: int;

    constructor(params: { message: Raw.TypeMessage; pts: int; ptsCount: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateEditMessage';
      this.constructorId = 0xe40370a3;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['message', 'pts', 'ptsCount'];
      this.message = params.message;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateEditMessage> {
      // no flags

      let message = await TLObject.read(b);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdateEditMessage({ message: message, pts: pts, ptsCount: ptsCount });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.message !== undefined) {
        b.write(this.message.write() as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateInlineBotCallbackQuery extends TLObject {
    queryId!: long;
    userId!: long;
    msgId!: Raw.TypeInputBotInlineMessageID;
    chatInstance!: long;
    data?: bytes;
    gameShortName?: string;

    constructor(params: {
      queryId: long;
      userId: long;
      msgId: Raw.TypeInputBotInlineMessageID;
      chatInstance: long;
      data?: bytes;
      gameShortName?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateInlineBotCallbackQuery';
      this.constructorId = 0x691e9052;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['queryId', 'userId', 'msgId', 'chatInstance', 'data', 'gameShortName'];
      this.queryId = params.queryId;
      this.userId = params.userId;
      this.msgId = params.msgId;
      this.chatInstance = params.chatInstance;
      this.data = params.data;
      this.gameShortName = params.gameShortName;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateInlineBotCallbackQuery> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let queryId = await Primitive.Long.read(b);
      let userId = await Primitive.Long.read(b);
      let msgId = await TLObject.read(b);
      let chatInstance = await Primitive.Long.read(b);
      let data = flags & (1 << 0) ? await Primitive.Bytes.read(b) : undefined;
      let gameShortName = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      return new Raw.UpdateInlineBotCallbackQuery({
        queryId: queryId,
        userId: userId,
        msgId: msgId,
        chatInstance: chatInstance,
        data: data,
        gameShortName: gameShortName,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.data !== undefined ? 1 << 0 : 0;
      flags |= this.gameShortName !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.queryId !== undefined) {
        b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(this.msgId.write() as unknown as Buffer);
      }
      if (this.chatInstance !== undefined) {
        b.write(Primitive.Long.write(this.chatInstance) as unknown as Buffer);
      }
      if (this.data !== undefined) {
        b.write(Primitive.Bytes.write(this.data) as unknown as Buffer);
      }
      if (this.gameShortName !== undefined) {
        b.write(Primitive.String.write(this.gameShortName) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateReadChannelOutbox extends TLObject {
    channelId!: long;
    maxId!: int;

    constructor(params: { channelId: long; maxId: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateReadChannelOutbox';
      this.constructorId = 0xb75f99a9;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId', 'maxId'];
      this.channelId = params.channelId;
      this.maxId = params.maxId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateReadChannelOutbox> {
      // no flags

      let channelId = await Primitive.Long.read(b);
      let maxId = await Primitive.Int.read(b);
      return new Raw.UpdateReadChannelOutbox({ channelId: channelId, maxId: maxId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.maxId !== undefined) {
        b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateDraftMessage extends TLObject {
    peer!: Raw.TypePeer;
    topMsgId?: int;
    draft!: Raw.TypeDraftMessage;

    constructor(params: { peer: Raw.TypePeer; topMsgId?: int; draft: Raw.TypeDraftMessage }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateDraftMessage';
      this.constructorId = 0x1b49ec6d;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'topMsgId', 'draft'];
      this.peer = params.peer;
      this.topMsgId = params.topMsgId;
      this.draft = params.draft;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateDraftMessage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let peer = await TLObject.read(b);
      let topMsgId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let draft = await TLObject.read(b);
      return new Raw.UpdateDraftMessage({ peer: peer, topMsgId: topMsgId, draft: draft });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.topMsgId !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.topMsgId !== undefined) {
        b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
      }
      if (this.draft !== undefined) {
        b.write(this.draft.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateReadFeaturedStickers extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateReadFeaturedStickers';
      this.constructorId = 0x571d2742;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateReadFeaturedStickers> {
      // no flags

      return new Raw.UpdateReadFeaturedStickers();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateRecentStickers extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateRecentStickers';
      this.constructorId = 0x9a422c20;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateRecentStickers> {
      // no flags

      return new Raw.UpdateRecentStickers();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateConfig extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateConfig';
      this.constructorId = 0xa229dd06;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateConfig> {
      // no flags

      return new Raw.UpdateConfig();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdatePtsChanged extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdatePtsChanged';
      this.constructorId = 0x3354678f;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatePtsChanged> {
      // no flags

      return new Raw.UpdatePtsChanged();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateChannelWebPage extends TLObject {
    channelId!: long;
    webpage!: Raw.TypeWebPage;
    pts!: int;
    ptsCount!: int;

    constructor(params: { channelId: long; webpage: Raw.TypeWebPage; pts: int; ptsCount: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChannelWebPage';
      this.constructorId = 0x2f2ba99f;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId', 'webpage', 'pts', 'ptsCount'];
      this.channelId = params.channelId;
      this.webpage = params.webpage;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChannelWebPage> {
      // no flags

      let channelId = await Primitive.Long.read(b);
      let webpage = await TLObject.read(b);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdateChannelWebPage({
        channelId: channelId,
        webpage: webpage,
        pts: pts,
        ptsCount: ptsCount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.webpage !== undefined) {
        b.write(this.webpage.write() as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateDialogPinned extends TLObject {
    pinned?: boolean;
    folderId?: int;
    peer!: Raw.TypeDialogPeer;

    constructor(params: { pinned?: boolean; folderId?: int; peer: Raw.TypeDialogPeer }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateDialogPinned';
      this.constructorId = 0x6e6fe51c;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['pinned', 'folderId', 'peer'];
      this.pinned = params.pinned;
      this.folderId = params.folderId;
      this.peer = params.peer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateDialogPinned> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let pinned = flags & (1 << 0) ? true : false;
      let folderId = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      let peer = await TLObject.read(b);
      return new Raw.UpdateDialogPinned({ pinned: pinned, folderId: folderId, peer: peer });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.pinned ? 1 << 0 : 0;
      flags |= this.folderId !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdatePinnedDialogs extends TLObject {
    folderId?: int;
    order?: Vector<Raw.TypeDialogPeer>;

    constructor(params: { folderId?: int; order?: Vector<Raw.TypeDialogPeer> }) {
      super();
      this.classType = 'types';
      this.className = 'UpdatePinnedDialogs';
      this.constructorId = 0xfa0f3ca2;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['folderId', 'order'];
      this.folderId = params.folderId;
      this.order = params.order;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatePinnedDialogs> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let folderId = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      let order = flags & (1 << 0) ? await TLObject.read(b) : [];
      return new Raw.UpdatePinnedDialogs({ folderId: folderId, order: order });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.folderId !== undefined ? 1 << 1 : 0;
      flags |= this.order ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      if (this.order) {
        b.write(Primitive.Vector.write(this.order) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateBotWebhookJSON extends TLObject {
    data!: Raw.TypeDataJSON;

    constructor(params: { data: Raw.TypeDataJSON }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateBotWebhookJSON';
      this.constructorId = 0x8317c0c3;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['data'];
      this.data = params.data;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateBotWebhookJSON> {
      // no flags

      let data = await TLObject.read(b);
      return new Raw.UpdateBotWebhookJSON({ data: data });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.data !== undefined) {
        b.write(this.data.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateBotWebhookJSONQuery extends TLObject {
    queryId!: long;
    data!: Raw.TypeDataJSON;
    timeout!: int;

    constructor(params: { queryId: long; data: Raw.TypeDataJSON; timeout: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateBotWebhookJSONQuery';
      this.constructorId = 0x9b9240a6;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['queryId', 'data', 'timeout'];
      this.queryId = params.queryId;
      this.data = params.data;
      this.timeout = params.timeout;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateBotWebhookJSONQuery> {
      // no flags

      let queryId = await Primitive.Long.read(b);
      let data = await TLObject.read(b);
      let timeout = await Primitive.Int.read(b);
      return new Raw.UpdateBotWebhookJSONQuery({ queryId: queryId, data: data, timeout: timeout });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.queryId !== undefined) {
        b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
      }
      if (this.data !== undefined) {
        b.write(this.data.write() as unknown as Buffer);
      }
      if (this.timeout !== undefined) {
        b.write(Primitive.Int.write(this.timeout) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateBotShippingQuery extends TLObject {
    queryId!: long;
    userId!: long;
    payload!: bytes;
    shippingAddress!: Raw.TypePostAddress;

    constructor(params: {
      queryId: long;
      userId: long;
      payload: bytes;
      shippingAddress: Raw.TypePostAddress;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateBotShippingQuery';
      this.constructorId = 0xb5aefd7d;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['queryId', 'userId', 'payload', 'shippingAddress'];
      this.queryId = params.queryId;
      this.userId = params.userId;
      this.payload = params.payload;
      this.shippingAddress = params.shippingAddress;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateBotShippingQuery> {
      // no flags

      let queryId = await Primitive.Long.read(b);
      let userId = await Primitive.Long.read(b);
      let payload = await Primitive.Bytes.read(b);
      let shippingAddress = await TLObject.read(b);
      return new Raw.UpdateBotShippingQuery({
        queryId: queryId,
        userId: userId,
        payload: payload,
        shippingAddress: shippingAddress,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.queryId !== undefined) {
        b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.payload !== undefined) {
        b.write(Primitive.Bytes.write(this.payload) as unknown as Buffer);
      }
      if (this.shippingAddress !== undefined) {
        b.write(this.shippingAddress.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateBotPrecheckoutQuery extends TLObject {
    queryId!: long;
    userId!: long;
    payload!: bytes;
    info?: Raw.TypePaymentRequestedInfo;
    shippingOptionId?: string;
    currency!: string;
    totalAmount!: long;

    constructor(params: {
      queryId: long;
      userId: long;
      payload: bytes;
      info?: Raw.TypePaymentRequestedInfo;
      shippingOptionId?: string;
      currency: string;
      totalAmount: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateBotPrecheckoutQuery';
      this.constructorId = 0x8caa9a96;
      this.subclassOfId = 0x9f89304e;
      this._slots = [
        'queryId',
        'userId',
        'payload',
        'info',
        'shippingOptionId',
        'currency',
        'totalAmount',
      ];
      this.queryId = params.queryId;
      this.userId = params.userId;
      this.payload = params.payload;
      this.info = params.info;
      this.shippingOptionId = params.shippingOptionId;
      this.currency = params.currency;
      this.totalAmount = params.totalAmount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateBotPrecheckoutQuery> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let queryId = await Primitive.Long.read(b);
      let userId = await Primitive.Long.read(b);
      let payload = await Primitive.Bytes.read(b);
      let info = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let shippingOptionId = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let currency = await Primitive.String.read(b);
      let totalAmount = await Primitive.Long.read(b);
      return new Raw.UpdateBotPrecheckoutQuery({
        queryId: queryId,
        userId: userId,
        payload: payload,
        info: info,
        shippingOptionId: shippingOptionId,
        currency: currency,
        totalAmount: totalAmount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.info !== undefined ? 1 << 0 : 0;
      flags |= this.shippingOptionId !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.queryId !== undefined) {
        b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.payload !== undefined) {
        b.write(Primitive.Bytes.write(this.payload) as unknown as Buffer);
      }
      if (this.info !== undefined) {
        b.write(this.info.write() as unknown as Buffer);
      }
      if (this.shippingOptionId !== undefined) {
        b.write(Primitive.String.write(this.shippingOptionId) as unknown as Buffer);
      }
      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.totalAmount !== undefined) {
        b.write(Primitive.Long.write(this.totalAmount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdatePhoneCall extends TLObject {
    phoneCall!: Raw.TypePhoneCall;

    constructor(params: { phoneCall: Raw.TypePhoneCall }) {
      super();
      this.classType = 'types';
      this.className = 'UpdatePhoneCall';
      this.constructorId = 0xab0f6b1e;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['phoneCall'];
      this.phoneCall = params.phoneCall;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatePhoneCall> {
      // no flags

      let phoneCall = await TLObject.read(b);
      return new Raw.UpdatePhoneCall({ phoneCall: phoneCall });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.phoneCall !== undefined) {
        b.write(this.phoneCall.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateLangPackTooLong extends TLObject {
    langCode!: string;

    constructor(params: { langCode: string }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateLangPackTooLong';
      this.constructorId = 0x46560264;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['langCode'];
      this.langCode = params.langCode;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateLangPackTooLong> {
      // no flags

      let langCode = await Primitive.String.read(b);
      return new Raw.UpdateLangPackTooLong({ langCode: langCode });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.langCode !== undefined) {
        b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateLangPack extends TLObject {
    difference!: Raw.TypeLangPackDifference;

    constructor(params: { difference: Raw.TypeLangPackDifference }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateLangPack';
      this.constructorId = 0x56022f4d;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['difference'];
      this.difference = params.difference;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateLangPack> {
      // no flags

      let difference = await TLObject.read(b);
      return new Raw.UpdateLangPack({ difference: difference });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.difference !== undefined) {
        b.write(this.difference.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateFavedStickers extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateFavedStickers';
      this.constructorId = 0xe511996d;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateFavedStickers> {
      // no flags

      return new Raw.UpdateFavedStickers();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateChannelReadMessagesContents extends TLObject {
    channelId!: long;
    topMsgId?: int;
    messages!: Vector<int>;

    constructor(params: { channelId: long; topMsgId?: int; messages: Vector<int> }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChannelReadMessagesContents';
      this.constructorId = 0xea29055d;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId', 'topMsgId', 'messages'];
      this.channelId = params.channelId;
      this.topMsgId = params.topMsgId;
      this.messages = params.messages;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.UpdateChannelReadMessagesContents> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let channelId = await Primitive.Long.read(b);
      let topMsgId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let messages = await TLObject.read(b, Primitive.Int);
      return new Raw.UpdateChannelReadMessagesContents({
        channelId: channelId,
        topMsgId: topMsgId,
        messages: messages,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.topMsgId !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.topMsgId !== undefined) {
        b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
      }
      if (this.messages) {
        b.write(Primitive.Vector.write(this.messages, Primitive.Int) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateContactsReset extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateContactsReset';
      this.constructorId = 0x7084a7be;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateContactsReset> {
      // no flags

      return new Raw.UpdateContactsReset();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateChannelAvailableMessages extends TLObject {
    channelId!: long;
    availableMinId!: int;

    constructor(params: { channelId: long; availableMinId: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChannelAvailableMessages';
      this.constructorId = 0xb23fc698;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId', 'availableMinId'];
      this.channelId = params.channelId;
      this.availableMinId = params.availableMinId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.UpdateChannelAvailableMessages> {
      // no flags

      let channelId = await Primitive.Long.read(b);
      let availableMinId = await Primitive.Int.read(b);
      return new Raw.UpdateChannelAvailableMessages({
        channelId: channelId,
        availableMinId: availableMinId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.availableMinId !== undefined) {
        b.write(Primitive.Int.write(this.availableMinId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateDialogUnreadMark extends TLObject {
    unread?: boolean;
    peer!: Raw.TypeDialogPeer;

    constructor(params: { unread?: boolean; peer: Raw.TypeDialogPeer }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateDialogUnreadMark';
      this.constructorId = 0xe16459c3;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['unread', 'peer'];
      this.unread = params.unread;
      this.peer = params.peer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateDialogUnreadMark> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let unread = flags & (1 << 0) ? true : false;
      let peer = await TLObject.read(b);
      return new Raw.UpdateDialogUnreadMark({ unread: unread, peer: peer });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.unread ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateMessagePoll extends TLObject {
    pollId!: long;
    poll?: Raw.TypePoll;
    results!: Raw.TypePollResults;

    constructor(params: { pollId: long; poll?: Raw.TypePoll; results: Raw.TypePollResults }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateMessagePoll';
      this.constructorId = 0xaca1657b;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['pollId', 'poll', 'results'];
      this.pollId = params.pollId;
      this.poll = params.poll;
      this.results = params.results;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateMessagePoll> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let pollId = await Primitive.Long.read(b);
      let poll = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let results = await TLObject.read(b);
      return new Raw.UpdateMessagePoll({ pollId: pollId, poll: poll, results: results });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.poll !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.pollId !== undefined) {
        b.write(Primitive.Long.write(this.pollId) as unknown as Buffer);
      }
      if (this.poll !== undefined) {
        b.write(this.poll.write() as unknown as Buffer);
      }
      if (this.results !== undefined) {
        b.write(this.results.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChatDefaultBannedRights extends TLObject {
    peer!: Raw.TypePeer;
    defaultBannedRights!: Raw.TypeChatBannedRights;
    version!: int;

    constructor(params: {
      peer: Raw.TypePeer;
      defaultBannedRights: Raw.TypeChatBannedRights;
      version: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChatDefaultBannedRights';
      this.constructorId = 0x54c01850;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'defaultBannedRights', 'version'];
      this.peer = params.peer;
      this.defaultBannedRights = params.defaultBannedRights;
      this.version = params.version;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChatDefaultBannedRights> {
      // no flags

      let peer = await TLObject.read(b);
      let defaultBannedRights = await TLObject.read(b);
      let version = await Primitive.Int.read(b);
      return new Raw.UpdateChatDefaultBannedRights({
        peer: peer,
        defaultBannedRights: defaultBannedRights,
        version: version,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.defaultBannedRights !== undefined) {
        b.write(this.defaultBannedRights.write() as unknown as Buffer);
      }
      if (this.version !== undefined) {
        b.write(Primitive.Int.write(this.version) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateFolderPeers extends TLObject {
    folderPeers!: Vector<Raw.TypeFolderPeer>;
    pts!: int;
    ptsCount!: int;

    constructor(params: { folderPeers: Vector<Raw.TypeFolderPeer>; pts: int; ptsCount: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateFolderPeers';
      this.constructorId = 0x19360dc0;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['folderPeers', 'pts', 'ptsCount'];
      this.folderPeers = params.folderPeers;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateFolderPeers> {
      // no flags

      let folderPeers = await TLObject.read(b);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdateFolderPeers({ folderPeers: folderPeers, pts: pts, ptsCount: ptsCount });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.folderPeers) {
        b.write(Primitive.Vector.write(this.folderPeers) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdatePeerSettings extends TLObject {
    peer!: Raw.TypePeer;
    settings!: Raw.TypePeerSettings;

    constructor(params: { peer: Raw.TypePeer; settings: Raw.TypePeerSettings }) {
      super();
      this.classType = 'types';
      this.className = 'UpdatePeerSettings';
      this.constructorId = 0x6a7e7366;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'settings'];
      this.peer = params.peer;
      this.settings = params.settings;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatePeerSettings> {
      // no flags

      let peer = await TLObject.read(b);
      let settings = await TLObject.read(b);
      return new Raw.UpdatePeerSettings({ peer: peer, settings: settings });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.settings !== undefined) {
        b.write(this.settings.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdatePeerLocated extends TLObject {
    peers!: Vector<Raw.TypePeerLocated>;

    constructor(params: { peers: Vector<Raw.TypePeerLocated> }) {
      super();
      this.classType = 'types';
      this.className = 'UpdatePeerLocated';
      this.constructorId = 0xb4afcfb0;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peers'];
      this.peers = params.peers;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatePeerLocated> {
      // no flags

      let peers = await TLObject.read(b);
      return new Raw.UpdatePeerLocated({ peers: peers });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peers) {
        b.write(Primitive.Vector.write(this.peers) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateNewScheduledMessage extends TLObject {
    message!: Raw.TypeMessage;

    constructor(params: { message: Raw.TypeMessage }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateNewScheduledMessage';
      this.constructorId = 0x39a51dfb;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['message'];
      this.message = params.message;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateNewScheduledMessage> {
      // no flags

      let message = await TLObject.read(b);
      return new Raw.UpdateNewScheduledMessage({ message: message });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.message !== undefined) {
        b.write(this.message.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateDeleteScheduledMessages extends TLObject {
    peer!: Raw.TypePeer;
    messages!: Vector<int>;

    constructor(params: { peer: Raw.TypePeer; messages: Vector<int> }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateDeleteScheduledMessages';
      this.constructorId = 0x90866cee;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'messages'];
      this.peer = params.peer;
      this.messages = params.messages;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateDeleteScheduledMessages> {
      // no flags

      let peer = await TLObject.read(b);
      let messages = await TLObject.read(b, Primitive.Int);
      return new Raw.UpdateDeleteScheduledMessages({ peer: peer, messages: messages });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.messages) {
        b.write(Primitive.Vector.write(this.messages, Primitive.Int) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateTheme extends TLObject {
    theme!: Raw.TypeTheme;

    constructor(params: { theme: Raw.TypeTheme }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateTheme';
      this.constructorId = 0x8216fba3;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['theme'];
      this.theme = params.theme;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateTheme> {
      // no flags

      let theme = await TLObject.read(b);
      return new Raw.UpdateTheme({ theme: theme });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.theme !== undefined) {
        b.write(this.theme.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateGeoLiveViewed extends TLObject {
    peer!: Raw.TypePeer;
    msgId!: int;

    constructor(params: { peer: Raw.TypePeer; msgId: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateGeoLiveViewed';
      this.constructorId = 0x871fb939;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'msgId'];
      this.peer = params.peer;
      this.msgId = params.msgId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateGeoLiveViewed> {
      // no flags

      let peer = await TLObject.read(b);
      let msgId = await Primitive.Int.read(b);
      return new Raw.UpdateGeoLiveViewed({ peer: peer, msgId: msgId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateLoginToken extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateLoginToken';
      this.constructorId = 0x564fe691;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateLoginToken> {
      // no flags

      return new Raw.UpdateLoginToken();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateMessagePollVote extends TLObject {
    pollId!: long;
    peer!: Raw.TypePeer;
    options!: Vector<bytes>;
    qts!: int;

    constructor(params: { pollId: long; peer: Raw.TypePeer; options: Vector<bytes>; qts: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateMessagePollVote';
      this.constructorId = 0x24f40e77;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['pollId', 'peer', 'options', 'qts'];
      this.pollId = params.pollId;
      this.peer = params.peer;
      this.options = params.options;
      this.qts = params.qts;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateMessagePollVote> {
      // no flags

      let pollId = await Primitive.Long.read(b);
      let peer = await TLObject.read(b);
      let options = await TLObject.read(b, Primitive.Bytes);
      let qts = await Primitive.Int.read(b);
      return new Raw.UpdateMessagePollVote({
        pollId: pollId,
        peer: peer,
        options: options,
        qts: qts,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.pollId !== undefined) {
        b.write(Primitive.Long.write(this.pollId) as unknown as Buffer);
      }
      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.options) {
        b.write(Primitive.Vector.write(this.options, Primitive.Bytes) as unknown as Buffer);
      }
      if (this.qts !== undefined) {
        b.write(Primitive.Int.write(this.qts) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateDialogFilter extends TLObject {
    id!: int;
    filter?: Raw.TypeDialogFilter;

    constructor(params: { id: int; filter?: Raw.TypeDialogFilter }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateDialogFilter';
      this.constructorId = 0x26ffde7d;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['id', 'filter'];
      this.id = params.id;
      this.filter = params.filter;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateDialogFilter> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let id = await Primitive.Int.read(b);
      let filter = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      return new Raw.UpdateDialogFilter({ id: id, filter: filter });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.filter !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.filter !== undefined) {
        b.write(this.filter.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateDialogFilterOrder extends TLObject {
    order!: Vector<int>;

    constructor(params: { order: Vector<int> }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateDialogFilterOrder';
      this.constructorId = 0xa5d72105;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['order'];
      this.order = params.order;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateDialogFilterOrder> {
      // no flags

      let order = await TLObject.read(b, Primitive.Int);
      return new Raw.UpdateDialogFilterOrder({ order: order });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.order) {
        b.write(Primitive.Vector.write(this.order, Primitive.Int) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateDialogFilters extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateDialogFilters';
      this.constructorId = 0x3504914f;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateDialogFilters> {
      // no flags

      return new Raw.UpdateDialogFilters();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdatePhoneCallSignalingData extends TLObject {
    phoneCallId!: long;
    data!: bytes;

    constructor(params: { phoneCallId: long; data: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'UpdatePhoneCallSignalingData';
      this.constructorId = 0x2661bf09;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['phoneCallId', 'data'];
      this.phoneCallId = params.phoneCallId;
      this.data = params.data;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatePhoneCallSignalingData> {
      // no flags

      let phoneCallId = await Primitive.Long.read(b);
      let data = await Primitive.Bytes.read(b);
      return new Raw.UpdatePhoneCallSignalingData({ phoneCallId: phoneCallId, data: data });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.phoneCallId !== undefined) {
        b.write(Primitive.Long.write(this.phoneCallId) as unknown as Buffer);
      }
      if (this.data !== undefined) {
        b.write(Primitive.Bytes.write(this.data) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChannelMessageForwards extends TLObject {
    channelId!: long;
    id!: int;
    forwards!: int;

    constructor(params: { channelId: long; id: int; forwards: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChannelMessageForwards';
      this.constructorId = 0xd29a27f4;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId', 'id', 'forwards'];
      this.channelId = params.channelId;
      this.id = params.id;
      this.forwards = params.forwards;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChannelMessageForwards> {
      // no flags

      let channelId = await Primitive.Long.read(b);
      let id = await Primitive.Int.read(b);
      let forwards = await Primitive.Int.read(b);
      return new Raw.UpdateChannelMessageForwards({
        channelId: channelId,
        id: id,
        forwards: forwards,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.forwards !== undefined) {
        b.write(Primitive.Int.write(this.forwards) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateReadChannelDiscussionInbox extends TLObject {
    channelId!: long;
    topMsgId!: int;
    readMaxId!: int;
    broadcastId?: long;
    broadcastPost?: int;

    constructor(params: {
      channelId: long;
      topMsgId: int;
      readMaxId: int;
      broadcastId?: long;
      broadcastPost?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateReadChannelDiscussionInbox';
      this.constructorId = 0xd6b19546;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId', 'topMsgId', 'readMaxId', 'broadcastId', 'broadcastPost'];
      this.channelId = params.channelId;
      this.topMsgId = params.topMsgId;
      this.readMaxId = params.readMaxId;
      this.broadcastId = params.broadcastId;
      this.broadcastPost = params.broadcastPost;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.UpdateReadChannelDiscussionInbox> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let channelId = await Primitive.Long.read(b);
      let topMsgId = await Primitive.Int.read(b);
      let readMaxId = await Primitive.Int.read(b);
      let broadcastId = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
      let broadcastPost = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.UpdateReadChannelDiscussionInbox({
        channelId: channelId,
        topMsgId: topMsgId,
        readMaxId: readMaxId,
        broadcastId: broadcastId,
        broadcastPost: broadcastPost,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.broadcastId !== undefined ? 1 << 0 : 0;
      flags |= this.broadcastPost !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.topMsgId !== undefined) {
        b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
      }
      if (this.readMaxId !== undefined) {
        b.write(Primitive.Int.write(this.readMaxId) as unknown as Buffer);
      }
      if (this.broadcastId !== undefined) {
        b.write(Primitive.Long.write(this.broadcastId) as unknown as Buffer);
      }
      if (this.broadcastPost !== undefined) {
        b.write(Primitive.Int.write(this.broadcastPost) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateReadChannelDiscussionOutbox extends TLObject {
    channelId!: long;
    topMsgId!: int;
    readMaxId!: int;

    constructor(params: { channelId: long; topMsgId: int; readMaxId: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateReadChannelDiscussionOutbox';
      this.constructorId = 0x695c9e7c;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId', 'topMsgId', 'readMaxId'];
      this.channelId = params.channelId;
      this.topMsgId = params.topMsgId;
      this.readMaxId = params.readMaxId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.UpdateReadChannelDiscussionOutbox> {
      // no flags

      let channelId = await Primitive.Long.read(b);
      let topMsgId = await Primitive.Int.read(b);
      let readMaxId = await Primitive.Int.read(b);
      return new Raw.UpdateReadChannelDiscussionOutbox({
        channelId: channelId,
        topMsgId: topMsgId,
        readMaxId: readMaxId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.topMsgId !== undefined) {
        b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
      }
      if (this.readMaxId !== undefined) {
        b.write(Primitive.Int.write(this.readMaxId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdatePeerBlocked extends TLObject {
    blocked?: boolean;
    blockedMyStoriesFrom?: boolean;
    peerId!: Raw.TypePeer;

    constructor(params: {
      blocked?: boolean;
      blockedMyStoriesFrom?: boolean;
      peerId: Raw.TypePeer;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdatePeerBlocked';
      this.constructorId = 0xebe07752;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['blocked', 'blockedMyStoriesFrom', 'peerId'];
      this.blocked = params.blocked;
      this.blockedMyStoriesFrom = params.blockedMyStoriesFrom;
      this.peerId = params.peerId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatePeerBlocked> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let blocked = flags & (1 << 0) ? true : false;
      let blockedMyStoriesFrom = flags & (1 << 1) ? true : false;
      let peerId = await TLObject.read(b);
      return new Raw.UpdatePeerBlocked({
        blocked: blocked,
        blockedMyStoriesFrom: blockedMyStoriesFrom,
        peerId: peerId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.blocked ? 1 << 0 : 0;
      flags |= this.blockedMyStoriesFrom ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peerId !== undefined) {
        b.write(this.peerId.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChannelUserTyping extends TLObject {
    channelId!: long;
    topMsgId?: int;
    fromId!: Raw.TypePeer;
    action!: Raw.TypeSendMessageAction;

    constructor(params: {
      channelId: long;
      topMsgId?: int;
      fromId: Raw.TypePeer;
      action: Raw.TypeSendMessageAction;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChannelUserTyping';
      this.constructorId = 0x8c88c923;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId', 'topMsgId', 'fromId', 'action'];
      this.channelId = params.channelId;
      this.topMsgId = params.topMsgId;
      this.fromId = params.fromId;
      this.action = params.action;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChannelUserTyping> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let channelId = await Primitive.Long.read(b);
      let topMsgId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let fromId = await TLObject.read(b);
      let action = await TLObject.read(b);
      return new Raw.UpdateChannelUserTyping({
        channelId: channelId,
        topMsgId: topMsgId,
        fromId: fromId,
        action: action,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.topMsgId !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.topMsgId !== undefined) {
        b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
      }
      if (this.fromId !== undefined) {
        b.write(this.fromId.write() as unknown as Buffer);
      }
      if (this.action !== undefined) {
        b.write(this.action.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdatePinnedMessages extends TLObject {
    pinned?: boolean;
    peer!: Raw.TypePeer;
    messages!: Vector<int>;
    pts!: int;
    ptsCount!: int;

    constructor(params: {
      pinned?: boolean;
      peer: Raw.TypePeer;
      messages: Vector<int>;
      pts: int;
      ptsCount: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdatePinnedMessages';
      this.constructorId = 0xed85eab5;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['pinned', 'peer', 'messages', 'pts', 'ptsCount'];
      this.pinned = params.pinned;
      this.peer = params.peer;
      this.messages = params.messages;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatePinnedMessages> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let pinned = flags & (1 << 0) ? true : false;
      let peer = await TLObject.read(b);
      let messages = await TLObject.read(b, Primitive.Int);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdatePinnedMessages({
        pinned: pinned,
        peer: peer,
        messages: messages,
        pts: pts,
        ptsCount: ptsCount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.pinned ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.messages) {
        b.write(Primitive.Vector.write(this.messages, Primitive.Int) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdatePinnedChannelMessages extends TLObject {
    pinned?: boolean;
    channelId!: long;
    messages!: Vector<int>;
    pts!: int;
    ptsCount!: int;

    constructor(params: {
      pinned?: boolean;
      channelId: long;
      messages: Vector<int>;
      pts: int;
      ptsCount: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdatePinnedChannelMessages';
      this.constructorId = 0x5bb98608;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['pinned', 'channelId', 'messages', 'pts', 'ptsCount'];
      this.pinned = params.pinned;
      this.channelId = params.channelId;
      this.messages = params.messages;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatePinnedChannelMessages> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let pinned = flags & (1 << 0) ? true : false;
      let channelId = await Primitive.Long.read(b);
      let messages = await TLObject.read(b, Primitive.Int);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      return new Raw.UpdatePinnedChannelMessages({
        pinned: pinned,
        channelId: channelId,
        messages: messages,
        pts: pts,
        ptsCount: ptsCount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.pinned ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.messages) {
        b.write(Primitive.Vector.write(this.messages, Primitive.Int) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChat extends TLObject {
    chatId!: long;

    constructor(params: { chatId: long }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChat';
      this.constructorId = 0xf89a6a4e;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['chatId'];
      this.chatId = params.chatId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChat> {
      // no flags

      let chatId = await Primitive.Long.read(b);
      return new Raw.UpdateChat({ chatId: chatId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateGroupCallParticipants extends TLObject {
    call!: Raw.TypeInputGroupCall;
    participants!: Vector<Raw.TypeGroupCallParticipant>;
    version!: int;

    constructor(params: {
      call: Raw.TypeInputGroupCall;
      participants: Vector<Raw.TypeGroupCallParticipant>;
      version: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateGroupCallParticipants';
      this.constructorId = 0xf2ebdb4e;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['call', 'participants', 'version'];
      this.call = params.call;
      this.participants = params.participants;
      this.version = params.version;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateGroupCallParticipants> {
      // no flags

      let call = await TLObject.read(b);
      let participants = await TLObject.read(b);
      let version = await Primitive.Int.read(b);
      return new Raw.UpdateGroupCallParticipants({
        call: call,
        participants: participants,
        version: version,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.call !== undefined) {
        b.write(this.call.write() as unknown as Buffer);
      }
      if (this.participants) {
        b.write(Primitive.Vector.write(this.participants) as unknown as Buffer);
      }
      if (this.version !== undefined) {
        b.write(Primitive.Int.write(this.version) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateGroupCall extends TLObject {
    chatId!: long;
    call!: Raw.TypeGroupCall;

    constructor(params: { chatId: long; call: Raw.TypeGroupCall }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateGroupCall';
      this.constructorId = 0x14b24500;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['chatId', 'call'];
      this.chatId = params.chatId;
      this.call = params.call;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateGroupCall> {
      // no flags

      let chatId = await Primitive.Long.read(b);
      let call = await TLObject.read(b);
      return new Raw.UpdateGroupCall({ chatId: chatId, call: call });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      if (this.call !== undefined) {
        b.write(this.call.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdatePeerHistoryTTL extends TLObject {
    peer!: Raw.TypePeer;
    ttlPeriod?: int;

    constructor(params: { peer: Raw.TypePeer; ttlPeriod?: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdatePeerHistoryTTL';
      this.constructorId = 0xbb9bb9a5;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'ttlPeriod'];
      this.peer = params.peer;
      this.ttlPeriod = params.ttlPeriod;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatePeerHistoryTTL> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let peer = await TLObject.read(b);
      let ttlPeriod = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.UpdatePeerHistoryTTL({ peer: peer, ttlPeriod: ttlPeriod });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.ttlPeriod !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.ttlPeriod !== undefined) {
        b.write(Primitive.Int.write(this.ttlPeriod) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChatParticipant extends TLObject {
    chatId!: long;
    date!: int;
    actorId!: long;
    userId!: long;
    prevParticipant?: Raw.TypeChatParticipant;
    newParticipant?: Raw.TypeChatParticipant;
    invite?: Raw.TypeExportedChatInvite;
    qts!: int;

    constructor(params: {
      chatId: long;
      date: int;
      actorId: long;
      userId: long;
      prevParticipant?: Raw.TypeChatParticipant;
      newParticipant?: Raw.TypeChatParticipant;
      invite?: Raw.TypeExportedChatInvite;
      qts: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChatParticipant';
      this.constructorId = 0xd087663a;
      this.subclassOfId = 0x9f89304e;
      this._slots = [
        'chatId',
        'date',
        'actorId',
        'userId',
        'prevParticipant',
        'newParticipant',
        'invite',
        'qts',
      ];
      this.chatId = params.chatId;
      this.date = params.date;
      this.actorId = params.actorId;
      this.userId = params.userId;
      this.prevParticipant = params.prevParticipant;
      this.newParticipant = params.newParticipant;
      this.invite = params.invite;
      this.qts = params.qts;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChatParticipant> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let chatId = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let actorId = await Primitive.Long.read(b);
      let userId = await Primitive.Long.read(b);
      let prevParticipant = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let newParticipant = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let invite = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      let qts = await Primitive.Int.read(b);
      return new Raw.UpdateChatParticipant({
        chatId: chatId,
        date: date,
        actorId: actorId,
        userId: userId,
        prevParticipant: prevParticipant,
        newParticipant: newParticipant,
        invite: invite,
        qts: qts,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.prevParticipant !== undefined ? 1 << 0 : 0;
      flags |= this.newParticipant !== undefined ? 1 << 1 : 0;
      flags |= this.invite !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.actorId !== undefined) {
        b.write(Primitive.Long.write(this.actorId) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.prevParticipant !== undefined) {
        b.write(this.prevParticipant.write() as unknown as Buffer);
      }
      if (this.newParticipant !== undefined) {
        b.write(this.newParticipant.write() as unknown as Buffer);
      }
      if (this.invite !== undefined) {
        b.write(this.invite.write() as unknown as Buffer);
      }
      if (this.qts !== undefined) {
        b.write(Primitive.Int.write(this.qts) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChannelParticipant extends TLObject {
    viaChatlist?: boolean;
    channelId!: long;
    date!: int;
    actorId!: long;
    userId!: long;
    prevParticipant?: Raw.TypeChannelParticipant;
    newParticipant?: Raw.TypeChannelParticipant;
    invite?: Raw.TypeExportedChatInvite;
    qts!: int;

    constructor(params: {
      viaChatlist?: boolean;
      channelId: long;
      date: int;
      actorId: long;
      userId: long;
      prevParticipant?: Raw.TypeChannelParticipant;
      newParticipant?: Raw.TypeChannelParticipant;
      invite?: Raw.TypeExportedChatInvite;
      qts: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChannelParticipant';
      this.constructorId = 0x985d3abb;
      this.subclassOfId = 0x9f89304e;
      this._slots = [
        'viaChatlist',
        'channelId',
        'date',
        'actorId',
        'userId',
        'prevParticipant',
        'newParticipant',
        'invite',
        'qts',
      ];
      this.viaChatlist = params.viaChatlist;
      this.channelId = params.channelId;
      this.date = params.date;
      this.actorId = params.actorId;
      this.userId = params.userId;
      this.prevParticipant = params.prevParticipant;
      this.newParticipant = params.newParticipant;
      this.invite = params.invite;
      this.qts = params.qts;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChannelParticipant> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let viaChatlist = flags & (1 << 3) ? true : false;
      let channelId = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let actorId = await Primitive.Long.read(b);
      let userId = await Primitive.Long.read(b);
      let prevParticipant = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let newParticipant = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let invite = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      let qts = await Primitive.Int.read(b);
      return new Raw.UpdateChannelParticipant({
        viaChatlist: viaChatlist,
        channelId: channelId,
        date: date,
        actorId: actorId,
        userId: userId,
        prevParticipant: prevParticipant,
        newParticipant: newParticipant,
        invite: invite,
        qts: qts,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.viaChatlist ? 1 << 3 : 0;
      flags |= this.prevParticipant !== undefined ? 1 << 0 : 0;
      flags |= this.newParticipant !== undefined ? 1 << 1 : 0;
      flags |= this.invite !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.actorId !== undefined) {
        b.write(Primitive.Long.write(this.actorId) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.prevParticipant !== undefined) {
        b.write(this.prevParticipant.write() as unknown as Buffer);
      }
      if (this.newParticipant !== undefined) {
        b.write(this.newParticipant.write() as unknown as Buffer);
      }
      if (this.invite !== undefined) {
        b.write(this.invite.write() as unknown as Buffer);
      }
      if (this.qts !== undefined) {
        b.write(Primitive.Int.write(this.qts) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateBotStopped extends TLObject {
    userId!: long;
    date!: int;
    stopped!: Bool;
    qts!: int;

    constructor(params: { userId: long; date: int; stopped: Bool; qts: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateBotStopped';
      this.constructorId = 0xc4870a49;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['userId', 'date', 'stopped', 'qts'];
      this.userId = params.userId;
      this.date = params.date;
      this.stopped = params.stopped;
      this.qts = params.qts;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateBotStopped> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let stopped = await Primitive.Bool.read(b);
      let qts = await Primitive.Int.read(b);
      return new Raw.UpdateBotStopped({ userId: userId, date: date, stopped: stopped, qts: qts });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.stopped !== undefined) {
        b.write(Primitive.Bool.write(this.stopped) as unknown as Buffer);
      }
      if (this.qts !== undefined) {
        b.write(Primitive.Int.write(this.qts) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateGroupCallConnection extends TLObject {
    presentation?: boolean;
    params!: Raw.TypeDataJSON;

    constructor(params: { presentation?: boolean; params: Raw.TypeDataJSON }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateGroupCallConnection';
      this.constructorId = 0xb783982;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['presentation', 'params'];
      this.presentation = params.presentation;
      this.params = params.params;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateGroupCallConnection> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let presentation = flags & (1 << 0) ? true : false;
      let params = await TLObject.read(b);
      return new Raw.UpdateGroupCallConnection({ presentation: presentation, params: params });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.presentation ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.params !== undefined) {
        b.write(this.params.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateBotCommands extends TLObject {
    peer!: Raw.TypePeer;
    botId!: long;
    commands!: Vector<Raw.TypeBotCommand>;

    constructor(params: { peer: Raw.TypePeer; botId: long; commands: Vector<Raw.TypeBotCommand> }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateBotCommands';
      this.constructorId = 0x4d712f2e;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'botId', 'commands'];
      this.peer = params.peer;
      this.botId = params.botId;
      this.commands = params.commands;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateBotCommands> {
      // no flags

      let peer = await TLObject.read(b);
      let botId = await Primitive.Long.read(b);
      let commands = await TLObject.read(b);
      return new Raw.UpdateBotCommands({ peer: peer, botId: botId, commands: commands });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.botId !== undefined) {
        b.write(Primitive.Long.write(this.botId) as unknown as Buffer);
      }
      if (this.commands) {
        b.write(Primitive.Vector.write(this.commands) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdatePendingJoinRequests extends TLObject {
    peer!: Raw.TypePeer;
    requestsPending!: int;
    recentRequesters!: Vector<long>;

    constructor(params: {
      peer: Raw.TypePeer;
      requestsPending: int;
      recentRequesters: Vector<long>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdatePendingJoinRequests';
      this.constructorId = 0x7063c3db;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'requestsPending', 'recentRequesters'];
      this.peer = params.peer;
      this.requestsPending = params.requestsPending;
      this.recentRequesters = params.recentRequesters;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatePendingJoinRequests> {
      // no flags

      let peer = await TLObject.read(b);
      let requestsPending = await Primitive.Int.read(b);
      let recentRequesters = await TLObject.read(b, Primitive.Long);
      return new Raw.UpdatePendingJoinRequests({
        peer: peer,
        requestsPending: requestsPending,
        recentRequesters: recentRequesters,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.requestsPending !== undefined) {
        b.write(Primitive.Int.write(this.requestsPending) as unknown as Buffer);
      }
      if (this.recentRequesters) {
        b.write(Primitive.Vector.write(this.recentRequesters, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateBotChatInviteRequester extends TLObject {
    peer!: Raw.TypePeer;
    date!: int;
    userId!: long;
    about!: string;
    invite!: Raw.TypeExportedChatInvite;
    qts!: int;

    constructor(params: {
      peer: Raw.TypePeer;
      date: int;
      userId: long;
      about: string;
      invite: Raw.TypeExportedChatInvite;
      qts: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateBotChatInviteRequester';
      this.constructorId = 0x11dfa986;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'date', 'userId', 'about', 'invite', 'qts'];
      this.peer = params.peer;
      this.date = params.date;
      this.userId = params.userId;
      this.about = params.about;
      this.invite = params.invite;
      this.qts = params.qts;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateBotChatInviteRequester> {
      // no flags

      let peer = await TLObject.read(b);
      let date = await Primitive.Int.read(b);
      let userId = await Primitive.Long.read(b);
      let about = await Primitive.String.read(b);
      let invite = await TLObject.read(b);
      let qts = await Primitive.Int.read(b);
      return new Raw.UpdateBotChatInviteRequester({
        peer: peer,
        date: date,
        userId: userId,
        about: about,
        invite: invite,
        qts: qts,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.about !== undefined) {
        b.write(Primitive.String.write(this.about) as unknown as Buffer);
      }
      if (this.invite !== undefined) {
        b.write(this.invite.write() as unknown as Buffer);
      }
      if (this.qts !== undefined) {
        b.write(Primitive.Int.write(this.qts) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateMessageReactions extends TLObject {
    peer!: Raw.TypePeer;
    msgId!: int;
    topMsgId?: int;
    reactions!: Raw.TypeMessageReactions;

    constructor(params: {
      peer: Raw.TypePeer;
      msgId: int;
      topMsgId?: int;
      reactions: Raw.TypeMessageReactions;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateMessageReactions';
      this.constructorId = 0x5e1b3cb8;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'msgId', 'topMsgId', 'reactions'];
      this.peer = params.peer;
      this.msgId = params.msgId;
      this.topMsgId = params.topMsgId;
      this.reactions = params.reactions;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateMessageReactions> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let peer = await TLObject.read(b);
      let msgId = await Primitive.Int.read(b);
      let topMsgId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let reactions = await TLObject.read(b);
      return new Raw.UpdateMessageReactions({
        peer: peer,
        msgId: msgId,
        topMsgId: topMsgId,
        reactions: reactions,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.topMsgId !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      if (this.topMsgId !== undefined) {
        b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
      }
      if (this.reactions !== undefined) {
        b.write(this.reactions.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateAttachMenuBots extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateAttachMenuBots';
      this.constructorId = 0x17b7a20b;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateAttachMenuBots> {
      // no flags

      return new Raw.UpdateAttachMenuBots();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateWebViewResultSent extends TLObject {
    queryId!: long;

    constructor(params: { queryId: long }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateWebViewResultSent';
      this.constructorId = 0x1592b79d;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['queryId'];
      this.queryId = params.queryId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateWebViewResultSent> {
      // no flags

      let queryId = await Primitive.Long.read(b);
      return new Raw.UpdateWebViewResultSent({ queryId: queryId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.queryId !== undefined) {
        b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateBotMenuButton extends TLObject {
    botId!: long;
    button!: Raw.TypeBotMenuButton;

    constructor(params: { botId: long; button: Raw.TypeBotMenuButton }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateBotMenuButton';
      this.constructorId = 0x14b85813;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['botId', 'button'];
      this.botId = params.botId;
      this.button = params.button;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateBotMenuButton> {
      // no flags

      let botId = await Primitive.Long.read(b);
      let button = await TLObject.read(b);
      return new Raw.UpdateBotMenuButton({ botId: botId, button: button });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.botId !== undefined) {
        b.write(Primitive.Long.write(this.botId) as unknown as Buffer);
      }
      if (this.button !== undefined) {
        b.write(this.button.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateSavedRingtones extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateSavedRingtones';
      this.constructorId = 0x74d8be99;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateSavedRingtones> {
      // no flags

      return new Raw.UpdateSavedRingtones();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateTranscribedAudio extends TLObject {
    pending?: boolean;
    peer!: Raw.TypePeer;
    msgId!: int;
    transcriptionId!: long;
    text!: string;

    constructor(params: {
      pending?: boolean;
      peer: Raw.TypePeer;
      msgId: int;
      transcriptionId: long;
      text: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateTranscribedAudio';
      this.constructorId = 0x84cd5a;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['pending', 'peer', 'msgId', 'transcriptionId', 'text'];
      this.pending = params.pending;
      this.peer = params.peer;
      this.msgId = params.msgId;
      this.transcriptionId = params.transcriptionId;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateTranscribedAudio> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let pending = flags & (1 << 0) ? true : false;
      let peer = await TLObject.read(b);
      let msgId = await Primitive.Int.read(b);
      let transcriptionId = await Primitive.Long.read(b);
      let text = await Primitive.String.read(b);
      return new Raw.UpdateTranscribedAudio({
        pending: pending,
        peer: peer,
        msgId: msgId,
        transcriptionId: transcriptionId,
        text: text,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.pending ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      if (this.transcriptionId !== undefined) {
        b.write(Primitive.Long.write(this.transcriptionId) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateReadFeaturedEmojiStickers extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateReadFeaturedEmojiStickers';
      this.constructorId = 0xfb4c496c;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.UpdateReadFeaturedEmojiStickers> {
      // no flags

      return new Raw.UpdateReadFeaturedEmojiStickers();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateUserEmojiStatus extends TLObject {
    userId!: long;
    emojiStatus!: Raw.TypeEmojiStatus;

    constructor(params: { userId: long; emojiStatus: Raw.TypeEmojiStatus }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateUserEmojiStatus';
      this.constructorId = 0x28373599;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['userId', 'emojiStatus'];
      this.userId = params.userId;
      this.emojiStatus = params.emojiStatus;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateUserEmojiStatus> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let emojiStatus = await TLObject.read(b);
      return new Raw.UpdateUserEmojiStatus({ userId: userId, emojiStatus: emojiStatus });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.emojiStatus !== undefined) {
        b.write(this.emojiStatus.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateRecentEmojiStatuses extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateRecentEmojiStatuses';
      this.constructorId = 0x30f443db;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateRecentEmojiStatuses> {
      // no flags

      return new Raw.UpdateRecentEmojiStatuses();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateRecentReactions extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateRecentReactions';
      this.constructorId = 0x6f7863f4;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateRecentReactions> {
      // no flags

      return new Raw.UpdateRecentReactions();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateMoveStickerSetToTop extends TLObject {
    masks?: boolean;
    emojis?: boolean;
    stickerset!: long;

    constructor(params: { masks?: boolean; emojis?: boolean; stickerset: long }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateMoveStickerSetToTop';
      this.constructorId = 0x86fccf85;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['masks', 'emojis', 'stickerset'];
      this.masks = params.masks;
      this.emojis = params.emojis;
      this.stickerset = params.stickerset;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateMoveStickerSetToTop> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let masks = flags & (1 << 0) ? true : false;
      let emojis = flags & (1 << 1) ? true : false;
      let stickerset = await Primitive.Long.read(b);
      return new Raw.UpdateMoveStickerSetToTop({
        masks: masks,
        emojis: emojis,
        stickerset: stickerset,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.masks ? 1 << 0 : 0;
      flags |= this.emojis ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.stickerset !== undefined) {
        b.write(Primitive.Long.write(this.stickerset) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateMessageExtendedMedia extends TLObject {
    peer!: Raw.TypePeer;
    msgId!: int;
    extendedMedia!: Raw.TypeMessageExtendedMedia;

    constructor(params: {
      peer: Raw.TypePeer;
      msgId: int;
      extendedMedia: Raw.TypeMessageExtendedMedia;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateMessageExtendedMedia';
      this.constructorId = 0x5a73a98c;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'msgId', 'extendedMedia'];
      this.peer = params.peer;
      this.msgId = params.msgId;
      this.extendedMedia = params.extendedMedia;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateMessageExtendedMedia> {
      // no flags

      let peer = await TLObject.read(b);
      let msgId = await Primitive.Int.read(b);
      let extendedMedia = await TLObject.read(b);
      return new Raw.UpdateMessageExtendedMedia({
        peer: peer,
        msgId: msgId,
        extendedMedia: extendedMedia,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      if (this.extendedMedia !== undefined) {
        b.write(this.extendedMedia.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChannelPinnedTopic extends TLObject {
    pinned?: boolean;
    channelId!: long;
    topicId!: int;

    constructor(params: { pinned?: boolean; channelId: long; topicId: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChannelPinnedTopic';
      this.constructorId = 0x192efbe3;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['pinned', 'channelId', 'topicId'];
      this.pinned = params.pinned;
      this.channelId = params.channelId;
      this.topicId = params.topicId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChannelPinnedTopic> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let pinned = flags & (1 << 0) ? true : false;
      let channelId = await Primitive.Long.read(b);
      let topicId = await Primitive.Int.read(b);
      return new Raw.UpdateChannelPinnedTopic({
        pinned: pinned,
        channelId: channelId,
        topicId: topicId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.pinned ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.topicId !== undefined) {
        b.write(Primitive.Int.write(this.topicId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateChannelPinnedTopics extends TLObject {
    channelId!: long;
    order?: Vector<int>;

    constructor(params: { channelId: long; order?: Vector<int> }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateChannelPinnedTopics';
      this.constructorId = 0xfe198602;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['channelId', 'order'];
      this.channelId = params.channelId;
      this.order = params.order;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateChannelPinnedTopics> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let channelId = await Primitive.Long.read(b);
      let order = flags & (1 << 0) ? await TLObject.read(b, Primitive.Int) : [];
      return new Raw.UpdateChannelPinnedTopics({ channelId: channelId, order: order });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.order ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.order) {
        b.write(Primitive.Vector.write(this.order, Primitive.Int) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateUser extends TLObject {
    userId!: long;

    constructor(params: { userId: long }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateUser';
      this.constructorId = 0x20529438;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['userId'];
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateUser> {
      // no flags

      let userId = await Primitive.Long.read(b);
      return new Raw.UpdateUser({ userId: userId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateAutoSaveSettings extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdateAutoSaveSettings';
      this.constructorId = 0xec05b097;
      this.subclassOfId = 0x9f89304e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateAutoSaveSettings> {
      // no flags

      return new Raw.UpdateAutoSaveSettings();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateGroupInvitePrivacyForbidden extends TLObject {
    userId!: long;

    constructor(params: { userId: long }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateGroupInvitePrivacyForbidden';
      this.constructorId = 0xccf08ad6;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['userId'];
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.UpdateGroupInvitePrivacyForbidden> {
      // no flags

      let userId = await Primitive.Long.read(b);
      return new Raw.UpdateGroupInvitePrivacyForbidden({ userId: userId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateStory extends TLObject {
    peer!: Raw.TypePeer;
    story!: Raw.TypeStoryItem;

    constructor(params: { peer: Raw.TypePeer; story: Raw.TypeStoryItem }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateStory';
      this.constructorId = 0x75b3b798;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'story'];
      this.peer = params.peer;
      this.story = params.story;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateStory> {
      // no flags

      let peer = await TLObject.read(b);
      let story = await TLObject.read(b);
      return new Raw.UpdateStory({ peer: peer, story: story });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.story !== undefined) {
        b.write(this.story.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateReadStories extends TLObject {
    peer!: Raw.TypePeer;
    maxId!: int;

    constructor(params: { peer: Raw.TypePeer; maxId: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateReadStories';
      this.constructorId = 0xf74e932b;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'maxId'];
      this.peer = params.peer;
      this.maxId = params.maxId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateReadStories> {
      // no flags

      let peer = await TLObject.read(b);
      let maxId = await Primitive.Int.read(b);
      return new Raw.UpdateReadStories({ peer: peer, maxId: maxId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.maxId !== undefined) {
        b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateStoryID extends TLObject {
    id!: int;
    randomId!: long;

    constructor(params: { id: int; randomId: long }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateStoryID';
      this.constructorId = 0x1bf335b9;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['id', 'randomId'];
      this.id = params.id;
      this.randomId = params.randomId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateStoryID> {
      // no flags

      let id = await Primitive.Int.read(b);
      let randomId = await Primitive.Long.read(b);
      return new Raw.UpdateStoryID({ id: id, randomId: randomId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.randomId !== undefined) {
        b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateStoriesStealthMode extends TLObject {
    stealthMode!: Raw.TypeStoriesStealthMode;

    constructor(params: { stealthMode: Raw.TypeStoriesStealthMode }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateStoriesStealthMode';
      this.constructorId = 0x2c084dc1;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['stealthMode'];
      this.stealthMode = params.stealthMode;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateStoriesStealthMode> {
      // no flags

      let stealthMode = await TLObject.read(b);
      return new Raw.UpdateStoriesStealthMode({ stealthMode: stealthMode });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.stealthMode !== undefined) {
        b.write(this.stealthMode.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateSentStoryReaction extends TLObject {
    peer!: Raw.TypePeer;
    storyId!: int;
    reaction!: Raw.TypeReaction;

    constructor(params: { peer: Raw.TypePeer; storyId: int; reaction: Raw.TypeReaction }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateSentStoryReaction';
      this.constructorId = 0x7d627683;
      this.subclassOfId = 0x9f89304e;
      this._slots = ['peer', 'storyId', 'reaction'];
      this.peer = params.peer;
      this.storyId = params.storyId;
      this.reaction = params.reaction;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateSentStoryReaction> {
      // no flags

      let peer = await TLObject.read(b);
      let storyId = await Primitive.Int.read(b);
      let reaction = await TLObject.read(b);
      return new Raw.UpdateSentStoryReaction({ peer: peer, storyId: storyId, reaction: reaction });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.storyId !== undefined) {
        b.write(Primitive.Int.write(this.storyId) as unknown as Buffer);
      }
      if (this.reaction !== undefined) {
        b.write(this.reaction.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdatesTooLong extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UpdatesTooLong';
      this.constructorId = 0xe317af7e;
      this.subclassOfId = 0x8af52aac;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatesTooLong> {
      // no flags

      return new Raw.UpdatesTooLong();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class UpdateShortMessage extends TLObject {
    out?: boolean;
    mentioned?: boolean;
    mediaUnread?: boolean;
    silent?: boolean;
    id!: int;
    userId!: long;
    message!: string;
    pts!: int;
    ptsCount!: int;
    date!: int;
    fwdFrom?: Raw.TypeMessageFwdHeader;
    viaBotId?: long;
    replyTo?: Raw.TypeMessageReplyHeader;
    entities?: Vector<Raw.TypeMessageEntity>;
    ttlPeriod?: int;

    constructor(params: {
      out?: boolean;
      mentioned?: boolean;
      mediaUnread?: boolean;
      silent?: boolean;
      id: int;
      userId: long;
      message: string;
      pts: int;
      ptsCount: int;
      date: int;
      fwdFrom?: Raw.TypeMessageFwdHeader;
      viaBotId?: long;
      replyTo?: Raw.TypeMessageReplyHeader;
      entities?: Vector<Raw.TypeMessageEntity>;
      ttlPeriod?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateShortMessage';
      this.constructorId = 0x313bc7f8;
      this.subclassOfId = 0x8af52aac;
      this._slots = [
        'out',
        'mentioned',
        'mediaUnread',
        'silent',
        'id',
        'userId',
        'message',
        'pts',
        'ptsCount',
        'date',
        'fwdFrom',
        'viaBotId',
        'replyTo',
        'entities',
        'ttlPeriod',
      ];
      this.out = params.out;
      this.mentioned = params.mentioned;
      this.mediaUnread = params.mediaUnread;
      this.silent = params.silent;
      this.id = params.id;
      this.userId = params.userId;
      this.message = params.message;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
      this.date = params.date;
      this.fwdFrom = params.fwdFrom;
      this.viaBotId = params.viaBotId;
      this.replyTo = params.replyTo;
      this.entities = params.entities;
      this.ttlPeriod = params.ttlPeriod;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateShortMessage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let out = flags & (1 << 1) ? true : false;
      let mentioned = flags & (1 << 4) ? true : false;
      let mediaUnread = flags & (1 << 5) ? true : false;
      let silent = flags & (1 << 13) ? true : false;
      let id = await Primitive.Int.read(b);
      let userId = await Primitive.Long.read(b);
      let message = await Primitive.String.read(b);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      let fwdFrom = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      let viaBotId = flags & (1 << 11) ? await Primitive.Long.read(b) : undefined;
      let replyTo = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      let entities = flags & (1 << 7) ? await TLObject.read(b) : [];
      let ttlPeriod = flags & (1 << 25) ? await Primitive.Int.read(b) : undefined;
      return new Raw.UpdateShortMessage({
        out: out,
        mentioned: mentioned,
        mediaUnread: mediaUnread,
        silent: silent,
        id: id,
        userId: userId,
        message: message,
        pts: pts,
        ptsCount: ptsCount,
        date: date,
        fwdFrom: fwdFrom,
        viaBotId: viaBotId,
        replyTo: replyTo,
        entities: entities,
        ttlPeriod: ttlPeriod,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.out ? 1 << 1 : 0;
      flags |= this.mentioned ? 1 << 4 : 0;
      flags |= this.mediaUnread ? 1 << 5 : 0;
      flags |= this.silent ? 1 << 13 : 0;
      flags |= this.fwdFrom !== undefined ? 1 << 2 : 0;
      flags |= this.viaBotId !== undefined ? 1 << 11 : 0;
      flags |= this.replyTo !== undefined ? 1 << 3 : 0;
      flags |= this.entities ? 1 << 7 : 0;
      flags |= this.ttlPeriod !== undefined ? 1 << 25 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.fwdFrom !== undefined) {
        b.write(this.fwdFrom.write() as unknown as Buffer);
      }
      if (this.viaBotId !== undefined) {
        b.write(Primitive.Long.write(this.viaBotId) as unknown as Buffer);
      }
      if (this.replyTo !== undefined) {
        b.write(this.replyTo.write() as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.ttlPeriod !== undefined) {
        b.write(Primitive.Int.write(this.ttlPeriod) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateShortChatMessage extends TLObject {
    out?: boolean;
    mentioned?: boolean;
    mediaUnread?: boolean;
    silent?: boolean;
    id!: int;
    fromId!: long;
    chatId!: long;
    message!: string;
    pts!: int;
    ptsCount!: int;
    date!: int;
    fwdFrom?: Raw.TypeMessageFwdHeader;
    viaBotId?: long;
    replyTo?: Raw.TypeMessageReplyHeader;
    entities?: Vector<Raw.TypeMessageEntity>;
    ttlPeriod?: int;

    constructor(params: {
      out?: boolean;
      mentioned?: boolean;
      mediaUnread?: boolean;
      silent?: boolean;
      id: int;
      fromId: long;
      chatId: long;
      message: string;
      pts: int;
      ptsCount: int;
      date: int;
      fwdFrom?: Raw.TypeMessageFwdHeader;
      viaBotId?: long;
      replyTo?: Raw.TypeMessageReplyHeader;
      entities?: Vector<Raw.TypeMessageEntity>;
      ttlPeriod?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateShortChatMessage';
      this.constructorId = 0x4d6deea5;
      this.subclassOfId = 0x8af52aac;
      this._slots = [
        'out',
        'mentioned',
        'mediaUnread',
        'silent',
        'id',
        'fromId',
        'chatId',
        'message',
        'pts',
        'ptsCount',
        'date',
        'fwdFrom',
        'viaBotId',
        'replyTo',
        'entities',
        'ttlPeriod',
      ];
      this.out = params.out;
      this.mentioned = params.mentioned;
      this.mediaUnread = params.mediaUnread;
      this.silent = params.silent;
      this.id = params.id;
      this.fromId = params.fromId;
      this.chatId = params.chatId;
      this.message = params.message;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
      this.date = params.date;
      this.fwdFrom = params.fwdFrom;
      this.viaBotId = params.viaBotId;
      this.replyTo = params.replyTo;
      this.entities = params.entities;
      this.ttlPeriod = params.ttlPeriod;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateShortChatMessage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let out = flags & (1 << 1) ? true : false;
      let mentioned = flags & (1 << 4) ? true : false;
      let mediaUnread = flags & (1 << 5) ? true : false;
      let silent = flags & (1 << 13) ? true : false;
      let id = await Primitive.Int.read(b);
      let fromId = await Primitive.Long.read(b);
      let chatId = await Primitive.Long.read(b);
      let message = await Primitive.String.read(b);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      let fwdFrom = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      let viaBotId = flags & (1 << 11) ? await Primitive.Long.read(b) : undefined;
      let replyTo = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      let entities = flags & (1 << 7) ? await TLObject.read(b) : [];
      let ttlPeriod = flags & (1 << 25) ? await Primitive.Int.read(b) : undefined;
      return new Raw.UpdateShortChatMessage({
        out: out,
        mentioned: mentioned,
        mediaUnread: mediaUnread,
        silent: silent,
        id: id,
        fromId: fromId,
        chatId: chatId,
        message: message,
        pts: pts,
        ptsCount: ptsCount,
        date: date,
        fwdFrom: fwdFrom,
        viaBotId: viaBotId,
        replyTo: replyTo,
        entities: entities,
        ttlPeriod: ttlPeriod,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.out ? 1 << 1 : 0;
      flags |= this.mentioned ? 1 << 4 : 0;
      flags |= this.mediaUnread ? 1 << 5 : 0;
      flags |= this.silent ? 1 << 13 : 0;
      flags |= this.fwdFrom !== undefined ? 1 << 2 : 0;
      flags |= this.viaBotId !== undefined ? 1 << 11 : 0;
      flags |= this.replyTo !== undefined ? 1 << 3 : 0;
      flags |= this.entities ? 1 << 7 : 0;
      flags |= this.ttlPeriod !== undefined ? 1 << 25 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.fromId !== undefined) {
        b.write(Primitive.Long.write(this.fromId) as unknown as Buffer);
      }
      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.fwdFrom !== undefined) {
        b.write(this.fwdFrom.write() as unknown as Buffer);
      }
      if (this.viaBotId !== undefined) {
        b.write(Primitive.Long.write(this.viaBotId) as unknown as Buffer);
      }
      if (this.replyTo !== undefined) {
        b.write(this.replyTo.write() as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.ttlPeriod !== undefined) {
        b.write(Primitive.Int.write(this.ttlPeriod) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateShort extends TLObject {
    update!: Raw.TypeUpdate;
    date!: int;

    constructor(params: { update: Raw.TypeUpdate; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateShort';
      this.constructorId = 0x78d4dec1;
      this.subclassOfId = 0x8af52aac;
      this._slots = ['update', 'date'];
      this.update = params.update;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateShort> {
      // no flags

      let update = await TLObject.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.UpdateShort({ update: update, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.update !== undefined) {
        b.write(this.update.write() as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdatesCombined extends TLObject {
    updates!: Vector<Raw.TypeUpdate>;
    users!: Vector<Raw.TypeUser>;
    chats!: Vector<Raw.TypeChat>;
    date!: int;
    seqStart!: int;
    seq!: int;

    constructor(params: {
      updates: Vector<Raw.TypeUpdate>;
      users: Vector<Raw.TypeUser>;
      chats: Vector<Raw.TypeChat>;
      date: int;
      seqStart: int;
      seq: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdatesCombined';
      this.constructorId = 0x725b04c3;
      this.subclassOfId = 0x8af52aac;
      this._slots = ['updates', 'users', 'chats', 'date', 'seqStart', 'seq'];
      this.updates = params.updates;
      this.users = params.users;
      this.chats = params.chats;
      this.date = params.date;
      this.seqStart = params.seqStart;
      this.seq = params.seq;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdatesCombined> {
      // no flags

      let updates = await TLObject.read(b);
      let users = await TLObject.read(b);
      let chats = await TLObject.read(b);
      let date = await Primitive.Int.read(b);
      let seqStart = await Primitive.Int.read(b);
      let seq = await Primitive.Int.read(b);
      return new Raw.UpdatesCombined({
        updates: updates,
        users: users,
        chats: chats,
        date: date,
        seqStart: seqStart,
        seq: seq,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.updates) {
        b.write(Primitive.Vector.write(this.updates) as unknown as Buffer);
      }
      if (this.users) {
        b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
      }
      if (this.chats) {
        b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.seqStart !== undefined) {
        b.write(Primitive.Int.write(this.seqStart) as unknown as Buffer);
      }
      if (this.seq !== undefined) {
        b.write(Primitive.Int.write(this.seq) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Updates extends TLObject {
    updates!: Vector<Raw.TypeUpdate>;
    users!: Vector<Raw.TypeUser>;
    chats!: Vector<Raw.TypeChat>;
    date!: int;
    seq!: int;

    constructor(params: {
      updates: Vector<Raw.TypeUpdate>;
      users: Vector<Raw.TypeUser>;
      chats: Vector<Raw.TypeChat>;
      date: int;
      seq: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Updates';
      this.constructorId = 0x74ae4240;
      this.subclassOfId = 0x8af52aac;
      this._slots = ['updates', 'users', 'chats', 'date', 'seq'];
      this.updates = params.updates;
      this.users = params.users;
      this.chats = params.chats;
      this.date = params.date;
      this.seq = params.seq;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Updates> {
      // no flags

      let updates = await TLObject.read(b);
      let users = await TLObject.read(b);
      let chats = await TLObject.read(b);
      let date = await Primitive.Int.read(b);
      let seq = await Primitive.Int.read(b);
      return new Raw.Updates({
        updates: updates,
        users: users,
        chats: chats,
        date: date,
        seq: seq,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.updates) {
        b.write(Primitive.Vector.write(this.updates) as unknown as Buffer);
      }
      if (this.users) {
        b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
      }
      if (this.chats) {
        b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.seq !== undefined) {
        b.write(Primitive.Int.write(this.seq) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UpdateShortSentMessage extends TLObject {
    out?: boolean;
    id!: int;
    pts!: int;
    ptsCount!: int;
    date!: int;
    media?: Raw.TypeMessageMedia;
    entities?: Vector<Raw.TypeMessageEntity>;
    ttlPeriod?: int;

    constructor(params: {
      out?: boolean;
      id: int;
      pts: int;
      ptsCount: int;
      date: int;
      media?: Raw.TypeMessageMedia;
      entities?: Vector<Raw.TypeMessageEntity>;
      ttlPeriod?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'UpdateShortSentMessage';
      this.constructorId = 0x9015e101;
      this.subclassOfId = 0x8af52aac;
      this._slots = ['out', 'id', 'pts', 'ptsCount', 'date', 'media', 'entities', 'ttlPeriod'];
      this.out = params.out;
      this.id = params.id;
      this.pts = params.pts;
      this.ptsCount = params.ptsCount;
      this.date = params.date;
      this.media = params.media;
      this.entities = params.entities;
      this.ttlPeriod = params.ttlPeriod;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UpdateShortSentMessage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let out = flags & (1 << 1) ? true : false;
      let id = await Primitive.Int.read(b);
      let pts = await Primitive.Int.read(b);
      let ptsCount = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      let media = flags & (1 << 9) ? await TLObject.read(b) : undefined;
      let entities = flags & (1 << 7) ? await TLObject.read(b) : [];
      let ttlPeriod = flags & (1 << 25) ? await Primitive.Int.read(b) : undefined;
      return new Raw.UpdateShortSentMessage({
        out: out,
        id: id,
        pts: pts,
        ptsCount: ptsCount,
        date: date,
        media: media,
        entities: entities,
        ttlPeriod: ttlPeriod,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.out ? 1 << 1 : 0;
      flags |= this.media !== undefined ? 1 << 9 : 0;
      flags |= this.entities ? 1 << 7 : 0;
      flags |= this.ttlPeriod !== undefined ? 1 << 25 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.pts !== undefined) {
        b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
      }
      if (this.ptsCount !== undefined) {
        b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.media !== undefined) {
        b.write(this.media.write() as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.ttlPeriod !== undefined) {
        b.write(Primitive.Int.write(this.ttlPeriod) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DcOption extends TLObject {
    ipv6?: boolean;
    mediaOnly?: boolean;
    tcpoOnly?: boolean;
    cdn?: boolean;
    static?: boolean;
    thisPortOnly?: boolean;
    id!: int;
    ipAddress!: string;
    port!: int;
    secret?: bytes;

    constructor(params: {
      ipv6?: boolean;
      mediaOnly?: boolean;
      tcpoOnly?: boolean;
      cdn?: boolean;
      static?: boolean;
      thisPortOnly?: boolean;
      id: int;
      ipAddress: string;
      port: int;
      secret?: bytes;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DcOption';
      this.constructorId = 0x18b7a10d;
      this.subclassOfId = 0x9e43e123;
      this._slots = [
        'ipv6',
        'mediaOnly',
        'tcpoOnly',
        'cdn',
        'static',
        'thisPortOnly',
        'id',
        'ipAddress',
        'port',
        'secret',
      ];
      this.ipv6 = params.ipv6;
      this.mediaOnly = params.mediaOnly;
      this.tcpoOnly = params.tcpoOnly;
      this.cdn = params.cdn;
      this.static = params.static;
      this.thisPortOnly = params.thisPortOnly;
      this.id = params.id;
      this.ipAddress = params.ipAddress;
      this.port = params.port;
      this.secret = params.secret;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DcOption> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let ipv6 = flags & (1 << 0) ? true : false;
      let mediaOnly = flags & (1 << 1) ? true : false;
      let tcpoOnly = flags & (1 << 2) ? true : false;
      let cdn = flags & (1 << 3) ? true : false;
      let _static = flags & (1 << 4) ? true : false;
      let thisPortOnly = flags & (1 << 5) ? true : false;
      let id = await Primitive.Int.read(b);
      let ipAddress = await Primitive.String.read(b);
      let port = await Primitive.Int.read(b);
      let secret = flags & (1 << 10) ? await Primitive.Bytes.read(b) : undefined;
      return new Raw.DcOption({
        ipv6: ipv6,
        mediaOnly: mediaOnly,
        tcpoOnly: tcpoOnly,
        cdn: cdn,
        static: _static,
        thisPortOnly: thisPortOnly,
        id: id,
        ipAddress: ipAddress,
        port: port,
        secret: secret,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.ipv6 ? 1 << 0 : 0;
      flags |= this.mediaOnly ? 1 << 1 : 0;
      flags |= this.tcpoOnly ? 1 << 2 : 0;
      flags |= this.cdn ? 1 << 3 : 0;
      flags |= this.static ? 1 << 4 : 0;
      flags |= this.thisPortOnly ? 1 << 5 : 0;
      flags |= this.secret !== undefined ? 1 << 10 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.ipAddress !== undefined) {
        b.write(Primitive.String.write(this.ipAddress) as unknown as Buffer);
      }
      if (this.port !== undefined) {
        b.write(Primitive.Int.write(this.port) as unknown as Buffer);
      }
      if (this.secret !== undefined) {
        b.write(Primitive.Bytes.write(this.secret) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Config extends TLObject {
    defaultP2pContacts?: boolean;
    preloadFeaturedStickers?: boolean;
    revokePmInbox?: boolean;
    blockedMode?: boolean;
    forceTryIpv6?: boolean;
    date!: int;
    expires!: int;
    testMode!: Bool;
    thisDc!: int;
    dcOptions!: Vector<Raw.TypeDcOption>;
    dcTxtDomainName!: string;
    chatSizeMax!: int;
    megagroupSizeMax!: int;
    forwardedCountMax!: int;
    onlineUpdatePeriodMs!: int;
    offlineBlurTimeoutMs!: int;
    offlineIdleTimeoutMs!: int;
    onlineCloudTimeoutMs!: int;
    notifyCloudDelayMs!: int;
    notifyDefaultDelayMs!: int;
    pushChatPeriodMs!: int;
    pushChatLimit!: int;
    editTimeLimit!: int;
    revokeTimeLimit!: int;
    revokePmTimeLimit!: int;
    ratingEDecay!: int;
    stickersRecentLimit!: int;
    channelsReadMediaPeriod!: int;
    tmpSessions?: int;
    callReceiveTimeoutMs!: int;
    callRingTimeoutMs!: int;
    callConnectTimeoutMs!: int;
    callPacketTimeoutMs!: int;
    meUrlPrefix!: string;
    autoupdateUrlPrefix?: string;
    gifSearchUsername?: string;
    venueSearchUsername?: string;
    imgSearchUsername?: string;
    staticMapsProvider?: string;
    captionLengthMax!: int;
    messageLengthMax!: int;
    webfileDcId!: int;
    suggestedLangCode?: string;
    langPackVersion?: int;
    baseLangPackVersion?: int;
    reactionsDefault?: Raw.TypeReaction;
    autologinToken?: string;

    constructor(params: {
      defaultP2pContacts?: boolean;
      preloadFeaturedStickers?: boolean;
      revokePmInbox?: boolean;
      blockedMode?: boolean;
      forceTryIpv6?: boolean;
      date: int;
      expires: int;
      testMode: Bool;
      thisDc: int;
      dcOptions: Vector<Raw.TypeDcOption>;
      dcTxtDomainName: string;
      chatSizeMax: int;
      megagroupSizeMax: int;
      forwardedCountMax: int;
      onlineUpdatePeriodMs: int;
      offlineBlurTimeoutMs: int;
      offlineIdleTimeoutMs: int;
      onlineCloudTimeoutMs: int;
      notifyCloudDelayMs: int;
      notifyDefaultDelayMs: int;
      pushChatPeriodMs: int;
      pushChatLimit: int;
      editTimeLimit: int;
      revokeTimeLimit: int;
      revokePmTimeLimit: int;
      ratingEDecay: int;
      stickersRecentLimit: int;
      channelsReadMediaPeriod: int;
      tmpSessions?: int;
      callReceiveTimeoutMs: int;
      callRingTimeoutMs: int;
      callConnectTimeoutMs: int;
      callPacketTimeoutMs: int;
      meUrlPrefix: string;
      autoupdateUrlPrefix?: string;
      gifSearchUsername?: string;
      venueSearchUsername?: string;
      imgSearchUsername?: string;
      staticMapsProvider?: string;
      captionLengthMax: int;
      messageLengthMax: int;
      webfileDcId: int;
      suggestedLangCode?: string;
      langPackVersion?: int;
      baseLangPackVersion?: int;
      reactionsDefault?: Raw.TypeReaction;
      autologinToken?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Config';
      this.constructorId = 0xcc1a241e;
      this.subclassOfId = 0xd3262a4a;
      this._slots = [
        'defaultP2pContacts',
        'preloadFeaturedStickers',
        'revokePmInbox',
        'blockedMode',
        'forceTryIpv6',
        'date',
        'expires',
        'testMode',
        'thisDc',
        'dcOptions',
        'dcTxtDomainName',
        'chatSizeMax',
        'megagroupSizeMax',
        'forwardedCountMax',
        'onlineUpdatePeriodMs',
        'offlineBlurTimeoutMs',
        'offlineIdleTimeoutMs',
        'onlineCloudTimeoutMs',
        'notifyCloudDelayMs',
        'notifyDefaultDelayMs',
        'pushChatPeriodMs',
        'pushChatLimit',
        'editTimeLimit',
        'revokeTimeLimit',
        'revokePmTimeLimit',
        'ratingEDecay',
        'stickersRecentLimit',
        'channelsReadMediaPeriod',
        'tmpSessions',
        'callReceiveTimeoutMs',
        'callRingTimeoutMs',
        'callConnectTimeoutMs',
        'callPacketTimeoutMs',
        'meUrlPrefix',
        'autoupdateUrlPrefix',
        'gifSearchUsername',
        'venueSearchUsername',
        'imgSearchUsername',
        'staticMapsProvider',
        'captionLengthMax',
        'messageLengthMax',
        'webfileDcId',
        'suggestedLangCode',
        'langPackVersion',
        'baseLangPackVersion',
        'reactionsDefault',
        'autologinToken',
      ];
      this.defaultP2pContacts = params.defaultP2pContacts;
      this.preloadFeaturedStickers = params.preloadFeaturedStickers;
      this.revokePmInbox = params.revokePmInbox;
      this.blockedMode = params.blockedMode;
      this.forceTryIpv6 = params.forceTryIpv6;
      this.date = params.date;
      this.expires = params.expires;
      this.testMode = params.testMode;
      this.thisDc = params.thisDc;
      this.dcOptions = params.dcOptions;
      this.dcTxtDomainName = params.dcTxtDomainName;
      this.chatSizeMax = params.chatSizeMax;
      this.megagroupSizeMax = params.megagroupSizeMax;
      this.forwardedCountMax = params.forwardedCountMax;
      this.onlineUpdatePeriodMs = params.onlineUpdatePeriodMs;
      this.offlineBlurTimeoutMs = params.offlineBlurTimeoutMs;
      this.offlineIdleTimeoutMs = params.offlineIdleTimeoutMs;
      this.onlineCloudTimeoutMs = params.onlineCloudTimeoutMs;
      this.notifyCloudDelayMs = params.notifyCloudDelayMs;
      this.notifyDefaultDelayMs = params.notifyDefaultDelayMs;
      this.pushChatPeriodMs = params.pushChatPeriodMs;
      this.pushChatLimit = params.pushChatLimit;
      this.editTimeLimit = params.editTimeLimit;
      this.revokeTimeLimit = params.revokeTimeLimit;
      this.revokePmTimeLimit = params.revokePmTimeLimit;
      this.ratingEDecay = params.ratingEDecay;
      this.stickersRecentLimit = params.stickersRecentLimit;
      this.channelsReadMediaPeriod = params.channelsReadMediaPeriod;
      this.tmpSessions = params.tmpSessions;
      this.callReceiveTimeoutMs = params.callReceiveTimeoutMs;
      this.callRingTimeoutMs = params.callRingTimeoutMs;
      this.callConnectTimeoutMs = params.callConnectTimeoutMs;
      this.callPacketTimeoutMs = params.callPacketTimeoutMs;
      this.meUrlPrefix = params.meUrlPrefix;
      this.autoupdateUrlPrefix = params.autoupdateUrlPrefix;
      this.gifSearchUsername = params.gifSearchUsername;
      this.venueSearchUsername = params.venueSearchUsername;
      this.imgSearchUsername = params.imgSearchUsername;
      this.staticMapsProvider = params.staticMapsProvider;
      this.captionLengthMax = params.captionLengthMax;
      this.messageLengthMax = params.messageLengthMax;
      this.webfileDcId = params.webfileDcId;
      this.suggestedLangCode = params.suggestedLangCode;
      this.langPackVersion = params.langPackVersion;
      this.baseLangPackVersion = params.baseLangPackVersion;
      this.reactionsDefault = params.reactionsDefault;
      this.autologinToken = params.autologinToken;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Config> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let defaultP2pContacts = flags & (1 << 3) ? true : false;
      let preloadFeaturedStickers = flags & (1 << 4) ? true : false;
      let revokePmInbox = flags & (1 << 6) ? true : false;
      let blockedMode = flags & (1 << 8) ? true : false;
      let forceTryIpv6 = flags & (1 << 14) ? true : false;
      let date = await Primitive.Int.read(b);
      let expires = await Primitive.Int.read(b);
      let testMode = await Primitive.Bool.read(b);
      let thisDc = await Primitive.Int.read(b);
      let dcOptions = await TLObject.read(b);
      let dcTxtDomainName = await Primitive.String.read(b);
      let chatSizeMax = await Primitive.Int.read(b);
      let megagroupSizeMax = await Primitive.Int.read(b);
      let forwardedCountMax = await Primitive.Int.read(b);
      let onlineUpdatePeriodMs = await Primitive.Int.read(b);
      let offlineBlurTimeoutMs = await Primitive.Int.read(b);
      let offlineIdleTimeoutMs = await Primitive.Int.read(b);
      let onlineCloudTimeoutMs = await Primitive.Int.read(b);
      let notifyCloudDelayMs = await Primitive.Int.read(b);
      let notifyDefaultDelayMs = await Primitive.Int.read(b);
      let pushChatPeriodMs = await Primitive.Int.read(b);
      let pushChatLimit = await Primitive.Int.read(b);
      let editTimeLimit = await Primitive.Int.read(b);
      let revokeTimeLimit = await Primitive.Int.read(b);
      let revokePmTimeLimit = await Primitive.Int.read(b);
      let ratingEDecay = await Primitive.Int.read(b);
      let stickersRecentLimit = await Primitive.Int.read(b);
      let channelsReadMediaPeriod = await Primitive.Int.read(b);
      let tmpSessions = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let callReceiveTimeoutMs = await Primitive.Int.read(b);
      let callRingTimeoutMs = await Primitive.Int.read(b);
      let callConnectTimeoutMs = await Primitive.Int.read(b);
      let callPacketTimeoutMs = await Primitive.Int.read(b);
      let meUrlPrefix = await Primitive.String.read(b);
      let autoupdateUrlPrefix = flags & (1 << 7) ? await Primitive.String.read(b) : undefined;
      let gifSearchUsername = flags & (1 << 9) ? await Primitive.String.read(b) : undefined;
      let venueSearchUsername = flags & (1 << 10) ? await Primitive.String.read(b) : undefined;
      let imgSearchUsername = flags & (1 << 11) ? await Primitive.String.read(b) : undefined;
      let staticMapsProvider = flags & (1 << 12) ? await Primitive.String.read(b) : undefined;
      let captionLengthMax = await Primitive.Int.read(b);
      let messageLengthMax = await Primitive.Int.read(b);
      let webfileDcId = await Primitive.Int.read(b);
      let suggestedLangCode = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      let langPackVersion = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let baseLangPackVersion = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let reactionsDefault = flags & (1 << 15) ? await TLObject.read(b) : undefined;
      let autologinToken = flags & (1 << 16) ? await Primitive.String.read(b) : undefined;
      return new Raw.Config({
        defaultP2pContacts: defaultP2pContacts,
        preloadFeaturedStickers: preloadFeaturedStickers,
        revokePmInbox: revokePmInbox,
        blockedMode: blockedMode,
        forceTryIpv6: forceTryIpv6,
        date: date,
        expires: expires,
        testMode: testMode,
        thisDc: thisDc,
        dcOptions: dcOptions,
        dcTxtDomainName: dcTxtDomainName,
        chatSizeMax: chatSizeMax,
        megagroupSizeMax: megagroupSizeMax,
        forwardedCountMax: forwardedCountMax,
        onlineUpdatePeriodMs: onlineUpdatePeriodMs,
        offlineBlurTimeoutMs: offlineBlurTimeoutMs,
        offlineIdleTimeoutMs: offlineIdleTimeoutMs,
        onlineCloudTimeoutMs: onlineCloudTimeoutMs,
        notifyCloudDelayMs: notifyCloudDelayMs,
        notifyDefaultDelayMs: notifyDefaultDelayMs,
        pushChatPeriodMs: pushChatPeriodMs,
        pushChatLimit: pushChatLimit,
        editTimeLimit: editTimeLimit,
        revokeTimeLimit: revokeTimeLimit,
        revokePmTimeLimit: revokePmTimeLimit,
        ratingEDecay: ratingEDecay,
        stickersRecentLimit: stickersRecentLimit,
        channelsReadMediaPeriod: channelsReadMediaPeriod,
        tmpSessions: tmpSessions,
        callReceiveTimeoutMs: callReceiveTimeoutMs,
        callRingTimeoutMs: callRingTimeoutMs,
        callConnectTimeoutMs: callConnectTimeoutMs,
        callPacketTimeoutMs: callPacketTimeoutMs,
        meUrlPrefix: meUrlPrefix,
        autoupdateUrlPrefix: autoupdateUrlPrefix,
        gifSearchUsername: gifSearchUsername,
        venueSearchUsername: venueSearchUsername,
        imgSearchUsername: imgSearchUsername,
        staticMapsProvider: staticMapsProvider,
        captionLengthMax: captionLengthMax,
        messageLengthMax: messageLengthMax,
        webfileDcId: webfileDcId,
        suggestedLangCode: suggestedLangCode,
        langPackVersion: langPackVersion,
        baseLangPackVersion: baseLangPackVersion,
        reactionsDefault: reactionsDefault,
        autologinToken: autologinToken,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.defaultP2pContacts ? 1 << 3 : 0;
      flags |= this.preloadFeaturedStickers ? 1 << 4 : 0;
      flags |= this.revokePmInbox ? 1 << 6 : 0;
      flags |= this.blockedMode ? 1 << 8 : 0;
      flags |= this.forceTryIpv6 ? 1 << 14 : 0;
      flags |= this.tmpSessions !== undefined ? 1 << 0 : 0;
      flags |= this.autoupdateUrlPrefix !== undefined ? 1 << 7 : 0;
      flags |= this.gifSearchUsername !== undefined ? 1 << 9 : 0;
      flags |= this.venueSearchUsername !== undefined ? 1 << 10 : 0;
      flags |= this.imgSearchUsername !== undefined ? 1 << 11 : 0;
      flags |= this.staticMapsProvider !== undefined ? 1 << 12 : 0;
      flags |= this.suggestedLangCode !== undefined ? 1 << 2 : 0;
      flags |= this.langPackVersion !== undefined ? 1 << 2 : 0;
      flags |= this.baseLangPackVersion !== undefined ? 1 << 2 : 0;
      flags |= this.reactionsDefault !== undefined ? 1 << 15 : 0;
      flags |= this.autologinToken !== undefined ? 1 << 16 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.expires !== undefined) {
        b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
      }
      if (this.testMode !== undefined) {
        b.write(Primitive.Bool.write(this.testMode) as unknown as Buffer);
      }
      if (this.thisDc !== undefined) {
        b.write(Primitive.Int.write(this.thisDc) as unknown as Buffer);
      }
      if (this.dcOptions) {
        b.write(Primitive.Vector.write(this.dcOptions) as unknown as Buffer);
      }
      if (this.dcTxtDomainName !== undefined) {
        b.write(Primitive.String.write(this.dcTxtDomainName) as unknown as Buffer);
      }
      if (this.chatSizeMax !== undefined) {
        b.write(Primitive.Int.write(this.chatSizeMax) as unknown as Buffer);
      }
      if (this.megagroupSizeMax !== undefined) {
        b.write(Primitive.Int.write(this.megagroupSizeMax) as unknown as Buffer);
      }
      if (this.forwardedCountMax !== undefined) {
        b.write(Primitive.Int.write(this.forwardedCountMax) as unknown as Buffer);
      }
      if (this.onlineUpdatePeriodMs !== undefined) {
        b.write(Primitive.Int.write(this.onlineUpdatePeriodMs) as unknown as Buffer);
      }
      if (this.offlineBlurTimeoutMs !== undefined) {
        b.write(Primitive.Int.write(this.offlineBlurTimeoutMs) as unknown as Buffer);
      }
      if (this.offlineIdleTimeoutMs !== undefined) {
        b.write(Primitive.Int.write(this.offlineIdleTimeoutMs) as unknown as Buffer);
      }
      if (this.onlineCloudTimeoutMs !== undefined) {
        b.write(Primitive.Int.write(this.onlineCloudTimeoutMs) as unknown as Buffer);
      }
      if (this.notifyCloudDelayMs !== undefined) {
        b.write(Primitive.Int.write(this.notifyCloudDelayMs) as unknown as Buffer);
      }
      if (this.notifyDefaultDelayMs !== undefined) {
        b.write(Primitive.Int.write(this.notifyDefaultDelayMs) as unknown as Buffer);
      }
      if (this.pushChatPeriodMs !== undefined) {
        b.write(Primitive.Int.write(this.pushChatPeriodMs) as unknown as Buffer);
      }
      if (this.pushChatLimit !== undefined) {
        b.write(Primitive.Int.write(this.pushChatLimit) as unknown as Buffer);
      }
      if (this.editTimeLimit !== undefined) {
        b.write(Primitive.Int.write(this.editTimeLimit) as unknown as Buffer);
      }
      if (this.revokeTimeLimit !== undefined) {
        b.write(Primitive.Int.write(this.revokeTimeLimit) as unknown as Buffer);
      }
      if (this.revokePmTimeLimit !== undefined) {
        b.write(Primitive.Int.write(this.revokePmTimeLimit) as unknown as Buffer);
      }
      if (this.ratingEDecay !== undefined) {
        b.write(Primitive.Int.write(this.ratingEDecay) as unknown as Buffer);
      }
      if (this.stickersRecentLimit !== undefined) {
        b.write(Primitive.Int.write(this.stickersRecentLimit) as unknown as Buffer);
      }
      if (this.channelsReadMediaPeriod !== undefined) {
        b.write(Primitive.Int.write(this.channelsReadMediaPeriod) as unknown as Buffer);
      }
      if (this.tmpSessions !== undefined) {
        b.write(Primitive.Int.write(this.tmpSessions) as unknown as Buffer);
      }
      if (this.callReceiveTimeoutMs !== undefined) {
        b.write(Primitive.Int.write(this.callReceiveTimeoutMs) as unknown as Buffer);
      }
      if (this.callRingTimeoutMs !== undefined) {
        b.write(Primitive.Int.write(this.callRingTimeoutMs) as unknown as Buffer);
      }
      if (this.callConnectTimeoutMs !== undefined) {
        b.write(Primitive.Int.write(this.callConnectTimeoutMs) as unknown as Buffer);
      }
      if (this.callPacketTimeoutMs !== undefined) {
        b.write(Primitive.Int.write(this.callPacketTimeoutMs) as unknown as Buffer);
      }
      if (this.meUrlPrefix !== undefined) {
        b.write(Primitive.String.write(this.meUrlPrefix) as unknown as Buffer);
      }
      if (this.autoupdateUrlPrefix !== undefined) {
        b.write(Primitive.String.write(this.autoupdateUrlPrefix) as unknown as Buffer);
      }
      if (this.gifSearchUsername !== undefined) {
        b.write(Primitive.String.write(this.gifSearchUsername) as unknown as Buffer);
      }
      if (this.venueSearchUsername !== undefined) {
        b.write(Primitive.String.write(this.venueSearchUsername) as unknown as Buffer);
      }
      if (this.imgSearchUsername !== undefined) {
        b.write(Primitive.String.write(this.imgSearchUsername) as unknown as Buffer);
      }
      if (this.staticMapsProvider !== undefined) {
        b.write(Primitive.String.write(this.staticMapsProvider) as unknown as Buffer);
      }
      if (this.captionLengthMax !== undefined) {
        b.write(Primitive.Int.write(this.captionLengthMax) as unknown as Buffer);
      }
      if (this.messageLengthMax !== undefined) {
        b.write(Primitive.Int.write(this.messageLengthMax) as unknown as Buffer);
      }
      if (this.webfileDcId !== undefined) {
        b.write(Primitive.Int.write(this.webfileDcId) as unknown as Buffer);
      }
      if (this.suggestedLangCode !== undefined) {
        b.write(Primitive.String.write(this.suggestedLangCode) as unknown as Buffer);
      }
      if (this.langPackVersion !== undefined) {
        b.write(Primitive.Int.write(this.langPackVersion) as unknown as Buffer);
      }
      if (this.baseLangPackVersion !== undefined) {
        b.write(Primitive.Int.write(this.baseLangPackVersion) as unknown as Buffer);
      }
      if (this.reactionsDefault !== undefined) {
        b.write(this.reactionsDefault.write() as unknown as Buffer);
      }
      if (this.autologinToken !== undefined) {
        b.write(Primitive.String.write(this.autologinToken) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class NearestDc extends TLObject {
    country!: string;
    thisDc!: int;
    nearestDc!: int;

    constructor(params: { country: string; thisDc: int; nearestDc: int }) {
      super();
      this.classType = 'types';
      this.className = 'NearestDc';
      this.constructorId = 0x8e1a1775;
      this.subclassOfId = 0x3877045f;
      this._slots = ['country', 'thisDc', 'nearestDc'];
      this.country = params.country;
      this.thisDc = params.thisDc;
      this.nearestDc = params.nearestDc;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.NearestDc> {
      // no flags

      let country = await Primitive.String.read(b);
      let thisDc = await Primitive.Int.read(b);
      let nearestDc = await Primitive.Int.read(b);
      return new Raw.NearestDc({ country: country, thisDc: thisDc, nearestDc: nearestDc });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.country !== undefined) {
        b.write(Primitive.String.write(this.country) as unknown as Buffer);
      }
      if (this.thisDc !== undefined) {
        b.write(Primitive.Int.write(this.thisDc) as unknown as Buffer);
      }
      if (this.nearestDc !== undefined) {
        b.write(Primitive.Int.write(this.nearestDc) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EncryptedChatEmpty extends TLObject {
    id!: int;

    constructor(params: { id: int }) {
      super();
      this.classType = 'types';
      this.className = 'EncryptedChatEmpty';
      this.constructorId = 0xab7ec0a0;
      this.subclassOfId = 0x6d28a37a;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EncryptedChatEmpty> {
      // no flags

      let id = await Primitive.Int.read(b);
      return new Raw.EncryptedChatEmpty({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EncryptedChatWaiting extends TLObject {
    id!: int;
    accessHash!: long;
    date!: int;
    adminId!: long;
    participantId!: long;

    constructor(params: {
      id: int;
      accessHash: long;
      date: int;
      adminId: long;
      participantId: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'EncryptedChatWaiting';
      this.constructorId = 0x66b25953;
      this.subclassOfId = 0x6d28a37a;
      this._slots = ['id', 'accessHash', 'date', 'adminId', 'participantId'];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.date = params.date;
      this.adminId = params.adminId;
      this.participantId = params.participantId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EncryptedChatWaiting> {
      // no flags

      let id = await Primitive.Int.read(b);
      let accessHash = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let adminId = await Primitive.Long.read(b);
      let participantId = await Primitive.Long.read(b);
      return new Raw.EncryptedChatWaiting({
        id: id,
        accessHash: accessHash,
        date: date,
        adminId: adminId,
        participantId: participantId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.adminId !== undefined) {
        b.write(Primitive.Long.write(this.adminId) as unknown as Buffer);
      }
      if (this.participantId !== undefined) {
        b.write(Primitive.Long.write(this.participantId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EncryptedChatRequested extends TLObject {
    folderId?: int;
    id!: int;
    accessHash!: long;
    date!: int;
    adminId!: long;
    participantId!: long;
    gA!: bytes;

    constructor(params: {
      folderId?: int;
      id: int;
      accessHash: long;
      date: int;
      adminId: long;
      participantId: long;
      gA: bytes;
    }) {
      super();
      this.classType = 'types';
      this.className = 'EncryptedChatRequested';
      this.constructorId = 0x48f1d94c;
      this.subclassOfId = 0x6d28a37a;
      this._slots = ['folderId', 'id', 'accessHash', 'date', 'adminId', 'participantId', 'gA'];
      this.folderId = params.folderId;
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.date = params.date;
      this.adminId = params.adminId;
      this.participantId = params.participantId;
      this.gA = params.gA;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EncryptedChatRequested> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let folderId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let id = await Primitive.Int.read(b);
      let accessHash = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let adminId = await Primitive.Long.read(b);
      let participantId = await Primitive.Long.read(b);
      let gA = await Primitive.Bytes.read(b);
      return new Raw.EncryptedChatRequested({
        folderId: folderId,
        id: id,
        accessHash: accessHash,
        date: date,
        adminId: adminId,
        participantId: participantId,
        gA: gA,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.folderId !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.adminId !== undefined) {
        b.write(Primitive.Long.write(this.adminId) as unknown as Buffer);
      }
      if (this.participantId !== undefined) {
        b.write(Primitive.Long.write(this.participantId) as unknown as Buffer);
      }
      if (this.gA !== undefined) {
        b.write(Primitive.Bytes.write(this.gA) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EncryptedChat extends TLObject {
    id!: int;
    accessHash!: long;
    date!: int;
    adminId!: long;
    participantId!: long;
    gAOrB!: bytes;
    keyFingerprint!: long;

    constructor(params: {
      id: int;
      accessHash: long;
      date: int;
      adminId: long;
      participantId: long;
      gAOrB: bytes;
      keyFingerprint: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'EncryptedChat';
      this.constructorId = 0x61f0d4c7;
      this.subclassOfId = 0x6d28a37a;
      this._slots = [
        'id',
        'accessHash',
        'date',
        'adminId',
        'participantId',
        'gAOrB',
        'keyFingerprint',
      ];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.date = params.date;
      this.adminId = params.adminId;
      this.participantId = params.participantId;
      this.gAOrB = params.gAOrB;
      this.keyFingerprint = params.keyFingerprint;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EncryptedChat> {
      // no flags

      let id = await Primitive.Int.read(b);
      let accessHash = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let adminId = await Primitive.Long.read(b);
      let participantId = await Primitive.Long.read(b);
      let gAOrB = await Primitive.Bytes.read(b);
      let keyFingerprint = await Primitive.Long.read(b);
      return new Raw.EncryptedChat({
        id: id,
        accessHash: accessHash,
        date: date,
        adminId: adminId,
        participantId: participantId,
        gAOrB: gAOrB,
        keyFingerprint: keyFingerprint,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.adminId !== undefined) {
        b.write(Primitive.Long.write(this.adminId) as unknown as Buffer);
      }
      if (this.participantId !== undefined) {
        b.write(Primitive.Long.write(this.participantId) as unknown as Buffer);
      }
      if (this.gAOrB !== undefined) {
        b.write(Primitive.Bytes.write(this.gAOrB) as unknown as Buffer);
      }
      if (this.keyFingerprint !== undefined) {
        b.write(Primitive.Long.write(this.keyFingerprint) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EncryptedChatDiscarded extends TLObject {
    historyDeleted?: boolean;
    id!: int;

    constructor(params: { historyDeleted?: boolean; id: int }) {
      super();
      this.classType = 'types';
      this.className = 'EncryptedChatDiscarded';
      this.constructorId = 0x1e1c7c45;
      this.subclassOfId = 0x6d28a37a;
      this._slots = ['historyDeleted', 'id'];
      this.historyDeleted = params.historyDeleted;
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EncryptedChatDiscarded> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let historyDeleted = flags & (1 << 0) ? true : false;
      let id = await Primitive.Int.read(b);
      return new Raw.EncryptedChatDiscarded({ historyDeleted: historyDeleted, id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.historyDeleted ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputEncryptedChat extends TLObject {
    chatId!: int;
    accessHash!: long;

    constructor(params: { chatId: int; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputEncryptedChat';
      this.constructorId = 0xf141b5e1;
      this.subclassOfId = 0x6c7606c0;
      this._slots = ['chatId', 'accessHash'];
      this.chatId = params.chatId;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputEncryptedChat> {
      // no flags

      let chatId = await Primitive.Int.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputEncryptedChat({ chatId: chatId, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chatId !== undefined) {
        b.write(Primitive.Int.write(this.chatId) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EncryptedFileEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'EncryptedFileEmpty';
      this.constructorId = 0xc21f497e;
      this.subclassOfId = 0x842a67c0;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EncryptedFileEmpty> {
      // no flags

      return new Raw.EncryptedFileEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class EncryptedFile extends TLObject {
    id!: long;
    accessHash!: long;
    size!: long;
    dcId!: int;
    keyFingerprint!: int;

    constructor(params: {
      id: long;
      accessHash: long;
      size: long;
      dcId: int;
      keyFingerprint: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'EncryptedFile';
      this.constructorId = 0xa8008cd8;
      this.subclassOfId = 0x842a67c0;
      this._slots = ['id', 'accessHash', 'size', 'dcId', 'keyFingerprint'];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.size = params.size;
      this.dcId = params.dcId;
      this.keyFingerprint = params.keyFingerprint;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EncryptedFile> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let size = await Primitive.Long.read(b);
      let dcId = await Primitive.Int.read(b);
      let keyFingerprint = await Primitive.Int.read(b);
      return new Raw.EncryptedFile({
        id: id,
        accessHash: accessHash,
        size: size,
        dcId: dcId,
        keyFingerprint: keyFingerprint,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Long.write(this.size) as unknown as Buffer);
      }
      if (this.dcId !== undefined) {
        b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
      }
      if (this.keyFingerprint !== undefined) {
        b.write(Primitive.Int.write(this.keyFingerprint) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputEncryptedFileEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputEncryptedFileEmpty';
      this.constructorId = 0x1837c364;
      this.subclassOfId = 0x8574c27a;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputEncryptedFileEmpty> {
      // no flags

      return new Raw.InputEncryptedFileEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputEncryptedFileUploaded extends TLObject {
    id!: long;
    parts!: int;
    md5Checksum!: string;
    keyFingerprint!: int;

    constructor(params: { id: long; parts: int; md5Checksum: string; keyFingerprint: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputEncryptedFileUploaded';
      this.constructorId = 0x64bd0306;
      this.subclassOfId = 0x8574c27a;
      this._slots = ['id', 'parts', 'md5Checksum', 'keyFingerprint'];
      this.id = params.id;
      this.parts = params.parts;
      this.md5Checksum = params.md5Checksum;
      this.keyFingerprint = params.keyFingerprint;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputEncryptedFileUploaded> {
      // no flags

      let id = await Primitive.Long.read(b);
      let parts = await Primitive.Int.read(b);
      let md5Checksum = await Primitive.String.read(b);
      let keyFingerprint = await Primitive.Int.read(b);
      return new Raw.InputEncryptedFileUploaded({
        id: id,
        parts: parts,
        md5Checksum: md5Checksum,
        keyFingerprint: keyFingerprint,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.parts !== undefined) {
        b.write(Primitive.Int.write(this.parts) as unknown as Buffer);
      }
      if (this.md5Checksum !== undefined) {
        b.write(Primitive.String.write(this.md5Checksum) as unknown as Buffer);
      }
      if (this.keyFingerprint !== undefined) {
        b.write(Primitive.Int.write(this.keyFingerprint) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputEncryptedFile extends TLObject {
    id!: long;
    accessHash!: long;

    constructor(params: { id: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputEncryptedFile';
      this.constructorId = 0x5a17b5e5;
      this.subclassOfId = 0x8574c27a;
      this._slots = ['id', 'accessHash'];
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputEncryptedFile> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputEncryptedFile({ id: id, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputEncryptedFileBigUploaded extends TLObject {
    id!: long;
    parts!: int;
    keyFingerprint!: int;

    constructor(params: { id: long; parts: int; keyFingerprint: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputEncryptedFileBigUploaded';
      this.constructorId = 0x2dc173c8;
      this.subclassOfId = 0x8574c27a;
      this._slots = ['id', 'parts', 'keyFingerprint'];
      this.id = params.id;
      this.parts = params.parts;
      this.keyFingerprint = params.keyFingerprint;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputEncryptedFileBigUploaded> {
      // no flags

      let id = await Primitive.Long.read(b);
      let parts = await Primitive.Int.read(b);
      let keyFingerprint = await Primitive.Int.read(b);
      return new Raw.InputEncryptedFileBigUploaded({
        id: id,
        parts: parts,
        keyFingerprint: keyFingerprint,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.parts !== undefined) {
        b.write(Primitive.Int.write(this.parts) as unknown as Buffer);
      }
      if (this.keyFingerprint !== undefined) {
        b.write(Primitive.Int.write(this.keyFingerprint) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EncryptedMessage extends TLObject {
    randomId!: long;
    chatId!: int;
    date!: int;
    bytes!: bytes;
    file!: Raw.TypeEncryptedFile;

    constructor(params: {
      randomId: long;
      chatId: int;
      date: int;
      bytes: bytes;
      file: Raw.TypeEncryptedFile;
    }) {
      super();
      this.classType = 'types';
      this.className = 'EncryptedMessage';
      this.constructorId = 0xed18c118;
      this.subclassOfId = 0x239f2e51;
      this._slots = ['randomId', 'chatId', 'date', 'bytes', 'file'];
      this.randomId = params.randomId;
      this.chatId = params.chatId;
      this.date = params.date;
      this.bytes = params.bytes;
      this.file = params.file;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EncryptedMessage> {
      // no flags

      let randomId = await Primitive.Long.read(b);
      let chatId = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      let bytes = await Primitive.Bytes.read(b);
      let file = await TLObject.read(b);
      return new Raw.EncryptedMessage({
        randomId: randomId,
        chatId: chatId,
        date: date,
        bytes: bytes,
        file: file,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.randomId !== undefined) {
        b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
      }
      if (this.chatId !== undefined) {
        b.write(Primitive.Int.write(this.chatId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.bytes !== undefined) {
        b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
      }
      if (this.file !== undefined) {
        b.write(this.file.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EncryptedMessageService extends TLObject {
    randomId!: long;
    chatId!: int;
    date!: int;
    bytes!: bytes;

    constructor(params: { randomId: long; chatId: int; date: int; bytes: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'EncryptedMessageService';
      this.constructorId = 0x23734b06;
      this.subclassOfId = 0x239f2e51;
      this._slots = ['randomId', 'chatId', 'date', 'bytes'];
      this.randomId = params.randomId;
      this.chatId = params.chatId;
      this.date = params.date;
      this.bytes = params.bytes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EncryptedMessageService> {
      // no flags

      let randomId = await Primitive.Long.read(b);
      let chatId = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      let bytes = await Primitive.Bytes.read(b);
      return new Raw.EncryptedMessageService({
        randomId: randomId,
        chatId: chatId,
        date: date,
        bytes: bytes,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.randomId !== undefined) {
        b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
      }
      if (this.chatId !== undefined) {
        b.write(Primitive.Int.write(this.chatId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.bytes !== undefined) {
        b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputDocumentEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputDocumentEmpty';
      this.constructorId = 0x72f0eaae;
      this.subclassOfId = 0xf33fdb68;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputDocumentEmpty> {
      // no flags

      return new Raw.InputDocumentEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputDocument extends TLObject {
    id!: long;
    accessHash!: long;
    fileReference!: bytes;

    constructor(params: { id: long; accessHash: long; fileReference: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'InputDocument';
      this.constructorId = 0x1abfb575;
      this.subclassOfId = 0xf33fdb68;
      this._slots = ['id', 'accessHash', 'fileReference'];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.fileReference = params.fileReference;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputDocument> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let fileReference = await Primitive.Bytes.read(b);
      return new Raw.InputDocument({
        id: id,
        accessHash: accessHash,
        fileReference: fileReference,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.fileReference !== undefined) {
        b.write(Primitive.Bytes.write(this.fileReference) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DocumentEmpty extends TLObject {
    id!: long;

    constructor(params: { id: long }) {
      super();
      this.classType = 'types';
      this.className = 'DocumentEmpty';
      this.constructorId = 0x36f8c871;
      this.subclassOfId = 0x211fe820;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentEmpty> {
      // no flags

      let id = await Primitive.Long.read(b);
      return new Raw.DocumentEmpty({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Document extends TLObject {
    id!: long;
    accessHash!: long;
    fileReference!: bytes;
    date!: int;
    mimeType!: string;
    size!: long;
    thumbs?: Vector<Raw.TypePhotoSize>;
    videoThumbs?: Vector<Raw.TypeVideoSize>;
    dcId!: int;
    attributes!: Vector<Raw.TypeDocumentAttribute>;

    constructor(params: {
      id: long;
      accessHash: long;
      fileReference: bytes;
      date: int;
      mimeType: string;
      size: long;
      thumbs?: Vector<Raw.TypePhotoSize>;
      videoThumbs?: Vector<Raw.TypeVideoSize>;
      dcId: int;
      attributes: Vector<Raw.TypeDocumentAttribute>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Document';
      this.constructorId = 0x8fd4c4d8;
      this.subclassOfId = 0x211fe820;
      this._slots = [
        'id',
        'accessHash',
        'fileReference',
        'date',
        'mimeType',
        'size',
        'thumbs',
        'videoThumbs',
        'dcId',
        'attributes',
      ];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.fileReference = params.fileReference;
      this.date = params.date;
      this.mimeType = params.mimeType;
      this.size = params.size;
      this.thumbs = params.thumbs;
      this.videoThumbs = params.videoThumbs;
      this.dcId = params.dcId;
      this.attributes = params.attributes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Document> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let fileReference = await Primitive.Bytes.read(b);
      let date = await Primitive.Int.read(b);
      let mimeType = await Primitive.String.read(b);
      let size = await Primitive.Long.read(b);
      let thumbs = flags & (1 << 0) ? await TLObject.read(b) : [];
      let videoThumbs = flags & (1 << 1) ? await TLObject.read(b) : [];
      let dcId = await Primitive.Int.read(b);
      let attributes = await TLObject.read(b);
      return new Raw.Document({
        id: id,
        accessHash: accessHash,
        fileReference: fileReference,
        date: date,
        mimeType: mimeType,
        size: size,
        thumbs: thumbs,
        videoThumbs: videoThumbs,
        dcId: dcId,
        attributes: attributes,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.thumbs ? 1 << 0 : 0;
      flags |= this.videoThumbs ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.fileReference !== undefined) {
        b.write(Primitive.Bytes.write(this.fileReference) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.mimeType !== undefined) {
        b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Long.write(this.size) as unknown as Buffer);
      }
      if (this.thumbs) {
        b.write(Primitive.Vector.write(this.thumbs) as unknown as Buffer);
      }
      if (this.videoThumbs) {
        b.write(Primitive.Vector.write(this.videoThumbs) as unknown as Buffer);
      }
      if (this.dcId !== undefined) {
        b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
      }
      if (this.attributes) {
        b.write(Primitive.Vector.write(this.attributes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class NotifyPeer extends TLObject {
    peer!: Raw.TypePeer;

    constructor(params: { peer: Raw.TypePeer }) {
      super();
      this.classType = 'types';
      this.className = 'NotifyPeer';
      this.constructorId = 0x9fd40bd8;
      this.subclassOfId = 0xdfe8602e;
      this._slots = ['peer'];
      this.peer = params.peer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.NotifyPeer> {
      // no flags

      let peer = await TLObject.read(b);
      return new Raw.NotifyPeer({ peer: peer });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class NotifyUsers extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'NotifyUsers';
      this.constructorId = 0xb4c83b4c;
      this.subclassOfId = 0xdfe8602e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.NotifyUsers> {
      // no flags

      return new Raw.NotifyUsers();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class NotifyChats extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'NotifyChats';
      this.constructorId = 0xc007cec3;
      this.subclassOfId = 0xdfe8602e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.NotifyChats> {
      // no flags

      return new Raw.NotifyChats();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class NotifyBroadcasts extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'NotifyBroadcasts';
      this.constructorId = 0xd612e8ef;
      this.subclassOfId = 0xdfe8602e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.NotifyBroadcasts> {
      // no flags

      return new Raw.NotifyBroadcasts();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class NotifyForumTopic extends TLObject {
    peer!: Raw.TypePeer;
    topMsgId!: int;

    constructor(params: { peer: Raw.TypePeer; topMsgId: int }) {
      super();
      this.classType = 'types';
      this.className = 'NotifyForumTopic';
      this.constructorId = 0x226e6308;
      this.subclassOfId = 0xdfe8602e;
      this._slots = ['peer', 'topMsgId'];
      this.peer = params.peer;
      this.topMsgId = params.topMsgId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.NotifyForumTopic> {
      // no flags

      let peer = await TLObject.read(b);
      let topMsgId = await Primitive.Int.read(b);
      return new Raw.NotifyForumTopic({ peer: peer, topMsgId: topMsgId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.topMsgId !== undefined) {
        b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SendMessageTypingAction extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageTypingAction';
      this.constructorId = 0x16bf744e;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendMessageTypingAction> {
      // no flags

      return new Raw.SendMessageTypingAction();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageCancelAction extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageCancelAction';
      this.constructorId = 0xfd5ec8f5;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendMessageCancelAction> {
      // no flags

      return new Raw.SendMessageCancelAction();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageRecordVideoAction extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageRecordVideoAction';
      this.constructorId = 0xa187d66f;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendMessageRecordVideoAction> {
      // no flags

      return new Raw.SendMessageRecordVideoAction();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageUploadVideoAction extends TLObject {
    progress!: int;

    constructor(params: { progress: int }) {
      super();
      this.classType = 'types';
      this.className = 'SendMessageUploadVideoAction';
      this.constructorId = 0xe9763aec;
      this.subclassOfId = 0x20b2cc21;
      this._slots = ['progress'];
      this.progress = params.progress;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendMessageUploadVideoAction> {
      // no flags

      let progress = await Primitive.Int.read(b);
      return new Raw.SendMessageUploadVideoAction({ progress: progress });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.progress !== undefined) {
        b.write(Primitive.Int.write(this.progress) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SendMessageRecordAudioAction extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageRecordAudioAction';
      this.constructorId = 0xd52f73f7;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendMessageRecordAudioAction> {
      // no flags

      return new Raw.SendMessageRecordAudioAction();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageUploadAudioAction extends TLObject {
    progress!: int;

    constructor(params: { progress: int }) {
      super();
      this.classType = 'types';
      this.className = 'SendMessageUploadAudioAction';
      this.constructorId = 0xf351d7ab;
      this.subclassOfId = 0x20b2cc21;
      this._slots = ['progress'];
      this.progress = params.progress;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendMessageUploadAudioAction> {
      // no flags

      let progress = await Primitive.Int.read(b);
      return new Raw.SendMessageUploadAudioAction({ progress: progress });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.progress !== undefined) {
        b.write(Primitive.Int.write(this.progress) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SendMessageUploadPhotoAction extends TLObject {
    progress!: int;

    constructor(params: { progress: int }) {
      super();
      this.classType = 'types';
      this.className = 'SendMessageUploadPhotoAction';
      this.constructorId = 0xd1d34a26;
      this.subclassOfId = 0x20b2cc21;
      this._slots = ['progress'];
      this.progress = params.progress;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendMessageUploadPhotoAction> {
      // no flags

      let progress = await Primitive.Int.read(b);
      return new Raw.SendMessageUploadPhotoAction({ progress: progress });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.progress !== undefined) {
        b.write(Primitive.Int.write(this.progress) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SendMessageUploadDocumentAction extends TLObject {
    progress!: int;

    constructor(params: { progress: int }) {
      super();
      this.classType = 'types';
      this.className = 'SendMessageUploadDocumentAction';
      this.constructorId = 0xaa0cd9e4;
      this.subclassOfId = 0x20b2cc21;
      this._slots = ['progress'];
      this.progress = params.progress;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SendMessageUploadDocumentAction> {
      // no flags

      let progress = await Primitive.Int.read(b);
      return new Raw.SendMessageUploadDocumentAction({ progress: progress });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.progress !== undefined) {
        b.write(Primitive.Int.write(this.progress) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SendMessageGeoLocationAction extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageGeoLocationAction';
      this.constructorId = 0x176f8ba1;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendMessageGeoLocationAction> {
      // no flags

      return new Raw.SendMessageGeoLocationAction();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageChooseContactAction extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageChooseContactAction';
      this.constructorId = 0x628cbc6f;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SendMessageChooseContactAction> {
      // no flags

      return new Raw.SendMessageChooseContactAction();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageGamePlayAction extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageGamePlayAction';
      this.constructorId = 0xdd6a8f48;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendMessageGamePlayAction> {
      // no flags

      return new Raw.SendMessageGamePlayAction();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageRecordRoundAction extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageRecordRoundAction';
      this.constructorId = 0x88f27fbc;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendMessageRecordRoundAction> {
      // no flags

      return new Raw.SendMessageRecordRoundAction();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageUploadRoundAction extends TLObject {
    progress!: int;

    constructor(params: { progress: int }) {
      super();
      this.classType = 'types';
      this.className = 'SendMessageUploadRoundAction';
      this.constructorId = 0x243e1c66;
      this.subclassOfId = 0x20b2cc21;
      this._slots = ['progress'];
      this.progress = params.progress;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendMessageUploadRoundAction> {
      // no flags

      let progress = await Primitive.Int.read(b);
      return new Raw.SendMessageUploadRoundAction({ progress: progress });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.progress !== undefined) {
        b.write(Primitive.Int.write(this.progress) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SpeakingInGroupCallAction extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SpeakingInGroupCallAction';
      this.constructorId = 0xd92c2285;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SpeakingInGroupCallAction> {
      // no flags

      return new Raw.SpeakingInGroupCallAction();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageHistoryImportAction extends TLObject {
    progress!: int;

    constructor(params: { progress: int }) {
      super();
      this.classType = 'types';
      this.className = 'SendMessageHistoryImportAction';
      this.constructorId = 0xdbda9246;
      this.subclassOfId = 0x20b2cc21;
      this._slots = ['progress'];
      this.progress = params.progress;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SendMessageHistoryImportAction> {
      // no flags

      let progress = await Primitive.Int.read(b);
      return new Raw.SendMessageHistoryImportAction({ progress: progress });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.progress !== undefined) {
        b.write(Primitive.Int.write(this.progress) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SendMessageChooseStickerAction extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageChooseStickerAction';
      this.constructorId = 0xb05ac6b1;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SendMessageChooseStickerAction> {
      // no flags

      return new Raw.SendMessageChooseStickerAction();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageEmojiInteraction extends TLObject {
    emoticon!: string;
    msgId!: int;
    interaction!: Raw.TypeDataJSON;

    constructor(params: { emoticon: string; msgId: int; interaction: Raw.TypeDataJSON }) {
      super();
      this.classType = 'types';
      this.className = 'SendMessageEmojiInteraction';
      this.constructorId = 0x25972bcb;
      this.subclassOfId = 0x20b2cc21;
      this._slots = ['emoticon', 'msgId', 'interaction'];
      this.emoticon = params.emoticon;
      this.msgId = params.msgId;
      this.interaction = params.interaction;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendMessageEmojiInteraction> {
      // no flags

      let emoticon = await Primitive.String.read(b);
      let msgId = await Primitive.Int.read(b);
      let interaction = await TLObject.read(b);
      return new Raw.SendMessageEmojiInteraction({
        emoticon: emoticon,
        msgId: msgId,
        interaction: interaction,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.emoticon !== undefined) {
        b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      if (this.interaction !== undefined) {
        b.write(this.interaction.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SendMessageEmojiInteractionSeen extends TLObject {
    emoticon!: string;

    constructor(params: { emoticon: string }) {
      super();
      this.classType = 'types';
      this.className = 'SendMessageEmojiInteractionSeen';
      this.constructorId = 0xb665902e;
      this.subclassOfId = 0x20b2cc21;
      this._slots = ['emoticon'];
      this.emoticon = params.emoticon;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SendMessageEmojiInteractionSeen> {
      // no flags

      let emoticon = await Primitive.String.read(b);
      return new Raw.SendMessageEmojiInteractionSeen({ emoticon: emoticon });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.emoticon !== undefined) {
        b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPrivacyKeyStatusTimestamp extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyKeyStatusTimestamp';
      this.constructorId = 0x4f96cb18;
      this.subclassOfId = 0x53627f8;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputPrivacyKeyStatusTimestamp> {
      // no flags

      return new Raw.InputPrivacyKeyStatusTimestamp();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyKeyChatInvite extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyKeyChatInvite';
      this.constructorId = 0xbdfb0426;
      this.subclassOfId = 0x53627f8;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPrivacyKeyChatInvite> {
      // no flags

      return new Raw.InputPrivacyKeyChatInvite();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyKeyPhoneCall extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyKeyPhoneCall';
      this.constructorId = 0xfabadc5f;
      this.subclassOfId = 0x53627f8;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPrivacyKeyPhoneCall> {
      // no flags

      return new Raw.InputPrivacyKeyPhoneCall();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyKeyPhoneP2P extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyKeyPhoneP2P';
      this.constructorId = 0xdb9e70d2;
      this.subclassOfId = 0x53627f8;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPrivacyKeyPhoneP2P> {
      // no flags

      return new Raw.InputPrivacyKeyPhoneP2P();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyKeyForwards extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyKeyForwards';
      this.constructorId = 0xa4dd4c08;
      this.subclassOfId = 0x53627f8;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPrivacyKeyForwards> {
      // no flags

      return new Raw.InputPrivacyKeyForwards();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyKeyProfilePhoto extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyKeyProfilePhoto';
      this.constructorId = 0x5719bacc;
      this.subclassOfId = 0x53627f8;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPrivacyKeyProfilePhoto> {
      // no flags

      return new Raw.InputPrivacyKeyProfilePhoto();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyKeyPhoneNumber extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyKeyPhoneNumber';
      this.constructorId = 0x352dafa;
      this.subclassOfId = 0x53627f8;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPrivacyKeyPhoneNumber> {
      // no flags

      return new Raw.InputPrivacyKeyPhoneNumber();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyKeyAddedByPhone extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyKeyAddedByPhone';
      this.constructorId = 0xd1219bdd;
      this.subclassOfId = 0x53627f8;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPrivacyKeyAddedByPhone> {
      // no flags

      return new Raw.InputPrivacyKeyAddedByPhone();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyKeyVoiceMessages extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyKeyVoiceMessages';
      this.constructorId = 0xaee69d68;
      this.subclassOfId = 0x53627f8;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPrivacyKeyVoiceMessages> {
      // no flags

      return new Raw.InputPrivacyKeyVoiceMessages();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyKeyAbout extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyKeyAbout';
      this.constructorId = 0x3823cc40;
      this.subclassOfId = 0x53627f8;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPrivacyKeyAbout> {
      // no flags

      return new Raw.InputPrivacyKeyAbout();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyKeyStatusTimestamp extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyKeyStatusTimestamp';
      this.constructorId = 0xbc2eab30;
      this.subclassOfId = 0x824651c3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyKeyStatusTimestamp> {
      // no flags

      return new Raw.PrivacyKeyStatusTimestamp();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyKeyChatInvite extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyKeyChatInvite';
      this.constructorId = 0x500e6dfa;
      this.subclassOfId = 0x824651c3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyKeyChatInvite> {
      // no flags

      return new Raw.PrivacyKeyChatInvite();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyKeyPhoneCall extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyKeyPhoneCall';
      this.constructorId = 0x3d662b7b;
      this.subclassOfId = 0x824651c3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyKeyPhoneCall> {
      // no flags

      return new Raw.PrivacyKeyPhoneCall();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyKeyPhoneP2P extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyKeyPhoneP2P';
      this.constructorId = 0x39491cc8;
      this.subclassOfId = 0x824651c3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyKeyPhoneP2P> {
      // no flags

      return new Raw.PrivacyKeyPhoneP2P();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyKeyForwards extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyKeyForwards';
      this.constructorId = 0x69ec56a3;
      this.subclassOfId = 0x824651c3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyKeyForwards> {
      // no flags

      return new Raw.PrivacyKeyForwards();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyKeyProfilePhoto extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyKeyProfilePhoto';
      this.constructorId = 0x96151fed;
      this.subclassOfId = 0x824651c3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyKeyProfilePhoto> {
      // no flags

      return new Raw.PrivacyKeyProfilePhoto();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyKeyPhoneNumber extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyKeyPhoneNumber';
      this.constructorId = 0xd19ae46d;
      this.subclassOfId = 0x824651c3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyKeyPhoneNumber> {
      // no flags

      return new Raw.PrivacyKeyPhoneNumber();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyKeyAddedByPhone extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyKeyAddedByPhone';
      this.constructorId = 0x42ffd42b;
      this.subclassOfId = 0x824651c3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyKeyAddedByPhone> {
      // no flags

      return new Raw.PrivacyKeyAddedByPhone();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyKeyVoiceMessages extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyKeyVoiceMessages';
      this.constructorId = 0x697f414;
      this.subclassOfId = 0x824651c3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyKeyVoiceMessages> {
      // no flags

      return new Raw.PrivacyKeyVoiceMessages();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyKeyAbout extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyKeyAbout';
      this.constructorId = 0xa486b761;
      this.subclassOfId = 0x824651c3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyKeyAbout> {
      // no flags

      return new Raw.PrivacyKeyAbout();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyValueAllowContacts extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyValueAllowContacts';
      this.constructorId = 0xd09e07b;
      this.subclassOfId = 0x5a3b6b22;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputPrivacyValueAllowContacts> {
      // no flags

      return new Raw.InputPrivacyValueAllowContacts();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyValueAllowAll extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyValueAllowAll';
      this.constructorId = 0x184b35ce;
      this.subclassOfId = 0x5a3b6b22;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPrivacyValueAllowAll> {
      // no flags

      return new Raw.InputPrivacyValueAllowAll();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyValueAllowUsers extends TLObject {
    users!: Vector<Raw.TypeInputUser>;

    constructor(params: { users: Vector<Raw.TypeInputUser> }) {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyValueAllowUsers';
      this.constructorId = 0x131cc67f;
      this.subclassOfId = 0x5a3b6b22;
      this._slots = ['users'];
      this.users = params.users;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPrivacyValueAllowUsers> {
      // no flags

      let users = await TLObject.read(b);
      return new Raw.InputPrivacyValueAllowUsers({ users: users });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.users) {
        b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPrivacyValueDisallowContacts extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyValueDisallowContacts';
      this.constructorId = 0xba52007;
      this.subclassOfId = 0x5a3b6b22;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputPrivacyValueDisallowContacts> {
      // no flags

      return new Raw.InputPrivacyValueDisallowContacts();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyValueDisallowAll extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyValueDisallowAll';
      this.constructorId = 0xd66b66c9;
      this.subclassOfId = 0x5a3b6b22;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPrivacyValueDisallowAll> {
      // no flags

      return new Raw.InputPrivacyValueDisallowAll();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputPrivacyValueDisallowUsers extends TLObject {
    users!: Vector<Raw.TypeInputUser>;

    constructor(params: { users: Vector<Raw.TypeInputUser> }) {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyValueDisallowUsers';
      this.constructorId = 0x90110467;
      this.subclassOfId = 0x5a3b6b22;
      this._slots = ['users'];
      this.users = params.users;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputPrivacyValueDisallowUsers> {
      // no flags

      let users = await TLObject.read(b);
      return new Raw.InputPrivacyValueDisallowUsers({ users: users });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.users) {
        b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPrivacyValueAllowChatParticipants extends TLObject {
    chats!: Vector<long>;

    constructor(params: { chats: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyValueAllowChatParticipants';
      this.constructorId = 0x840649cf;
      this.subclassOfId = 0x5a3b6b22;
      this._slots = ['chats'];
      this.chats = params.chats;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputPrivacyValueAllowChatParticipants> {
      // no flags

      let chats = await TLObject.read(b, Primitive.Long);
      return new Raw.InputPrivacyValueAllowChatParticipants({ chats: chats });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chats) {
        b.write(Primitive.Vector.write(this.chats, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPrivacyValueDisallowChatParticipants extends TLObject {
    chats!: Vector<long>;

    constructor(params: { chats: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyValueDisallowChatParticipants';
      this.constructorId = 0xe94f0f86;
      this.subclassOfId = 0x5a3b6b22;
      this._slots = ['chats'];
      this.chats = params.chats;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputPrivacyValueDisallowChatParticipants> {
      // no flags

      let chats = await TLObject.read(b, Primitive.Long);
      return new Raw.InputPrivacyValueDisallowChatParticipants({ chats: chats });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chats) {
        b.write(Primitive.Vector.write(this.chats, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPrivacyValueAllowCloseFriends extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputPrivacyValueAllowCloseFriends';
      this.constructorId = 0x2f453e49;
      this.subclassOfId = 0x5a3b6b22;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputPrivacyValueAllowCloseFriends> {
      // no flags

      return new Raw.InputPrivacyValueAllowCloseFriends();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyValueAllowContacts extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyValueAllowContacts';
      this.constructorId = 0xfffe1bac;
      this.subclassOfId = 0xebb7f270;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyValueAllowContacts> {
      // no flags

      return new Raw.PrivacyValueAllowContacts();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyValueAllowAll extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyValueAllowAll';
      this.constructorId = 0x65427b82;
      this.subclassOfId = 0xebb7f270;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyValueAllowAll> {
      // no flags

      return new Raw.PrivacyValueAllowAll();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyValueAllowUsers extends TLObject {
    users!: Vector<long>;

    constructor(params: { users: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'PrivacyValueAllowUsers';
      this.constructorId = 0xb8905fb2;
      this.subclassOfId = 0xebb7f270;
      this._slots = ['users'];
      this.users = params.users;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyValueAllowUsers> {
      // no flags

      let users = await TLObject.read(b, Primitive.Long);
      return new Raw.PrivacyValueAllowUsers({ users: users });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.users) {
        b.write(Primitive.Vector.write(this.users, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PrivacyValueDisallowContacts extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyValueDisallowContacts';
      this.constructorId = 0xf888fa1a;
      this.subclassOfId = 0xebb7f270;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyValueDisallowContacts> {
      // no flags

      return new Raw.PrivacyValueDisallowContacts();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyValueDisallowAll extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyValueDisallowAll';
      this.constructorId = 0x8b73e763;
      this.subclassOfId = 0xebb7f270;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyValueDisallowAll> {
      // no flags

      return new Raw.PrivacyValueDisallowAll();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PrivacyValueDisallowUsers extends TLObject {
    users!: Vector<long>;

    constructor(params: { users: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'PrivacyValueDisallowUsers';
      this.constructorId = 0xe4621141;
      this.subclassOfId = 0xebb7f270;
      this._slots = ['users'];
      this.users = params.users;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyValueDisallowUsers> {
      // no flags

      let users = await TLObject.read(b, Primitive.Long);
      return new Raw.PrivacyValueDisallowUsers({ users: users });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.users) {
        b.write(Primitive.Vector.write(this.users, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PrivacyValueAllowChatParticipants extends TLObject {
    chats!: Vector<long>;

    constructor(params: { chats: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'PrivacyValueAllowChatParticipants';
      this.constructorId = 0x6b134e8e;
      this.subclassOfId = 0xebb7f270;
      this._slots = ['chats'];
      this.chats = params.chats;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.PrivacyValueAllowChatParticipants> {
      // no flags

      let chats = await TLObject.read(b, Primitive.Long);
      return new Raw.PrivacyValueAllowChatParticipants({ chats: chats });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chats) {
        b.write(Primitive.Vector.write(this.chats, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PrivacyValueDisallowChatParticipants extends TLObject {
    chats!: Vector<long>;

    constructor(params: { chats: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'PrivacyValueDisallowChatParticipants';
      this.constructorId = 0x41c87565;
      this.subclassOfId = 0xebb7f270;
      this._slots = ['chats'];
      this.chats = params.chats;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.PrivacyValueDisallowChatParticipants> {
      // no flags

      let chats = await TLObject.read(b, Primitive.Long);
      return new Raw.PrivacyValueDisallowChatParticipants({ chats: chats });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chats) {
        b.write(Primitive.Vector.write(this.chats, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PrivacyValueAllowCloseFriends extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PrivacyValueAllowCloseFriends';
      this.constructorId = 0xf7e8d89b;
      this.subclassOfId = 0xebb7f270;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrivacyValueAllowCloseFriends> {
      // no flags

      return new Raw.PrivacyValueAllowCloseFriends();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class AccountDaysTTL extends TLObject {
    days!: int;

    constructor(params: { days: int }) {
      super();
      this.classType = 'types';
      this.className = 'AccountDaysTTL';
      this.constructorId = 0xb8d0afdf;
      this.subclassOfId = 0xbaa39d88;
      this._slots = ['days'];
      this.days = params.days;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AccountDaysTTL> {
      // no flags

      let days = await Primitive.Int.read(b);
      return new Raw.AccountDaysTTL({ days: days });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.days !== undefined) {
        b.write(Primitive.Int.write(this.days) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DocumentAttributeImageSize extends TLObject {
    w!: int;
    h!: int;

    constructor(params: { w: int; h: int }) {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeImageSize';
      this.constructorId = 0x6c37c15c;
      this.subclassOfId = 0xf729eb9b;
      this._slots = ['w', 'h'];
      this.w = params.w;
      this.h = params.h;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeImageSize> {
      // no flags

      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      return new Raw.DocumentAttributeImageSize({ w: w, h: h });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DocumentAttributeAnimated extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeAnimated';
      this.constructorId = 0x11b58939;
      this.subclassOfId = 0xf729eb9b;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeAnimated> {
      // no flags

      return new Raw.DocumentAttributeAnimated();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class DocumentAttributeSticker extends TLObject {
    mask?: boolean;
    alt!: string;
    stickerset!: Raw.TypeInputStickerSet;
    maskCoords?: Raw.TypeMaskCoords;

    constructor(params: {
      mask?: boolean;
      alt: string;
      stickerset: Raw.TypeInputStickerSet;
      maskCoords?: Raw.TypeMaskCoords;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeSticker';
      this.constructorId = 0x6319d612;
      this.subclassOfId = 0xf729eb9b;
      this._slots = ['mask', 'alt', 'stickerset', 'maskCoords'];
      this.mask = params.mask;
      this.alt = params.alt;
      this.stickerset = params.stickerset;
      this.maskCoords = params.maskCoords;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeSticker> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let mask = flags & (1 << 1) ? true : false;
      let alt = await Primitive.String.read(b);
      let stickerset = await TLObject.read(b);
      let maskCoords = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      return new Raw.DocumentAttributeSticker({
        mask: mask,
        alt: alt,
        stickerset: stickerset,
        maskCoords: maskCoords,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.mask ? 1 << 1 : 0;
      flags |= this.maskCoords !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.alt !== undefined) {
        b.write(Primitive.String.write(this.alt) as unknown as Buffer);
      }
      if (this.stickerset !== undefined) {
        b.write(this.stickerset.write() as unknown as Buffer);
      }
      if (this.maskCoords !== undefined) {
        b.write(this.maskCoords.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DocumentAttributeVideo extends TLObject {
    roundMessage?: boolean;
    supportsStreaming?: boolean;
    nosound?: boolean;
    duration!: double;
    w!: int;
    h!: int;
    preloadPrefixSize?: int;

    constructor(params: {
      roundMessage?: boolean;
      supportsStreaming?: boolean;
      nosound?: boolean;
      duration: double;
      w: int;
      h: int;
      preloadPrefixSize?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeVideo';
      this.constructorId = 0xd38ff1c2;
      this.subclassOfId = 0xf729eb9b;
      this._slots = [
        'roundMessage',
        'supportsStreaming',
        'nosound',
        'duration',
        'w',
        'h',
        'preloadPrefixSize',
      ];
      this.roundMessage = params.roundMessage;
      this.supportsStreaming = params.supportsStreaming;
      this.nosound = params.nosound;
      this.duration = params.duration;
      this.w = params.w;
      this.h = params.h;
      this.preloadPrefixSize = params.preloadPrefixSize;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeVideo> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let roundMessage = flags & (1 << 0) ? true : false;
      let supportsStreaming = flags & (1 << 1) ? true : false;
      let nosound = flags & (1 << 3) ? true : false;
      let duration = await Primitive.Double.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let preloadPrefixSize = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      return new Raw.DocumentAttributeVideo({
        roundMessage: roundMessage,
        supportsStreaming: supportsStreaming,
        nosound: nosound,
        duration: duration,
        w: w,
        h: h,
        preloadPrefixSize: preloadPrefixSize,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.roundMessage ? 1 << 0 : 0;
      flags |= this.supportsStreaming ? 1 << 1 : 0;
      flags |= this.nosound ? 1 << 3 : 0;
      flags |= this.preloadPrefixSize !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.duration !== undefined) {
        b.write(Primitive.Double.write(this.duration) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.preloadPrefixSize !== undefined) {
        b.write(Primitive.Int.write(this.preloadPrefixSize) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DocumentAttributeAudio extends TLObject {
    voice?: boolean;
    duration!: int;
    title?: string;
    performer?: string;
    waveform?: bytes;

    constructor(params: {
      voice?: boolean;
      duration: int;
      title?: string;
      performer?: string;
      waveform?: bytes;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeAudio';
      this.constructorId = 0x9852f9c6;
      this.subclassOfId = 0xf729eb9b;
      this._slots = ['voice', 'duration', 'title', 'performer', 'waveform'];
      this.voice = params.voice;
      this.duration = params.duration;
      this.title = params.title;
      this.performer = params.performer;
      this.waveform = params.waveform;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeAudio> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let voice = flags & (1 << 10) ? true : false;
      let duration = await Primitive.Int.read(b);
      let title = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let performer = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let waveform = flags & (1 << 2) ? await Primitive.Bytes.read(b) : undefined;
      return new Raw.DocumentAttributeAudio({
        voice: voice,
        duration: duration,
        title: title,
        performer: performer,
        waveform: waveform,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.voice ? 1 << 10 : 0;
      flags |= this.title !== undefined ? 1 << 0 : 0;
      flags |= this.performer !== undefined ? 1 << 1 : 0;
      flags |= this.waveform !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.performer !== undefined) {
        b.write(Primitive.String.write(this.performer) as unknown as Buffer);
      }
      if (this.waveform !== undefined) {
        b.write(Primitive.Bytes.write(this.waveform) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DocumentAttributeFilename extends TLObject {
    fileName!: string;

    constructor(params: { fileName: string }) {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeFilename';
      this.constructorId = 0x15590068;
      this.subclassOfId = 0xf729eb9b;
      this._slots = ['fileName'];
      this.fileName = params.fileName;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeFilename> {
      // no flags

      let fileName = await Primitive.String.read(b);
      return new Raw.DocumentAttributeFilename({ fileName: fileName });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.fileName !== undefined) {
        b.write(Primitive.String.write(this.fileName) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DocumentAttributeHasStickers extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeHasStickers';
      this.constructorId = 0x9801d2f7;
      this.subclassOfId = 0xf729eb9b;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeHasStickers> {
      // no flags

      return new Raw.DocumentAttributeHasStickers();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class DocumentAttributeCustomEmoji extends TLObject {
    free?: boolean;
    textColor?: boolean;
    alt!: string;
    stickerset!: Raw.TypeInputStickerSet;

    constructor(params: {
      free?: boolean;
      textColor?: boolean;
      alt: string;
      stickerset: Raw.TypeInputStickerSet;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeCustomEmoji';
      this.constructorId = 0xfd149899;
      this.subclassOfId = 0xf729eb9b;
      this._slots = ['free', 'textColor', 'alt', 'stickerset'];
      this.free = params.free;
      this.textColor = params.textColor;
      this.alt = params.alt;
      this.stickerset = params.stickerset;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeCustomEmoji> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let free = flags & (1 << 0) ? true : false;
      let textColor = flags & (1 << 1) ? true : false;
      let alt = await Primitive.String.read(b);
      let stickerset = await TLObject.read(b);
      return new Raw.DocumentAttributeCustomEmoji({
        free: free,
        textColor: textColor,
        alt: alt,
        stickerset: stickerset,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.free ? 1 << 0 : 0;
      flags |= this.textColor ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.alt !== undefined) {
        b.write(Primitive.String.write(this.alt) as unknown as Buffer);
      }
      if (this.stickerset !== undefined) {
        b.write(this.stickerset.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StickerPack extends TLObject {
    emoticon!: string;
    documents!: Vector<long>;

    constructor(params: { emoticon: string; documents: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'StickerPack';
      this.constructorId = 0x12b299d4;
      this.subclassOfId = 0x9fefa4d4;
      this._slots = ['emoticon', 'documents'];
      this.emoticon = params.emoticon;
      this.documents = params.documents;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StickerPack> {
      // no flags

      let emoticon = await Primitive.String.read(b);
      let documents = await TLObject.read(b, Primitive.Long);
      return new Raw.StickerPack({ emoticon: emoticon, documents: documents });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.emoticon !== undefined) {
        b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
      }
      if (this.documents) {
        b.write(Primitive.Vector.write(this.documents, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WebPageEmpty extends TLObject {
    id!: long;
    url?: string;

    constructor(params: { id: long; url?: string }) {
      super();
      this.classType = 'types';
      this.className = 'WebPageEmpty';
      this.constructorId = 0x211a1788;
      this.subclassOfId = 0x55a97481;
      this._slots = ['id', 'url'];
      this.id = params.id;
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WebPageEmpty> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let id = await Primitive.Long.read(b);
      let url = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      return new Raw.WebPageEmpty({ id: id, url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.url !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WebPagePending extends TLObject {
    id!: long;
    url?: string;
    date!: int;

    constructor(params: { id: long; url?: string; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'WebPagePending';
      this.constructorId = 0xb0d13e47;
      this.subclassOfId = 0x55a97481;
      this._slots = ['id', 'url', 'date'];
      this.id = params.id;
      this.url = params.url;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WebPagePending> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let id = await Primitive.Long.read(b);
      let url = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let date = await Primitive.Int.read(b);
      return new Raw.WebPagePending({ id: id, url: url, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.url !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WebPage extends TLObject {
    hasLargeMedia?: boolean;
    id!: long;
    url!: string;
    displayUrl!: string;
    hash!: int;
    type?: string;
    siteName?: string;
    title?: string;
    description?: string;
    photo?: Raw.TypePhoto;
    embedUrl?: string;
    embedType?: string;
    embedWidth?: int;
    embedHeight?: int;
    duration?: int;
    author?: string;
    document?: Raw.TypeDocument;
    cachedPage?: Raw.TypePage;
    attributes?: Vector<Raw.TypeWebPageAttribute>;

    constructor(params: {
      hasLargeMedia?: boolean;
      id: long;
      url: string;
      displayUrl: string;
      hash: int;
      type?: string;
      siteName?: string;
      title?: string;
      description?: string;
      photo?: Raw.TypePhoto;
      embedUrl?: string;
      embedType?: string;
      embedWidth?: int;
      embedHeight?: int;
      duration?: int;
      author?: string;
      document?: Raw.TypeDocument;
      cachedPage?: Raw.TypePage;
      attributes?: Vector<Raw.TypeWebPageAttribute>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'WebPage';
      this.constructorId = 0xe89c45b2;
      this.subclassOfId = 0x55a97481;
      this._slots = [
        'hasLargeMedia',
        'id',
        'url',
        'displayUrl',
        'hash',
        'type',
        'siteName',
        'title',
        'description',
        'photo',
        'embedUrl',
        'embedType',
        'embedWidth',
        'embedHeight',
        'duration',
        'author',
        'document',
        'cachedPage',
        'attributes',
      ];
      this.hasLargeMedia = params.hasLargeMedia;
      this.id = params.id;
      this.url = params.url;
      this.displayUrl = params.displayUrl;
      this.hash = params.hash;
      this.type = params.type;
      this.siteName = params.siteName;
      this.title = params.title;
      this.description = params.description;
      this.photo = params.photo;
      this.embedUrl = params.embedUrl;
      this.embedType = params.embedType;
      this.embedWidth = params.embedWidth;
      this.embedHeight = params.embedHeight;
      this.duration = params.duration;
      this.author = params.author;
      this.document = params.document;
      this.cachedPage = params.cachedPage;
      this.attributes = params.attributes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WebPage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let hasLargeMedia = flags & (1 << 13) ? true : false;
      let id = await Primitive.Long.read(b);
      let url = await Primitive.String.read(b);
      let displayUrl = await Primitive.String.read(b);
      let hash = await Primitive.Int.read(b);
      let type = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let siteName = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let title = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      let description = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
      let photo = flags & (1 << 4) ? await TLObject.read(b) : undefined;
      let embedUrl = flags & (1 << 5) ? await Primitive.String.read(b) : undefined;
      let embedType = flags & (1 << 5) ? await Primitive.String.read(b) : undefined;
      let embedWidth = flags & (1 << 6) ? await Primitive.Int.read(b) : undefined;
      let embedHeight = flags & (1 << 6) ? await Primitive.Int.read(b) : undefined;
      let duration = flags & (1 << 7) ? await Primitive.Int.read(b) : undefined;
      let author = flags & (1 << 8) ? await Primitive.String.read(b) : undefined;
      let document = flags & (1 << 9) ? await TLObject.read(b) : undefined;
      let cachedPage = flags & (1 << 10) ? await TLObject.read(b) : undefined;
      let attributes = flags & (1 << 12) ? await TLObject.read(b) : [];
      return new Raw.WebPage({
        hasLargeMedia: hasLargeMedia,
        id: id,
        url: url,
        displayUrl: displayUrl,
        hash: hash,
        type: type,
        siteName: siteName,
        title: title,
        description: description,
        photo: photo,
        embedUrl: embedUrl,
        embedType: embedType,
        embedWidth: embedWidth,
        embedHeight: embedHeight,
        duration: duration,
        author: author,
        document: document,
        cachedPage: cachedPage,
        attributes: attributes,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.hasLargeMedia ? 1 << 13 : 0;
      flags |= this.type !== undefined ? 1 << 0 : 0;
      flags |= this.siteName !== undefined ? 1 << 1 : 0;
      flags |= this.title !== undefined ? 1 << 2 : 0;
      flags |= this.description !== undefined ? 1 << 3 : 0;
      flags |= this.photo !== undefined ? 1 << 4 : 0;
      flags |= this.embedUrl !== undefined ? 1 << 5 : 0;
      flags |= this.embedType !== undefined ? 1 << 5 : 0;
      flags |= this.embedWidth !== undefined ? 1 << 6 : 0;
      flags |= this.embedHeight !== undefined ? 1 << 6 : 0;
      flags |= this.duration !== undefined ? 1 << 7 : 0;
      flags |= this.author !== undefined ? 1 << 8 : 0;
      flags |= this.document !== undefined ? 1 << 9 : 0;
      flags |= this.cachedPage !== undefined ? 1 << 10 : 0;
      flags |= this.attributes ? 1 << 12 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.displayUrl !== undefined) {
        b.write(Primitive.String.write(this.displayUrl) as unknown as Buffer);
      }
      if (this.hash !== undefined) {
        b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
      }
      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.siteName !== undefined) {
        b.write(Primitive.String.write(this.siteName) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.embedUrl !== undefined) {
        b.write(Primitive.String.write(this.embedUrl) as unknown as Buffer);
      }
      if (this.embedType !== undefined) {
        b.write(Primitive.String.write(this.embedType) as unknown as Buffer);
      }
      if (this.embedWidth !== undefined) {
        b.write(Primitive.Int.write(this.embedWidth) as unknown as Buffer);
      }
      if (this.embedHeight !== undefined) {
        b.write(Primitive.Int.write(this.embedHeight) as unknown as Buffer);
      }
      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      if (this.author !== undefined) {
        b.write(Primitive.String.write(this.author) as unknown as Buffer);
      }
      if (this.document !== undefined) {
        b.write(this.document.write() as unknown as Buffer);
      }
      if (this.cachedPage !== undefined) {
        b.write(this.cachedPage.write() as unknown as Buffer);
      }
      if (this.attributes) {
        b.write(Primitive.Vector.write(this.attributes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WebPageNotModified extends TLObject {
    cachedPageViews?: int;

    constructor(params: { cachedPageViews?: int }) {
      super();
      this.classType = 'types';
      this.className = 'WebPageNotModified';
      this.constructorId = 0x7311ca11;
      this.subclassOfId = 0x55a97481;
      this._slots = ['cachedPageViews'];
      this.cachedPageViews = params.cachedPageViews;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WebPageNotModified> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let cachedPageViews = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.WebPageNotModified({ cachedPageViews: cachedPageViews });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.cachedPageViews !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.cachedPageViews !== undefined) {
        b.write(Primitive.Int.write(this.cachedPageViews) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Authorization extends TLObject {
    current?: boolean;
    officialApp?: boolean;
    passwordPending?: boolean;
    encryptedRequestsDisabled?: boolean;
    callRequestsDisabled?: boolean;
    unconfirmed?: boolean;
    hash!: long;
    deviceModel!: string;
    platform!: string;
    systemVersion!: string;
    apiId!: int;
    appName!: string;
    appVersion!: string;
    dateCreated!: int;
    dateActive!: int;
    ip!: string;
    country!: string;
    region!: string;

    constructor(params: {
      current?: boolean;
      officialApp?: boolean;
      passwordPending?: boolean;
      encryptedRequestsDisabled?: boolean;
      callRequestsDisabled?: boolean;
      unconfirmed?: boolean;
      hash: long;
      deviceModel: string;
      platform: string;
      systemVersion: string;
      apiId: int;
      appName: string;
      appVersion: string;
      dateCreated: int;
      dateActive: int;
      ip: string;
      country: string;
      region: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Authorization';
      this.constructorId = 0xad01d61d;
      this.subclassOfId = 0xc913c01a;
      this._slots = [
        'current',
        'officialApp',
        'passwordPending',
        'encryptedRequestsDisabled',
        'callRequestsDisabled',
        'unconfirmed',
        'hash',
        'deviceModel',
        'platform',
        'systemVersion',
        'apiId',
        'appName',
        'appVersion',
        'dateCreated',
        'dateActive',
        'ip',
        'country',
        'region',
      ];
      this.current = params.current;
      this.officialApp = params.officialApp;
      this.passwordPending = params.passwordPending;
      this.encryptedRequestsDisabled = params.encryptedRequestsDisabled;
      this.callRequestsDisabled = params.callRequestsDisabled;
      this.unconfirmed = params.unconfirmed;
      this.hash = params.hash;
      this.deviceModel = params.deviceModel;
      this.platform = params.platform;
      this.systemVersion = params.systemVersion;
      this.apiId = params.apiId;
      this.appName = params.appName;
      this.appVersion = params.appVersion;
      this.dateCreated = params.dateCreated;
      this.dateActive = params.dateActive;
      this.ip = params.ip;
      this.country = params.country;
      this.region = params.region;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Authorization> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let current = flags & (1 << 0) ? true : false;
      let officialApp = flags & (1 << 1) ? true : false;
      let passwordPending = flags & (1 << 2) ? true : false;
      let encryptedRequestsDisabled = flags & (1 << 3) ? true : false;
      let callRequestsDisabled = flags & (1 << 4) ? true : false;
      let unconfirmed = flags & (1 << 5) ? true : false;
      let hash = await Primitive.Long.read(b);
      let deviceModel = await Primitive.String.read(b);
      let platform = await Primitive.String.read(b);
      let systemVersion = await Primitive.String.read(b);
      let apiId = await Primitive.Int.read(b);
      let appName = await Primitive.String.read(b);
      let appVersion = await Primitive.String.read(b);
      let dateCreated = await Primitive.Int.read(b);
      let dateActive = await Primitive.Int.read(b);
      let ip = await Primitive.String.read(b);
      let country = await Primitive.String.read(b);
      let region = await Primitive.String.read(b);
      return new Raw.Authorization({
        current: current,
        officialApp: officialApp,
        passwordPending: passwordPending,
        encryptedRequestsDisabled: encryptedRequestsDisabled,
        callRequestsDisabled: callRequestsDisabled,
        unconfirmed: unconfirmed,
        hash: hash,
        deviceModel: deviceModel,
        platform: platform,
        systemVersion: systemVersion,
        apiId: apiId,
        appName: appName,
        appVersion: appVersion,
        dateCreated: dateCreated,
        dateActive: dateActive,
        ip: ip,
        country: country,
        region: region,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.current ? 1 << 0 : 0;
      flags |= this.officialApp ? 1 << 1 : 0;
      flags |= this.passwordPending ? 1 << 2 : 0;
      flags |= this.encryptedRequestsDisabled ? 1 << 3 : 0;
      flags |= this.callRequestsDisabled ? 1 << 4 : 0;
      flags |= this.unconfirmed ? 1 << 5 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.hash !== undefined) {
        b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
      }
      if (this.deviceModel !== undefined) {
        b.write(Primitive.String.write(this.deviceModel) as unknown as Buffer);
      }
      if (this.platform !== undefined) {
        b.write(Primitive.String.write(this.platform) as unknown as Buffer);
      }
      if (this.systemVersion !== undefined) {
        b.write(Primitive.String.write(this.systemVersion) as unknown as Buffer);
      }
      if (this.apiId !== undefined) {
        b.write(Primitive.Int.write(this.apiId) as unknown as Buffer);
      }
      if (this.appName !== undefined) {
        b.write(Primitive.String.write(this.appName) as unknown as Buffer);
      }
      if (this.appVersion !== undefined) {
        b.write(Primitive.String.write(this.appVersion) as unknown as Buffer);
      }
      if (this.dateCreated !== undefined) {
        b.write(Primitive.Int.write(this.dateCreated) as unknown as Buffer);
      }
      if (this.dateActive !== undefined) {
        b.write(Primitive.Int.write(this.dateActive) as unknown as Buffer);
      }
      if (this.ip !== undefined) {
        b.write(Primitive.String.write(this.ip) as unknown as Buffer);
      }
      if (this.country !== undefined) {
        b.write(Primitive.String.write(this.country) as unknown as Buffer);
      }
      if (this.region !== undefined) {
        b.write(Primitive.String.write(this.region) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ReceivedNotifyMessage extends TLObject {
    id!: int;
    flags!: int;

    constructor(params: { id: int; flags: int }) {
      super();
      this.classType = 'types';
      this.className = 'ReceivedNotifyMessage';
      this.constructorId = 0xa384b779;
      this.subclassOfId = 0xa962381e;
      this._slots = ['id', 'flags'];
      this.id = params.id;
      this.flags = params.flags;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReceivedNotifyMessage> {
      // no flags

      let id = await Primitive.Int.read(b);
      let flags = await Primitive.Int.read(b);
      return new Raw.ReceivedNotifyMessage({ id: id, flags: flags });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.flags !== undefined) {
        b.write(Primitive.Int.write(this.flags) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatInviteExported extends TLObject {
    revoked?: boolean;
    permanent?: boolean;
    requestNeeded?: boolean;
    link!: string;
    adminId!: long;
    date!: int;
    startDate?: int;
    expireDate?: int;
    usageLimit?: int;
    usage?: int;
    requested?: int;
    title?: string;

    constructor(params: {
      revoked?: boolean;
      permanent?: boolean;
      requestNeeded?: boolean;
      link: string;
      adminId: long;
      date: int;
      startDate?: int;
      expireDate?: int;
      usageLimit?: int;
      usage?: int;
      requested?: int;
      title?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChatInviteExported';
      this.constructorId = 0xab4a819;
      this.subclassOfId = 0xb4748a58;
      this._slots = [
        'revoked',
        'permanent',
        'requestNeeded',
        'link',
        'adminId',
        'date',
        'startDate',
        'expireDate',
        'usageLimit',
        'usage',
        'requested',
        'title',
      ];
      this.revoked = params.revoked;
      this.permanent = params.permanent;
      this.requestNeeded = params.requestNeeded;
      this.link = params.link;
      this.adminId = params.adminId;
      this.date = params.date;
      this.startDate = params.startDate;
      this.expireDate = params.expireDate;
      this.usageLimit = params.usageLimit;
      this.usage = params.usage;
      this.requested = params.requested;
      this.title = params.title;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatInviteExported> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let revoked = flags & (1 << 0) ? true : false;
      let permanent = flags & (1 << 5) ? true : false;
      let requestNeeded = flags & (1 << 6) ? true : false;
      let link = await Primitive.String.read(b);
      let adminId = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let startDate = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      let expireDate = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      let usageLimit = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let usage = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
      let requested = flags & (1 << 7) ? await Primitive.Int.read(b) : undefined;
      let title = flags & (1 << 8) ? await Primitive.String.read(b) : undefined;
      return new Raw.ChatInviteExported({
        revoked: revoked,
        permanent: permanent,
        requestNeeded: requestNeeded,
        link: link,
        adminId: adminId,
        date: date,
        startDate: startDate,
        expireDate: expireDate,
        usageLimit: usageLimit,
        usage: usage,
        requested: requested,
        title: title,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.revoked ? 1 << 0 : 0;
      flags |= this.permanent ? 1 << 5 : 0;
      flags |= this.requestNeeded ? 1 << 6 : 0;
      flags |= this.startDate !== undefined ? 1 << 4 : 0;
      flags |= this.expireDate !== undefined ? 1 << 1 : 0;
      flags |= this.usageLimit !== undefined ? 1 << 2 : 0;
      flags |= this.usage !== undefined ? 1 << 3 : 0;
      flags |= this.requested !== undefined ? 1 << 7 : 0;
      flags |= this.title !== undefined ? 1 << 8 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.link !== undefined) {
        b.write(Primitive.String.write(this.link) as unknown as Buffer);
      }
      if (this.adminId !== undefined) {
        b.write(Primitive.Long.write(this.adminId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.startDate !== undefined) {
        b.write(Primitive.Int.write(this.startDate) as unknown as Buffer);
      }
      if (this.expireDate !== undefined) {
        b.write(Primitive.Int.write(this.expireDate) as unknown as Buffer);
      }
      if (this.usageLimit !== undefined) {
        b.write(Primitive.Int.write(this.usageLimit) as unknown as Buffer);
      }
      if (this.usage !== undefined) {
        b.write(Primitive.Int.write(this.usage) as unknown as Buffer);
      }
      if (this.requested !== undefined) {
        b.write(Primitive.Int.write(this.requested) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatInvitePublicJoinRequests extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'ChatInvitePublicJoinRequests';
      this.constructorId = 0xed107ab7;
      this.subclassOfId = 0xb4748a58;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatInvitePublicJoinRequests> {
      // no flags

      return new Raw.ChatInvitePublicJoinRequests();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChatInviteAlready extends TLObject {
    chat!: Raw.TypeChat;

    constructor(params: { chat: Raw.TypeChat }) {
      super();
      this.classType = 'types';
      this.className = 'ChatInviteAlready';
      this.constructorId = 0x5a686d7c;
      this.subclassOfId = 0x4561736;
      this._slots = ['chat'];
      this.chat = params.chat;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatInviteAlready> {
      // no flags

      let chat = await TLObject.read(b);
      return new Raw.ChatInviteAlready({ chat: chat });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chat !== undefined) {
        b.write(this.chat.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatInvite extends TLObject {
    channel?: boolean;
    broadcast?: boolean;
    public?: boolean;
    megagroup?: boolean;
    requestNeeded?: boolean;
    verified?: boolean;
    scam?: boolean;
    fake?: boolean;
    title!: string;
    about?: string;
    photo!: Raw.TypePhoto;
    participantsCount!: int;
    participants?: Vector<Raw.TypeUser>;
    color!: int;

    constructor(params: {
      channel?: boolean;
      broadcast?: boolean;
      public?: boolean;
      megagroup?: boolean;
      requestNeeded?: boolean;
      verified?: boolean;
      scam?: boolean;
      fake?: boolean;
      title: string;
      about?: string;
      photo: Raw.TypePhoto;
      participantsCount: int;
      participants?: Vector<Raw.TypeUser>;
      color: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChatInvite';
      this.constructorId = 0xcde0ec40;
      this.subclassOfId = 0x4561736;
      this._slots = [
        'channel',
        'broadcast',
        'public',
        'megagroup',
        'requestNeeded',
        'verified',
        'scam',
        'fake',
        'title',
        'about',
        'photo',
        'participantsCount',
        'participants',
        'color',
      ];
      this.channel = params.channel;
      this.broadcast = params.broadcast;
      this.public = params.public;
      this.megagroup = params.megagroup;
      this.requestNeeded = params.requestNeeded;
      this.verified = params.verified;
      this.scam = params.scam;
      this.fake = params.fake;
      this.title = params.title;
      this.about = params.about;
      this.photo = params.photo;
      this.participantsCount = params.participantsCount;
      this.participants = params.participants;
      this.color = params.color;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatInvite> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let channel = flags & (1 << 0) ? true : false;
      let broadcast = flags & (1 << 1) ? true : false;
      let _public = flags & (1 << 2) ? true : false;
      let megagroup = flags & (1 << 3) ? true : false;
      let requestNeeded = flags & (1 << 6) ? true : false;
      let verified = flags & (1 << 7) ? true : false;
      let scam = flags & (1 << 8) ? true : false;
      let fake = flags & (1 << 9) ? true : false;
      let title = await Primitive.String.read(b);
      let about = flags & (1 << 5) ? await Primitive.String.read(b) : undefined;
      let photo = await TLObject.read(b);
      let participantsCount = await Primitive.Int.read(b);
      let participants = flags & (1 << 4) ? await TLObject.read(b) : [];
      let color = await Primitive.Int.read(b);
      return new Raw.ChatInvite({
        channel: channel,
        broadcast: broadcast,
        public: _public,
        megagroup: megagroup,
        requestNeeded: requestNeeded,
        verified: verified,
        scam: scam,
        fake: fake,
        title: title,
        about: about,
        photo: photo,
        participantsCount: participantsCount,
        participants: participants,
        color: color,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.channel ? 1 << 0 : 0;
      flags |= this.broadcast ? 1 << 1 : 0;
      flags |= this.public ? 1 << 2 : 0;
      flags |= this.megagroup ? 1 << 3 : 0;
      flags |= this.requestNeeded ? 1 << 6 : 0;
      flags |= this.verified ? 1 << 7 : 0;
      flags |= this.scam ? 1 << 8 : 0;
      flags |= this.fake ? 1 << 9 : 0;
      flags |= this.about !== undefined ? 1 << 5 : 0;
      flags |= this.participants ? 1 << 4 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.about !== undefined) {
        b.write(Primitive.String.write(this.about) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.participantsCount !== undefined) {
        b.write(Primitive.Int.write(this.participantsCount) as unknown as Buffer);
      }
      if (this.participants) {
        b.write(Primitive.Vector.write(this.participants) as unknown as Buffer);
      }
      if (this.color !== undefined) {
        b.write(Primitive.Int.write(this.color) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatInvitePeek extends TLObject {
    chat!: Raw.TypeChat;
    expires!: int;

    constructor(params: { chat: Raw.TypeChat; expires: int }) {
      super();
      this.classType = 'types';
      this.className = 'ChatInvitePeek';
      this.constructorId = 0x61695cb0;
      this.subclassOfId = 0x4561736;
      this._slots = ['chat', 'expires'];
      this.chat = params.chat;
      this.expires = params.expires;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatInvitePeek> {
      // no flags

      let chat = await TLObject.read(b);
      let expires = await Primitive.Int.read(b);
      return new Raw.ChatInvitePeek({ chat: chat, expires: expires });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.chat !== undefined) {
        b.write(this.chat.write() as unknown as Buffer);
      }
      if (this.expires !== undefined) {
        b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputStickerSetEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputStickerSetEmpty';
      this.constructorId = 0xffb62b95;
      this.subclassOfId = 0x3da389aa;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputStickerSetEmpty> {
      // no flags

      return new Raw.InputStickerSetEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputStickerSetID extends TLObject {
    id!: long;
    accessHash!: long;

    constructor(params: { id: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputStickerSetID';
      this.constructorId = 0x9de7a269;
      this.subclassOfId = 0x3da389aa;
      this._slots = ['id', 'accessHash'];
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputStickerSetID> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputStickerSetID({ id: id, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputStickerSetShortName extends TLObject {
    shortName!: string;

    constructor(params: { shortName: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputStickerSetShortName';
      this.constructorId = 0x861cc8a0;
      this.subclassOfId = 0x3da389aa;
      this._slots = ['shortName'];
      this.shortName = params.shortName;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputStickerSetShortName> {
      // no flags

      let shortName = await Primitive.String.read(b);
      return new Raw.InputStickerSetShortName({ shortName: shortName });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.shortName !== undefined) {
        b.write(Primitive.String.write(this.shortName) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputStickerSetAnimatedEmoji extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputStickerSetAnimatedEmoji';
      this.constructorId = 0x28703c8;
      this.subclassOfId = 0x3da389aa;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputStickerSetAnimatedEmoji> {
      // no flags

      return new Raw.InputStickerSetAnimatedEmoji();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputStickerSetDice extends TLObject {
    emoticon!: string;

    constructor(params: { emoticon: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputStickerSetDice';
      this.constructorId = 0xe67f520e;
      this.subclassOfId = 0x3da389aa;
      this._slots = ['emoticon'];
      this.emoticon = params.emoticon;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputStickerSetDice> {
      // no flags

      let emoticon = await Primitive.String.read(b);
      return new Raw.InputStickerSetDice({ emoticon: emoticon });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.emoticon !== undefined) {
        b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputStickerSetAnimatedEmojiAnimations extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputStickerSetAnimatedEmojiAnimations';
      this.constructorId = 0xcde3739;
      this.subclassOfId = 0x3da389aa;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputStickerSetAnimatedEmojiAnimations> {
      // no flags

      return new Raw.InputStickerSetAnimatedEmojiAnimations();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputStickerSetPremiumGifts extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputStickerSetPremiumGifts';
      this.constructorId = 0xc88b3b02;
      this.subclassOfId = 0x3da389aa;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputStickerSetPremiumGifts> {
      // no flags

      return new Raw.InputStickerSetPremiumGifts();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputStickerSetEmojiGenericAnimations extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputStickerSetEmojiGenericAnimations';
      this.constructorId = 0x4c4d4ce;
      this.subclassOfId = 0x3da389aa;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputStickerSetEmojiGenericAnimations> {
      // no flags

      return new Raw.InputStickerSetEmojiGenericAnimations();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputStickerSetEmojiDefaultStatuses extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputStickerSetEmojiDefaultStatuses';
      this.constructorId = 0x29d0f5ee;
      this.subclassOfId = 0x3da389aa;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputStickerSetEmojiDefaultStatuses> {
      // no flags

      return new Raw.InputStickerSetEmojiDefaultStatuses();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputStickerSetEmojiDefaultTopicIcons extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputStickerSetEmojiDefaultTopicIcons';
      this.constructorId = 0x44c1f8e9;
      this.subclassOfId = 0x3da389aa;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputStickerSetEmojiDefaultTopicIcons> {
      // no flags

      return new Raw.InputStickerSetEmojiDefaultTopicIcons();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class StickerSet extends TLObject {
    archived?: boolean;
    official?: boolean;
    masks?: boolean;
    animated?: boolean;
    videos?: boolean;
    emojis?: boolean;
    textColor?: boolean;
    installedDate?: int;
    id!: long;
    accessHash!: long;
    title!: string;
    shortName!: string;
    thumbs?: Vector<Raw.TypePhotoSize>;
    thumbDcId?: int;
    thumbVersion?: int;
    thumbDocumentId?: long;
    count!: int;
    hash!: int;

    constructor(params: {
      archived?: boolean;
      official?: boolean;
      masks?: boolean;
      animated?: boolean;
      videos?: boolean;
      emojis?: boolean;
      textColor?: boolean;
      installedDate?: int;
      id: long;
      accessHash: long;
      title: string;
      shortName: string;
      thumbs?: Vector<Raw.TypePhotoSize>;
      thumbDcId?: int;
      thumbVersion?: int;
      thumbDocumentId?: long;
      count: int;
      hash: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'StickerSet';
      this.constructorId = 0x2dd14edc;
      this.subclassOfId = 0xbad3ff91;
      this._slots = [
        'archived',
        'official',
        'masks',
        'animated',
        'videos',
        'emojis',
        'textColor',
        'installedDate',
        'id',
        'accessHash',
        'title',
        'shortName',
        'thumbs',
        'thumbDcId',
        'thumbVersion',
        'thumbDocumentId',
        'count',
        'hash',
      ];
      this.archived = params.archived;
      this.official = params.official;
      this.masks = params.masks;
      this.animated = params.animated;
      this.videos = params.videos;
      this.emojis = params.emojis;
      this.textColor = params.textColor;
      this.installedDate = params.installedDate;
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.title = params.title;
      this.shortName = params.shortName;
      this.thumbs = params.thumbs;
      this.thumbDcId = params.thumbDcId;
      this.thumbVersion = params.thumbVersion;
      this.thumbDocumentId = params.thumbDocumentId;
      this.count = params.count;
      this.hash = params.hash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StickerSet> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let archived = flags & (1 << 1) ? true : false;
      let official = flags & (1 << 2) ? true : false;
      let masks = flags & (1 << 3) ? true : false;
      let animated = flags & (1 << 5) ? true : false;
      let videos = flags & (1 << 6) ? true : false;
      let emojis = flags & (1 << 7) ? true : false;
      let textColor = flags & (1 << 9) ? true : false;
      let installedDate = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let title = await Primitive.String.read(b);
      let shortName = await Primitive.String.read(b);
      let thumbs = flags & (1 << 4) ? await TLObject.read(b) : [];
      let thumbDcId = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      let thumbVersion = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      let thumbDocumentId = flags & (1 << 8) ? await Primitive.Long.read(b) : undefined;
      let count = await Primitive.Int.read(b);
      let hash = await Primitive.Int.read(b);
      return new Raw.StickerSet({
        archived: archived,
        official: official,
        masks: masks,
        animated: animated,
        videos: videos,
        emojis: emojis,
        textColor: textColor,
        installedDate: installedDate,
        id: id,
        accessHash: accessHash,
        title: title,
        shortName: shortName,
        thumbs: thumbs,
        thumbDcId: thumbDcId,
        thumbVersion: thumbVersion,
        thumbDocumentId: thumbDocumentId,
        count: count,
        hash: hash,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.archived ? 1 << 1 : 0;
      flags |= this.official ? 1 << 2 : 0;
      flags |= this.masks ? 1 << 3 : 0;
      flags |= this.animated ? 1 << 5 : 0;
      flags |= this.videos ? 1 << 6 : 0;
      flags |= this.emojis ? 1 << 7 : 0;
      flags |= this.textColor ? 1 << 9 : 0;
      flags |= this.installedDate !== undefined ? 1 << 0 : 0;
      flags |= this.thumbs ? 1 << 4 : 0;
      flags |= this.thumbDcId !== undefined ? 1 << 4 : 0;
      flags |= this.thumbVersion !== undefined ? 1 << 4 : 0;
      flags |= this.thumbDocumentId !== undefined ? 1 << 8 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.installedDate !== undefined) {
        b.write(Primitive.Int.write(this.installedDate) as unknown as Buffer);
      }
      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.shortName !== undefined) {
        b.write(Primitive.String.write(this.shortName) as unknown as Buffer);
      }
      if (this.thumbs) {
        b.write(Primitive.Vector.write(this.thumbs) as unknown as Buffer);
      }
      if (this.thumbDcId !== undefined) {
        b.write(Primitive.Int.write(this.thumbDcId) as unknown as Buffer);
      }
      if (this.thumbVersion !== undefined) {
        b.write(Primitive.Int.write(this.thumbVersion) as unknown as Buffer);
      }
      if (this.thumbDocumentId !== undefined) {
        b.write(Primitive.Long.write(this.thumbDocumentId) as unknown as Buffer);
      }
      if (this.count !== undefined) {
        b.write(Primitive.Int.write(this.count) as unknown as Buffer);
      }
      if (this.hash !== undefined) {
        b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotCommand extends TLObject {
    command!: string;
    description!: string;

    constructor(params: { command: string; description: string }) {
      super();
      this.classType = 'types';
      this.className = 'BotCommand';
      this.constructorId = 0xc27ac8c7;
      this.subclassOfId = 0xe1e62c2;
      this._slots = ['command', 'description'];
      this.command = params.command;
      this.description = params.description;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotCommand> {
      // no flags

      let command = await Primitive.String.read(b);
      let description = await Primitive.String.read(b);
      return new Raw.BotCommand({ command: command, description: description });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.command !== undefined) {
        b.write(Primitive.String.write(this.command) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotInfo extends TLObject {
    userId?: long;
    description?: string;
    descriptionPhoto?: Raw.TypePhoto;
    descriptionDocument?: Raw.TypeDocument;
    commands?: Vector<Raw.TypeBotCommand>;
    menuButton?: Raw.TypeBotMenuButton;

    constructor(params: {
      userId?: long;
      description?: string;
      descriptionPhoto?: Raw.TypePhoto;
      descriptionDocument?: Raw.TypeDocument;
      commands?: Vector<Raw.TypeBotCommand>;
      menuButton?: Raw.TypeBotMenuButton;
    }) {
      super();
      this.classType = 'types';
      this.className = 'BotInfo';
      this.constructorId = 0x8f300b57;
      this.subclassOfId = 0xf1f701db;
      this._slots = [
        'userId',
        'description',
        'descriptionPhoto',
        'descriptionDocument',
        'commands',
        'menuButton',
      ];
      this.userId = params.userId;
      this.description = params.description;
      this.descriptionPhoto = params.descriptionPhoto;
      this.descriptionDocument = params.descriptionDocument;
      this.commands = params.commands;
      this.menuButton = params.menuButton;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotInfo> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let userId = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
      let description = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let descriptionPhoto = flags & (1 << 4) ? await TLObject.read(b) : undefined;
      let descriptionDocument = flags & (1 << 5) ? await TLObject.read(b) : undefined;
      let commands = flags & (1 << 2) ? await TLObject.read(b) : [];
      let menuButton = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      return new Raw.BotInfo({
        userId: userId,
        description: description,
        descriptionPhoto: descriptionPhoto,
        descriptionDocument: descriptionDocument,
        commands: commands,
        menuButton: menuButton,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.userId !== undefined ? 1 << 0 : 0;
      flags |= this.description !== undefined ? 1 << 1 : 0;
      flags |= this.descriptionPhoto !== undefined ? 1 << 4 : 0;
      flags |= this.descriptionDocument !== undefined ? 1 << 5 : 0;
      flags |= this.commands ? 1 << 2 : 0;
      flags |= this.menuButton !== undefined ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.descriptionPhoto !== undefined) {
        b.write(this.descriptionPhoto.write() as unknown as Buffer);
      }
      if (this.descriptionDocument !== undefined) {
        b.write(this.descriptionDocument.write() as unknown as Buffer);
      }
      if (this.commands) {
        b.write(Primitive.Vector.write(this.commands) as unknown as Buffer);
      }
      if (this.menuButton !== undefined) {
        b.write(this.menuButton.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButton extends TLObject {
    text!: string;

    constructor(params: { text: string }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButton';
      this.constructorId = 0xa2fa4880;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButton> {
      // no flags

      let text = await Primitive.String.read(b);
      return new Raw.KeyboardButton({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonUrl extends TLObject {
    text!: string;
    url!: string;

    constructor(params: { text: string; url: string }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonUrl';
      this.constructorId = 0x258aff05;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['text', 'url'];
      this.text = params.text;
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonUrl> {
      // no flags

      let text = await Primitive.String.read(b);
      let url = await Primitive.String.read(b);
      return new Raw.KeyboardButtonUrl({ text: text, url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonCallback extends TLObject {
    requiresPassword?: boolean;
    text!: string;
    data!: bytes;

    constructor(params: { requiresPassword?: boolean; text: string; data: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonCallback';
      this.constructorId = 0x35bbdb6b;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['requiresPassword', 'text', 'data'];
      this.requiresPassword = params.requiresPassword;
      this.text = params.text;
      this.data = params.data;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonCallback> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let requiresPassword = flags & (1 << 0) ? true : false;
      let text = await Primitive.String.read(b);
      let data = await Primitive.Bytes.read(b);
      return new Raw.KeyboardButtonCallback({
        requiresPassword: requiresPassword,
        text: text,
        data: data,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.requiresPassword ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.data !== undefined) {
        b.write(Primitive.Bytes.write(this.data) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonRequestPhone extends TLObject {
    text!: string;

    constructor(params: { text: string }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonRequestPhone';
      this.constructorId = 0xb16a6c29;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonRequestPhone> {
      // no flags

      let text = await Primitive.String.read(b);
      return new Raw.KeyboardButtonRequestPhone({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonRequestGeoLocation extends TLObject {
    text!: string;

    constructor(params: { text: string }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonRequestGeoLocation';
      this.constructorId = 0xfc796b3f;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.KeyboardButtonRequestGeoLocation> {
      // no flags

      let text = await Primitive.String.read(b);
      return new Raw.KeyboardButtonRequestGeoLocation({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonSwitchInline extends TLObject {
    samePeer?: boolean;
    text!: string;
    query!: string;
    peerTypes?: Vector<Raw.TypeInlineQueryPeerType>;

    constructor(params: {
      samePeer?: boolean;
      text: string;
      query: string;
      peerTypes?: Vector<Raw.TypeInlineQueryPeerType>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonSwitchInline';
      this.constructorId = 0x93b9fbb5;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['samePeer', 'text', 'query', 'peerTypes'];
      this.samePeer = params.samePeer;
      this.text = params.text;
      this.query = params.query;
      this.peerTypes = params.peerTypes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonSwitchInline> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let samePeer = flags & (1 << 0) ? true : false;
      let text = await Primitive.String.read(b);
      let query = await Primitive.String.read(b);
      let peerTypes = flags & (1 << 1) ? await TLObject.read(b) : [];
      return new Raw.KeyboardButtonSwitchInline({
        samePeer: samePeer,
        text: text,
        query: query,
        peerTypes: peerTypes,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.samePeer ? 1 << 0 : 0;
      flags |= this.peerTypes ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.query !== undefined) {
        b.write(Primitive.String.write(this.query) as unknown as Buffer);
      }
      if (this.peerTypes) {
        b.write(Primitive.Vector.write(this.peerTypes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonGame extends TLObject {
    text!: string;

    constructor(params: { text: string }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonGame';
      this.constructorId = 0x50f41ccf;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonGame> {
      // no flags

      let text = await Primitive.String.read(b);
      return new Raw.KeyboardButtonGame({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonBuy extends TLObject {
    text!: string;

    constructor(params: { text: string }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonBuy';
      this.constructorId = 0xafd93fbb;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonBuy> {
      // no flags

      let text = await Primitive.String.read(b);
      return new Raw.KeyboardButtonBuy({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonUrlAuth extends TLObject {
    text!: string;
    fwdText?: string;
    url!: string;
    buttonId!: int;

    constructor(params: { text: string; fwdText?: string; url: string; buttonId: int }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonUrlAuth';
      this.constructorId = 0x10b78d29;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['text', 'fwdText', 'url', 'buttonId'];
      this.text = params.text;
      this.fwdText = params.fwdText;
      this.url = params.url;
      this.buttonId = params.buttonId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonUrlAuth> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let text = await Primitive.String.read(b);
      let fwdText = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let url = await Primitive.String.read(b);
      let buttonId = await Primitive.Int.read(b);
      return new Raw.KeyboardButtonUrlAuth({
        text: text,
        fwdText: fwdText,
        url: url,
        buttonId: buttonId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.fwdText !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.fwdText !== undefined) {
        b.write(Primitive.String.write(this.fwdText) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.buttonId !== undefined) {
        b.write(Primitive.Int.write(this.buttonId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputKeyboardButtonUrlAuth extends TLObject {
    requestWriteAccess?: boolean;
    text!: string;
    fwdText?: string;
    url!: string;
    bot!: Raw.TypeInputUser;

    constructor(params: {
      requestWriteAccess?: boolean;
      text: string;
      fwdText?: string;
      url: string;
      bot: Raw.TypeInputUser;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputKeyboardButtonUrlAuth';
      this.constructorId = 0xd02e7fd4;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['requestWriteAccess', 'text', 'fwdText', 'url', 'bot'];
      this.requestWriteAccess = params.requestWriteAccess;
      this.text = params.text;
      this.fwdText = params.fwdText;
      this.url = params.url;
      this.bot = params.bot;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputKeyboardButtonUrlAuth> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let requestWriteAccess = flags & (1 << 0) ? true : false;
      let text = await Primitive.String.read(b);
      let fwdText = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let url = await Primitive.String.read(b);
      let bot = await TLObject.read(b);
      return new Raw.InputKeyboardButtonUrlAuth({
        requestWriteAccess: requestWriteAccess,
        text: text,
        fwdText: fwdText,
        url: url,
        bot: bot,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.requestWriteAccess ? 1 << 0 : 0;
      flags |= this.fwdText !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.fwdText !== undefined) {
        b.write(Primitive.String.write(this.fwdText) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.bot !== undefined) {
        b.write(this.bot.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonRequestPoll extends TLObject {
    quiz?: Bool;
    text!: string;

    constructor(params: { quiz?: Bool; text: string }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonRequestPoll';
      this.constructorId = 0xbbc7515d;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['quiz', 'text'];
      this.quiz = params.quiz;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonRequestPoll> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let quiz = flags & (1 << 0) ? await Primitive.Bool.read(b) : undefined;
      let text = await Primitive.String.read(b);
      return new Raw.KeyboardButtonRequestPoll({ quiz: quiz, text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.quiz !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.quiz !== undefined) {
        b.write(Primitive.Bool.write(this.quiz) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputKeyboardButtonUserProfile extends TLObject {
    text!: string;
    userId!: Raw.TypeInputUser;

    constructor(params: { text: string; userId: Raw.TypeInputUser }) {
      super();
      this.classType = 'types';
      this.className = 'InputKeyboardButtonUserProfile';
      this.constructorId = 0xe988037b;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['text', 'userId'];
      this.text = params.text;
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputKeyboardButtonUserProfile> {
      // no flags

      let text = await Primitive.String.read(b);
      let userId = await TLObject.read(b);
      return new Raw.InputKeyboardButtonUserProfile({ text: text, userId: userId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(this.userId.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonUserProfile extends TLObject {
    text!: string;
    userId!: long;

    constructor(params: { text: string; userId: long }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonUserProfile';
      this.constructorId = 0x308660c1;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['text', 'userId'];
      this.text = params.text;
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonUserProfile> {
      // no flags

      let text = await Primitive.String.read(b);
      let userId = await Primitive.Long.read(b);
      return new Raw.KeyboardButtonUserProfile({ text: text, userId: userId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonWebView extends TLObject {
    text!: string;
    url!: string;

    constructor(params: { text: string; url: string }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonWebView';
      this.constructorId = 0x13767230;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['text', 'url'];
      this.text = params.text;
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonWebView> {
      // no flags

      let text = await Primitive.String.read(b);
      let url = await Primitive.String.read(b);
      return new Raw.KeyboardButtonWebView({ text: text, url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonSimpleWebView extends TLObject {
    text!: string;
    url!: string;

    constructor(params: { text: string; url: string }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonSimpleWebView';
      this.constructorId = 0xa0c0505c;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['text', 'url'];
      this.text = params.text;
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonSimpleWebView> {
      // no flags

      let text = await Primitive.String.read(b);
      let url = await Primitive.String.read(b);
      return new Raw.KeyboardButtonSimpleWebView({ text: text, url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonRequestPeer extends TLObject {
    text!: string;
    buttonId!: int;
    peerType!: Raw.TypeRequestPeerType;

    constructor(params: { text: string; buttonId: int; peerType: Raw.TypeRequestPeerType }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonRequestPeer';
      this.constructorId = 0xd0b468c;
      this.subclassOfId = 0xbad74a3;
      this._slots = ['text', 'buttonId', 'peerType'];
      this.text = params.text;
      this.buttonId = params.buttonId;
      this.peerType = params.peerType;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonRequestPeer> {
      // no flags

      let text = await Primitive.String.read(b);
      let buttonId = await Primitive.Int.read(b);
      let peerType = await TLObject.read(b);
      return new Raw.KeyboardButtonRequestPeer({
        text: text,
        buttonId: buttonId,
        peerType: peerType,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.buttonId !== undefined) {
        b.write(Primitive.Int.write(this.buttonId) as unknown as Buffer);
      }
      if (this.peerType !== undefined) {
        b.write(this.peerType.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class KeyboardButtonRow extends TLObject {
    buttons!: Vector<Raw.TypeKeyboardButton>;

    constructor(params: { buttons: Vector<Raw.TypeKeyboardButton> }) {
      super();
      this.classType = 'types';
      this.className = 'KeyboardButtonRow';
      this.constructorId = 0x77608b83;
      this.subclassOfId = 0x847730ae;
      this._slots = ['buttons'];
      this.buttons = params.buttons;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.KeyboardButtonRow> {
      // no flags

      let buttons = await TLObject.read(b);
      return new Raw.KeyboardButtonRow({ buttons: buttons });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.buttons) {
        b.write(Primitive.Vector.write(this.buttons) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ReplyKeyboardHide extends TLObject {
    selective?: boolean;

    constructor(params: { selective?: boolean }) {
      super();
      this.classType = 'types';
      this.className = 'ReplyKeyboardHide';
      this.constructorId = 0xa03e5b85;
      this.subclassOfId = 0xe2e10ef2;
      this._slots = ['selective'];
      this.selective = params.selective;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReplyKeyboardHide> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let selective = flags & (1 << 2) ? true : false;
      return new Raw.ReplyKeyboardHide({ selective: selective });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.selective ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      return b.buffer;
    }
  }
  export class ReplyKeyboardForceReply extends TLObject {
    singleUse?: boolean;
    selective?: boolean;
    placeholder?: string;

    constructor(params: { singleUse?: boolean; selective?: boolean; placeholder?: string }) {
      super();
      this.classType = 'types';
      this.className = 'ReplyKeyboardForceReply';
      this.constructorId = 0x86b40b08;
      this.subclassOfId = 0xe2e10ef2;
      this._slots = ['singleUse', 'selective', 'placeholder'];
      this.singleUse = params.singleUse;
      this.selective = params.selective;
      this.placeholder = params.placeholder;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReplyKeyboardForceReply> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let singleUse = flags & (1 << 1) ? true : false;
      let selective = flags & (1 << 2) ? true : false;
      let placeholder = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
      return new Raw.ReplyKeyboardForceReply({
        singleUse: singleUse,
        selective: selective,
        placeholder: placeholder,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.singleUse ? 1 << 1 : 0;
      flags |= this.selective ? 1 << 2 : 0;
      flags |= this.placeholder !== undefined ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.placeholder !== undefined) {
        b.write(Primitive.String.write(this.placeholder) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ReplyKeyboardMarkup extends TLObject {
    resize?: boolean;
    singleUse?: boolean;
    selective?: boolean;
    persistent?: boolean;
    rows!: Vector<Raw.TypeKeyboardButtonRow>;
    placeholder?: string;

    constructor(params: {
      resize?: boolean;
      singleUse?: boolean;
      selective?: boolean;
      persistent?: boolean;
      rows: Vector<Raw.TypeKeyboardButtonRow>;
      placeholder?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ReplyKeyboardMarkup';
      this.constructorId = 0x85dd99d1;
      this.subclassOfId = 0xe2e10ef2;
      this._slots = ['resize', 'singleUse', 'selective', 'persistent', 'rows', 'placeholder'];
      this.resize = params.resize;
      this.singleUse = params.singleUse;
      this.selective = params.selective;
      this.persistent = params.persistent;
      this.rows = params.rows;
      this.placeholder = params.placeholder;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReplyKeyboardMarkup> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let resize = flags & (1 << 0) ? true : false;
      let singleUse = flags & (1 << 1) ? true : false;
      let selective = flags & (1 << 2) ? true : false;
      let persistent = flags & (1 << 4) ? true : false;
      let rows = await TLObject.read(b);
      let placeholder = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
      return new Raw.ReplyKeyboardMarkup({
        resize: resize,
        singleUse: singleUse,
        selective: selective,
        persistent: persistent,
        rows: rows,
        placeholder: placeholder,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.resize ? 1 << 0 : 0;
      flags |= this.singleUse ? 1 << 1 : 0;
      flags |= this.selective ? 1 << 2 : 0;
      flags |= this.persistent ? 1 << 4 : 0;
      flags |= this.placeholder !== undefined ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.rows) {
        b.write(Primitive.Vector.write(this.rows) as unknown as Buffer);
      }
      if (this.placeholder !== undefined) {
        b.write(Primitive.String.write(this.placeholder) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ReplyInlineMarkup extends TLObject {
    rows!: Vector<Raw.TypeKeyboardButtonRow>;

    constructor(params: { rows: Vector<Raw.TypeKeyboardButtonRow> }) {
      super();
      this.classType = 'types';
      this.className = 'ReplyInlineMarkup';
      this.constructorId = 0x48a30254;
      this.subclassOfId = 0xe2e10ef2;
      this._slots = ['rows'];
      this.rows = params.rows;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReplyInlineMarkup> {
      // no flags

      let rows = await TLObject.read(b);
      return new Raw.ReplyInlineMarkup({ rows: rows });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.rows) {
        b.write(Primitive.Vector.write(this.rows) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityUnknown extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityUnknown';
      this.constructorId = 0xbb92ba95;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityUnknown> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityUnknown({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityMention extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityMention';
      this.constructorId = 0xfa04579d;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityMention> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityMention({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityHashtag extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityHashtag';
      this.constructorId = 0x6f635b0d;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityHashtag> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityHashtag({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityBotCommand extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityBotCommand';
      this.constructorId = 0x6cef8ac7;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityBotCommand> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityBotCommand({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityUrl extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityUrl';
      this.constructorId = 0x6ed02538;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityUrl> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityUrl({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityEmail extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityEmail';
      this.constructorId = 0x64e475c2;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityEmail> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityEmail({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityBold extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityBold';
      this.constructorId = 0xbd610bc9;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityBold> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityBold({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityItalic extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityItalic';
      this.constructorId = 0x826f8b60;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityItalic> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityItalic({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityCode extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityCode';
      this.constructorId = 0x28a20571;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityCode> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityCode({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityPre extends TLObject {
    offset!: int;
    length!: int;
    language!: string;

    constructor(params: { offset: int; length: int; language: string }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityPre';
      this.constructorId = 0x73924be0;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length', 'language'];
      this.offset = params.offset;
      this.length = params.length;
      this.language = params.language;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityPre> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      let language = await Primitive.String.read(b);
      return new Raw.MessageEntityPre({ offset: offset, length: length, language: language });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      if (this.language !== undefined) {
        b.write(Primitive.String.write(this.language) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityTextUrl extends TLObject {
    offset!: int;
    length!: int;
    url!: string;

    constructor(params: { offset: int; length: int; url: string }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityTextUrl';
      this.constructorId = 0x76a6d327;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length', 'url'];
      this.offset = params.offset;
      this.length = params.length;
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityTextUrl> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      let url = await Primitive.String.read(b);
      return new Raw.MessageEntityTextUrl({ offset: offset, length: length, url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityMentionName extends TLObject {
    offset!: int;
    length!: int;
    userId!: long;

    constructor(params: { offset: int; length: int; userId: long }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityMentionName';
      this.constructorId = 0xdc7b1140;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length', 'userId'];
      this.offset = params.offset;
      this.length = params.length;
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityMentionName> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      let userId = await Primitive.Long.read(b);
      return new Raw.MessageEntityMentionName({ offset: offset, length: length, userId: userId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMessageEntityMentionName extends TLObject {
    offset!: int;
    length!: int;
    userId!: Raw.TypeInputUser;

    constructor(params: { offset: int; length: int; userId: Raw.TypeInputUser }) {
      super();
      this.classType = 'types';
      this.className = 'InputMessageEntityMentionName';
      this.constructorId = 0x208e68c9;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length', 'userId'];
      this.offset = params.offset;
      this.length = params.length;
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessageEntityMentionName> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      let userId = await TLObject.read(b);
      return new Raw.InputMessageEntityMentionName({
        offset: offset,
        length: length,
        userId: userId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(this.userId.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityPhone extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityPhone';
      this.constructorId = 0x9b69e34b;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityPhone> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityPhone({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityCashtag extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityCashtag';
      this.constructorId = 0x4c4e743f;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityCashtag> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityCashtag({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityUnderline extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityUnderline';
      this.constructorId = 0x9c4e7e8b;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityUnderline> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityUnderline({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityStrike extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityStrike';
      this.constructorId = 0xbf0693d4;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityStrike> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityStrike({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityBankCard extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityBankCard';
      this.constructorId = 0x761e6af4;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityBankCard> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityBankCard({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntitySpoiler extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntitySpoiler';
      this.constructorId = 0x32ca960f;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntitySpoiler> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntitySpoiler({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityCustomEmoji extends TLObject {
    offset!: int;
    length!: int;
    documentId!: long;

    constructor(params: { offset: int; length: int; documentId: long }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityCustomEmoji';
      this.constructorId = 0xc8cf05f8;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length', 'documentId'];
      this.offset = params.offset;
      this.length = params.length;
      this.documentId = params.documentId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityCustomEmoji> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      let documentId = await Primitive.Long.read(b);
      return new Raw.MessageEntityCustomEmoji({
        offset: offset,
        length: length,
        documentId: documentId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      if (this.documentId !== undefined) {
        b.write(Primitive.Long.write(this.documentId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageEntityBlockquote extends TLObject {
    offset!: int;
    length!: int;

    constructor(params: { offset: int; length: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageEntityBlockquote';
      this.constructorId = 0x20df5d0;
      this.subclassOfId = 0xcf6419dc;
      this._slots = ['offset', 'length'];
      this.offset = params.offset;
      this.length = params.length;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageEntityBlockquote> {
      // no flags

      let offset = await Primitive.Int.read(b);
      let length = await Primitive.Int.read(b);
      return new Raw.MessageEntityBlockquote({ offset: offset, length: length });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      if (this.length !== undefined) {
        b.write(Primitive.Int.write(this.length) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputChannelEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputChannelEmpty';
      this.constructorId = 0xee8c1e86;
      this.subclassOfId = 0x40f202fd;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputChannelEmpty> {
      // no flags

      return new Raw.InputChannelEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputChannel extends TLObject {
    channelId!: long;
    accessHash!: long;

    constructor(params: { channelId: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputChannel';
      this.constructorId = 0xf35aec28;
      this.subclassOfId = 0x40f202fd;
      this._slots = ['channelId', 'accessHash'];
      this.channelId = params.channelId;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputChannel> {
      // no flags

      let channelId = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputChannel({ channelId: channelId, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputChannelFromMessage extends TLObject {
    peer!: Raw.TypeInputPeer;
    msgId!: int;
    channelId!: long;

    constructor(params: { peer: Raw.TypeInputPeer; msgId: int; channelId: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputChannelFromMessage';
      this.constructorId = 0x5b934f9d;
      this.subclassOfId = 0x40f202fd;
      this._slots = ['peer', 'msgId', 'channelId'];
      this.peer = params.peer;
      this.msgId = params.msgId;
      this.channelId = params.channelId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputChannelFromMessage> {
      // no flags

      let peer = await TLObject.read(b);
      let msgId = await Primitive.Int.read(b);
      let channelId = await Primitive.Long.read(b);
      return new Raw.InputChannelFromMessage({ peer: peer, msgId: msgId, channelId: channelId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageRange extends TLObject {
    minId!: int;
    maxId!: int;

    constructor(params: { minId: int; maxId: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageRange';
      this.constructorId = 0xae30253;
      this.subclassOfId = 0xbec74577;
      this._slots = ['minId', 'maxId'];
      this.minId = params.minId;
      this.maxId = params.maxId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageRange> {
      // no flags

      let minId = await Primitive.Int.read(b);
      let maxId = await Primitive.Int.read(b);
      return new Raw.MessageRange({ minId: minId, maxId: maxId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.minId !== undefined) {
        b.write(Primitive.Int.write(this.minId) as unknown as Buffer);
      }
      if (this.maxId !== undefined) {
        b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelMessagesFilterEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'ChannelMessagesFilterEmpty';
      this.constructorId = 0x94d42ee7;
      this.subclassOfId = 0x13336a56;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelMessagesFilterEmpty> {
      // no flags

      return new Raw.ChannelMessagesFilterEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChannelMessagesFilter extends TLObject {
    excludeNewMessages?: boolean;
    ranges!: Vector<Raw.TypeMessageRange>;

    constructor(params: { excludeNewMessages?: boolean; ranges: Vector<Raw.TypeMessageRange> }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelMessagesFilter';
      this.constructorId = 0xcd77d957;
      this.subclassOfId = 0x13336a56;
      this._slots = ['excludeNewMessages', 'ranges'];
      this.excludeNewMessages = params.excludeNewMessages;
      this.ranges = params.ranges;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelMessagesFilter> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let excludeNewMessages = flags & (1 << 1) ? true : false;
      let ranges = await TLObject.read(b);
      return new Raw.ChannelMessagesFilter({
        excludeNewMessages: excludeNewMessages,
        ranges: ranges,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.excludeNewMessages ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.ranges) {
        b.write(Primitive.Vector.write(this.ranges) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelParticipant extends TLObject {
    userId!: long;
    date!: int;

    constructor(params: { userId: long; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipant';
      this.constructorId = 0xc00c07c0;
      this.subclassOfId = 0xd9c7fc18;
      this._slots = ['userId', 'date'];
      this.userId = params.userId;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipant> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.ChannelParticipant({ userId: userId, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelParticipantSelf extends TLObject {
    viaRequest?: boolean;
    userId!: long;
    inviterId!: long;
    date!: int;

    constructor(params: { viaRequest?: boolean; userId: long; inviterId: long; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantSelf';
      this.constructorId = 0x35a8bfa7;
      this.subclassOfId = 0xd9c7fc18;
      this._slots = ['viaRequest', 'userId', 'inviterId', 'date'];
      this.viaRequest = params.viaRequest;
      this.userId = params.userId;
      this.inviterId = params.inviterId;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantSelf> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let viaRequest = flags & (1 << 0) ? true : false;
      let userId = await Primitive.Long.read(b);
      let inviterId = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.ChannelParticipantSelf({
        viaRequest: viaRequest,
        userId: userId,
        inviterId: inviterId,
        date: date,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.viaRequest ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.inviterId !== undefined) {
        b.write(Primitive.Long.write(this.inviterId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelParticipantCreator extends TLObject {
    userId!: long;
    adminRights!: Raw.TypeChatAdminRights;
    rank?: string;

    constructor(params: { userId: long; adminRights: Raw.TypeChatAdminRights; rank?: string }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantCreator';
      this.constructorId = 0x2fe601d3;
      this.subclassOfId = 0xd9c7fc18;
      this._slots = ['userId', 'adminRights', 'rank'];
      this.userId = params.userId;
      this.adminRights = params.adminRights;
      this.rank = params.rank;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantCreator> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let userId = await Primitive.Long.read(b);
      let adminRights = await TLObject.read(b);
      let rank = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      return new Raw.ChannelParticipantCreator({
        userId: userId,
        adminRights: adminRights,
        rank: rank,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.rank !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.adminRights !== undefined) {
        b.write(this.adminRights.write() as unknown as Buffer);
      }
      if (this.rank !== undefined) {
        b.write(Primitive.String.write(this.rank) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelParticipantAdmin extends TLObject {
    canEdit?: boolean;
    self?: boolean;
    userId!: long;
    inviterId?: long;
    promotedBy!: long;
    date!: int;
    adminRights!: Raw.TypeChatAdminRights;
    rank?: string;

    constructor(params: {
      canEdit?: boolean;
      self?: boolean;
      userId: long;
      inviterId?: long;
      promotedBy: long;
      date: int;
      adminRights: Raw.TypeChatAdminRights;
      rank?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantAdmin';
      this.constructorId = 0x34c3bb53;
      this.subclassOfId = 0xd9c7fc18;
      this._slots = [
        'canEdit',
        'self',
        'userId',
        'inviterId',
        'promotedBy',
        'date',
        'adminRights',
        'rank',
      ];
      this.canEdit = params.canEdit;
      this.self = params.self;
      this.userId = params.userId;
      this.inviterId = params.inviterId;
      this.promotedBy = params.promotedBy;
      this.date = params.date;
      this.adminRights = params.adminRights;
      this.rank = params.rank;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantAdmin> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let canEdit = flags & (1 << 0) ? true : false;
      let self = flags & (1 << 1) ? true : false;
      let userId = await Primitive.Long.read(b);
      let inviterId = flags & (1 << 1) ? await Primitive.Long.read(b) : undefined;
      let promotedBy = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let adminRights = await TLObject.read(b);
      let rank = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      return new Raw.ChannelParticipantAdmin({
        canEdit: canEdit,
        self: self,
        userId: userId,
        inviterId: inviterId,
        promotedBy: promotedBy,
        date: date,
        adminRights: adminRights,
        rank: rank,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.canEdit ? 1 << 0 : 0;
      flags |= this.self ? 1 << 1 : 0;
      flags |= this.inviterId !== undefined ? 1 << 1 : 0;
      flags |= this.rank !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.inviterId !== undefined) {
        b.write(Primitive.Long.write(this.inviterId) as unknown as Buffer);
      }
      if (this.promotedBy !== undefined) {
        b.write(Primitive.Long.write(this.promotedBy) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.adminRights !== undefined) {
        b.write(this.adminRights.write() as unknown as Buffer);
      }
      if (this.rank !== undefined) {
        b.write(Primitive.String.write(this.rank) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelParticipantBanned extends TLObject {
    left?: boolean;
    peer!: Raw.TypePeer;
    kickedBy!: long;
    date!: int;
    bannedRights!: Raw.TypeChatBannedRights;

    constructor(params: {
      left?: boolean;
      peer: Raw.TypePeer;
      kickedBy: long;
      date: int;
      bannedRights: Raw.TypeChatBannedRights;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantBanned';
      this.constructorId = 0x6df8014e;
      this.subclassOfId = 0xd9c7fc18;
      this._slots = ['left', 'peer', 'kickedBy', 'date', 'bannedRights'];
      this.left = params.left;
      this.peer = params.peer;
      this.kickedBy = params.kickedBy;
      this.date = params.date;
      this.bannedRights = params.bannedRights;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantBanned> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let left = flags & (1 << 0) ? true : false;
      let peer = await TLObject.read(b);
      let kickedBy = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let bannedRights = await TLObject.read(b);
      return new Raw.ChannelParticipantBanned({
        left: left,
        peer: peer,
        kickedBy: kickedBy,
        date: date,
        bannedRights: bannedRights,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.left ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.kickedBy !== undefined) {
        b.write(Primitive.Long.write(this.kickedBy) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.bannedRights !== undefined) {
        b.write(this.bannedRights.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelParticipantLeft extends TLObject {
    peer!: Raw.TypePeer;

    constructor(params: { peer: Raw.TypePeer }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantLeft';
      this.constructorId = 0x1b03f006;
      this.subclassOfId = 0xd9c7fc18;
      this._slots = ['peer'];
      this.peer = params.peer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantLeft> {
      // no flags

      let peer = await TLObject.read(b);
      return new Raw.ChannelParticipantLeft({ peer: peer });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelParticipantsRecent extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantsRecent';
      this.constructorId = 0xde3f3c79;
      this.subclassOfId = 0xbf4e2753;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantsRecent> {
      // no flags

      return new Raw.ChannelParticipantsRecent();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChannelParticipantsAdmins extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantsAdmins';
      this.constructorId = 0xb4608969;
      this.subclassOfId = 0xbf4e2753;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantsAdmins> {
      // no flags

      return new Raw.ChannelParticipantsAdmins();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChannelParticipantsKicked extends TLObject {
    q!: string;

    constructor(params: { q: string }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantsKicked';
      this.constructorId = 0xa3b54985;
      this.subclassOfId = 0xbf4e2753;
      this._slots = ['q'];
      this.q = params.q;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantsKicked> {
      // no flags

      let q = await Primitive.String.read(b);
      return new Raw.ChannelParticipantsKicked({ q: q });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.q !== undefined) {
        b.write(Primitive.String.write(this.q) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelParticipantsBots extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantsBots';
      this.constructorId = 0xb0d1865b;
      this.subclassOfId = 0xbf4e2753;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantsBots> {
      // no flags

      return new Raw.ChannelParticipantsBots();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChannelParticipantsBanned extends TLObject {
    q!: string;

    constructor(params: { q: string }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantsBanned';
      this.constructorId = 0x1427a5e1;
      this.subclassOfId = 0xbf4e2753;
      this._slots = ['q'];
      this.q = params.q;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantsBanned> {
      // no flags

      let q = await Primitive.String.read(b);
      return new Raw.ChannelParticipantsBanned({ q: q });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.q !== undefined) {
        b.write(Primitive.String.write(this.q) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelParticipantsSearch extends TLObject {
    q!: string;

    constructor(params: { q: string }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantsSearch';
      this.constructorId = 0x656ac4b;
      this.subclassOfId = 0xbf4e2753;
      this._slots = ['q'];
      this.q = params.q;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantsSearch> {
      // no flags

      let q = await Primitive.String.read(b);
      return new Raw.ChannelParticipantsSearch({ q: q });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.q !== undefined) {
        b.write(Primitive.String.write(this.q) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelParticipantsContacts extends TLObject {
    q!: string;

    constructor(params: { q: string }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantsContacts';
      this.constructorId = 0xbb6ae88d;
      this.subclassOfId = 0xbf4e2753;
      this._slots = ['q'];
      this.q = params.q;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantsContacts> {
      // no flags

      let q = await Primitive.String.read(b);
      return new Raw.ChannelParticipantsContacts({ q: q });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.q !== undefined) {
        b.write(Primitive.String.write(this.q) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelParticipantsMentions extends TLObject {
    q?: string;
    topMsgId?: int;

    constructor(params: { q?: string; topMsgId?: int }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelParticipantsMentions';
      this.constructorId = 0xe04b5ceb;
      this.subclassOfId = 0xbf4e2753;
      this._slots = ['q', 'topMsgId'];
      this.q = params.q;
      this.topMsgId = params.topMsgId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelParticipantsMentions> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let q = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let topMsgId = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      return new Raw.ChannelParticipantsMentions({ q: q, topMsgId: topMsgId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.q !== undefined ? 1 << 0 : 0;
      flags |= this.topMsgId !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.q !== undefined) {
        b.write(Primitive.String.write(this.q) as unknown as Buffer);
      }
      if (this.topMsgId !== undefined) {
        b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineMessageMediaAuto extends TLObject {
    invertMedia?: boolean;
    message!: string;
    entities?: Vector<Raw.TypeMessageEntity>;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      invertMedia?: boolean;
      message: string;
      entities?: Vector<Raw.TypeMessageEntity>;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineMessageMediaAuto';
      this.constructorId = 0x3380c786;
      this.subclassOfId = 0x53fb4010;
      this._slots = ['invertMedia', 'message', 'entities', 'replyMarkup'];
      this.invertMedia = params.invertMedia;
      this.message = params.message;
      this.entities = params.entities;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputBotInlineMessageMediaAuto> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let invertMedia = flags & (1 << 3) ? true : false;
      let message = await Primitive.String.read(b);
      let entities = flags & (1 << 1) ? await TLObject.read(b) : [];
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.InputBotInlineMessageMediaAuto({
        invertMedia: invertMedia,
        message: message,
        entities: entities,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.invertMedia ? 1 << 3 : 0;
      flags |= this.entities ? 1 << 1 : 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineMessageText extends TLObject {
    noWebpage?: boolean;
    invertMedia?: boolean;
    message!: string;
    entities?: Vector<Raw.TypeMessageEntity>;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      noWebpage?: boolean;
      invertMedia?: boolean;
      message: string;
      entities?: Vector<Raw.TypeMessageEntity>;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineMessageText';
      this.constructorId = 0x3dcd7a87;
      this.subclassOfId = 0x53fb4010;
      this._slots = ['noWebpage', 'invertMedia', 'message', 'entities', 'replyMarkup'];
      this.noWebpage = params.noWebpage;
      this.invertMedia = params.invertMedia;
      this.message = params.message;
      this.entities = params.entities;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputBotInlineMessageText> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let noWebpage = flags & (1 << 0) ? true : false;
      let invertMedia = flags & (1 << 3) ? true : false;
      let message = await Primitive.String.read(b);
      let entities = flags & (1 << 1) ? await TLObject.read(b) : [];
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.InputBotInlineMessageText({
        noWebpage: noWebpage,
        invertMedia: invertMedia,
        message: message,
        entities: entities,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.noWebpage ? 1 << 0 : 0;
      flags |= this.invertMedia ? 1 << 3 : 0;
      flags |= this.entities ? 1 << 1 : 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineMessageMediaGeo extends TLObject {
    geoPoint!: Raw.TypeInputGeoPoint;
    heading?: int;
    period?: int;
    proximityNotificationRadius?: int;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      geoPoint: Raw.TypeInputGeoPoint;
      heading?: int;
      period?: int;
      proximityNotificationRadius?: int;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineMessageMediaGeo';
      this.constructorId = 0x96929a85;
      this.subclassOfId = 0x53fb4010;
      this._slots = ['geoPoint', 'heading', 'period', 'proximityNotificationRadius', 'replyMarkup'];
      this.geoPoint = params.geoPoint;
      this.heading = params.heading;
      this.period = params.period;
      this.proximityNotificationRadius = params.proximityNotificationRadius;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputBotInlineMessageMediaGeo> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let geoPoint = await TLObject.read(b);
      let heading = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let period = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      let proximityNotificationRadius = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.InputBotInlineMessageMediaGeo({
        geoPoint: geoPoint,
        heading: heading,
        period: period,
        proximityNotificationRadius: proximityNotificationRadius,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.heading !== undefined ? 1 << 0 : 0;
      flags |= this.period !== undefined ? 1 << 1 : 0;
      flags |= this.proximityNotificationRadius !== undefined ? 1 << 3 : 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.geoPoint !== undefined) {
        b.write(this.geoPoint.write() as unknown as Buffer);
      }
      if (this.heading !== undefined) {
        b.write(Primitive.Int.write(this.heading) as unknown as Buffer);
      }
      if (this.period !== undefined) {
        b.write(Primitive.Int.write(this.period) as unknown as Buffer);
      }
      if (this.proximityNotificationRadius !== undefined) {
        b.write(Primitive.Int.write(this.proximityNotificationRadius) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineMessageMediaVenue extends TLObject {
    geoPoint!: Raw.TypeInputGeoPoint;
    title!: string;
    address!: string;
    provider!: string;
    venueId!: string;
    venueType!: string;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      geoPoint: Raw.TypeInputGeoPoint;
      title: string;
      address: string;
      provider: string;
      venueId: string;
      venueType: string;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineMessageMediaVenue';
      this.constructorId = 0x417bbf11;
      this.subclassOfId = 0x53fb4010;
      this._slots = [
        'geoPoint',
        'title',
        'address',
        'provider',
        'venueId',
        'venueType',
        'replyMarkup',
      ];
      this.geoPoint = params.geoPoint;
      this.title = params.title;
      this.address = params.address;
      this.provider = params.provider;
      this.venueId = params.venueId;
      this.venueType = params.venueType;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputBotInlineMessageMediaVenue> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let geoPoint = await TLObject.read(b);
      let title = await Primitive.String.read(b);
      let address = await Primitive.String.read(b);
      let provider = await Primitive.String.read(b);
      let venueId = await Primitive.String.read(b);
      let venueType = await Primitive.String.read(b);
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.InputBotInlineMessageMediaVenue({
        geoPoint: geoPoint,
        title: title,
        address: address,
        provider: provider,
        venueId: venueId,
        venueType: venueType,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.geoPoint !== undefined) {
        b.write(this.geoPoint.write() as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.address !== undefined) {
        b.write(Primitive.String.write(this.address) as unknown as Buffer);
      }
      if (this.provider !== undefined) {
        b.write(Primitive.String.write(this.provider) as unknown as Buffer);
      }
      if (this.venueId !== undefined) {
        b.write(Primitive.String.write(this.venueId) as unknown as Buffer);
      }
      if (this.venueType !== undefined) {
        b.write(Primitive.String.write(this.venueType) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineMessageMediaContact extends TLObject {
    phoneNumber!: string;
    firstName!: string;
    lastName!: string;
    vcard!: string;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      phoneNumber: string;
      firstName: string;
      lastName: string;
      vcard: string;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineMessageMediaContact';
      this.constructorId = 0xa6edbffd;
      this.subclassOfId = 0x53fb4010;
      this._slots = ['phoneNumber', 'firstName', 'lastName', 'vcard', 'replyMarkup'];
      this.phoneNumber = params.phoneNumber;
      this.firstName = params.firstName;
      this.lastName = params.lastName;
      this.vcard = params.vcard;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputBotInlineMessageMediaContact> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let phoneNumber = await Primitive.String.read(b);
      let firstName = await Primitive.String.read(b);
      let lastName = await Primitive.String.read(b);
      let vcard = await Primitive.String.read(b);
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.InputBotInlineMessageMediaContact({
        phoneNumber: phoneNumber,
        firstName: firstName,
        lastName: lastName,
        vcard: vcard,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.phoneNumber !== undefined) {
        b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
      }
      if (this.firstName !== undefined) {
        b.write(Primitive.String.write(this.firstName) as unknown as Buffer);
      }
      if (this.lastName !== undefined) {
        b.write(Primitive.String.write(this.lastName) as unknown as Buffer);
      }
      if (this.vcard !== undefined) {
        b.write(Primitive.String.write(this.vcard) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineMessageGame extends TLObject {
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: { replyMarkup?: Raw.TypeReplyMarkup }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineMessageGame';
      this.constructorId = 0x4b425864;
      this.subclassOfId = 0x53fb4010;
      this._slots = ['replyMarkup'];
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputBotInlineMessageGame> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.InputBotInlineMessageGame({ replyMarkup: replyMarkup });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineMessageMediaInvoice extends TLObject {
    title!: string;
    description!: string;
    photo?: Raw.TypeInputWebDocument;
    invoice!: Raw.TypeInvoice;
    payload!: bytes;
    provider!: string;
    providerData!: Raw.TypeDataJSON;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      title: string;
      description: string;
      photo?: Raw.TypeInputWebDocument;
      invoice: Raw.TypeInvoice;
      payload: bytes;
      provider: string;
      providerData: Raw.TypeDataJSON;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineMessageMediaInvoice';
      this.constructorId = 0xd7e78225;
      this.subclassOfId = 0x53fb4010;
      this._slots = [
        'title',
        'description',
        'photo',
        'invoice',
        'payload',
        'provider',
        'providerData',
        'replyMarkup',
      ];
      this.title = params.title;
      this.description = params.description;
      this.photo = params.photo;
      this.invoice = params.invoice;
      this.payload = params.payload;
      this.provider = params.provider;
      this.providerData = params.providerData;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputBotInlineMessageMediaInvoice> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let title = await Primitive.String.read(b);
      let description = await Primitive.String.read(b);
      let photo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let invoice = await TLObject.read(b);
      let payload = await Primitive.Bytes.read(b);
      let provider = await Primitive.String.read(b);
      let providerData = await TLObject.read(b);
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.InputBotInlineMessageMediaInvoice({
        title: title,
        description: description,
        photo: photo,
        invoice: invoice,
        payload: payload,
        provider: provider,
        providerData: providerData,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.photo !== undefined ? 1 << 0 : 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.invoice !== undefined) {
        b.write(this.invoice.write() as unknown as Buffer);
      }
      if (this.payload !== undefined) {
        b.write(Primitive.Bytes.write(this.payload) as unknown as Buffer);
      }
      if (this.provider !== undefined) {
        b.write(Primitive.String.write(this.provider) as unknown as Buffer);
      }
      if (this.providerData !== undefined) {
        b.write(this.providerData.write() as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineMessageMediaWebPage extends TLObject {
    invertMedia?: boolean;
    forceLargeMedia?: boolean;
    forceSmallMedia?: boolean;
    optional?: boolean;
    message!: string;
    entities?: Vector<Raw.TypeMessageEntity>;
    url!: string;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      invertMedia?: boolean;
      forceLargeMedia?: boolean;
      forceSmallMedia?: boolean;
      optional?: boolean;
      message: string;
      entities?: Vector<Raw.TypeMessageEntity>;
      url: string;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineMessageMediaWebPage';
      this.constructorId = 0xbddcc510;
      this.subclassOfId = 0x53fb4010;
      this._slots = [
        'invertMedia',
        'forceLargeMedia',
        'forceSmallMedia',
        'optional',
        'message',
        'entities',
        'url',
        'replyMarkup',
      ];
      this.invertMedia = params.invertMedia;
      this.forceLargeMedia = params.forceLargeMedia;
      this.forceSmallMedia = params.forceSmallMedia;
      this.optional = params.optional;
      this.message = params.message;
      this.entities = params.entities;
      this.url = params.url;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputBotInlineMessageMediaWebPage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let invertMedia = flags & (1 << 3) ? true : false;
      let forceLargeMedia = flags & (1 << 4) ? true : false;
      let forceSmallMedia = flags & (1 << 5) ? true : false;
      let optional = flags & (1 << 6) ? true : false;
      let message = await Primitive.String.read(b);
      let entities = flags & (1 << 1) ? await TLObject.read(b) : [];
      let url = await Primitive.String.read(b);
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.InputBotInlineMessageMediaWebPage({
        invertMedia: invertMedia,
        forceLargeMedia: forceLargeMedia,
        forceSmallMedia: forceSmallMedia,
        optional: optional,
        message: message,
        entities: entities,
        url: url,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.invertMedia ? 1 << 3 : 0;
      flags |= this.forceLargeMedia ? 1 << 4 : 0;
      flags |= this.forceSmallMedia ? 1 << 5 : 0;
      flags |= this.optional ? 1 << 6 : 0;
      flags |= this.entities ? 1 << 1 : 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineResult extends TLObject {
    id!: string;
    type!: string;
    title?: string;
    description?: string;
    url?: string;
    thumb?: Raw.TypeInputWebDocument;
    content?: Raw.TypeInputWebDocument;
    sendMessage!: Raw.TypeInputBotInlineMessage;

    constructor(params: {
      id: string;
      type: string;
      title?: string;
      description?: string;
      url?: string;
      thumb?: Raw.TypeInputWebDocument;
      content?: Raw.TypeInputWebDocument;
      sendMessage: Raw.TypeInputBotInlineMessage;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineResult';
      this.constructorId = 0x88bf9319;
      this.subclassOfId = 0x80a4a3de;
      this._slots = [
        'id',
        'type',
        'title',
        'description',
        'url',
        'thumb',
        'content',
        'sendMessage',
      ];
      this.id = params.id;
      this.type = params.type;
      this.title = params.title;
      this.description = params.description;
      this.url = params.url;
      this.thumb = params.thumb;
      this.content = params.content;
      this.sendMessage = params.sendMessage;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputBotInlineResult> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let id = await Primitive.String.read(b);
      let type = await Primitive.String.read(b);
      let title = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let description = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      let url = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
      let thumb = flags & (1 << 4) ? await TLObject.read(b) : undefined;
      let content = flags & (1 << 5) ? await TLObject.read(b) : undefined;
      let sendMessage = await TLObject.read(b);
      return new Raw.InputBotInlineResult({
        id: id,
        type: type,
        title: title,
        description: description,
        url: url,
        thumb: thumb,
        content: content,
        sendMessage: sendMessage,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.title !== undefined ? 1 << 1 : 0;
      flags |= this.description !== undefined ? 1 << 2 : 0;
      flags |= this.url !== undefined ? 1 << 3 : 0;
      flags |= this.thumb !== undefined ? 1 << 4 : 0;
      flags |= this.content !== undefined ? 1 << 5 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.String.write(this.id) as unknown as Buffer);
      }
      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.thumb !== undefined) {
        b.write(this.thumb.write() as unknown as Buffer);
      }
      if (this.content !== undefined) {
        b.write(this.content.write() as unknown as Buffer);
      }
      if (this.sendMessage !== undefined) {
        b.write(this.sendMessage.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineResultPhoto extends TLObject {
    id!: string;
    type!: string;
    photo!: Raw.TypeInputPhoto;
    sendMessage!: Raw.TypeInputBotInlineMessage;

    constructor(params: {
      id: string;
      type: string;
      photo: Raw.TypeInputPhoto;
      sendMessage: Raw.TypeInputBotInlineMessage;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineResultPhoto';
      this.constructorId = 0xa8d864a7;
      this.subclassOfId = 0x80a4a3de;
      this._slots = ['id', 'type', 'photo', 'sendMessage'];
      this.id = params.id;
      this.type = params.type;
      this.photo = params.photo;
      this.sendMessage = params.sendMessage;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputBotInlineResultPhoto> {
      // no flags

      let id = await Primitive.String.read(b);
      let type = await Primitive.String.read(b);
      let photo = await TLObject.read(b);
      let sendMessage = await TLObject.read(b);
      return new Raw.InputBotInlineResultPhoto({
        id: id,
        type: type,
        photo: photo,
        sendMessage: sendMessage,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.String.write(this.id) as unknown as Buffer);
      }
      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.sendMessage !== undefined) {
        b.write(this.sendMessage.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineResultDocument extends TLObject {
    id!: string;
    type!: string;
    title?: string;
    description?: string;
    document!: Raw.TypeInputDocument;
    sendMessage!: Raw.TypeInputBotInlineMessage;

    constructor(params: {
      id: string;
      type: string;
      title?: string;
      description?: string;
      document: Raw.TypeInputDocument;
      sendMessage: Raw.TypeInputBotInlineMessage;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineResultDocument';
      this.constructorId = 0xfff8fdc4;
      this.subclassOfId = 0x80a4a3de;
      this._slots = ['id', 'type', 'title', 'description', 'document', 'sendMessage'];
      this.id = params.id;
      this.type = params.type;
      this.title = params.title;
      this.description = params.description;
      this.document = params.document;
      this.sendMessage = params.sendMessage;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputBotInlineResultDocument> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let id = await Primitive.String.read(b);
      let type = await Primitive.String.read(b);
      let title = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let description = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      let document = await TLObject.read(b);
      let sendMessage = await TLObject.read(b);
      return new Raw.InputBotInlineResultDocument({
        id: id,
        type: type,
        title: title,
        description: description,
        document: document,
        sendMessage: sendMessage,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.title !== undefined ? 1 << 1 : 0;
      flags |= this.description !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.String.write(this.id) as unknown as Buffer);
      }
      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.document !== undefined) {
        b.write(this.document.write() as unknown as Buffer);
      }
      if (this.sendMessage !== undefined) {
        b.write(this.sendMessage.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineResultGame extends TLObject {
    id!: string;
    shortName!: string;
    sendMessage!: Raw.TypeInputBotInlineMessage;

    constructor(params: {
      id: string;
      shortName: string;
      sendMessage: Raw.TypeInputBotInlineMessage;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineResultGame';
      this.constructorId = 0x4fa417f2;
      this.subclassOfId = 0x80a4a3de;
      this._slots = ['id', 'shortName', 'sendMessage'];
      this.id = params.id;
      this.shortName = params.shortName;
      this.sendMessage = params.sendMessage;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputBotInlineResultGame> {
      // no flags

      let id = await Primitive.String.read(b);
      let shortName = await Primitive.String.read(b);
      let sendMessage = await TLObject.read(b);
      return new Raw.InputBotInlineResultGame({
        id: id,
        shortName: shortName,
        sendMessage: sendMessage,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.String.write(this.id) as unknown as Buffer);
      }
      if (this.shortName !== undefined) {
        b.write(Primitive.String.write(this.shortName) as unknown as Buffer);
      }
      if (this.sendMessage !== undefined) {
        b.write(this.sendMessage.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotInlineMessageMediaAuto extends TLObject {
    invertMedia?: boolean;
    message!: string;
    entities?: Vector<Raw.TypeMessageEntity>;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      invertMedia?: boolean;
      message: string;
      entities?: Vector<Raw.TypeMessageEntity>;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'BotInlineMessageMediaAuto';
      this.constructorId = 0x764cf810;
      this.subclassOfId = 0xc4910f88;
      this._slots = ['invertMedia', 'message', 'entities', 'replyMarkup'];
      this.invertMedia = params.invertMedia;
      this.message = params.message;
      this.entities = params.entities;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotInlineMessageMediaAuto> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let invertMedia = flags & (1 << 3) ? true : false;
      let message = await Primitive.String.read(b);
      let entities = flags & (1 << 1) ? await TLObject.read(b) : [];
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.BotInlineMessageMediaAuto({
        invertMedia: invertMedia,
        message: message,
        entities: entities,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.invertMedia ? 1 << 3 : 0;
      flags |= this.entities ? 1 << 1 : 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotInlineMessageText extends TLObject {
    noWebpage?: boolean;
    invertMedia?: boolean;
    message!: string;
    entities?: Vector<Raw.TypeMessageEntity>;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      noWebpage?: boolean;
      invertMedia?: boolean;
      message: string;
      entities?: Vector<Raw.TypeMessageEntity>;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'BotInlineMessageText';
      this.constructorId = 0x8c7f65e2;
      this.subclassOfId = 0xc4910f88;
      this._slots = ['noWebpage', 'invertMedia', 'message', 'entities', 'replyMarkup'];
      this.noWebpage = params.noWebpage;
      this.invertMedia = params.invertMedia;
      this.message = params.message;
      this.entities = params.entities;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotInlineMessageText> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let noWebpage = flags & (1 << 0) ? true : false;
      let invertMedia = flags & (1 << 3) ? true : false;
      let message = await Primitive.String.read(b);
      let entities = flags & (1 << 1) ? await TLObject.read(b) : [];
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.BotInlineMessageText({
        noWebpage: noWebpage,
        invertMedia: invertMedia,
        message: message,
        entities: entities,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.noWebpage ? 1 << 0 : 0;
      flags |= this.invertMedia ? 1 << 3 : 0;
      flags |= this.entities ? 1 << 1 : 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotInlineMessageMediaGeo extends TLObject {
    geo!: Raw.TypeGeoPoint;
    heading?: int;
    period?: int;
    proximityNotificationRadius?: int;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      geo: Raw.TypeGeoPoint;
      heading?: int;
      period?: int;
      proximityNotificationRadius?: int;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'BotInlineMessageMediaGeo';
      this.constructorId = 0x51846fd;
      this.subclassOfId = 0xc4910f88;
      this._slots = ['geo', 'heading', 'period', 'proximityNotificationRadius', 'replyMarkup'];
      this.geo = params.geo;
      this.heading = params.heading;
      this.period = params.period;
      this.proximityNotificationRadius = params.proximityNotificationRadius;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotInlineMessageMediaGeo> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let geo = await TLObject.read(b);
      let heading = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let period = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      let proximityNotificationRadius = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.BotInlineMessageMediaGeo({
        geo: geo,
        heading: heading,
        period: period,
        proximityNotificationRadius: proximityNotificationRadius,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.heading !== undefined ? 1 << 0 : 0;
      flags |= this.period !== undefined ? 1 << 1 : 0;
      flags |= this.proximityNotificationRadius !== undefined ? 1 << 3 : 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.geo !== undefined) {
        b.write(this.geo.write() as unknown as Buffer);
      }
      if (this.heading !== undefined) {
        b.write(Primitive.Int.write(this.heading) as unknown as Buffer);
      }
      if (this.period !== undefined) {
        b.write(Primitive.Int.write(this.period) as unknown as Buffer);
      }
      if (this.proximityNotificationRadius !== undefined) {
        b.write(Primitive.Int.write(this.proximityNotificationRadius) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotInlineMessageMediaVenue extends TLObject {
    geo!: Raw.TypeGeoPoint;
    title!: string;
    address!: string;
    provider!: string;
    venueId!: string;
    venueType!: string;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      geo: Raw.TypeGeoPoint;
      title: string;
      address: string;
      provider: string;
      venueId: string;
      venueType: string;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'BotInlineMessageMediaVenue';
      this.constructorId = 0x8a86659c;
      this.subclassOfId = 0xc4910f88;
      this._slots = ['geo', 'title', 'address', 'provider', 'venueId', 'venueType', 'replyMarkup'];
      this.geo = params.geo;
      this.title = params.title;
      this.address = params.address;
      this.provider = params.provider;
      this.venueId = params.venueId;
      this.venueType = params.venueType;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotInlineMessageMediaVenue> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let geo = await TLObject.read(b);
      let title = await Primitive.String.read(b);
      let address = await Primitive.String.read(b);
      let provider = await Primitive.String.read(b);
      let venueId = await Primitive.String.read(b);
      let venueType = await Primitive.String.read(b);
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.BotInlineMessageMediaVenue({
        geo: geo,
        title: title,
        address: address,
        provider: provider,
        venueId: venueId,
        venueType: venueType,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.geo !== undefined) {
        b.write(this.geo.write() as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.address !== undefined) {
        b.write(Primitive.String.write(this.address) as unknown as Buffer);
      }
      if (this.provider !== undefined) {
        b.write(Primitive.String.write(this.provider) as unknown as Buffer);
      }
      if (this.venueId !== undefined) {
        b.write(Primitive.String.write(this.venueId) as unknown as Buffer);
      }
      if (this.venueType !== undefined) {
        b.write(Primitive.String.write(this.venueType) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotInlineMessageMediaContact extends TLObject {
    phoneNumber!: string;
    firstName!: string;
    lastName!: string;
    vcard!: string;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      phoneNumber: string;
      firstName: string;
      lastName: string;
      vcard: string;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'BotInlineMessageMediaContact';
      this.constructorId = 0x18d1cdc2;
      this.subclassOfId = 0xc4910f88;
      this._slots = ['phoneNumber', 'firstName', 'lastName', 'vcard', 'replyMarkup'];
      this.phoneNumber = params.phoneNumber;
      this.firstName = params.firstName;
      this.lastName = params.lastName;
      this.vcard = params.vcard;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotInlineMessageMediaContact> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let phoneNumber = await Primitive.String.read(b);
      let firstName = await Primitive.String.read(b);
      let lastName = await Primitive.String.read(b);
      let vcard = await Primitive.String.read(b);
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.BotInlineMessageMediaContact({
        phoneNumber: phoneNumber,
        firstName: firstName,
        lastName: lastName,
        vcard: vcard,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.phoneNumber !== undefined) {
        b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
      }
      if (this.firstName !== undefined) {
        b.write(Primitive.String.write(this.firstName) as unknown as Buffer);
      }
      if (this.lastName !== undefined) {
        b.write(Primitive.String.write(this.lastName) as unknown as Buffer);
      }
      if (this.vcard !== undefined) {
        b.write(Primitive.String.write(this.vcard) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotInlineMessageMediaInvoice extends TLObject {
    shippingAddressRequested?: boolean;
    test?: boolean;
    title!: string;
    description!: string;
    photo?: Raw.TypeWebDocument;
    currency!: string;
    totalAmount!: long;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      shippingAddressRequested?: boolean;
      test?: boolean;
      title: string;
      description: string;
      photo?: Raw.TypeWebDocument;
      currency: string;
      totalAmount: long;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'BotInlineMessageMediaInvoice';
      this.constructorId = 0x354a9b09;
      this.subclassOfId = 0xc4910f88;
      this._slots = [
        'shippingAddressRequested',
        'test',
        'title',
        'description',
        'photo',
        'currency',
        'totalAmount',
        'replyMarkup',
      ];
      this.shippingAddressRequested = params.shippingAddressRequested;
      this.test = params.test;
      this.title = params.title;
      this.description = params.description;
      this.photo = params.photo;
      this.currency = params.currency;
      this.totalAmount = params.totalAmount;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotInlineMessageMediaInvoice> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let shippingAddressRequested = flags & (1 << 1) ? true : false;
      let test = flags & (1 << 3) ? true : false;
      let title = await Primitive.String.read(b);
      let description = await Primitive.String.read(b);
      let photo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let currency = await Primitive.String.read(b);
      let totalAmount = await Primitive.Long.read(b);
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.BotInlineMessageMediaInvoice({
        shippingAddressRequested: shippingAddressRequested,
        test: test,
        title: title,
        description: description,
        photo: photo,
        currency: currency,
        totalAmount: totalAmount,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.shippingAddressRequested ? 1 << 1 : 0;
      flags |= this.test ? 1 << 3 : 0;
      flags |= this.photo !== undefined ? 1 << 0 : 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.totalAmount !== undefined) {
        b.write(Primitive.Long.write(this.totalAmount) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotInlineMessageMediaWebPage extends TLObject {
    invertMedia?: boolean;
    forceLargeMedia?: boolean;
    forceSmallMedia?: boolean;
    manual?: boolean;
    safe?: boolean;
    message!: string;
    entities?: Vector<Raw.TypeMessageEntity>;
    url!: string;
    replyMarkup?: Raw.TypeReplyMarkup;

    constructor(params: {
      invertMedia?: boolean;
      forceLargeMedia?: boolean;
      forceSmallMedia?: boolean;
      manual?: boolean;
      safe?: boolean;
      message: string;
      entities?: Vector<Raw.TypeMessageEntity>;
      url: string;
      replyMarkup?: Raw.TypeReplyMarkup;
    }) {
      super();
      this.classType = 'types';
      this.className = 'BotInlineMessageMediaWebPage';
      this.constructorId = 0x809ad9a6;
      this.subclassOfId = 0xc4910f88;
      this._slots = [
        'invertMedia',
        'forceLargeMedia',
        'forceSmallMedia',
        'manual',
        'safe',
        'message',
        'entities',
        'url',
        'replyMarkup',
      ];
      this.invertMedia = params.invertMedia;
      this.forceLargeMedia = params.forceLargeMedia;
      this.forceSmallMedia = params.forceSmallMedia;
      this.manual = params.manual;
      this.safe = params.safe;
      this.message = params.message;
      this.entities = params.entities;
      this.url = params.url;
      this.replyMarkup = params.replyMarkup;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotInlineMessageMediaWebPage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let invertMedia = flags & (1 << 3) ? true : false;
      let forceLargeMedia = flags & (1 << 4) ? true : false;
      let forceSmallMedia = flags & (1 << 5) ? true : false;
      let manual = flags & (1 << 7) ? true : false;
      let safe = flags & (1 << 8) ? true : false;
      let message = await Primitive.String.read(b);
      let entities = flags & (1 << 1) ? await TLObject.read(b) : [];
      let url = await Primitive.String.read(b);
      let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.BotInlineMessageMediaWebPage({
        invertMedia: invertMedia,
        forceLargeMedia: forceLargeMedia,
        forceSmallMedia: forceSmallMedia,
        manual: manual,
        safe: safe,
        message: message,
        entities: entities,
        url: url,
        replyMarkup: replyMarkup,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.invertMedia ? 1 << 3 : 0;
      flags |= this.forceLargeMedia ? 1 << 4 : 0;
      flags |= this.forceSmallMedia ? 1 << 5 : 0;
      flags |= this.manual ? 1 << 7 : 0;
      flags |= this.safe ? 1 << 8 : 0;
      flags |= this.entities ? 1 << 1 : 0;
      flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.replyMarkup !== undefined) {
        b.write(this.replyMarkup.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotInlineResult extends TLObject {
    id!: string;
    type!: string;
    title?: string;
    description?: string;
    url?: string;
    thumb?: Raw.TypeWebDocument;
    content?: Raw.TypeWebDocument;
    sendMessage!: Raw.TypeBotInlineMessage;

    constructor(params: {
      id: string;
      type: string;
      title?: string;
      description?: string;
      url?: string;
      thumb?: Raw.TypeWebDocument;
      content?: Raw.TypeWebDocument;
      sendMessage: Raw.TypeBotInlineMessage;
    }) {
      super();
      this.classType = 'types';
      this.className = 'BotInlineResult';
      this.constructorId = 0x11965f3a;
      this.subclassOfId = 0x3832b3d5;
      this._slots = [
        'id',
        'type',
        'title',
        'description',
        'url',
        'thumb',
        'content',
        'sendMessage',
      ];
      this.id = params.id;
      this.type = params.type;
      this.title = params.title;
      this.description = params.description;
      this.url = params.url;
      this.thumb = params.thumb;
      this.content = params.content;
      this.sendMessage = params.sendMessage;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotInlineResult> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let id = await Primitive.String.read(b);
      let type = await Primitive.String.read(b);
      let title = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let description = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      let url = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
      let thumb = flags & (1 << 4) ? await TLObject.read(b) : undefined;
      let content = flags & (1 << 5) ? await TLObject.read(b) : undefined;
      let sendMessage = await TLObject.read(b);
      return new Raw.BotInlineResult({
        id: id,
        type: type,
        title: title,
        description: description,
        url: url,
        thumb: thumb,
        content: content,
        sendMessage: sendMessage,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.title !== undefined ? 1 << 1 : 0;
      flags |= this.description !== undefined ? 1 << 2 : 0;
      flags |= this.url !== undefined ? 1 << 3 : 0;
      flags |= this.thumb !== undefined ? 1 << 4 : 0;
      flags |= this.content !== undefined ? 1 << 5 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.String.write(this.id) as unknown as Buffer);
      }
      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.thumb !== undefined) {
        b.write(this.thumb.write() as unknown as Buffer);
      }
      if (this.content !== undefined) {
        b.write(this.content.write() as unknown as Buffer);
      }
      if (this.sendMessage !== undefined) {
        b.write(this.sendMessage.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotInlineMediaResult extends TLObject {
    id!: string;
    type!: string;
    photo?: Raw.TypePhoto;
    document?: Raw.TypeDocument;
    title?: string;
    description?: string;
    sendMessage!: Raw.TypeBotInlineMessage;

    constructor(params: {
      id: string;
      type: string;
      photo?: Raw.TypePhoto;
      document?: Raw.TypeDocument;
      title?: string;
      description?: string;
      sendMessage: Raw.TypeBotInlineMessage;
    }) {
      super();
      this.classType = 'types';
      this.className = 'BotInlineMediaResult';
      this.constructorId = 0x17db940b;
      this.subclassOfId = 0x3832b3d5;
      this._slots = ['id', 'type', 'photo', 'document', 'title', 'description', 'sendMessage'];
      this.id = params.id;
      this.type = params.type;
      this.photo = params.photo;
      this.document = params.document;
      this.title = params.title;
      this.description = params.description;
      this.sendMessage = params.sendMessage;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotInlineMediaResult> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let id = await Primitive.String.read(b);
      let type = await Primitive.String.read(b);
      let photo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let document = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let title = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      let description = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
      let sendMessage = await TLObject.read(b);
      return new Raw.BotInlineMediaResult({
        id: id,
        type: type,
        photo: photo,
        document: document,
        title: title,
        description: description,
        sendMessage: sendMessage,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.photo !== undefined ? 1 << 0 : 0;
      flags |= this.document !== undefined ? 1 << 1 : 0;
      flags |= this.title !== undefined ? 1 << 2 : 0;
      flags |= this.description !== undefined ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.String.write(this.id) as unknown as Buffer);
      }
      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.document !== undefined) {
        b.write(this.document.write() as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.sendMessage !== undefined) {
        b.write(this.sendMessage.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ExportedMessageLink extends TLObject {
    link!: string;
    html!: string;

    constructor(params: { link: string; html: string }) {
      super();
      this.classType = 'types';
      this.className = 'ExportedMessageLink';
      this.constructorId = 0x5dab1af4;
      this.subclassOfId = 0xdee644cc;
      this._slots = ['link', 'html'];
      this.link = params.link;
      this.html = params.html;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ExportedMessageLink> {
      // no flags

      let link = await Primitive.String.read(b);
      let html = await Primitive.String.read(b);
      return new Raw.ExportedMessageLink({ link: link, html: html });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.link !== undefined) {
        b.write(Primitive.String.write(this.link) as unknown as Buffer);
      }
      if (this.html !== undefined) {
        b.write(Primitive.String.write(this.html) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageFwdHeader extends TLObject {
    imported?: boolean;
    fromId?: Raw.TypePeer;
    fromName?: string;
    date!: int;
    channelPost?: int;
    postAuthor?: string;
    savedFromPeer?: Raw.TypePeer;
    savedFromMsgId?: int;
    psaType?: string;

    constructor(params: {
      imported?: boolean;
      fromId?: Raw.TypePeer;
      fromName?: string;
      date: int;
      channelPost?: int;
      postAuthor?: string;
      savedFromPeer?: Raw.TypePeer;
      savedFromMsgId?: int;
      psaType?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageFwdHeader';
      this.constructorId = 0x5f777dce;
      this.subclassOfId = 0x7a286804;
      this._slots = [
        'imported',
        'fromId',
        'fromName',
        'date',
        'channelPost',
        'postAuthor',
        'savedFromPeer',
        'savedFromMsgId',
        'psaType',
      ];
      this.imported = params.imported;
      this.fromId = params.fromId;
      this.fromName = params.fromName;
      this.date = params.date;
      this.channelPost = params.channelPost;
      this.postAuthor = params.postAuthor;
      this.savedFromPeer = params.savedFromPeer;
      this.savedFromMsgId = params.savedFromMsgId;
      this.psaType = params.psaType;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageFwdHeader> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let imported = flags & (1 << 7) ? true : false;
      let fromId = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let fromName = flags & (1 << 5) ? await Primitive.String.read(b) : undefined;
      let date = await Primitive.Int.read(b);
      let channelPost = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let postAuthor = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
      let savedFromPeer = flags & (1 << 4) ? await TLObject.read(b) : undefined;
      let savedFromMsgId = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      let psaType = flags & (1 << 6) ? await Primitive.String.read(b) : undefined;
      return new Raw.MessageFwdHeader({
        imported: imported,
        fromId: fromId,
        fromName: fromName,
        date: date,
        channelPost: channelPost,
        postAuthor: postAuthor,
        savedFromPeer: savedFromPeer,
        savedFromMsgId: savedFromMsgId,
        psaType: psaType,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.imported ? 1 << 7 : 0;
      flags |= this.fromId !== undefined ? 1 << 0 : 0;
      flags |= this.fromName !== undefined ? 1 << 5 : 0;
      flags |= this.channelPost !== undefined ? 1 << 2 : 0;
      flags |= this.postAuthor !== undefined ? 1 << 3 : 0;
      flags |= this.savedFromPeer !== undefined ? 1 << 4 : 0;
      flags |= this.savedFromMsgId !== undefined ? 1 << 4 : 0;
      flags |= this.psaType !== undefined ? 1 << 6 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.fromId !== undefined) {
        b.write(this.fromId.write() as unknown as Buffer);
      }
      if (this.fromName !== undefined) {
        b.write(Primitive.String.write(this.fromName) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.channelPost !== undefined) {
        b.write(Primitive.Int.write(this.channelPost) as unknown as Buffer);
      }
      if (this.postAuthor !== undefined) {
        b.write(Primitive.String.write(this.postAuthor) as unknown as Buffer);
      }
      if (this.savedFromPeer !== undefined) {
        b.write(this.savedFromPeer.write() as unknown as Buffer);
      }
      if (this.savedFromMsgId !== undefined) {
        b.write(Primitive.Int.write(this.savedFromMsgId) as unknown as Buffer);
      }
      if (this.psaType !== undefined) {
        b.write(Primitive.String.write(this.psaType) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineMessageID extends TLObject {
    dcId!: int;
    id!: long;
    accessHash!: long;

    constructor(params: { dcId: int; id: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineMessageID';
      this.constructorId = 0x890c3d89;
      this.subclassOfId = 0x2dcd6300;
      this._slots = ['dcId', 'id', 'accessHash'];
      this.dcId = params.dcId;
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputBotInlineMessageID> {
      // no flags

      let dcId = await Primitive.Int.read(b);
      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputBotInlineMessageID({ dcId: dcId, id: id, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.dcId !== undefined) {
        b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
      }
      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotInlineMessageID64 extends TLObject {
    dcId!: int;
    ownerId!: long;
    id!: int;
    accessHash!: long;

    constructor(params: { dcId: int; ownerId: long; id: int; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotInlineMessageID64';
      this.constructorId = 0xb6d915d7;
      this.subclassOfId = 0x2dcd6300;
      this._slots = ['dcId', 'ownerId', 'id', 'accessHash'];
      this.dcId = params.dcId;
      this.ownerId = params.ownerId;
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputBotInlineMessageID64> {
      // no flags

      let dcId = await Primitive.Int.read(b);
      let ownerId = await Primitive.Long.read(b);
      let id = await Primitive.Int.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputBotInlineMessageID64({
        dcId: dcId,
        ownerId: ownerId,
        id: id,
        accessHash: accessHash,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.dcId !== undefined) {
        b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
      }
      if (this.ownerId !== undefined) {
        b.write(Primitive.Long.write(this.ownerId) as unknown as Buffer);
      }
      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InlineBotSwitchPM extends TLObject {
    text!: string;
    startParam!: string;

    constructor(params: { text: string; startParam: string }) {
      super();
      this.classType = 'types';
      this.className = 'InlineBotSwitchPM';
      this.constructorId = 0x3c20629f;
      this.subclassOfId = 0x82b1f73b;
      this._slots = ['text', 'startParam'];
      this.text = params.text;
      this.startParam = params.startParam;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InlineBotSwitchPM> {
      // no flags

      let text = await Primitive.String.read(b);
      let startParam = await Primitive.String.read(b);
      return new Raw.InlineBotSwitchPM({ text: text, startParam: startParam });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.startParam !== undefined) {
        b.write(Primitive.String.write(this.startParam) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TopPeer extends TLObject {
    peer!: Raw.TypePeer;
    rating!: double;

    constructor(params: { peer: Raw.TypePeer; rating: double }) {
      super();
      this.classType = 'types';
      this.className = 'TopPeer';
      this.constructorId = 0xedcdc05b;
      this.subclassOfId = 0x6916c601;
      this._slots = ['peer', 'rating'];
      this.peer = params.peer;
      this.rating = params.rating;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TopPeer> {
      // no flags

      let peer = await TLObject.read(b);
      let rating = await Primitive.Double.read(b);
      return new Raw.TopPeer({ peer: peer, rating: rating });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.rating !== undefined) {
        b.write(Primitive.Double.write(this.rating) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TopPeerCategoryBotsPM extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'TopPeerCategoryBotsPM';
      this.constructorId = 0xab661b5b;
      this.subclassOfId = 0xddf02502;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TopPeerCategoryBotsPM> {
      // no flags

      return new Raw.TopPeerCategoryBotsPM();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class TopPeerCategoryBotsInline extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'TopPeerCategoryBotsInline';
      this.constructorId = 0x148677e2;
      this.subclassOfId = 0xddf02502;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TopPeerCategoryBotsInline> {
      // no flags

      return new Raw.TopPeerCategoryBotsInline();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class TopPeerCategoryCorrespondents extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'TopPeerCategoryCorrespondents';
      this.constructorId = 0x637b7ed;
      this.subclassOfId = 0xddf02502;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TopPeerCategoryCorrespondents> {
      // no flags

      return new Raw.TopPeerCategoryCorrespondents();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class TopPeerCategoryGroups extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'TopPeerCategoryGroups';
      this.constructorId = 0xbd17a14a;
      this.subclassOfId = 0xddf02502;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TopPeerCategoryGroups> {
      // no flags

      return new Raw.TopPeerCategoryGroups();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class TopPeerCategoryChannels extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'TopPeerCategoryChannels';
      this.constructorId = 0x161d9628;
      this.subclassOfId = 0xddf02502;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TopPeerCategoryChannels> {
      // no flags

      return new Raw.TopPeerCategoryChannels();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class TopPeerCategoryPhoneCalls extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'TopPeerCategoryPhoneCalls';
      this.constructorId = 0x1e76a78c;
      this.subclassOfId = 0xddf02502;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TopPeerCategoryPhoneCalls> {
      // no flags

      return new Raw.TopPeerCategoryPhoneCalls();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class TopPeerCategoryForwardUsers extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'TopPeerCategoryForwardUsers';
      this.constructorId = 0xa8406ca9;
      this.subclassOfId = 0xddf02502;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TopPeerCategoryForwardUsers> {
      // no flags

      return new Raw.TopPeerCategoryForwardUsers();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class TopPeerCategoryForwardChats extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'TopPeerCategoryForwardChats';
      this.constructorId = 0xfbeec0f0;
      this.subclassOfId = 0xddf02502;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TopPeerCategoryForwardChats> {
      // no flags

      return new Raw.TopPeerCategoryForwardChats();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class TopPeerCategoryPeers extends TLObject {
    category!: Raw.TypeTopPeerCategory;
    count!: int;
    peers!: Vector<Raw.TypeTopPeer>;

    constructor(params: {
      category: Raw.TypeTopPeerCategory;
      count: int;
      peers: Vector<Raw.TypeTopPeer>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'TopPeerCategoryPeers';
      this.constructorId = 0xfb834291;
      this.subclassOfId = 0x4aec930;
      this._slots = ['category', 'count', 'peers'];
      this.category = params.category;
      this.count = params.count;
      this.peers = params.peers;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TopPeerCategoryPeers> {
      // no flags

      let category = await TLObject.read(b);
      let count = await Primitive.Int.read(b);
      let peers = await TLObject.read(b);
      return new Raw.TopPeerCategoryPeers({ category: category, count: count, peers: peers });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.category !== undefined) {
        b.write(this.category.write() as unknown as Buffer);
      }
      if (this.count !== undefined) {
        b.write(Primitive.Int.write(this.count) as unknown as Buffer);
      }
      if (this.peers) {
        b.write(Primitive.Vector.write(this.peers) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DraftMessageEmpty extends TLObject {
    date?: int;

    constructor(params: { date?: int }) {
      super();
      this.classType = 'types';
      this.className = 'DraftMessageEmpty';
      this.constructorId = 0x1b0c841a;
      this.subclassOfId = 0x33d47f45;
      this._slots = ['date'];
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DraftMessageEmpty> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let date = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.DraftMessageEmpty({ date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.date !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DraftMessage extends TLObject {
    noWebpage?: boolean;
    invertMedia?: boolean;
    replyTo?: Raw.TypeInputReplyTo;
    message!: string;
    entities?: Vector<Raw.TypeMessageEntity>;
    media?: Raw.TypeInputMedia;
    date!: int;

    constructor(params: {
      noWebpage?: boolean;
      invertMedia?: boolean;
      replyTo?: Raw.TypeInputReplyTo;
      message: string;
      entities?: Vector<Raw.TypeMessageEntity>;
      media?: Raw.TypeInputMedia;
      date: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DraftMessage';
      this.constructorId = 0x3fccf7ef;
      this.subclassOfId = 0x33d47f45;
      this._slots = ['noWebpage', 'invertMedia', 'replyTo', 'message', 'entities', 'media', 'date'];
      this.noWebpage = params.noWebpage;
      this.invertMedia = params.invertMedia;
      this.replyTo = params.replyTo;
      this.message = params.message;
      this.entities = params.entities;
      this.media = params.media;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DraftMessage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let noWebpage = flags & (1 << 1) ? true : false;
      let invertMedia = flags & (1 << 6) ? true : false;
      let replyTo = flags & (1 << 4) ? await TLObject.read(b) : undefined;
      let message = await Primitive.String.read(b);
      let entities = flags & (1 << 3) ? await TLObject.read(b) : [];
      let media = flags & (1 << 5) ? await TLObject.read(b) : undefined;
      let date = await Primitive.Int.read(b);
      return new Raw.DraftMessage({
        noWebpage: noWebpage,
        invertMedia: invertMedia,
        replyTo: replyTo,
        message: message,
        entities: entities,
        media: media,
        date: date,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.noWebpage ? 1 << 1 : 0;
      flags |= this.invertMedia ? 1 << 6 : 0;
      flags |= this.replyTo !== undefined ? 1 << 4 : 0;
      flags |= this.entities ? 1 << 3 : 0;
      flags |= this.media !== undefined ? 1 << 5 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.replyTo !== undefined) {
        b.write(this.replyTo.write() as unknown as Buffer);
      }
      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.media !== undefined) {
        b.write(this.media.write() as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StickerSetCovered extends TLObject {
    set!: Raw.TypeStickerSet;
    cover!: Raw.TypeDocument;

    constructor(params: { set: Raw.TypeStickerSet; cover: Raw.TypeDocument }) {
      super();
      this.classType = 'types';
      this.className = 'StickerSetCovered';
      this.constructorId = 0x6410a5d2;
      this.subclassOfId = 0x7f86e4e5;
      this._slots = ['set', 'cover'];
      this.set = params.set;
      this.cover = params.cover;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StickerSetCovered> {
      // no flags

      let set = await TLObject.read(b);
      let cover = await TLObject.read(b);
      return new Raw.StickerSetCovered({ set: set, cover: cover });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.set !== undefined) {
        b.write(this.set.write() as unknown as Buffer);
      }
      if (this.cover !== undefined) {
        b.write(this.cover.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StickerSetMultiCovered extends TLObject {
    set!: Raw.TypeStickerSet;
    covers!: Vector<Raw.TypeDocument>;

    constructor(params: { set: Raw.TypeStickerSet; covers: Vector<Raw.TypeDocument> }) {
      super();
      this.classType = 'types';
      this.className = 'StickerSetMultiCovered';
      this.constructorId = 0x3407e51b;
      this.subclassOfId = 0x7f86e4e5;
      this._slots = ['set', 'covers'];
      this.set = params.set;
      this.covers = params.covers;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StickerSetMultiCovered> {
      // no flags

      let set = await TLObject.read(b);
      let covers = await TLObject.read(b);
      return new Raw.StickerSetMultiCovered({ set: set, covers: covers });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.set !== undefined) {
        b.write(this.set.write() as unknown as Buffer);
      }
      if (this.covers) {
        b.write(Primitive.Vector.write(this.covers) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StickerSetFullCovered extends TLObject {
    set!: Raw.TypeStickerSet;
    packs!: Vector<Raw.TypeStickerPack>;
    keywords!: Vector<Raw.TypeStickerKeyword>;
    documents!: Vector<Raw.TypeDocument>;

    constructor(params: {
      set: Raw.TypeStickerSet;
      packs: Vector<Raw.TypeStickerPack>;
      keywords: Vector<Raw.TypeStickerKeyword>;
      documents: Vector<Raw.TypeDocument>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'StickerSetFullCovered';
      this.constructorId = 0x40d13c0e;
      this.subclassOfId = 0x7f86e4e5;
      this._slots = ['set', 'packs', 'keywords', 'documents'];
      this.set = params.set;
      this.packs = params.packs;
      this.keywords = params.keywords;
      this.documents = params.documents;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StickerSetFullCovered> {
      // no flags

      let set = await TLObject.read(b);
      let packs = await TLObject.read(b);
      let keywords = await TLObject.read(b);
      let documents = await TLObject.read(b);
      return new Raw.StickerSetFullCovered({
        set: set,
        packs: packs,
        keywords: keywords,
        documents: documents,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.set !== undefined) {
        b.write(this.set.write() as unknown as Buffer);
      }
      if (this.packs) {
        b.write(Primitive.Vector.write(this.packs) as unknown as Buffer);
      }
      if (this.keywords) {
        b.write(Primitive.Vector.write(this.keywords) as unknown as Buffer);
      }
      if (this.documents) {
        b.write(Primitive.Vector.write(this.documents) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StickerSetNoCovered extends TLObject {
    set!: Raw.TypeStickerSet;

    constructor(params: { set: Raw.TypeStickerSet }) {
      super();
      this.classType = 'types';
      this.className = 'StickerSetNoCovered';
      this.constructorId = 0x77b15d1c;
      this.subclassOfId = 0x7f86e4e5;
      this._slots = ['set'];
      this.set = params.set;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StickerSetNoCovered> {
      // no flags

      let set = await TLObject.read(b);
      return new Raw.StickerSetNoCovered({ set: set });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.set !== undefined) {
        b.write(this.set.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MaskCoords extends TLObject {
    n!: int;
    x!: double;
    y!: double;
    zoom!: double;

    constructor(params: { n: int; x: double; y: double; zoom: double }) {
      super();
      this.classType = 'types';
      this.className = 'MaskCoords';
      this.constructorId = 0xaed6dbb2;
      this.subclassOfId = 0x6bbb2fd;
      this._slots = ['n', 'x', 'y', 'zoom'];
      this.n = params.n;
      this.x = params.x;
      this.y = params.y;
      this.zoom = params.zoom;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MaskCoords> {
      // no flags

      let n = await Primitive.Int.read(b);
      let x = await Primitive.Double.read(b);
      let y = await Primitive.Double.read(b);
      let zoom = await Primitive.Double.read(b);
      return new Raw.MaskCoords({ n: n, x: x, y: y, zoom: zoom });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.n !== undefined) {
        b.write(Primitive.Int.write(this.n) as unknown as Buffer);
      }
      if (this.x !== undefined) {
        b.write(Primitive.Double.write(this.x) as unknown as Buffer);
      }
      if (this.y !== undefined) {
        b.write(Primitive.Double.write(this.y) as unknown as Buffer);
      }
      if (this.zoom !== undefined) {
        b.write(Primitive.Double.write(this.zoom) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputStickeredMediaPhoto extends TLObject {
    id!: Raw.TypeInputPhoto;

    constructor(params: { id: Raw.TypeInputPhoto }) {
      super();
      this.classType = 'types';
      this.className = 'InputStickeredMediaPhoto';
      this.constructorId = 0x4a992157;
      this.subclassOfId = 0x5146d99e;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputStickeredMediaPhoto> {
      // no flags

      let id = await TLObject.read(b);
      return new Raw.InputStickeredMediaPhoto({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(this.id.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputStickeredMediaDocument extends TLObject {
    id!: Raw.TypeInputDocument;

    constructor(params: { id: Raw.TypeInputDocument }) {
      super();
      this.classType = 'types';
      this.className = 'InputStickeredMediaDocument';
      this.constructorId = 0x438865b;
      this.subclassOfId = 0x5146d99e;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputStickeredMediaDocument> {
      // no flags

      let id = await TLObject.read(b);
      return new Raw.InputStickeredMediaDocument({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(this.id.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Game extends TLObject {
    id!: long;
    accessHash!: long;
    shortName!: string;
    title!: string;
    description!: string;
    photo!: Raw.TypePhoto;
    document?: Raw.TypeDocument;

    constructor(params: {
      id: long;
      accessHash: long;
      shortName: string;
      title: string;
      description: string;
      photo: Raw.TypePhoto;
      document?: Raw.TypeDocument;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Game';
      this.constructorId = 0xbdf9653b;
      this.subclassOfId = 0x83199eb2;
      this._slots = ['id', 'accessHash', 'shortName', 'title', 'description', 'photo', 'document'];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.shortName = params.shortName;
      this.title = params.title;
      this.description = params.description;
      this.photo = params.photo;
      this.document = params.document;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Game> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let shortName = await Primitive.String.read(b);
      let title = await Primitive.String.read(b);
      let description = await Primitive.String.read(b);
      let photo = await TLObject.read(b);
      let document = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      return new Raw.Game({
        id: id,
        accessHash: accessHash,
        shortName: shortName,
        title: title,
        description: description,
        photo: photo,
        document: document,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.document !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.shortName !== undefined) {
        b.write(Primitive.String.write(this.shortName) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.document !== undefined) {
        b.write(this.document.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputGameID extends TLObject {
    id!: long;
    accessHash!: long;

    constructor(params: { id: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputGameID';
      this.constructorId = 0x32c3e77;
      this.subclassOfId = 0x48d15883;
      this._slots = ['id', 'accessHash'];
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputGameID> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputGameID({ id: id, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputGameShortName extends TLObject {
    botId!: Raw.TypeInputUser;
    shortName!: string;

    constructor(params: { botId: Raw.TypeInputUser; shortName: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputGameShortName';
      this.constructorId = 0xc331e80a;
      this.subclassOfId = 0x48d15883;
      this._slots = ['botId', 'shortName'];
      this.botId = params.botId;
      this.shortName = params.shortName;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputGameShortName> {
      // no flags

      let botId = await TLObject.read(b);
      let shortName = await Primitive.String.read(b);
      return new Raw.InputGameShortName({ botId: botId, shortName: shortName });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.botId !== undefined) {
        b.write(this.botId.write() as unknown as Buffer);
      }
      if (this.shortName !== undefined) {
        b.write(Primitive.String.write(this.shortName) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class HighScore extends TLObject {
    pos!: int;
    userId!: long;
    score!: int;

    constructor(params: { pos: int; userId: long; score: int }) {
      super();
      this.classType = 'types';
      this.className = 'HighScore';
      this.constructorId = 0x73a379eb;
      this.subclassOfId = 0xd32b1e35;
      this._slots = ['pos', 'userId', 'score'];
      this.pos = params.pos;
      this.userId = params.userId;
      this.score = params.score;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.HighScore> {
      // no flags

      let pos = await Primitive.Int.read(b);
      let userId = await Primitive.Long.read(b);
      let score = await Primitive.Int.read(b);
      return new Raw.HighScore({ pos: pos, userId: userId, score: score });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.pos !== undefined) {
        b.write(Primitive.Int.write(this.pos) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.score !== undefined) {
        b.write(Primitive.Int.write(this.score) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'TextEmpty';
      this.constructorId = 0xdc3d824f;
      this.subclassOfId = 0xf1d0b479;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextEmpty> {
      // no flags

      return new Raw.TextEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class TextPlain extends TLObject {
    text!: string;

    constructor(params: { text: string }) {
      super();
      this.classType = 'types';
      this.className = 'TextPlain';
      this.constructorId = 0x744694e0;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextPlain> {
      // no flags

      let text = await Primitive.String.read(b);
      return new Raw.TextPlain({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextBold extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'TextBold';
      this.constructorId = 0x6724abc4;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextBold> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.TextBold({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextItalic extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'TextItalic';
      this.constructorId = 0xd912a59c;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextItalic> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.TextItalic({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextUnderline extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'TextUnderline';
      this.constructorId = 0xc12622c4;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextUnderline> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.TextUnderline({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextStrike extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'TextStrike';
      this.constructorId = 0x9bf8bb95;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextStrike> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.TextStrike({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextFixed extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'TextFixed';
      this.constructorId = 0x6c3f19b9;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextFixed> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.TextFixed({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextUrl extends TLObject {
    text!: Raw.TypeRichText;
    url!: string;
    webpageId!: long;

    constructor(params: { text: Raw.TypeRichText; url: string; webpageId: long }) {
      super();
      this.classType = 'types';
      this.className = 'TextUrl';
      this.constructorId = 0x3c2884c1;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text', 'url', 'webpageId'];
      this.text = params.text;
      this.url = params.url;
      this.webpageId = params.webpageId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextUrl> {
      // no flags

      let text = await TLObject.read(b);
      let url = await Primitive.String.read(b);
      let webpageId = await Primitive.Long.read(b);
      return new Raw.TextUrl({ text: text, url: url, webpageId: webpageId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.webpageId !== undefined) {
        b.write(Primitive.Long.write(this.webpageId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextEmail extends TLObject {
    text!: Raw.TypeRichText;
    email!: string;

    constructor(params: { text: Raw.TypeRichText; email: string }) {
      super();
      this.classType = 'types';
      this.className = 'TextEmail';
      this.constructorId = 0xde5a0dd6;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text', 'email'];
      this.text = params.text;
      this.email = params.email;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextEmail> {
      // no flags

      let text = await TLObject.read(b);
      let email = await Primitive.String.read(b);
      return new Raw.TextEmail({ text: text, email: email });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      if (this.email !== undefined) {
        b.write(Primitive.String.write(this.email) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextConcat extends TLObject {
    texts!: Vector<Raw.TypeRichText>;

    constructor(params: { texts: Vector<Raw.TypeRichText> }) {
      super();
      this.classType = 'types';
      this.className = 'TextConcat';
      this.constructorId = 0x7e6260d7;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['texts'];
      this.texts = params.texts;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextConcat> {
      // no flags

      let texts = await TLObject.read(b);
      return new Raw.TextConcat({ texts: texts });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.texts) {
        b.write(Primitive.Vector.write(this.texts) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextSubscript extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'TextSubscript';
      this.constructorId = 0xed6a8504;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextSubscript> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.TextSubscript({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextSuperscript extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'TextSuperscript';
      this.constructorId = 0xc7fb5e01;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextSuperscript> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.TextSuperscript({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextMarked extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'TextMarked';
      this.constructorId = 0x34b8621;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextMarked> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.TextMarked({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextPhone extends TLObject {
    text!: Raw.TypeRichText;
    phone!: string;

    constructor(params: { text: Raw.TypeRichText; phone: string }) {
      super();
      this.classType = 'types';
      this.className = 'TextPhone';
      this.constructorId = 0x1ccb966a;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text', 'phone'];
      this.text = params.text;
      this.phone = params.phone;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextPhone> {
      // no flags

      let text = await TLObject.read(b);
      let phone = await Primitive.String.read(b);
      return new Raw.TextPhone({ text: text, phone: phone });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      if (this.phone !== undefined) {
        b.write(Primitive.String.write(this.phone) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextImage extends TLObject {
    documentId!: long;
    w!: int;
    h!: int;

    constructor(params: { documentId: long; w: int; h: int }) {
      super();
      this.classType = 'types';
      this.className = 'TextImage';
      this.constructorId = 0x81ccf4f;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['documentId', 'w', 'h'];
      this.documentId = params.documentId;
      this.w = params.w;
      this.h = params.h;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextImage> {
      // no flags

      let documentId = await Primitive.Long.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      return new Raw.TextImage({ documentId: documentId, w: w, h: h });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.documentId !== undefined) {
        b.write(Primitive.Long.write(this.documentId) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextAnchor extends TLObject {
    text!: Raw.TypeRichText;
    name!: string;

    constructor(params: { text: Raw.TypeRichText; name: string }) {
      super();
      this.classType = 'types';
      this.className = 'TextAnchor';
      this.constructorId = 0x35553762;
      this.subclassOfId = 0xf1d0b479;
      this._slots = ['text', 'name'];
      this.text = params.text;
      this.name = params.name;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextAnchor> {
      // no flags

      let text = await TLObject.read(b);
      let name = await Primitive.String.read(b);
      return new Raw.TextAnchor({ text: text, name: name });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      if (this.name !== undefined) {
        b.write(Primitive.String.write(this.name) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockUnsupported extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PageBlockUnsupported';
      this.constructorId = 0x13567e8a;
      this.subclassOfId = 0x1aca5644;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockUnsupported> {
      // no flags

      return new Raw.PageBlockUnsupported();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PageBlockTitle extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockTitle';
      this.constructorId = 0x70abc3fd;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockTitle> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.PageBlockTitle({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockSubtitle extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockSubtitle';
      this.constructorId = 0x8ffa9a1f;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockSubtitle> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.PageBlockSubtitle({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockAuthorDate extends TLObject {
    author!: Raw.TypeRichText;
    publishedDate!: int;

    constructor(params: { author: Raw.TypeRichText; publishedDate: int }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockAuthorDate';
      this.constructorId = 0xbaafe5e0;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['author', 'publishedDate'];
      this.author = params.author;
      this.publishedDate = params.publishedDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockAuthorDate> {
      // no flags

      let author = await TLObject.read(b);
      let publishedDate = await Primitive.Int.read(b);
      return new Raw.PageBlockAuthorDate({ author: author, publishedDate: publishedDate });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.author !== undefined) {
        b.write(this.author.write() as unknown as Buffer);
      }
      if (this.publishedDate !== undefined) {
        b.write(Primitive.Int.write(this.publishedDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockHeader extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockHeader';
      this.constructorId = 0xbfd064ec;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockHeader> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.PageBlockHeader({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockSubheader extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockSubheader';
      this.constructorId = 0xf12bb6e1;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockSubheader> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.PageBlockSubheader({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockParagraph extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockParagraph';
      this.constructorId = 0x467a0766;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockParagraph> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.PageBlockParagraph({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockPreformatted extends TLObject {
    text!: Raw.TypeRichText;
    language!: string;

    constructor(params: { text: Raw.TypeRichText; language: string }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockPreformatted';
      this.constructorId = 0xc070d93e;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['text', 'language'];
      this.text = params.text;
      this.language = params.language;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockPreformatted> {
      // no flags

      let text = await TLObject.read(b);
      let language = await Primitive.String.read(b);
      return new Raw.PageBlockPreformatted({ text: text, language: language });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      if (this.language !== undefined) {
        b.write(Primitive.String.write(this.language) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockFooter extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockFooter';
      this.constructorId = 0x48870999;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockFooter> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.PageBlockFooter({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockDivider extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PageBlockDivider';
      this.constructorId = 0xdb20b188;
      this.subclassOfId = 0x1aca5644;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockDivider> {
      // no flags

      return new Raw.PageBlockDivider();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PageBlockAnchor extends TLObject {
    name!: string;

    constructor(params: { name: string }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockAnchor';
      this.constructorId = 0xce0d37b0;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['name'];
      this.name = params.name;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockAnchor> {
      // no flags

      let name = await Primitive.String.read(b);
      return new Raw.PageBlockAnchor({ name: name });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.name !== undefined) {
        b.write(Primitive.String.write(this.name) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockList extends TLObject {
    items!: Vector<Raw.TypePageListItem>;

    constructor(params: { items: Vector<Raw.TypePageListItem> }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockList';
      this.constructorId = 0xe4e88011;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['items'];
      this.items = params.items;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockList> {
      // no flags

      let items = await TLObject.read(b);
      return new Raw.PageBlockList({ items: items });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.items) {
        b.write(Primitive.Vector.write(this.items) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockBlockquote extends TLObject {
    text!: Raw.TypeRichText;
    caption!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText; caption: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockBlockquote';
      this.constructorId = 0x263d7c26;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['text', 'caption'];
      this.text = params.text;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockBlockquote> {
      // no flags

      let text = await TLObject.read(b);
      let caption = await TLObject.read(b);
      return new Raw.PageBlockBlockquote({ text: text, caption: caption });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(this.caption.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockPullquote extends TLObject {
    text!: Raw.TypeRichText;
    caption!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText; caption: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockPullquote';
      this.constructorId = 0x4f4456d3;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['text', 'caption'];
      this.text = params.text;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockPullquote> {
      // no flags

      let text = await TLObject.read(b);
      let caption = await TLObject.read(b);
      return new Raw.PageBlockPullquote({ text: text, caption: caption });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(this.caption.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockPhoto extends TLObject {
    photoId!: long;
    caption!: Raw.TypePageCaption;
    url?: string;
    webpageId?: long;

    constructor(params: {
      photoId: long;
      caption: Raw.TypePageCaption;
      url?: string;
      webpageId?: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockPhoto';
      this.constructorId = 0x1759c560;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['photoId', 'caption', 'url', 'webpageId'];
      this.photoId = params.photoId;
      this.caption = params.caption;
      this.url = params.url;
      this.webpageId = params.webpageId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockPhoto> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let photoId = await Primitive.Long.read(b);
      let caption = await TLObject.read(b);
      let url = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let webpageId = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
      return new Raw.PageBlockPhoto({
        photoId: photoId,
        caption: caption,
        url: url,
        webpageId: webpageId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.url !== undefined ? 1 << 0 : 0;
      flags |= this.webpageId !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.photoId !== undefined) {
        b.write(Primitive.Long.write(this.photoId) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(this.caption.write() as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.webpageId !== undefined) {
        b.write(Primitive.Long.write(this.webpageId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockVideo extends TLObject {
    autoplay?: boolean;
    loop?: boolean;
    videoId!: long;
    caption!: Raw.TypePageCaption;

    constructor(params: {
      autoplay?: boolean;
      loop?: boolean;
      videoId: long;
      caption: Raw.TypePageCaption;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockVideo';
      this.constructorId = 0x7c8fe7b6;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['autoplay', 'loop', 'videoId', 'caption'];
      this.autoplay = params.autoplay;
      this.loop = params.loop;
      this.videoId = params.videoId;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockVideo> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let autoplay = flags & (1 << 0) ? true : false;
      let loop = flags & (1 << 1) ? true : false;
      let videoId = await Primitive.Long.read(b);
      let caption = await TLObject.read(b);
      return new Raw.PageBlockVideo({
        autoplay: autoplay,
        loop: loop,
        videoId: videoId,
        caption: caption,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.autoplay ? 1 << 0 : 0;
      flags |= this.loop ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.videoId !== undefined) {
        b.write(Primitive.Long.write(this.videoId) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(this.caption.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockCover extends TLObject {
    cover!: Raw.TypePageBlock;

    constructor(params: { cover: Raw.TypePageBlock }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockCover';
      this.constructorId = 0x39f23300;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['cover'];
      this.cover = params.cover;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockCover> {
      // no flags

      let cover = await TLObject.read(b);
      return new Raw.PageBlockCover({ cover: cover });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.cover !== undefined) {
        b.write(this.cover.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockEmbed extends TLObject {
    fullWidth?: boolean;
    allowScrolling?: boolean;
    url?: string;
    html?: string;
    posterPhotoId?: long;
    w?: int;
    h?: int;
    caption!: Raw.TypePageCaption;

    constructor(params: {
      fullWidth?: boolean;
      allowScrolling?: boolean;
      url?: string;
      html?: string;
      posterPhotoId?: long;
      w?: int;
      h?: int;
      caption: Raw.TypePageCaption;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockEmbed';
      this.constructorId = 0xa8718dc5;
      this.subclassOfId = 0x1aca5644;
      this._slots = [
        'fullWidth',
        'allowScrolling',
        'url',
        'html',
        'posterPhotoId',
        'w',
        'h',
        'caption',
      ];
      this.fullWidth = params.fullWidth;
      this.allowScrolling = params.allowScrolling;
      this.url = params.url;
      this.html = params.html;
      this.posterPhotoId = params.posterPhotoId;
      this.w = params.w;
      this.h = params.h;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockEmbed> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let fullWidth = flags & (1 << 0) ? true : false;
      let allowScrolling = flags & (1 << 3) ? true : false;
      let url = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let html = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      let posterPhotoId = flags & (1 << 4) ? await Primitive.Long.read(b) : undefined;
      let w = flags & (1 << 5) ? await Primitive.Int.read(b) : undefined;
      let h = flags & (1 << 5) ? await Primitive.Int.read(b) : undefined;
      let caption = await TLObject.read(b);
      return new Raw.PageBlockEmbed({
        fullWidth: fullWidth,
        allowScrolling: allowScrolling,
        url: url,
        html: html,
        posterPhotoId: posterPhotoId,
        w: w,
        h: h,
        caption: caption,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.fullWidth ? 1 << 0 : 0;
      flags |= this.allowScrolling ? 1 << 3 : 0;
      flags |= this.url !== undefined ? 1 << 1 : 0;
      flags |= this.html !== undefined ? 1 << 2 : 0;
      flags |= this.posterPhotoId !== undefined ? 1 << 4 : 0;
      flags |= this.w !== undefined ? 1 << 5 : 0;
      flags |= this.h !== undefined ? 1 << 5 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.html !== undefined) {
        b.write(Primitive.String.write(this.html) as unknown as Buffer);
      }
      if (this.posterPhotoId !== undefined) {
        b.write(Primitive.Long.write(this.posterPhotoId) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(this.caption.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockEmbedPost extends TLObject {
    url!: string;
    webpageId!: long;
    authorPhotoId!: long;
    author!: string;
    date!: int;
    blocks!: Vector<Raw.TypePageBlock>;
    caption!: Raw.TypePageCaption;

    constructor(params: {
      url: string;
      webpageId: long;
      authorPhotoId: long;
      author: string;
      date: int;
      blocks: Vector<Raw.TypePageBlock>;
      caption: Raw.TypePageCaption;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockEmbedPost';
      this.constructorId = 0xf259a80b;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['url', 'webpageId', 'authorPhotoId', 'author', 'date', 'blocks', 'caption'];
      this.url = params.url;
      this.webpageId = params.webpageId;
      this.authorPhotoId = params.authorPhotoId;
      this.author = params.author;
      this.date = params.date;
      this.blocks = params.blocks;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockEmbedPost> {
      // no flags

      let url = await Primitive.String.read(b);
      let webpageId = await Primitive.Long.read(b);
      let authorPhotoId = await Primitive.Long.read(b);
      let author = await Primitive.String.read(b);
      let date = await Primitive.Int.read(b);
      let blocks = await TLObject.read(b);
      let caption = await TLObject.read(b);
      return new Raw.PageBlockEmbedPost({
        url: url,
        webpageId: webpageId,
        authorPhotoId: authorPhotoId,
        author: author,
        date: date,
        blocks: blocks,
        caption: caption,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.webpageId !== undefined) {
        b.write(Primitive.Long.write(this.webpageId) as unknown as Buffer);
      }
      if (this.authorPhotoId !== undefined) {
        b.write(Primitive.Long.write(this.authorPhotoId) as unknown as Buffer);
      }
      if (this.author !== undefined) {
        b.write(Primitive.String.write(this.author) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.blocks) {
        b.write(Primitive.Vector.write(this.blocks) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(this.caption.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockCollage extends TLObject {
    items!: Vector<Raw.TypePageBlock>;
    caption!: Raw.TypePageCaption;

    constructor(params: { items: Vector<Raw.TypePageBlock>; caption: Raw.TypePageCaption }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockCollage';
      this.constructorId = 0x65a0fa4d;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['items', 'caption'];
      this.items = params.items;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockCollage> {
      // no flags

      let items = await TLObject.read(b);
      let caption = await TLObject.read(b);
      return new Raw.PageBlockCollage({ items: items, caption: caption });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.items) {
        b.write(Primitive.Vector.write(this.items) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(this.caption.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockSlideshow extends TLObject {
    items!: Vector<Raw.TypePageBlock>;
    caption!: Raw.TypePageCaption;

    constructor(params: { items: Vector<Raw.TypePageBlock>; caption: Raw.TypePageCaption }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockSlideshow';
      this.constructorId = 0x31f9590;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['items', 'caption'];
      this.items = params.items;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockSlideshow> {
      // no flags

      let items = await TLObject.read(b);
      let caption = await TLObject.read(b);
      return new Raw.PageBlockSlideshow({ items: items, caption: caption });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.items) {
        b.write(Primitive.Vector.write(this.items) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(this.caption.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockChannel extends TLObject {
    channel!: Raw.TypeChat;

    constructor(params: { channel: Raw.TypeChat }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockChannel';
      this.constructorId = 0xef1751b5;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['channel'];
      this.channel = params.channel;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockChannel> {
      // no flags

      let channel = await TLObject.read(b);
      return new Raw.PageBlockChannel({ channel: channel });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channel !== undefined) {
        b.write(this.channel.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockAudio extends TLObject {
    audioId!: long;
    caption!: Raw.TypePageCaption;

    constructor(params: { audioId: long; caption: Raw.TypePageCaption }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockAudio';
      this.constructorId = 0x804361ea;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['audioId', 'caption'];
      this.audioId = params.audioId;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockAudio> {
      // no flags

      let audioId = await Primitive.Long.read(b);
      let caption = await TLObject.read(b);
      return new Raw.PageBlockAudio({ audioId: audioId, caption: caption });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.audioId !== undefined) {
        b.write(Primitive.Long.write(this.audioId) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(this.caption.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockKicker extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockKicker';
      this.constructorId = 0x1e148390;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockKicker> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.PageBlockKicker({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockTable extends TLObject {
    bordered?: boolean;
    striped?: boolean;
    title!: Raw.TypeRichText;
    rows!: Vector<Raw.TypePageTableRow>;

    constructor(params: {
      bordered?: boolean;
      striped?: boolean;
      title: Raw.TypeRichText;
      rows: Vector<Raw.TypePageTableRow>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockTable';
      this.constructorId = 0xbf4dea82;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['bordered', 'striped', 'title', 'rows'];
      this.bordered = params.bordered;
      this.striped = params.striped;
      this.title = params.title;
      this.rows = params.rows;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockTable> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let bordered = flags & (1 << 0) ? true : false;
      let striped = flags & (1 << 1) ? true : false;
      let title = await TLObject.read(b);
      let rows = await TLObject.read(b);
      return new Raw.PageBlockTable({
        bordered: bordered,
        striped: striped,
        title: title,
        rows: rows,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.bordered ? 1 << 0 : 0;
      flags |= this.striped ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.title !== undefined) {
        b.write(this.title.write() as unknown as Buffer);
      }
      if (this.rows) {
        b.write(Primitive.Vector.write(this.rows) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockOrderedList extends TLObject {
    items!: Vector<Raw.TypePageListOrderedItem>;

    constructor(params: { items: Vector<Raw.TypePageListOrderedItem> }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockOrderedList';
      this.constructorId = 0x9a8ae1e1;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['items'];
      this.items = params.items;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockOrderedList> {
      // no flags

      let items = await TLObject.read(b);
      return new Raw.PageBlockOrderedList({ items: items });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.items) {
        b.write(Primitive.Vector.write(this.items) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockDetails extends TLObject {
    open?: boolean;
    blocks!: Vector<Raw.TypePageBlock>;
    title!: Raw.TypeRichText;

    constructor(params: {
      open?: boolean;
      blocks: Vector<Raw.TypePageBlock>;
      title: Raw.TypeRichText;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockDetails';
      this.constructorId = 0x76768bed;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['open', 'blocks', 'title'];
      this.open = params.open;
      this.blocks = params.blocks;
      this.title = params.title;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockDetails> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let open = flags & (1 << 0) ? true : false;
      let blocks = await TLObject.read(b);
      let title = await TLObject.read(b);
      return new Raw.PageBlockDetails({ open: open, blocks: blocks, title: title });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.open ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.blocks) {
        b.write(Primitive.Vector.write(this.blocks) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(this.title.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockRelatedArticles extends TLObject {
    title!: Raw.TypeRichText;
    articles!: Vector<Raw.TypePageRelatedArticle>;

    constructor(params: { title: Raw.TypeRichText; articles: Vector<Raw.TypePageRelatedArticle> }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockRelatedArticles';
      this.constructorId = 0x16115a96;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['title', 'articles'];
      this.title = params.title;
      this.articles = params.articles;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockRelatedArticles> {
      // no flags

      let title = await TLObject.read(b);
      let articles = await TLObject.read(b);
      return new Raw.PageBlockRelatedArticles({ title: title, articles: articles });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.title !== undefined) {
        b.write(this.title.write() as unknown as Buffer);
      }
      if (this.articles) {
        b.write(Primitive.Vector.write(this.articles) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageBlockMap extends TLObject {
    geo!: Raw.TypeGeoPoint;
    zoom!: int;
    w!: int;
    h!: int;
    caption!: Raw.TypePageCaption;

    constructor(params: {
      geo: Raw.TypeGeoPoint;
      zoom: int;
      w: int;
      h: int;
      caption: Raw.TypePageCaption;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PageBlockMap';
      this.constructorId = 0xa44f3ef6;
      this.subclassOfId = 0x1aca5644;
      this._slots = ['geo', 'zoom', 'w', 'h', 'caption'];
      this.geo = params.geo;
      this.zoom = params.zoom;
      this.w = params.w;
      this.h = params.h;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageBlockMap> {
      // no flags

      let geo = await TLObject.read(b);
      let zoom = await Primitive.Int.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let caption = await TLObject.read(b);
      return new Raw.PageBlockMap({ geo: geo, zoom: zoom, w: w, h: h, caption: caption });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.geo !== undefined) {
        b.write(this.geo.write() as unknown as Buffer);
      }
      if (this.zoom !== undefined) {
        b.write(Primitive.Int.write(this.zoom) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(this.caption.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhoneCallDiscardReasonMissed extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PhoneCallDiscardReasonMissed';
      this.constructorId = 0x85e42301;
      this.subclassOfId = 0xd89bad3d;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhoneCallDiscardReasonMissed> {
      // no flags

      return new Raw.PhoneCallDiscardReasonMissed();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PhoneCallDiscardReasonDisconnect extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PhoneCallDiscardReasonDisconnect';
      this.constructorId = 0xe095c1a0;
      this.subclassOfId = 0xd89bad3d;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.PhoneCallDiscardReasonDisconnect> {
      // no flags

      return new Raw.PhoneCallDiscardReasonDisconnect();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PhoneCallDiscardReasonHangup extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PhoneCallDiscardReasonHangup';
      this.constructorId = 0x57adc690;
      this.subclassOfId = 0xd89bad3d;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhoneCallDiscardReasonHangup> {
      // no flags

      return new Raw.PhoneCallDiscardReasonHangup();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PhoneCallDiscardReasonBusy extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PhoneCallDiscardReasonBusy';
      this.constructorId = 0xfaf7e8c9;
      this.subclassOfId = 0xd89bad3d;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhoneCallDiscardReasonBusy> {
      // no flags

      return new Raw.PhoneCallDiscardReasonBusy();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class DataJSON extends TLObject {
    data!: string;

    constructor(params: { data: string }) {
      super();
      this.classType = 'types';
      this.className = 'DataJSON';
      this.constructorId = 0x7d748d04;
      this.subclassOfId = 0xad0352e8;
      this._slots = ['data'];
      this.data = params.data;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DataJSON> {
      // no flags

      let data = await Primitive.String.read(b);
      return new Raw.DataJSON({ data: data });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.data !== undefined) {
        b.write(Primitive.String.write(this.data) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class LabeledPrice extends TLObject {
    label!: string;
    amount!: long;

    constructor(params: { label: string; amount: long }) {
      super();
      this.classType = 'types';
      this.className = 'LabeledPrice';
      this.constructorId = 0xcb296bf8;
      this.subclassOfId = 0x1c84047a;
      this._slots = ['label', 'amount'];
      this.label = params.label;
      this.amount = params.amount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.LabeledPrice> {
      // no flags

      let label = await Primitive.String.read(b);
      let amount = await Primitive.Long.read(b);
      return new Raw.LabeledPrice({ label: label, amount: amount });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.label !== undefined) {
        b.write(Primitive.String.write(this.label) as unknown as Buffer);
      }
      if (this.amount !== undefined) {
        b.write(Primitive.Long.write(this.amount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Invoice extends TLObject {
    test?: boolean;
    nameRequested?: boolean;
    phoneRequested?: boolean;
    emailRequested?: boolean;
    shippingAddressRequested?: boolean;
    flexible?: boolean;
    phoneToProvider?: boolean;
    emailToProvider?: boolean;
    recurring?: boolean;
    currency!: string;
    prices!: Vector<Raw.TypeLabeledPrice>;
    maxTipAmount?: long;
    suggestedTipAmounts?: Vector<long>;
    termsUrl?: string;

    constructor(params: {
      test?: boolean;
      nameRequested?: boolean;
      phoneRequested?: boolean;
      emailRequested?: boolean;
      shippingAddressRequested?: boolean;
      flexible?: boolean;
      phoneToProvider?: boolean;
      emailToProvider?: boolean;
      recurring?: boolean;
      currency: string;
      prices: Vector<Raw.TypeLabeledPrice>;
      maxTipAmount?: long;
      suggestedTipAmounts?: Vector<long>;
      termsUrl?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Invoice';
      this.constructorId = 0x5db95a15;
      this.subclassOfId = 0x5fd82ed8;
      this._slots = [
        'test',
        'nameRequested',
        'phoneRequested',
        'emailRequested',
        'shippingAddressRequested',
        'flexible',
        'phoneToProvider',
        'emailToProvider',
        'recurring',
        'currency',
        'prices',
        'maxTipAmount',
        'suggestedTipAmounts',
        'termsUrl',
      ];
      this.test = params.test;
      this.nameRequested = params.nameRequested;
      this.phoneRequested = params.phoneRequested;
      this.emailRequested = params.emailRequested;
      this.shippingAddressRequested = params.shippingAddressRequested;
      this.flexible = params.flexible;
      this.phoneToProvider = params.phoneToProvider;
      this.emailToProvider = params.emailToProvider;
      this.recurring = params.recurring;
      this.currency = params.currency;
      this.prices = params.prices;
      this.maxTipAmount = params.maxTipAmount;
      this.suggestedTipAmounts = params.suggestedTipAmounts;
      this.termsUrl = params.termsUrl;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Invoice> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let test = flags & (1 << 0) ? true : false;
      let nameRequested = flags & (1 << 1) ? true : false;
      let phoneRequested = flags & (1 << 2) ? true : false;
      let emailRequested = flags & (1 << 3) ? true : false;
      let shippingAddressRequested = flags & (1 << 4) ? true : false;
      let flexible = flags & (1 << 5) ? true : false;
      let phoneToProvider = flags & (1 << 6) ? true : false;
      let emailToProvider = flags & (1 << 7) ? true : false;
      let recurring = flags & (1 << 9) ? true : false;
      let currency = await Primitive.String.read(b);
      let prices = await TLObject.read(b);
      let maxTipAmount = flags & (1 << 8) ? await Primitive.Long.read(b) : undefined;
      let suggestedTipAmounts = flags & (1 << 8) ? await TLObject.read(b, Primitive.Long) : [];
      let termsUrl = flags & (1 << 10) ? await Primitive.String.read(b) : undefined;
      return new Raw.Invoice({
        test: test,
        nameRequested: nameRequested,
        phoneRequested: phoneRequested,
        emailRequested: emailRequested,
        shippingAddressRequested: shippingAddressRequested,
        flexible: flexible,
        phoneToProvider: phoneToProvider,
        emailToProvider: emailToProvider,
        recurring: recurring,
        currency: currency,
        prices: prices,
        maxTipAmount: maxTipAmount,
        suggestedTipAmounts: suggestedTipAmounts,
        termsUrl: termsUrl,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.test ? 1 << 0 : 0;
      flags |= this.nameRequested ? 1 << 1 : 0;
      flags |= this.phoneRequested ? 1 << 2 : 0;
      flags |= this.emailRequested ? 1 << 3 : 0;
      flags |= this.shippingAddressRequested ? 1 << 4 : 0;
      flags |= this.flexible ? 1 << 5 : 0;
      flags |= this.phoneToProvider ? 1 << 6 : 0;
      flags |= this.emailToProvider ? 1 << 7 : 0;
      flags |= this.recurring ? 1 << 9 : 0;
      flags |= this.maxTipAmount !== undefined ? 1 << 8 : 0;
      flags |= this.suggestedTipAmounts ? 1 << 8 : 0;
      flags |= this.termsUrl !== undefined ? 1 << 10 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.prices) {
        b.write(Primitive.Vector.write(this.prices) as unknown as Buffer);
      }
      if (this.maxTipAmount !== undefined) {
        b.write(Primitive.Long.write(this.maxTipAmount) as unknown as Buffer);
      }
      if (this.suggestedTipAmounts) {
        b.write(
          Primitive.Vector.write(this.suggestedTipAmounts, Primitive.Long) as unknown as Buffer,
        );
      }
      if (this.termsUrl !== undefined) {
        b.write(Primitive.String.write(this.termsUrl) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PaymentCharge extends TLObject {
    id!: string;
    providerChargeId!: string;

    constructor(params: { id: string; providerChargeId: string }) {
      super();
      this.classType = 'types';
      this.className = 'PaymentCharge';
      this.constructorId = 0xea02c27e;
      this.subclassOfId = 0x3cc830d9;
      this._slots = ['id', 'providerChargeId'];
      this.id = params.id;
      this.providerChargeId = params.providerChargeId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PaymentCharge> {
      // no flags

      let id = await Primitive.String.read(b);
      let providerChargeId = await Primitive.String.read(b);
      return new Raw.PaymentCharge({ id: id, providerChargeId: providerChargeId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.String.write(this.id) as unknown as Buffer);
      }
      if (this.providerChargeId !== undefined) {
        b.write(Primitive.String.write(this.providerChargeId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PostAddress extends TLObject {
    streetLine1!: string;
    streetLine2!: string;
    city!: string;
    state!: string;
    countryIso2!: string;
    postCode!: string;

    constructor(params: {
      streetLine1: string;
      streetLine2: string;
      city: string;
      state: string;
      countryIso2: string;
      postCode: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PostAddress';
      this.constructorId = 0x1e8caaeb;
      this.subclassOfId = 0x8d7eda2c;
      this._slots = ['streetLine1', 'streetLine2', 'city', 'state', 'countryIso2', 'postCode'];
      this.streetLine1 = params.streetLine1;
      this.streetLine2 = params.streetLine2;
      this.city = params.city;
      this.state = params.state;
      this.countryIso2 = params.countryIso2;
      this.postCode = params.postCode;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PostAddress> {
      // no flags

      let streetLine1 = await Primitive.String.read(b);
      let streetLine2 = await Primitive.String.read(b);
      let city = await Primitive.String.read(b);
      let state = await Primitive.String.read(b);
      let countryIso2 = await Primitive.String.read(b);
      let postCode = await Primitive.String.read(b);
      return new Raw.PostAddress({
        streetLine1: streetLine1,
        streetLine2: streetLine2,
        city: city,
        state: state,
        countryIso2: countryIso2,
        postCode: postCode,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.streetLine1 !== undefined) {
        b.write(Primitive.String.write(this.streetLine1) as unknown as Buffer);
      }
      if (this.streetLine2 !== undefined) {
        b.write(Primitive.String.write(this.streetLine2) as unknown as Buffer);
      }
      if (this.city !== undefined) {
        b.write(Primitive.String.write(this.city) as unknown as Buffer);
      }
      if (this.state !== undefined) {
        b.write(Primitive.String.write(this.state) as unknown as Buffer);
      }
      if (this.countryIso2 !== undefined) {
        b.write(Primitive.String.write(this.countryIso2) as unknown as Buffer);
      }
      if (this.postCode !== undefined) {
        b.write(Primitive.String.write(this.postCode) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PaymentRequestedInfo extends TLObject {
    name?: string;
    phone?: string;
    email?: string;
    shippingAddress?: Raw.TypePostAddress;

    constructor(params: {
      name?: string;
      phone?: string;
      email?: string;
      shippingAddress?: Raw.TypePostAddress;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PaymentRequestedInfo';
      this.constructorId = 0x909c3f94;
      this.subclassOfId = 0x8db03146;
      this._slots = ['name', 'phone', 'email', 'shippingAddress'];
      this.name = params.name;
      this.phone = params.phone;
      this.email = params.email;
      this.shippingAddress = params.shippingAddress;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PaymentRequestedInfo> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let name = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let phone = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let email = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      let shippingAddress = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      return new Raw.PaymentRequestedInfo({
        name: name,
        phone: phone,
        email: email,
        shippingAddress: shippingAddress,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.name !== undefined ? 1 << 0 : 0;
      flags |= this.phone !== undefined ? 1 << 1 : 0;
      flags |= this.email !== undefined ? 1 << 2 : 0;
      flags |= this.shippingAddress !== undefined ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.name !== undefined) {
        b.write(Primitive.String.write(this.name) as unknown as Buffer);
      }
      if (this.phone !== undefined) {
        b.write(Primitive.String.write(this.phone) as unknown as Buffer);
      }
      if (this.email !== undefined) {
        b.write(Primitive.String.write(this.email) as unknown as Buffer);
      }
      if (this.shippingAddress !== undefined) {
        b.write(this.shippingAddress.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PaymentSavedCredentialsCard extends TLObject {
    id!: string;
    title!: string;

    constructor(params: { id: string; title: string }) {
      super();
      this.classType = 'types';
      this.className = 'PaymentSavedCredentialsCard';
      this.constructorId = 0xcdc27a1f;
      this.subclassOfId = 0xb3627ee3;
      this._slots = ['id', 'title'];
      this.id = params.id;
      this.title = params.title;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PaymentSavedCredentialsCard> {
      // no flags

      let id = await Primitive.String.read(b);
      let title = await Primitive.String.read(b);
      return new Raw.PaymentSavedCredentialsCard({ id: id, title: title });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.String.write(this.id) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WebDocument extends TLObject {
    url!: string;
    accessHash!: long;
    size!: int;
    mimeType!: string;
    attributes!: Vector<Raw.TypeDocumentAttribute>;

    constructor(params: {
      url: string;
      accessHash: long;
      size: int;
      mimeType: string;
      attributes: Vector<Raw.TypeDocumentAttribute>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'WebDocument';
      this.constructorId = 0x1c570ed1;
      this.subclassOfId = 0x3b642814;
      this._slots = ['url', 'accessHash', 'size', 'mimeType', 'attributes'];
      this.url = params.url;
      this.accessHash = params.accessHash;
      this.size = params.size;
      this.mimeType = params.mimeType;
      this.attributes = params.attributes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WebDocument> {
      // no flags

      let url = await Primitive.String.read(b);
      let accessHash = await Primitive.Long.read(b);
      let size = await Primitive.Int.read(b);
      let mimeType = await Primitive.String.read(b);
      let attributes = await TLObject.read(b);
      return new Raw.WebDocument({
        url: url,
        accessHash: accessHash,
        size: size,
        mimeType: mimeType,
        attributes: attributes,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.mimeType !== undefined) {
        b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
      }
      if (this.attributes) {
        b.write(Primitive.Vector.write(this.attributes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WebDocumentNoProxy extends TLObject {
    url!: string;
    size!: int;
    mimeType!: string;
    attributes!: Vector<Raw.TypeDocumentAttribute>;

    constructor(params: {
      url: string;
      size: int;
      mimeType: string;
      attributes: Vector<Raw.TypeDocumentAttribute>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'WebDocumentNoProxy';
      this.constructorId = 0xf9c8bcc6;
      this.subclassOfId = 0x3b642814;
      this._slots = ['url', 'size', 'mimeType', 'attributes'];
      this.url = params.url;
      this.size = params.size;
      this.mimeType = params.mimeType;
      this.attributes = params.attributes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WebDocumentNoProxy> {
      // no flags

      let url = await Primitive.String.read(b);
      let size = await Primitive.Int.read(b);
      let mimeType = await Primitive.String.read(b);
      let attributes = await TLObject.read(b);
      return new Raw.WebDocumentNoProxy({
        url: url,
        size: size,
        mimeType: mimeType,
        attributes: attributes,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.mimeType !== undefined) {
        b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
      }
      if (this.attributes) {
        b.write(Primitive.Vector.write(this.attributes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputWebDocument extends TLObject {
    url!: string;
    size!: int;
    mimeType!: string;
    attributes!: Vector<Raw.TypeDocumentAttribute>;

    constructor(params: {
      url: string;
      size: int;
      mimeType: string;
      attributes: Vector<Raw.TypeDocumentAttribute>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputWebDocument';
      this.constructorId = 0x9bed434d;
      this.subclassOfId = 0x8ae8b146;
      this._slots = ['url', 'size', 'mimeType', 'attributes'];
      this.url = params.url;
      this.size = params.size;
      this.mimeType = params.mimeType;
      this.attributes = params.attributes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputWebDocument> {
      // no flags

      let url = await Primitive.String.read(b);
      let size = await Primitive.Int.read(b);
      let mimeType = await Primitive.String.read(b);
      let attributes = await TLObject.read(b);
      return new Raw.InputWebDocument({
        url: url,
        size: size,
        mimeType: mimeType,
        attributes: attributes,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.mimeType !== undefined) {
        b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
      }
      if (this.attributes) {
        b.write(Primitive.Vector.write(this.attributes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputWebFileLocation extends TLObject {
    url!: string;
    accessHash!: long;

    constructor(params: { url: string; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputWebFileLocation';
      this.constructorId = 0xc239d686;
      this.subclassOfId = 0xf72ed8d9;
      this._slots = ['url', 'accessHash'];
      this.url = params.url;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputWebFileLocation> {
      // no flags

      let url = await Primitive.String.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputWebFileLocation({ url: url, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputWebFileGeoPointLocation extends TLObject {
    geoPoint!: Raw.TypeInputGeoPoint;
    accessHash!: long;
    w!: int;
    h!: int;
    zoom!: int;
    scale!: int;

    constructor(params: {
      geoPoint: Raw.TypeInputGeoPoint;
      accessHash: long;
      w: int;
      h: int;
      zoom: int;
      scale: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputWebFileGeoPointLocation';
      this.constructorId = 0x9f2221c9;
      this.subclassOfId = 0xf72ed8d9;
      this._slots = ['geoPoint', 'accessHash', 'w', 'h', 'zoom', 'scale'];
      this.geoPoint = params.geoPoint;
      this.accessHash = params.accessHash;
      this.w = params.w;
      this.h = params.h;
      this.zoom = params.zoom;
      this.scale = params.scale;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputWebFileGeoPointLocation> {
      // no flags

      let geoPoint = await TLObject.read(b);
      let accessHash = await Primitive.Long.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let zoom = await Primitive.Int.read(b);
      let scale = await Primitive.Int.read(b);
      return new Raw.InputWebFileGeoPointLocation({
        geoPoint: geoPoint,
        accessHash: accessHash,
        w: w,
        h: h,
        zoom: zoom,
        scale: scale,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.geoPoint !== undefined) {
        b.write(this.geoPoint.write() as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.zoom !== undefined) {
        b.write(Primitive.Int.write(this.zoom) as unknown as Buffer);
      }
      if (this.scale !== undefined) {
        b.write(Primitive.Int.write(this.scale) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputWebFileAudioAlbumThumbLocation extends TLObject {
    small?: boolean;
    document?: Raw.TypeInputDocument;
    title?: string;
    performer?: string;

    constructor(params: {
      small?: boolean;
      document?: Raw.TypeInputDocument;
      title?: string;
      performer?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputWebFileAudioAlbumThumbLocation';
      this.constructorId = 0xf46fe924;
      this.subclassOfId = 0xf72ed8d9;
      this._slots = ['small', 'document', 'title', 'performer'];
      this.small = params.small;
      this.document = params.document;
      this.title = params.title;
      this.performer = params.performer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputWebFileAudioAlbumThumbLocation> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let small = flags & (1 << 2) ? true : false;
      let document = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let title = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let performer = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      return new Raw.InputWebFileAudioAlbumThumbLocation({
        small: small,
        document: document,
        title: title,
        performer: performer,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.small ? 1 << 2 : 0;
      flags |= this.document !== undefined ? 1 << 0 : 0;
      flags |= this.title !== undefined ? 1 << 1 : 0;
      flags |= this.performer !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.document !== undefined) {
        b.write(this.document.write() as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.performer !== undefined) {
        b.write(Primitive.String.write(this.performer) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPaymentCredentialsSaved extends TLObject {
    id!: string;
    tmpPassword!: bytes;

    constructor(params: { id: string; tmpPassword: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'InputPaymentCredentialsSaved';
      this.constructorId = 0xc10eb2cf;
      this.subclassOfId = 0x2899a53d;
      this._slots = ['id', 'tmpPassword'];
      this.id = params.id;
      this.tmpPassword = params.tmpPassword;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPaymentCredentialsSaved> {
      // no flags

      let id = await Primitive.String.read(b);
      let tmpPassword = await Primitive.Bytes.read(b);
      return new Raw.InputPaymentCredentialsSaved({ id: id, tmpPassword: tmpPassword });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.String.write(this.id) as unknown as Buffer);
      }
      if (this.tmpPassword !== undefined) {
        b.write(Primitive.Bytes.write(this.tmpPassword) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPaymentCredentials extends TLObject {
    save?: boolean;
    data!: Raw.TypeDataJSON;

    constructor(params: { save?: boolean; data: Raw.TypeDataJSON }) {
      super();
      this.classType = 'types';
      this.className = 'InputPaymentCredentials';
      this.constructorId = 0x3417d728;
      this.subclassOfId = 0x2899a53d;
      this._slots = ['save', 'data'];
      this.save = params.save;
      this.data = params.data;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPaymentCredentials> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let save = flags & (1 << 0) ? true : false;
      let data = await TLObject.read(b);
      return new Raw.InputPaymentCredentials({ save: save, data: data });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.save ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.data !== undefined) {
        b.write(this.data.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPaymentCredentialsApplePay extends TLObject {
    paymentData!: Raw.TypeDataJSON;

    constructor(params: { paymentData: Raw.TypeDataJSON }) {
      super();
      this.classType = 'types';
      this.className = 'InputPaymentCredentialsApplePay';
      this.constructorId = 0xaa1c39f;
      this.subclassOfId = 0x2899a53d;
      this._slots = ['paymentData'];
      this.paymentData = params.paymentData;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputPaymentCredentialsApplePay> {
      // no flags

      let paymentData = await TLObject.read(b);
      return new Raw.InputPaymentCredentialsApplePay({ paymentData: paymentData });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.paymentData !== undefined) {
        b.write(this.paymentData.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPaymentCredentialsGooglePay extends TLObject {
    paymentToken!: Raw.TypeDataJSON;

    constructor(params: { paymentToken: Raw.TypeDataJSON }) {
      super();
      this.classType = 'types';
      this.className = 'InputPaymentCredentialsGooglePay';
      this.constructorId = 0x8ac32801;
      this.subclassOfId = 0x2899a53d;
      this._slots = ['paymentToken'];
      this.paymentToken = params.paymentToken;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputPaymentCredentialsGooglePay> {
      // no flags

      let paymentToken = await TLObject.read(b);
      return new Raw.InputPaymentCredentialsGooglePay({ paymentToken: paymentToken });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.paymentToken !== undefined) {
        b.write(this.paymentToken.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ShippingOption extends TLObject {
    id!: string;
    title!: string;
    prices!: Vector<Raw.TypeLabeledPrice>;

    constructor(params: { id: string; title: string; prices: Vector<Raw.TypeLabeledPrice> }) {
      super();
      this.classType = 'types';
      this.className = 'ShippingOption';
      this.constructorId = 0xb6213cdf;
      this.subclassOfId = 0xf4e94c78;
      this._slots = ['id', 'title', 'prices'];
      this.id = params.id;
      this.title = params.title;
      this.prices = params.prices;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ShippingOption> {
      // no flags

      let id = await Primitive.String.read(b);
      let title = await Primitive.String.read(b);
      let prices = await TLObject.read(b);
      return new Raw.ShippingOption({ id: id, title: title, prices: prices });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.String.write(this.id) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.prices) {
        b.write(Primitive.Vector.write(this.prices) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputStickerSetItem extends TLObject {
    document!: Raw.TypeInputDocument;
    emoji!: string;
    maskCoords?: Raw.TypeMaskCoords;
    keywords?: string;

    constructor(params: {
      document: Raw.TypeInputDocument;
      emoji: string;
      maskCoords?: Raw.TypeMaskCoords;
      keywords?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputStickerSetItem';
      this.constructorId = 0x32da9e9c;
      this.subclassOfId = 0xae59f075;
      this._slots = ['document', 'emoji', 'maskCoords', 'keywords'];
      this.document = params.document;
      this.emoji = params.emoji;
      this.maskCoords = params.maskCoords;
      this.keywords = params.keywords;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputStickerSetItem> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let document = await TLObject.read(b);
      let emoji = await Primitive.String.read(b);
      let maskCoords = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let keywords = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      return new Raw.InputStickerSetItem({
        document: document,
        emoji: emoji,
        maskCoords: maskCoords,
        keywords: keywords,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.maskCoords !== undefined ? 1 << 0 : 0;
      flags |= this.keywords !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.document !== undefined) {
        b.write(this.document.write() as unknown as Buffer);
      }
      if (this.emoji !== undefined) {
        b.write(Primitive.String.write(this.emoji) as unknown as Buffer);
      }
      if (this.maskCoords !== undefined) {
        b.write(this.maskCoords.write() as unknown as Buffer);
      }
      if (this.keywords !== undefined) {
        b.write(Primitive.String.write(this.keywords) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputPhoneCall extends TLObject {
    id!: long;
    accessHash!: long;

    constructor(params: { id: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputPhoneCall';
      this.constructorId = 0x1e36fded;
      this.subclassOfId = 0xbcaaf240;
      this._slots = ['id', 'accessHash'];
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputPhoneCall> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputPhoneCall({ id: id, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhoneCallEmpty extends TLObject {
    id!: long;

    constructor(params: { id: long }) {
      super();
      this.classType = 'types';
      this.className = 'PhoneCallEmpty';
      this.constructorId = 0x5366c915;
      this.subclassOfId = 0xc47f1bd1;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhoneCallEmpty> {
      // no flags

      let id = await Primitive.Long.read(b);
      return new Raw.PhoneCallEmpty({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhoneCallWaiting extends TLObject {
    video?: boolean;
    id!: long;
    accessHash!: long;
    date!: int;
    adminId!: long;
    participantId!: long;
    protocol!: Raw.TypePhoneCallProtocol;
    receiveDate?: int;

    constructor(params: {
      video?: boolean;
      id: long;
      accessHash: long;
      date: int;
      adminId: long;
      participantId: long;
      protocol: Raw.TypePhoneCallProtocol;
      receiveDate?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PhoneCallWaiting';
      this.constructorId = 0xc5226f17;
      this.subclassOfId = 0xc47f1bd1;
      this._slots = [
        'video',
        'id',
        'accessHash',
        'date',
        'adminId',
        'participantId',
        'protocol',
        'receiveDate',
      ];
      this.video = params.video;
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.date = params.date;
      this.adminId = params.adminId;
      this.participantId = params.participantId;
      this.protocol = params.protocol;
      this.receiveDate = params.receiveDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhoneCallWaiting> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let video = flags & (1 << 6) ? true : false;
      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let adminId = await Primitive.Long.read(b);
      let participantId = await Primitive.Long.read(b);
      let protocol = await TLObject.read(b);
      let receiveDate = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      return new Raw.PhoneCallWaiting({
        video: video,
        id: id,
        accessHash: accessHash,
        date: date,
        adminId: adminId,
        participantId: participantId,
        protocol: protocol,
        receiveDate: receiveDate,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.video ? 1 << 6 : 0;
      flags |= this.receiveDate !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.adminId !== undefined) {
        b.write(Primitive.Long.write(this.adminId) as unknown as Buffer);
      }
      if (this.participantId !== undefined) {
        b.write(Primitive.Long.write(this.participantId) as unknown as Buffer);
      }
      if (this.protocol !== undefined) {
        b.write(this.protocol.write() as unknown as Buffer);
      }
      if (this.receiveDate !== undefined) {
        b.write(Primitive.Int.write(this.receiveDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhoneCallRequested extends TLObject {
    video?: boolean;
    id!: long;
    accessHash!: long;
    date!: int;
    adminId!: long;
    participantId!: long;
    gAHash!: bytes;
    protocol!: Raw.TypePhoneCallProtocol;

    constructor(params: {
      video?: boolean;
      id: long;
      accessHash: long;
      date: int;
      adminId: long;
      participantId: long;
      gAHash: bytes;
      protocol: Raw.TypePhoneCallProtocol;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PhoneCallRequested';
      this.constructorId = 0x14b0ed0c;
      this.subclassOfId = 0xc47f1bd1;
      this._slots = [
        'video',
        'id',
        'accessHash',
        'date',
        'adminId',
        'participantId',
        'gAHash',
        'protocol',
      ];
      this.video = params.video;
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.date = params.date;
      this.adminId = params.adminId;
      this.participantId = params.participantId;
      this.gAHash = params.gAHash;
      this.protocol = params.protocol;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhoneCallRequested> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let video = flags & (1 << 6) ? true : false;
      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let adminId = await Primitive.Long.read(b);
      let participantId = await Primitive.Long.read(b);
      let gAHash = await Primitive.Bytes.read(b);
      let protocol = await TLObject.read(b);
      return new Raw.PhoneCallRequested({
        video: video,
        id: id,
        accessHash: accessHash,
        date: date,
        adminId: adminId,
        participantId: participantId,
        gAHash: gAHash,
        protocol: protocol,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.video ? 1 << 6 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.adminId !== undefined) {
        b.write(Primitive.Long.write(this.adminId) as unknown as Buffer);
      }
      if (this.participantId !== undefined) {
        b.write(Primitive.Long.write(this.participantId) as unknown as Buffer);
      }
      if (this.gAHash !== undefined) {
        b.write(Primitive.Bytes.write(this.gAHash) as unknown as Buffer);
      }
      if (this.protocol !== undefined) {
        b.write(this.protocol.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhoneCallAccepted extends TLObject {
    video?: boolean;
    id!: long;
    accessHash!: long;
    date!: int;
    adminId!: long;
    participantId!: long;
    gB!: bytes;
    protocol!: Raw.TypePhoneCallProtocol;

    constructor(params: {
      video?: boolean;
      id: long;
      accessHash: long;
      date: int;
      adminId: long;
      participantId: long;
      gB: bytes;
      protocol: Raw.TypePhoneCallProtocol;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PhoneCallAccepted';
      this.constructorId = 0x3660c311;
      this.subclassOfId = 0xc47f1bd1;
      this._slots = [
        'video',
        'id',
        'accessHash',
        'date',
        'adminId',
        'participantId',
        'gB',
        'protocol',
      ];
      this.video = params.video;
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.date = params.date;
      this.adminId = params.adminId;
      this.participantId = params.participantId;
      this.gB = params.gB;
      this.protocol = params.protocol;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhoneCallAccepted> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let video = flags & (1 << 6) ? true : false;
      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let adminId = await Primitive.Long.read(b);
      let participantId = await Primitive.Long.read(b);
      let gB = await Primitive.Bytes.read(b);
      let protocol = await TLObject.read(b);
      return new Raw.PhoneCallAccepted({
        video: video,
        id: id,
        accessHash: accessHash,
        date: date,
        adminId: adminId,
        participantId: participantId,
        gB: gB,
        protocol: protocol,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.video ? 1 << 6 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.adminId !== undefined) {
        b.write(Primitive.Long.write(this.adminId) as unknown as Buffer);
      }
      if (this.participantId !== undefined) {
        b.write(Primitive.Long.write(this.participantId) as unknown as Buffer);
      }
      if (this.gB !== undefined) {
        b.write(Primitive.Bytes.write(this.gB) as unknown as Buffer);
      }
      if (this.protocol !== undefined) {
        b.write(this.protocol.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhoneCall extends TLObject {
    p2pAllowed?: boolean;
    video?: boolean;
    id!: long;
    accessHash!: long;
    date!: int;
    adminId!: long;
    participantId!: long;
    gAOrB!: bytes;
    keyFingerprint!: long;
    protocol!: Raw.TypePhoneCallProtocol;
    connections!: Vector<Raw.TypePhoneConnection>;
    startDate!: int;

    constructor(params: {
      p2pAllowed?: boolean;
      video?: boolean;
      id: long;
      accessHash: long;
      date: int;
      adminId: long;
      participantId: long;
      gAOrB: bytes;
      keyFingerprint: long;
      protocol: Raw.TypePhoneCallProtocol;
      connections: Vector<Raw.TypePhoneConnection>;
      startDate: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PhoneCall';
      this.constructorId = 0x967f7c67;
      this.subclassOfId = 0xc47f1bd1;
      this._slots = [
        'p2pAllowed',
        'video',
        'id',
        'accessHash',
        'date',
        'adminId',
        'participantId',
        'gAOrB',
        'keyFingerprint',
        'protocol',
        'connections',
        'startDate',
      ];
      this.p2pAllowed = params.p2pAllowed;
      this.video = params.video;
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.date = params.date;
      this.adminId = params.adminId;
      this.participantId = params.participantId;
      this.gAOrB = params.gAOrB;
      this.keyFingerprint = params.keyFingerprint;
      this.protocol = params.protocol;
      this.connections = params.connections;
      this.startDate = params.startDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhoneCall> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let p2pAllowed = flags & (1 << 5) ? true : false;
      let video = flags & (1 << 6) ? true : false;
      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let adminId = await Primitive.Long.read(b);
      let participantId = await Primitive.Long.read(b);
      let gAOrB = await Primitive.Bytes.read(b);
      let keyFingerprint = await Primitive.Long.read(b);
      let protocol = await TLObject.read(b);
      let connections = await TLObject.read(b);
      let startDate = await Primitive.Int.read(b);
      return new Raw.PhoneCall({
        p2pAllowed: p2pAllowed,
        video: video,
        id: id,
        accessHash: accessHash,
        date: date,
        adminId: adminId,
        participantId: participantId,
        gAOrB: gAOrB,
        keyFingerprint: keyFingerprint,
        protocol: protocol,
        connections: connections,
        startDate: startDate,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.p2pAllowed ? 1 << 5 : 0;
      flags |= this.video ? 1 << 6 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.adminId !== undefined) {
        b.write(Primitive.Long.write(this.adminId) as unknown as Buffer);
      }
      if (this.participantId !== undefined) {
        b.write(Primitive.Long.write(this.participantId) as unknown as Buffer);
      }
      if (this.gAOrB !== undefined) {
        b.write(Primitive.Bytes.write(this.gAOrB) as unknown as Buffer);
      }
      if (this.keyFingerprint !== undefined) {
        b.write(Primitive.Long.write(this.keyFingerprint) as unknown as Buffer);
      }
      if (this.protocol !== undefined) {
        b.write(this.protocol.write() as unknown as Buffer);
      }
      if (this.connections) {
        b.write(Primitive.Vector.write(this.connections) as unknown as Buffer);
      }
      if (this.startDate !== undefined) {
        b.write(Primitive.Int.write(this.startDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhoneCallDiscarded extends TLObject {
    needRating?: boolean;
    needDebug?: boolean;
    video?: boolean;
    id!: long;
    reason?: Raw.TypePhoneCallDiscardReason;
    duration?: int;

    constructor(params: {
      needRating?: boolean;
      needDebug?: boolean;
      video?: boolean;
      id: long;
      reason?: Raw.TypePhoneCallDiscardReason;
      duration?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PhoneCallDiscarded';
      this.constructorId = 0x50ca4de1;
      this.subclassOfId = 0xc47f1bd1;
      this._slots = ['needRating', 'needDebug', 'video', 'id', 'reason', 'duration'];
      this.needRating = params.needRating;
      this.needDebug = params.needDebug;
      this.video = params.video;
      this.id = params.id;
      this.reason = params.reason;
      this.duration = params.duration;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhoneCallDiscarded> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let needRating = flags & (1 << 2) ? true : false;
      let needDebug = flags & (1 << 3) ? true : false;
      let video = flags & (1 << 6) ? true : false;
      let id = await Primitive.Long.read(b);
      let reason = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let duration = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      return new Raw.PhoneCallDiscarded({
        needRating: needRating,
        needDebug: needDebug,
        video: video,
        id: id,
        reason: reason,
        duration: duration,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.needRating ? 1 << 2 : 0;
      flags |= this.needDebug ? 1 << 3 : 0;
      flags |= this.video ? 1 << 6 : 0;
      flags |= this.reason !== undefined ? 1 << 0 : 0;
      flags |= this.duration !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.reason !== undefined) {
        b.write(this.reason.write() as unknown as Buffer);
      }
      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhoneConnection extends TLObject {
    tcp?: boolean;
    id!: long;
    ip!: string;
    ipv6!: string;
    port!: int;
    peerTag!: bytes;

    constructor(params: {
      tcp?: boolean;
      id: long;
      ip: string;
      ipv6: string;
      port: int;
      peerTag: bytes;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PhoneConnection';
      this.constructorId = 0x9cc123c7;
      this.subclassOfId = 0xaa8de40d;
      this._slots = ['tcp', 'id', 'ip', 'ipv6', 'port', 'peerTag'];
      this.tcp = params.tcp;
      this.id = params.id;
      this.ip = params.ip;
      this.ipv6 = params.ipv6;
      this.port = params.port;
      this.peerTag = params.peerTag;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhoneConnection> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let tcp = flags & (1 << 0) ? true : false;
      let id = await Primitive.Long.read(b);
      let ip = await Primitive.String.read(b);
      let ipv6 = await Primitive.String.read(b);
      let port = await Primitive.Int.read(b);
      let peerTag = await Primitive.Bytes.read(b);
      return new Raw.PhoneConnection({
        tcp: tcp,
        id: id,
        ip: ip,
        ipv6: ipv6,
        port: port,
        peerTag: peerTag,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.tcp ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.ip !== undefined) {
        b.write(Primitive.String.write(this.ip) as unknown as Buffer);
      }
      if (this.ipv6 !== undefined) {
        b.write(Primitive.String.write(this.ipv6) as unknown as Buffer);
      }
      if (this.port !== undefined) {
        b.write(Primitive.Int.write(this.port) as unknown as Buffer);
      }
      if (this.peerTag !== undefined) {
        b.write(Primitive.Bytes.write(this.peerTag) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhoneConnectionWebrtc extends TLObject {
    turn?: boolean;
    stun?: boolean;
    id!: long;
    ip!: string;
    ipv6!: string;
    port!: int;
    username!: string;
    password!: string;

    constructor(params: {
      turn?: boolean;
      stun?: boolean;
      id: long;
      ip: string;
      ipv6: string;
      port: int;
      username: string;
      password: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PhoneConnectionWebrtc';
      this.constructorId = 0x635fe375;
      this.subclassOfId = 0xaa8de40d;
      this._slots = ['turn', 'stun', 'id', 'ip', 'ipv6', 'port', 'username', 'password'];
      this.turn = params.turn;
      this.stun = params.stun;
      this.id = params.id;
      this.ip = params.ip;
      this.ipv6 = params.ipv6;
      this.port = params.port;
      this.username = params.username;
      this.password = params.password;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhoneConnectionWebrtc> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let turn = flags & (1 << 0) ? true : false;
      let stun = flags & (1 << 1) ? true : false;
      let id = await Primitive.Long.read(b);
      let ip = await Primitive.String.read(b);
      let ipv6 = await Primitive.String.read(b);
      let port = await Primitive.Int.read(b);
      let username = await Primitive.String.read(b);
      let password = await Primitive.String.read(b);
      return new Raw.PhoneConnectionWebrtc({
        turn: turn,
        stun: stun,
        id: id,
        ip: ip,
        ipv6: ipv6,
        port: port,
        username: username,
        password: password,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.turn ? 1 << 0 : 0;
      flags |= this.stun ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.ip !== undefined) {
        b.write(Primitive.String.write(this.ip) as unknown as Buffer);
      }
      if (this.ipv6 !== undefined) {
        b.write(Primitive.String.write(this.ipv6) as unknown as Buffer);
      }
      if (this.port !== undefined) {
        b.write(Primitive.Int.write(this.port) as unknown as Buffer);
      }
      if (this.username !== undefined) {
        b.write(Primitive.String.write(this.username) as unknown as Buffer);
      }
      if (this.password !== undefined) {
        b.write(Primitive.String.write(this.password) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhoneCallProtocol extends TLObject {
    udpP2p?: boolean;
    udpReflector?: boolean;
    minLayer!: int;
    maxLayer!: int;
    libraryVersions!: Vector<string>;

    constructor(params: {
      udpP2p?: boolean;
      udpReflector?: boolean;
      minLayer: int;
      maxLayer: int;
      libraryVersions: Vector<string>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PhoneCallProtocol';
      this.constructorId = 0xfc878fc8;
      this.subclassOfId = 0x783991a3;
      this._slots = ['udpP2p', 'udpReflector', 'minLayer', 'maxLayer', 'libraryVersions'];
      this.udpP2p = params.udpP2p;
      this.udpReflector = params.udpReflector;
      this.minLayer = params.minLayer;
      this.maxLayer = params.maxLayer;
      this.libraryVersions = params.libraryVersions;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhoneCallProtocol> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let udpP2p = flags & (1 << 0) ? true : false;
      let udpReflector = flags & (1 << 1) ? true : false;
      let minLayer = await Primitive.Int.read(b);
      let maxLayer = await Primitive.Int.read(b);
      let libraryVersions = await TLObject.read(b, Primitive.String);
      return new Raw.PhoneCallProtocol({
        udpP2p: udpP2p,
        udpReflector: udpReflector,
        minLayer: minLayer,
        maxLayer: maxLayer,
        libraryVersions: libraryVersions,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.udpP2p ? 1 << 0 : 0;
      flags |= this.udpReflector ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.minLayer !== undefined) {
        b.write(Primitive.Int.write(this.minLayer) as unknown as Buffer);
      }
      if (this.maxLayer !== undefined) {
        b.write(Primitive.Int.write(this.maxLayer) as unknown as Buffer);
      }
      if (this.libraryVersions) {
        b.write(
          Primitive.Vector.write(this.libraryVersions, Primitive.String) as unknown as Buffer,
        );
      }
      return b.buffer;
    }
  }
  export class CdnPublicKey extends TLObject {
    dcId!: int;
    publicKey!: string;

    constructor(params: { dcId: int; publicKey: string }) {
      super();
      this.classType = 'types';
      this.className = 'CdnPublicKey';
      this.constructorId = 0xc982eaba;
      this.subclassOfId = 0x16db47f3;
      this._slots = ['dcId', 'publicKey'];
      this.dcId = params.dcId;
      this.publicKey = params.publicKey;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.CdnPublicKey> {
      // no flags

      let dcId = await Primitive.Int.read(b);
      let publicKey = await Primitive.String.read(b);
      return new Raw.CdnPublicKey({ dcId: dcId, publicKey: publicKey });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.dcId !== undefined) {
        b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
      }
      if (this.publicKey !== undefined) {
        b.write(Primitive.String.write(this.publicKey) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class CdnConfig extends TLObject {
    publicKeys!: Vector<Raw.TypeCdnPublicKey>;

    constructor(params: { publicKeys: Vector<Raw.TypeCdnPublicKey> }) {
      super();
      this.classType = 'types';
      this.className = 'CdnConfig';
      this.constructorId = 0x5725e40a;
      this.subclassOfId = 0xecda397c;
      this._slots = ['publicKeys'];
      this.publicKeys = params.publicKeys;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.CdnConfig> {
      // no flags

      let publicKeys = await TLObject.read(b);
      return new Raw.CdnConfig({ publicKeys: publicKeys });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.publicKeys) {
        b.write(Primitive.Vector.write(this.publicKeys) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class LangPackString extends TLObject {
    key!: string;
    value!: string;

    constructor(params: { key: string; value: string }) {
      super();
      this.classType = 'types';
      this.className = 'LangPackString';
      this.constructorId = 0xcad181f6;
      this.subclassOfId = 0xdc179ab9;
      this._slots = ['key', 'value'];
      this.key = params.key;
      this.value = params.value;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.LangPackString> {
      // no flags

      let key = await Primitive.String.read(b);
      let value = await Primitive.String.read(b);
      return new Raw.LangPackString({ key: key, value: value });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.key !== undefined) {
        b.write(Primitive.String.write(this.key) as unknown as Buffer);
      }
      if (this.value !== undefined) {
        b.write(Primitive.String.write(this.value) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class LangPackStringPluralized extends TLObject {
    key!: string;
    zeroValue?: string;
    oneValue?: string;
    twoValue?: string;
    fewValue?: string;
    manyValue?: string;
    otherValue!: string;

    constructor(params: {
      key: string;
      zeroValue?: string;
      oneValue?: string;
      twoValue?: string;
      fewValue?: string;
      manyValue?: string;
      otherValue: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'LangPackStringPluralized';
      this.constructorId = 0x6c47ac9f;
      this.subclassOfId = 0xdc179ab9;
      this._slots = [
        'key',
        'zeroValue',
        'oneValue',
        'twoValue',
        'fewValue',
        'manyValue',
        'otherValue',
      ];
      this.key = params.key;
      this.zeroValue = params.zeroValue;
      this.oneValue = params.oneValue;
      this.twoValue = params.twoValue;
      this.fewValue = params.fewValue;
      this.manyValue = params.manyValue;
      this.otherValue = params.otherValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.LangPackStringPluralized> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let key = await Primitive.String.read(b);
      let zeroValue = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let oneValue = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let twoValue = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      let fewValue = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
      let manyValue = flags & (1 << 4) ? await Primitive.String.read(b) : undefined;
      let otherValue = await Primitive.String.read(b);
      return new Raw.LangPackStringPluralized({
        key: key,
        zeroValue: zeroValue,
        oneValue: oneValue,
        twoValue: twoValue,
        fewValue: fewValue,
        manyValue: manyValue,
        otherValue: otherValue,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.zeroValue !== undefined ? 1 << 0 : 0;
      flags |= this.oneValue !== undefined ? 1 << 1 : 0;
      flags |= this.twoValue !== undefined ? 1 << 2 : 0;
      flags |= this.fewValue !== undefined ? 1 << 3 : 0;
      flags |= this.manyValue !== undefined ? 1 << 4 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.key !== undefined) {
        b.write(Primitive.String.write(this.key) as unknown as Buffer);
      }
      if (this.zeroValue !== undefined) {
        b.write(Primitive.String.write(this.zeroValue) as unknown as Buffer);
      }
      if (this.oneValue !== undefined) {
        b.write(Primitive.String.write(this.oneValue) as unknown as Buffer);
      }
      if (this.twoValue !== undefined) {
        b.write(Primitive.String.write(this.twoValue) as unknown as Buffer);
      }
      if (this.fewValue !== undefined) {
        b.write(Primitive.String.write(this.fewValue) as unknown as Buffer);
      }
      if (this.manyValue !== undefined) {
        b.write(Primitive.String.write(this.manyValue) as unknown as Buffer);
      }
      if (this.otherValue !== undefined) {
        b.write(Primitive.String.write(this.otherValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class LangPackStringDeleted extends TLObject {
    key!: string;

    constructor(params: { key: string }) {
      super();
      this.classType = 'types';
      this.className = 'LangPackStringDeleted';
      this.constructorId = 0x2979eeb2;
      this.subclassOfId = 0xdc179ab9;
      this._slots = ['key'];
      this.key = params.key;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.LangPackStringDeleted> {
      // no flags

      let key = await Primitive.String.read(b);
      return new Raw.LangPackStringDeleted({ key: key });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.key !== undefined) {
        b.write(Primitive.String.write(this.key) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class LangPackDifference extends TLObject {
    langCode!: string;
    fromVersion!: int;
    version!: int;
    strings!: Vector<Raw.TypeLangPackString>;

    constructor(params: {
      langCode: string;
      fromVersion: int;
      version: int;
      strings: Vector<Raw.TypeLangPackString>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'LangPackDifference';
      this.constructorId = 0xf385c1f6;
      this.subclassOfId = 0x52662d55;
      this._slots = ['langCode', 'fromVersion', 'version', 'strings'];
      this.langCode = params.langCode;
      this.fromVersion = params.fromVersion;
      this.version = params.version;
      this.strings = params.strings;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.LangPackDifference> {
      // no flags

      let langCode = await Primitive.String.read(b);
      let fromVersion = await Primitive.Int.read(b);
      let version = await Primitive.Int.read(b);
      let strings = await TLObject.read(b);
      return new Raw.LangPackDifference({
        langCode: langCode,
        fromVersion: fromVersion,
        version: version,
        strings: strings,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.langCode !== undefined) {
        b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
      }
      if (this.fromVersion !== undefined) {
        b.write(Primitive.Int.write(this.fromVersion) as unknown as Buffer);
      }
      if (this.version !== undefined) {
        b.write(Primitive.Int.write(this.version) as unknown as Buffer);
      }
      if (this.strings) {
        b.write(Primitive.Vector.write(this.strings) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class LangPackLanguage extends TLObject {
    official?: boolean;
    rtl?: boolean;
    beta?: boolean;
    name!: string;
    nativeName!: string;
    langCode!: string;
    baseLangCode?: string;
    pluralCode!: string;
    stringsCount!: int;
    translatedCount!: int;
    translationsUrl!: string;

    constructor(params: {
      official?: boolean;
      rtl?: boolean;
      beta?: boolean;
      name: string;
      nativeName: string;
      langCode: string;
      baseLangCode?: string;
      pluralCode: string;
      stringsCount: int;
      translatedCount: int;
      translationsUrl: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'LangPackLanguage';
      this.constructorId = 0xeeca5ce3;
      this.subclassOfId = 0xabac89b7;
      this._slots = [
        'official',
        'rtl',
        'beta',
        'name',
        'nativeName',
        'langCode',
        'baseLangCode',
        'pluralCode',
        'stringsCount',
        'translatedCount',
        'translationsUrl',
      ];
      this.official = params.official;
      this.rtl = params.rtl;
      this.beta = params.beta;
      this.name = params.name;
      this.nativeName = params.nativeName;
      this.langCode = params.langCode;
      this.baseLangCode = params.baseLangCode;
      this.pluralCode = params.pluralCode;
      this.stringsCount = params.stringsCount;
      this.translatedCount = params.translatedCount;
      this.translationsUrl = params.translationsUrl;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.LangPackLanguage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let official = flags & (1 << 0) ? true : false;
      let rtl = flags & (1 << 2) ? true : false;
      let beta = flags & (1 << 3) ? true : false;
      let name = await Primitive.String.read(b);
      let nativeName = await Primitive.String.read(b);
      let langCode = await Primitive.String.read(b);
      let baseLangCode = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let pluralCode = await Primitive.String.read(b);
      let stringsCount = await Primitive.Int.read(b);
      let translatedCount = await Primitive.Int.read(b);
      let translationsUrl = await Primitive.String.read(b);
      return new Raw.LangPackLanguage({
        official: official,
        rtl: rtl,
        beta: beta,
        name: name,
        nativeName: nativeName,
        langCode: langCode,
        baseLangCode: baseLangCode,
        pluralCode: pluralCode,
        stringsCount: stringsCount,
        translatedCount: translatedCount,
        translationsUrl: translationsUrl,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.official ? 1 << 0 : 0;
      flags |= this.rtl ? 1 << 2 : 0;
      flags |= this.beta ? 1 << 3 : 0;
      flags |= this.baseLangCode !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.name !== undefined) {
        b.write(Primitive.String.write(this.name) as unknown as Buffer);
      }
      if (this.nativeName !== undefined) {
        b.write(Primitive.String.write(this.nativeName) as unknown as Buffer);
      }
      if (this.langCode !== undefined) {
        b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
      }
      if (this.baseLangCode !== undefined) {
        b.write(Primitive.String.write(this.baseLangCode) as unknown as Buffer);
      }
      if (this.pluralCode !== undefined) {
        b.write(Primitive.String.write(this.pluralCode) as unknown as Buffer);
      }
      if (this.stringsCount !== undefined) {
        b.write(Primitive.Int.write(this.stringsCount) as unknown as Buffer);
      }
      if (this.translatedCount !== undefined) {
        b.write(Primitive.Int.write(this.translatedCount) as unknown as Buffer);
      }
      if (this.translationsUrl !== undefined) {
        b.write(Primitive.String.write(this.translationsUrl) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionChangeTitle extends TLObject {
    prevValue!: string;
    newValue!: string;

    constructor(params: { prevValue: string; newValue: string }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionChangeTitle';
      this.constructorId = 0xe6dfb825;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevValue', 'newValue'];
      this.prevValue = params.prevValue;
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionChangeTitle> {
      // no flags

      let prevValue = await Primitive.String.read(b);
      let newValue = await Primitive.String.read(b);
      return new Raw.ChannelAdminLogEventActionChangeTitle({
        prevValue: prevValue,
        newValue: newValue,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevValue !== undefined) {
        b.write(Primitive.String.write(this.prevValue) as unknown as Buffer);
      }
      if (this.newValue !== undefined) {
        b.write(Primitive.String.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionChangeAbout extends TLObject {
    prevValue!: string;
    newValue!: string;

    constructor(params: { prevValue: string; newValue: string }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionChangeAbout';
      this.constructorId = 0x55188a2e;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevValue', 'newValue'];
      this.prevValue = params.prevValue;
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionChangeAbout> {
      // no flags

      let prevValue = await Primitive.String.read(b);
      let newValue = await Primitive.String.read(b);
      return new Raw.ChannelAdminLogEventActionChangeAbout({
        prevValue: prevValue,
        newValue: newValue,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevValue !== undefined) {
        b.write(Primitive.String.write(this.prevValue) as unknown as Buffer);
      }
      if (this.newValue !== undefined) {
        b.write(Primitive.String.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionChangeUsername extends TLObject {
    prevValue!: string;
    newValue!: string;

    constructor(params: { prevValue: string; newValue: string }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionChangeUsername';
      this.constructorId = 0x6a4afc38;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevValue', 'newValue'];
      this.prevValue = params.prevValue;
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionChangeUsername> {
      // no flags

      let prevValue = await Primitive.String.read(b);
      let newValue = await Primitive.String.read(b);
      return new Raw.ChannelAdminLogEventActionChangeUsername({
        prevValue: prevValue,
        newValue: newValue,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevValue !== undefined) {
        b.write(Primitive.String.write(this.prevValue) as unknown as Buffer);
      }
      if (this.newValue !== undefined) {
        b.write(Primitive.String.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionChangePhoto extends TLObject {
    prevPhoto!: Raw.TypePhoto;
    newPhoto!: Raw.TypePhoto;

    constructor(params: { prevPhoto: Raw.TypePhoto; newPhoto: Raw.TypePhoto }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionChangePhoto';
      this.constructorId = 0x434bd2af;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevPhoto', 'newPhoto'];
      this.prevPhoto = params.prevPhoto;
      this.newPhoto = params.newPhoto;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionChangePhoto> {
      // no flags

      let prevPhoto = await TLObject.read(b);
      let newPhoto = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionChangePhoto({
        prevPhoto: prevPhoto,
        newPhoto: newPhoto,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevPhoto !== undefined) {
        b.write(this.prevPhoto.write() as unknown as Buffer);
      }
      if (this.newPhoto !== undefined) {
        b.write(this.newPhoto.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionToggleInvites extends TLObject {
    newValue!: Bool;

    constructor(params: { newValue: Bool }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionToggleInvites';
      this.constructorId = 0x1b7907ae;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['newValue'];
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionToggleInvites> {
      // no flags

      let newValue = await Primitive.Bool.read(b);
      return new Raw.ChannelAdminLogEventActionToggleInvites({ newValue: newValue });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.newValue !== undefined) {
        b.write(Primitive.Bool.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionToggleSignatures extends TLObject {
    newValue!: Bool;

    constructor(params: { newValue: Bool }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionToggleSignatures';
      this.constructorId = 0x26ae0971;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['newValue'];
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionToggleSignatures> {
      // no flags

      let newValue = await Primitive.Bool.read(b);
      return new Raw.ChannelAdminLogEventActionToggleSignatures({ newValue: newValue });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.newValue !== undefined) {
        b.write(Primitive.Bool.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionUpdatePinned extends TLObject {
    message!: Raw.TypeMessage;

    constructor(params: { message: Raw.TypeMessage }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionUpdatePinned';
      this.constructorId = 0xe9e82c18;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['message'];
      this.message = params.message;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionUpdatePinned> {
      // no flags

      let message = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionUpdatePinned({ message: message });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.message !== undefined) {
        b.write(this.message.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionEditMessage extends TLObject {
    prevMessage!: Raw.TypeMessage;
    newMessage!: Raw.TypeMessage;

    constructor(params: { prevMessage: Raw.TypeMessage; newMessage: Raw.TypeMessage }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionEditMessage';
      this.constructorId = 0x709b2405;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevMessage', 'newMessage'];
      this.prevMessage = params.prevMessage;
      this.newMessage = params.newMessage;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionEditMessage> {
      // no flags

      let prevMessage = await TLObject.read(b);
      let newMessage = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionEditMessage({
        prevMessage: prevMessage,
        newMessage: newMessage,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevMessage !== undefined) {
        b.write(this.prevMessage.write() as unknown as Buffer);
      }
      if (this.newMessage !== undefined) {
        b.write(this.newMessage.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionDeleteMessage extends TLObject {
    message!: Raw.TypeMessage;

    constructor(params: { message: Raw.TypeMessage }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionDeleteMessage';
      this.constructorId = 0x42e047bb;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['message'];
      this.message = params.message;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionDeleteMessage> {
      // no flags

      let message = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionDeleteMessage({ message: message });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.message !== undefined) {
        b.write(this.message.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionParticipantJoin extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionParticipantJoin';
      this.constructorId = 0x183040d3;
      this.subclassOfId = 0xb2b987f3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionParticipantJoin> {
      // no flags

      return new Raw.ChannelAdminLogEventActionParticipantJoin();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionParticipantLeave extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionParticipantLeave';
      this.constructorId = 0xf89777f2;
      this.subclassOfId = 0xb2b987f3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionParticipantLeave> {
      // no flags

      return new Raw.ChannelAdminLogEventActionParticipantLeave();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionParticipantInvite extends TLObject {
    participant!: Raw.TypeChannelParticipant;

    constructor(params: { participant: Raw.TypeChannelParticipant }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionParticipantInvite';
      this.constructorId = 0xe31c34d8;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['participant'];
      this.participant = params.participant;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionParticipantInvite> {
      // no flags

      let participant = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionParticipantInvite({ participant: participant });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.participant !== undefined) {
        b.write(this.participant.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionParticipantToggleBan extends TLObject {
    prevParticipant!: Raw.TypeChannelParticipant;
    newParticipant!: Raw.TypeChannelParticipant;

    constructor(params: {
      prevParticipant: Raw.TypeChannelParticipant;
      newParticipant: Raw.TypeChannelParticipant;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionParticipantToggleBan';
      this.constructorId = 0xe6d83d7e;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevParticipant', 'newParticipant'];
      this.prevParticipant = params.prevParticipant;
      this.newParticipant = params.newParticipant;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionParticipantToggleBan> {
      // no flags

      let prevParticipant = await TLObject.read(b);
      let newParticipant = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionParticipantToggleBan({
        prevParticipant: prevParticipant,
        newParticipant: newParticipant,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevParticipant !== undefined) {
        b.write(this.prevParticipant.write() as unknown as Buffer);
      }
      if (this.newParticipant !== undefined) {
        b.write(this.newParticipant.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionParticipantToggleAdmin extends TLObject {
    prevParticipant!: Raw.TypeChannelParticipant;
    newParticipant!: Raw.TypeChannelParticipant;

    constructor(params: {
      prevParticipant: Raw.TypeChannelParticipant;
      newParticipant: Raw.TypeChannelParticipant;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionParticipantToggleAdmin';
      this.constructorId = 0xd5676710;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevParticipant', 'newParticipant'];
      this.prevParticipant = params.prevParticipant;
      this.newParticipant = params.newParticipant;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionParticipantToggleAdmin> {
      // no flags

      let prevParticipant = await TLObject.read(b);
      let newParticipant = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionParticipantToggleAdmin({
        prevParticipant: prevParticipant,
        newParticipant: newParticipant,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevParticipant !== undefined) {
        b.write(this.prevParticipant.write() as unknown as Buffer);
      }
      if (this.newParticipant !== undefined) {
        b.write(this.newParticipant.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionChangeStickerSet extends TLObject {
    prevStickerset!: Raw.TypeInputStickerSet;
    newStickerset!: Raw.TypeInputStickerSet;

    constructor(params: {
      prevStickerset: Raw.TypeInputStickerSet;
      newStickerset: Raw.TypeInputStickerSet;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionChangeStickerSet';
      this.constructorId = 0xb1c3caa7;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevStickerset', 'newStickerset'];
      this.prevStickerset = params.prevStickerset;
      this.newStickerset = params.newStickerset;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionChangeStickerSet> {
      // no flags

      let prevStickerset = await TLObject.read(b);
      let newStickerset = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionChangeStickerSet({
        prevStickerset: prevStickerset,
        newStickerset: newStickerset,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevStickerset !== undefined) {
        b.write(this.prevStickerset.write() as unknown as Buffer);
      }
      if (this.newStickerset !== undefined) {
        b.write(this.newStickerset.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionTogglePreHistoryHidden extends TLObject {
    newValue!: Bool;

    constructor(params: { newValue: Bool }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionTogglePreHistoryHidden';
      this.constructorId = 0x5f5c95f1;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['newValue'];
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionTogglePreHistoryHidden> {
      // no flags

      let newValue = await Primitive.Bool.read(b);
      return new Raw.ChannelAdminLogEventActionTogglePreHistoryHidden({ newValue: newValue });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.newValue !== undefined) {
        b.write(Primitive.Bool.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionDefaultBannedRights extends TLObject {
    prevBannedRights!: Raw.TypeChatBannedRights;
    newBannedRights!: Raw.TypeChatBannedRights;

    constructor(params: {
      prevBannedRights: Raw.TypeChatBannedRights;
      newBannedRights: Raw.TypeChatBannedRights;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionDefaultBannedRights';
      this.constructorId = 0x2df5fc0a;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevBannedRights', 'newBannedRights'];
      this.prevBannedRights = params.prevBannedRights;
      this.newBannedRights = params.newBannedRights;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionDefaultBannedRights> {
      // no flags

      let prevBannedRights = await TLObject.read(b);
      let newBannedRights = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionDefaultBannedRights({
        prevBannedRights: prevBannedRights,
        newBannedRights: newBannedRights,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevBannedRights !== undefined) {
        b.write(this.prevBannedRights.write() as unknown as Buffer);
      }
      if (this.newBannedRights !== undefined) {
        b.write(this.newBannedRights.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionStopPoll extends TLObject {
    message!: Raw.TypeMessage;

    constructor(params: { message: Raw.TypeMessage }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionStopPoll';
      this.constructorId = 0x8f079643;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['message'];
      this.message = params.message;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionStopPoll> {
      // no flags

      let message = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionStopPoll({ message: message });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.message !== undefined) {
        b.write(this.message.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionChangeLinkedChat extends TLObject {
    prevValue!: long;
    newValue!: long;

    constructor(params: { prevValue: long; newValue: long }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionChangeLinkedChat';
      this.constructorId = 0x50c7ac8;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevValue', 'newValue'];
      this.prevValue = params.prevValue;
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionChangeLinkedChat> {
      // no flags

      let prevValue = await Primitive.Long.read(b);
      let newValue = await Primitive.Long.read(b);
      return new Raw.ChannelAdminLogEventActionChangeLinkedChat({
        prevValue: prevValue,
        newValue: newValue,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevValue !== undefined) {
        b.write(Primitive.Long.write(this.prevValue) as unknown as Buffer);
      }
      if (this.newValue !== undefined) {
        b.write(Primitive.Long.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionChangeLocation extends TLObject {
    prevValue!: Raw.TypeChannelLocation;
    newValue!: Raw.TypeChannelLocation;

    constructor(params: { prevValue: Raw.TypeChannelLocation; newValue: Raw.TypeChannelLocation }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionChangeLocation';
      this.constructorId = 0xe6b76ae;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevValue', 'newValue'];
      this.prevValue = params.prevValue;
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionChangeLocation> {
      // no flags

      let prevValue = await TLObject.read(b);
      let newValue = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionChangeLocation({
        prevValue: prevValue,
        newValue: newValue,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevValue !== undefined) {
        b.write(this.prevValue.write() as unknown as Buffer);
      }
      if (this.newValue !== undefined) {
        b.write(this.newValue.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionToggleSlowMode extends TLObject {
    prevValue!: int;
    newValue!: int;

    constructor(params: { prevValue: int; newValue: int }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionToggleSlowMode';
      this.constructorId = 0x53909779;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevValue', 'newValue'];
      this.prevValue = params.prevValue;
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionToggleSlowMode> {
      // no flags

      let prevValue = await Primitive.Int.read(b);
      let newValue = await Primitive.Int.read(b);
      return new Raw.ChannelAdminLogEventActionToggleSlowMode({
        prevValue: prevValue,
        newValue: newValue,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevValue !== undefined) {
        b.write(Primitive.Int.write(this.prevValue) as unknown as Buffer);
      }
      if (this.newValue !== undefined) {
        b.write(Primitive.Int.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionStartGroupCall extends TLObject {
    call!: Raw.TypeInputGroupCall;

    constructor(params: { call: Raw.TypeInputGroupCall }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionStartGroupCall';
      this.constructorId = 0x23209745;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['call'];
      this.call = params.call;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionStartGroupCall> {
      // no flags

      let call = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionStartGroupCall({ call: call });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.call !== undefined) {
        b.write(this.call.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionDiscardGroupCall extends TLObject {
    call!: Raw.TypeInputGroupCall;

    constructor(params: { call: Raw.TypeInputGroupCall }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionDiscardGroupCall';
      this.constructorId = 0xdb9f9140;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['call'];
      this.call = params.call;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionDiscardGroupCall> {
      // no flags

      let call = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionDiscardGroupCall({ call: call });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.call !== undefined) {
        b.write(this.call.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionParticipantMute extends TLObject {
    participant!: Raw.TypeGroupCallParticipant;

    constructor(params: { participant: Raw.TypeGroupCallParticipant }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionParticipantMute';
      this.constructorId = 0xf92424d2;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['participant'];
      this.participant = params.participant;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionParticipantMute> {
      // no flags

      let participant = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionParticipantMute({ participant: participant });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.participant !== undefined) {
        b.write(this.participant.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionParticipantUnmute extends TLObject {
    participant!: Raw.TypeGroupCallParticipant;

    constructor(params: { participant: Raw.TypeGroupCallParticipant }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionParticipantUnmute';
      this.constructorId = 0xe64429c0;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['participant'];
      this.participant = params.participant;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionParticipantUnmute> {
      // no flags

      let participant = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionParticipantUnmute({ participant: participant });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.participant !== undefined) {
        b.write(this.participant.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionToggleGroupCallSetting extends TLObject {
    joinMuted!: Bool;

    constructor(params: { joinMuted: Bool }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionToggleGroupCallSetting';
      this.constructorId = 0x56d6a247;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['joinMuted'];
      this.joinMuted = params.joinMuted;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionToggleGroupCallSetting> {
      // no flags

      let joinMuted = await Primitive.Bool.read(b);
      return new Raw.ChannelAdminLogEventActionToggleGroupCallSetting({ joinMuted: joinMuted });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.joinMuted !== undefined) {
        b.write(Primitive.Bool.write(this.joinMuted) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionParticipantJoinByInvite extends TLObject {
    viaChatlist?: boolean;
    invite!: Raw.TypeExportedChatInvite;

    constructor(params: { viaChatlist?: boolean; invite: Raw.TypeExportedChatInvite }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionParticipantJoinByInvite';
      this.constructorId = 0xfe9fc158;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['viaChatlist', 'invite'];
      this.viaChatlist = params.viaChatlist;
      this.invite = params.invite;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionParticipantJoinByInvite> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let viaChatlist = flags & (1 << 0) ? true : false;
      let invite = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionParticipantJoinByInvite({
        viaChatlist: viaChatlist,
        invite: invite,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.viaChatlist ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.invite !== undefined) {
        b.write(this.invite.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionExportedInviteDelete extends TLObject {
    invite!: Raw.TypeExportedChatInvite;

    constructor(params: { invite: Raw.TypeExportedChatInvite }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionExportedInviteDelete';
      this.constructorId = 0x5a50fca4;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['invite'];
      this.invite = params.invite;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionExportedInviteDelete> {
      // no flags

      let invite = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionExportedInviteDelete({ invite: invite });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.invite !== undefined) {
        b.write(this.invite.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionExportedInviteRevoke extends TLObject {
    invite!: Raw.TypeExportedChatInvite;

    constructor(params: { invite: Raw.TypeExportedChatInvite }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionExportedInviteRevoke';
      this.constructorId = 0x410a134e;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['invite'];
      this.invite = params.invite;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionExportedInviteRevoke> {
      // no flags

      let invite = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionExportedInviteRevoke({ invite: invite });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.invite !== undefined) {
        b.write(this.invite.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionExportedInviteEdit extends TLObject {
    prevInvite!: Raw.TypeExportedChatInvite;
    newInvite!: Raw.TypeExportedChatInvite;

    constructor(params: {
      prevInvite: Raw.TypeExportedChatInvite;
      newInvite: Raw.TypeExportedChatInvite;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionExportedInviteEdit';
      this.constructorId = 0xe90ebb59;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevInvite', 'newInvite'];
      this.prevInvite = params.prevInvite;
      this.newInvite = params.newInvite;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionExportedInviteEdit> {
      // no flags

      let prevInvite = await TLObject.read(b);
      let newInvite = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionExportedInviteEdit({
        prevInvite: prevInvite,
        newInvite: newInvite,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevInvite !== undefined) {
        b.write(this.prevInvite.write() as unknown as Buffer);
      }
      if (this.newInvite !== undefined) {
        b.write(this.newInvite.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionParticipantVolume extends TLObject {
    participant!: Raw.TypeGroupCallParticipant;

    constructor(params: { participant: Raw.TypeGroupCallParticipant }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionParticipantVolume';
      this.constructorId = 0x3e7f6847;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['participant'];
      this.participant = params.participant;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionParticipantVolume> {
      // no flags

      let participant = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionParticipantVolume({ participant: participant });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.participant !== undefined) {
        b.write(this.participant.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionChangeHistoryTTL extends TLObject {
    prevValue!: int;
    newValue!: int;

    constructor(params: { prevValue: int; newValue: int }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionChangeHistoryTTL';
      this.constructorId = 0x6e941a38;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevValue', 'newValue'];
      this.prevValue = params.prevValue;
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionChangeHistoryTTL> {
      // no flags

      let prevValue = await Primitive.Int.read(b);
      let newValue = await Primitive.Int.read(b);
      return new Raw.ChannelAdminLogEventActionChangeHistoryTTL({
        prevValue: prevValue,
        newValue: newValue,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevValue !== undefined) {
        b.write(Primitive.Int.write(this.prevValue) as unknown as Buffer);
      }
      if (this.newValue !== undefined) {
        b.write(Primitive.Int.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionParticipantJoinByRequest extends TLObject {
    invite!: Raw.TypeExportedChatInvite;
    approvedBy!: long;

    constructor(params: { invite: Raw.TypeExportedChatInvite; approvedBy: long }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionParticipantJoinByRequest';
      this.constructorId = 0xafb6144a;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['invite', 'approvedBy'];
      this.invite = params.invite;
      this.approvedBy = params.approvedBy;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionParticipantJoinByRequest> {
      // no flags

      let invite = await TLObject.read(b);
      let approvedBy = await Primitive.Long.read(b);
      return new Raw.ChannelAdminLogEventActionParticipantJoinByRequest({
        invite: invite,
        approvedBy: approvedBy,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.invite !== undefined) {
        b.write(this.invite.write() as unknown as Buffer);
      }
      if (this.approvedBy !== undefined) {
        b.write(Primitive.Long.write(this.approvedBy) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionToggleNoForwards extends TLObject {
    newValue!: Bool;

    constructor(params: { newValue: Bool }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionToggleNoForwards';
      this.constructorId = 0xcb2ac766;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['newValue'];
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionToggleNoForwards> {
      // no flags

      let newValue = await Primitive.Bool.read(b);
      return new Raw.ChannelAdminLogEventActionToggleNoForwards({ newValue: newValue });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.newValue !== undefined) {
        b.write(Primitive.Bool.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionSendMessage extends TLObject {
    message!: Raw.TypeMessage;

    constructor(params: { message: Raw.TypeMessage }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionSendMessage';
      this.constructorId = 0x278f2868;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['message'];
      this.message = params.message;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionSendMessage> {
      // no flags

      let message = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionSendMessage({ message: message });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.message !== undefined) {
        b.write(this.message.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionChangeAvailableReactions extends TLObject {
    prevValue!: Raw.TypeChatReactions;
    newValue!: Raw.TypeChatReactions;

    constructor(params: { prevValue: Raw.TypeChatReactions; newValue: Raw.TypeChatReactions }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionChangeAvailableReactions';
      this.constructorId = 0xbe4e0ef8;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevValue', 'newValue'];
      this.prevValue = params.prevValue;
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionChangeAvailableReactions> {
      // no flags

      let prevValue = await TLObject.read(b);
      let newValue = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionChangeAvailableReactions({
        prevValue: prevValue,
        newValue: newValue,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevValue !== undefined) {
        b.write(this.prevValue.write() as unknown as Buffer);
      }
      if (this.newValue !== undefined) {
        b.write(this.newValue.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionChangeUsernames extends TLObject {
    prevValue!: Vector<string>;
    newValue!: Vector<string>;

    constructor(params: { prevValue: Vector<string>; newValue: Vector<string> }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionChangeUsernames';
      this.constructorId = 0xf04fb3a9;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevValue', 'newValue'];
      this.prevValue = params.prevValue;
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionChangeUsernames> {
      // no flags

      let prevValue = await TLObject.read(b, Primitive.String);
      let newValue = await TLObject.read(b, Primitive.String);
      return new Raw.ChannelAdminLogEventActionChangeUsernames({
        prevValue: prevValue,
        newValue: newValue,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevValue) {
        b.write(Primitive.Vector.write(this.prevValue, Primitive.String) as unknown as Buffer);
      }
      if (this.newValue) {
        b.write(Primitive.Vector.write(this.newValue, Primitive.String) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionToggleForum extends TLObject {
    newValue!: Bool;

    constructor(params: { newValue: Bool }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionToggleForum';
      this.constructorId = 0x2cc6383;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['newValue'];
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionToggleForum> {
      // no flags

      let newValue = await Primitive.Bool.read(b);
      return new Raw.ChannelAdminLogEventActionToggleForum({ newValue: newValue });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.newValue !== undefined) {
        b.write(Primitive.Bool.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionCreateTopic extends TLObject {
    topic!: Raw.TypeForumTopic;

    constructor(params: { topic: Raw.TypeForumTopic }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionCreateTopic';
      this.constructorId = 0x58707d28;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['topic'];
      this.topic = params.topic;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionCreateTopic> {
      // no flags

      let topic = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionCreateTopic({ topic: topic });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.topic !== undefined) {
        b.write(this.topic.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionEditTopic extends TLObject {
    prevTopic!: Raw.TypeForumTopic;
    newTopic!: Raw.TypeForumTopic;

    constructor(params: { prevTopic: Raw.TypeForumTopic; newTopic: Raw.TypeForumTopic }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionEditTopic';
      this.constructorId = 0xf06fe208;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevTopic', 'newTopic'];
      this.prevTopic = params.prevTopic;
      this.newTopic = params.newTopic;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionEditTopic> {
      // no flags

      let prevTopic = await TLObject.read(b);
      let newTopic = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionEditTopic({
        prevTopic: prevTopic,
        newTopic: newTopic,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevTopic !== undefined) {
        b.write(this.prevTopic.write() as unknown as Buffer);
      }
      if (this.newTopic !== undefined) {
        b.write(this.newTopic.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionDeleteTopic extends TLObject {
    topic!: Raw.TypeForumTopic;

    constructor(params: { topic: Raw.TypeForumTopic }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionDeleteTopic';
      this.constructorId = 0xae168909;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['topic'];
      this.topic = params.topic;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionDeleteTopic> {
      // no flags

      let topic = await TLObject.read(b);
      return new Raw.ChannelAdminLogEventActionDeleteTopic({ topic: topic });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.topic !== undefined) {
        b.write(this.topic.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionPinTopic extends TLObject {
    prevTopic?: Raw.TypeForumTopic;
    newTopic?: Raw.TypeForumTopic;

    constructor(params: { prevTopic?: Raw.TypeForumTopic; newTopic?: Raw.TypeForumTopic }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionPinTopic';
      this.constructorId = 0x5d8d353b;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevTopic', 'newTopic'];
      this.prevTopic = params.prevTopic;
      this.newTopic = params.newTopic;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionPinTopic> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let prevTopic = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let newTopic = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      return new Raw.ChannelAdminLogEventActionPinTopic({
        prevTopic: prevTopic,
        newTopic: newTopic,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.prevTopic !== undefined ? 1 << 0 : 0;
      flags |= this.newTopic !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.prevTopic !== undefined) {
        b.write(this.prevTopic.write() as unknown as Buffer);
      }
      if (this.newTopic !== undefined) {
        b.write(this.newTopic.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionToggleAntiSpam extends TLObject {
    newValue!: Bool;

    constructor(params: { newValue: Bool }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionToggleAntiSpam';
      this.constructorId = 0x64f36dfc;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['newValue'];
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionToggleAntiSpam> {
      // no flags

      let newValue = await Primitive.Bool.read(b);
      return new Raw.ChannelAdminLogEventActionToggleAntiSpam({ newValue: newValue });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.newValue !== undefined) {
        b.write(Primitive.Bool.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionChangeColor extends TLObject {
    prevValue!: int;
    newValue!: int;

    constructor(params: { prevValue: int; newValue: int }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionChangeColor';
      this.constructorId = 0x3c2b247b;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevValue', 'newValue'];
      this.prevValue = params.prevValue;
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionChangeColor> {
      // no flags

      let prevValue = await Primitive.Int.read(b);
      let newValue = await Primitive.Int.read(b);
      return new Raw.ChannelAdminLogEventActionChangeColor({
        prevValue: prevValue,
        newValue: newValue,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevValue !== undefined) {
        b.write(Primitive.Int.write(this.prevValue) as unknown as Buffer);
      }
      if (this.newValue !== undefined) {
        b.write(Primitive.Int.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventActionChangeBackgroundEmoji extends TLObject {
    prevValue!: long;
    newValue!: long;

    constructor(params: { prevValue: long; newValue: long }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventActionChangeBackgroundEmoji';
      this.constructorId = 0x445fc434;
      this.subclassOfId = 0xb2b987f3;
      this._slots = ['prevValue', 'newValue'];
      this.prevValue = params.prevValue;
      this.newValue = params.newValue;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.ChannelAdminLogEventActionChangeBackgroundEmoji> {
      // no flags

      let prevValue = await Primitive.Long.read(b);
      let newValue = await Primitive.Long.read(b);
      return new Raw.ChannelAdminLogEventActionChangeBackgroundEmoji({
        prevValue: prevValue,
        newValue: newValue,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.prevValue !== undefined) {
        b.write(Primitive.Long.write(this.prevValue) as unknown as Buffer);
      }
      if (this.newValue !== undefined) {
        b.write(Primitive.Long.write(this.newValue) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEvent extends TLObject {
    id!: long;
    date!: int;
    userId!: long;
    action!: Raw.TypeChannelAdminLogEventAction;

    constructor(params: {
      id: long;
      date: int;
      userId: long;
      action: Raw.TypeChannelAdminLogEventAction;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEvent';
      this.constructorId = 0x1fad68cd;
      this.subclassOfId = 0x408f0999;
      this._slots = ['id', 'date', 'userId', 'action'];
      this.id = params.id;
      this.date = params.date;
      this.userId = params.userId;
      this.action = params.action;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelAdminLogEvent> {
      // no flags

      let id = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let userId = await Primitive.Long.read(b);
      let action = await TLObject.read(b);
      return new Raw.ChannelAdminLogEvent({ id: id, date: date, userId: userId, action: action });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.action !== undefined) {
        b.write(this.action.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChannelAdminLogEventsFilter extends TLObject {
    join?: boolean;
    leave?: boolean;
    invite?: boolean;
    ban?: boolean;
    unban?: boolean;
    kick?: boolean;
    unkick?: boolean;
    promote?: boolean;
    demote?: boolean;
    info?: boolean;
    settings?: boolean;
    pinned?: boolean;
    edit?: boolean;
    delete?: boolean;
    groupCall?: boolean;
    invites?: boolean;
    send?: boolean;
    forums?: boolean;

    constructor(params: {
      join?: boolean;
      leave?: boolean;
      invite?: boolean;
      ban?: boolean;
      unban?: boolean;
      kick?: boolean;
      unkick?: boolean;
      promote?: boolean;
      demote?: boolean;
      info?: boolean;
      settings?: boolean;
      pinned?: boolean;
      edit?: boolean;
      delete?: boolean;
      groupCall?: boolean;
      invites?: boolean;
      send?: boolean;
      forums?: boolean;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelAdminLogEventsFilter';
      this.constructorId = 0xea107ae4;
      this.subclassOfId = 0x7cbbf319;
      this._slots = [
        'join',
        'leave',
        'invite',
        'ban',
        'unban',
        'kick',
        'unkick',
        'promote',
        'demote',
        'info',
        'settings',
        'pinned',
        'edit',
        'delete',
        'groupCall',
        'invites',
        'send',
        'forums',
      ];
      this.join = params.join;
      this.leave = params.leave;
      this.invite = params.invite;
      this.ban = params.ban;
      this.unban = params.unban;
      this.kick = params.kick;
      this.unkick = params.unkick;
      this.promote = params.promote;
      this.demote = params.demote;
      this.info = params.info;
      this.settings = params.settings;
      this.pinned = params.pinned;
      this.edit = params.edit;
      this.delete = params.delete;
      this.groupCall = params.groupCall;
      this.invites = params.invites;
      this.send = params.send;
      this.forums = params.forums;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelAdminLogEventsFilter> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let join = flags & (1 << 0) ? true : false;
      let leave = flags & (1 << 1) ? true : false;
      let invite = flags & (1 << 2) ? true : false;
      let ban = flags & (1 << 3) ? true : false;
      let unban = flags & (1 << 4) ? true : false;
      let kick = flags & (1 << 5) ? true : false;
      let unkick = flags & (1 << 6) ? true : false;
      let promote = flags & (1 << 7) ? true : false;
      let demote = flags & (1 << 8) ? true : false;
      let info = flags & (1 << 9) ? true : false;
      let settings = flags & (1 << 10) ? true : false;
      let pinned = flags & (1 << 11) ? true : false;
      let edit = flags & (1 << 12) ? true : false;
      let _delete = flags & (1 << 13) ? true : false;
      let groupCall = flags & (1 << 14) ? true : false;
      let invites = flags & (1 << 15) ? true : false;
      let send = flags & (1 << 16) ? true : false;
      let forums = flags & (1 << 17) ? true : false;
      return new Raw.ChannelAdminLogEventsFilter({
        join: join,
        leave: leave,
        invite: invite,
        ban: ban,
        unban: unban,
        kick: kick,
        unkick: unkick,
        promote: promote,
        demote: demote,
        info: info,
        settings: settings,
        pinned: pinned,
        edit: edit,
        delete: _delete,
        groupCall: groupCall,
        invites: invites,
        send: send,
        forums: forums,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.join ? 1 << 0 : 0;
      flags |= this.leave ? 1 << 1 : 0;
      flags |= this.invite ? 1 << 2 : 0;
      flags |= this.ban ? 1 << 3 : 0;
      flags |= this.unban ? 1 << 4 : 0;
      flags |= this.kick ? 1 << 5 : 0;
      flags |= this.unkick ? 1 << 6 : 0;
      flags |= this.promote ? 1 << 7 : 0;
      flags |= this.demote ? 1 << 8 : 0;
      flags |= this.info ? 1 << 9 : 0;
      flags |= this.settings ? 1 << 10 : 0;
      flags |= this.pinned ? 1 << 11 : 0;
      flags |= this.edit ? 1 << 12 : 0;
      flags |= this.delete ? 1 << 13 : 0;
      flags |= this.groupCall ? 1 << 14 : 0;
      flags |= this.invites ? 1 << 15 : 0;
      flags |= this.send ? 1 << 16 : 0;
      flags |= this.forums ? 1 << 17 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      return b.buffer;
    }
  }
  export class PopularContact extends TLObject {
    clientId!: long;
    importers!: int;

    constructor(params: { clientId: long; importers: int }) {
      super();
      this.classType = 'types';
      this.className = 'PopularContact';
      this.constructorId = 0x5ce14175;
      this.subclassOfId = 0x409255a;
      this._slots = ['clientId', 'importers'];
      this.clientId = params.clientId;
      this.importers = params.importers;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PopularContact> {
      // no flags

      let clientId = await Primitive.Long.read(b);
      let importers = await Primitive.Int.read(b);
      return new Raw.PopularContact({ clientId: clientId, importers: importers });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.clientId !== undefined) {
        b.write(Primitive.Long.write(this.clientId) as unknown as Buffer);
      }
      if (this.importers !== undefined) {
        b.write(Primitive.Int.write(this.importers) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RecentMeUrlUnknown extends TLObject {
    url!: string;

    constructor(params: { url: string }) {
      super();
      this.classType = 'types';
      this.className = 'RecentMeUrlUnknown';
      this.constructorId = 0x46e1d13d;
      this.subclassOfId = 0x55a53079;
      this._slots = ['url'];
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RecentMeUrlUnknown> {
      // no flags

      let url = await Primitive.String.read(b);
      return new Raw.RecentMeUrlUnknown({ url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RecentMeUrlUser extends TLObject {
    url!: string;
    userId!: long;

    constructor(params: { url: string; userId: long }) {
      super();
      this.classType = 'types';
      this.className = 'RecentMeUrlUser';
      this.constructorId = 0xb92c09e2;
      this.subclassOfId = 0x55a53079;
      this._slots = ['url', 'userId'];
      this.url = params.url;
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RecentMeUrlUser> {
      // no flags

      let url = await Primitive.String.read(b);
      let userId = await Primitive.Long.read(b);
      return new Raw.RecentMeUrlUser({ url: url, userId: userId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RecentMeUrlChat extends TLObject {
    url!: string;
    chatId!: long;

    constructor(params: { url: string; chatId: long }) {
      super();
      this.classType = 'types';
      this.className = 'RecentMeUrlChat';
      this.constructorId = 0xb2da71d2;
      this.subclassOfId = 0x55a53079;
      this._slots = ['url', 'chatId'];
      this.url = params.url;
      this.chatId = params.chatId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RecentMeUrlChat> {
      // no flags

      let url = await Primitive.String.read(b);
      let chatId = await Primitive.Long.read(b);
      return new Raw.RecentMeUrlChat({ url: url, chatId: chatId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.chatId !== undefined) {
        b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RecentMeUrlChatInvite extends TLObject {
    url!: string;
    chatInvite!: Raw.TypeChatInvite;

    constructor(params: { url: string; chatInvite: Raw.TypeChatInvite }) {
      super();
      this.classType = 'types';
      this.className = 'RecentMeUrlChatInvite';
      this.constructorId = 0xeb49081d;
      this.subclassOfId = 0x55a53079;
      this._slots = ['url', 'chatInvite'];
      this.url = params.url;
      this.chatInvite = params.chatInvite;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RecentMeUrlChatInvite> {
      // no flags

      let url = await Primitive.String.read(b);
      let chatInvite = await TLObject.read(b);
      return new Raw.RecentMeUrlChatInvite({ url: url, chatInvite: chatInvite });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.chatInvite !== undefined) {
        b.write(this.chatInvite.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RecentMeUrlStickerSet extends TLObject {
    url!: string;
    set!: Raw.TypeStickerSetCovered;

    constructor(params: { url: string; set: Raw.TypeStickerSetCovered }) {
      super();
      this.classType = 'types';
      this.className = 'RecentMeUrlStickerSet';
      this.constructorId = 0xbc0a57dc;
      this.subclassOfId = 0x55a53079;
      this._slots = ['url', 'set'];
      this.url = params.url;
      this.set = params.set;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RecentMeUrlStickerSet> {
      // no flags

      let url = await Primitive.String.read(b);
      let set = await TLObject.read(b);
      return new Raw.RecentMeUrlStickerSet({ url: url, set: set });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.set !== undefined) {
        b.write(this.set.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputSingleMedia extends TLObject {
    media!: Raw.TypeInputMedia;
    randomId!: long;
    message!: string;
    entities?: Vector<Raw.TypeMessageEntity>;

    constructor(params: {
      media: Raw.TypeInputMedia;
      randomId: long;
      message: string;
      entities?: Vector<Raw.TypeMessageEntity>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputSingleMedia';
      this.constructorId = 0x1cc6e91f;
      this.subclassOfId = 0x21ca8ed8;
      this._slots = ['media', 'randomId', 'message', 'entities'];
      this.media = params.media;
      this.randomId = params.randomId;
      this.message = params.message;
      this.entities = params.entities;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputSingleMedia> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let media = await TLObject.read(b);
      let randomId = await Primitive.Long.read(b);
      let message = await Primitive.String.read(b);
      let entities = flags & (1 << 0) ? await TLObject.read(b) : [];
      return new Raw.InputSingleMedia({
        media: media,
        randomId: randomId,
        message: message,
        entities: entities,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.entities ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.media !== undefined) {
        b.write(this.media.write() as unknown as Buffer);
      }
      if (this.randomId !== undefined) {
        b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
      }
      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WebAuthorization extends TLObject {
    hash!: long;
    botId!: long;
    domain!: string;
    browser!: string;
    platform!: string;
    dateCreated!: int;
    dateActive!: int;
    ip!: string;
    region!: string;

    constructor(params: {
      hash: long;
      botId: long;
      domain: string;
      browser: string;
      platform: string;
      dateCreated: int;
      dateActive: int;
      ip: string;
      region: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'WebAuthorization';
      this.constructorId = 0xa6f8f452;
      this.subclassOfId = 0x3764d30;
      this._slots = [
        'hash',
        'botId',
        'domain',
        'browser',
        'platform',
        'dateCreated',
        'dateActive',
        'ip',
        'region',
      ];
      this.hash = params.hash;
      this.botId = params.botId;
      this.domain = params.domain;
      this.browser = params.browser;
      this.platform = params.platform;
      this.dateCreated = params.dateCreated;
      this.dateActive = params.dateActive;
      this.ip = params.ip;
      this.region = params.region;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WebAuthorization> {
      // no flags

      let hash = await Primitive.Long.read(b);
      let botId = await Primitive.Long.read(b);
      let domain = await Primitive.String.read(b);
      let browser = await Primitive.String.read(b);
      let platform = await Primitive.String.read(b);
      let dateCreated = await Primitive.Int.read(b);
      let dateActive = await Primitive.Int.read(b);
      let ip = await Primitive.String.read(b);
      let region = await Primitive.String.read(b);
      return new Raw.WebAuthorization({
        hash: hash,
        botId: botId,
        domain: domain,
        browser: browser,
        platform: platform,
        dateCreated: dateCreated,
        dateActive: dateActive,
        ip: ip,
        region: region,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.hash !== undefined) {
        b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
      }
      if (this.botId !== undefined) {
        b.write(Primitive.Long.write(this.botId) as unknown as Buffer);
      }
      if (this.domain !== undefined) {
        b.write(Primitive.String.write(this.domain) as unknown as Buffer);
      }
      if (this.browser !== undefined) {
        b.write(Primitive.String.write(this.browser) as unknown as Buffer);
      }
      if (this.platform !== undefined) {
        b.write(Primitive.String.write(this.platform) as unknown as Buffer);
      }
      if (this.dateCreated !== undefined) {
        b.write(Primitive.Int.write(this.dateCreated) as unknown as Buffer);
      }
      if (this.dateActive !== undefined) {
        b.write(Primitive.Int.write(this.dateActive) as unknown as Buffer);
      }
      if (this.ip !== undefined) {
        b.write(Primitive.String.write(this.ip) as unknown as Buffer);
      }
      if (this.region !== undefined) {
        b.write(Primitive.String.write(this.region) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMessageID extends TLObject {
    id!: int;

    constructor(params: { id: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputMessageID';
      this.constructorId = 0xa676a322;
      this.subclassOfId = 0x54b6bcc5;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessageID> {
      // no flags

      let id = await Primitive.Int.read(b);
      return new Raw.InputMessageID({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMessageReplyTo extends TLObject {
    id!: int;

    constructor(params: { id: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputMessageReplyTo';
      this.constructorId = 0xbad88395;
      this.subclassOfId = 0x54b6bcc5;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessageReplyTo> {
      // no flags

      let id = await Primitive.Int.read(b);
      return new Raw.InputMessageReplyTo({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMessagePinned extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputMessagePinned';
      this.constructorId = 0x86872538;
      this.subclassOfId = 0x54b6bcc5;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessagePinned> {
      // no flags

      return new Raw.InputMessagePinned();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputMessageCallbackQuery extends TLObject {
    id!: int;
    queryId!: long;

    constructor(params: { id: int; queryId: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputMessageCallbackQuery';
      this.constructorId = 0xacfa1a7e;
      this.subclassOfId = 0x54b6bcc5;
      this._slots = ['id', 'queryId'];
      this.id = params.id;
      this.queryId = params.queryId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMessageCallbackQuery> {
      // no flags

      let id = await Primitive.Int.read(b);
      let queryId = await Primitive.Long.read(b);
      return new Raw.InputMessageCallbackQuery({ id: id, queryId: queryId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.queryId !== undefined) {
        b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputDialogPeer extends TLObject {
    peer!: Raw.TypeInputPeer;

    constructor(params: { peer: Raw.TypeInputPeer }) {
      super();
      this.classType = 'types';
      this.className = 'InputDialogPeer';
      this.constructorId = 0xfcaafeb7;
      this.subclassOfId = 0xa21c9795;
      this._slots = ['peer'];
      this.peer = params.peer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputDialogPeer> {
      // no flags

      let peer = await TLObject.read(b);
      return new Raw.InputDialogPeer({ peer: peer });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputDialogPeerFolder extends TLObject {
    folderId!: int;

    constructor(params: { folderId: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputDialogPeerFolder';
      this.constructorId = 0x64600527;
      this.subclassOfId = 0xa21c9795;
      this._slots = ['folderId'];
      this.folderId = params.folderId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputDialogPeerFolder> {
      // no flags

      let folderId = await Primitive.Int.read(b);
      return new Raw.InputDialogPeerFolder({ folderId: folderId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DialogPeer extends TLObject {
    peer!: Raw.TypePeer;

    constructor(params: { peer: Raw.TypePeer }) {
      super();
      this.classType = 'types';
      this.className = 'DialogPeer';
      this.constructorId = 0xe56dbf05;
      this.subclassOfId = 0x256ce1ae;
      this._slots = ['peer'];
      this.peer = params.peer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DialogPeer> {
      // no flags

      let peer = await TLObject.read(b);
      return new Raw.DialogPeer({ peer: peer });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DialogPeerFolder extends TLObject {
    folderId!: int;

    constructor(params: { folderId: int }) {
      super();
      this.classType = 'types';
      this.className = 'DialogPeerFolder';
      this.constructorId = 0x514519e2;
      this.subclassOfId = 0x256ce1ae;
      this._slots = ['folderId'];
      this.folderId = params.folderId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DialogPeerFolder> {
      // no flags

      let folderId = await Primitive.Int.read(b);
      return new Raw.DialogPeerFolder({ folderId: folderId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class FileHash extends TLObject {
    offset!: long;
    limit!: int;
    hash!: bytes;

    constructor(params: { offset: long; limit: int; hash: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'FileHash';
      this.constructorId = 0xf39b035c;
      this.subclassOfId = 0xead438b3;
      this._slots = ['offset', 'limit', 'hash'];
      this.offset = params.offset;
      this.limit = params.limit;
      this.hash = params.hash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.FileHash> {
      // no flags

      let offset = await Primitive.Long.read(b);
      let limit = await Primitive.Int.read(b);
      let hash = await Primitive.Bytes.read(b);
      return new Raw.FileHash({ offset: offset, limit: limit, hash: hash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.offset !== undefined) {
        b.write(Primitive.Long.write(this.offset) as unknown as Buffer);
      }
      if (this.limit !== undefined) {
        b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
      }
      if (this.hash !== undefined) {
        b.write(Primitive.Bytes.write(this.hash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputClientProxy extends TLObject {
    address!: string;
    port!: int;

    constructor(params: { address: string; port: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputClientProxy';
      this.constructorId = 0x75588b3f;
      this.subclassOfId = 0x91a4346;
      this._slots = ['address', 'port'];
      this.address = params.address;
      this.port = params.port;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputClientProxy> {
      // no flags

      let address = await Primitive.String.read(b);
      let port = await Primitive.Int.read(b);
      return new Raw.InputClientProxy({ address: address, port: port });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.address !== undefined) {
        b.write(Primitive.String.write(this.address) as unknown as Buffer);
      }
      if (this.port !== undefined) {
        b.write(Primitive.Int.write(this.port) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputSecureFileUploaded extends TLObject {
    id!: long;
    parts!: int;
    md5Checksum!: string;
    fileHash!: bytes;
    secret!: bytes;

    constructor(params: {
      id: long;
      parts: int;
      md5Checksum: string;
      fileHash: bytes;
      secret: bytes;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputSecureFileUploaded';
      this.constructorId = 0x3334b0f0;
      this.subclassOfId = 0xdac8adfc;
      this._slots = ['id', 'parts', 'md5Checksum', 'fileHash', 'secret'];
      this.id = params.id;
      this.parts = params.parts;
      this.md5Checksum = params.md5Checksum;
      this.fileHash = params.fileHash;
      this.secret = params.secret;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputSecureFileUploaded> {
      // no flags

      let id = await Primitive.Long.read(b);
      let parts = await Primitive.Int.read(b);
      let md5Checksum = await Primitive.String.read(b);
      let fileHash = await Primitive.Bytes.read(b);
      let secret = await Primitive.Bytes.read(b);
      return new Raw.InputSecureFileUploaded({
        id: id,
        parts: parts,
        md5Checksum: md5Checksum,
        fileHash: fileHash,
        secret: secret,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.parts !== undefined) {
        b.write(Primitive.Int.write(this.parts) as unknown as Buffer);
      }
      if (this.md5Checksum !== undefined) {
        b.write(Primitive.String.write(this.md5Checksum) as unknown as Buffer);
      }
      if (this.fileHash !== undefined) {
        b.write(Primitive.Bytes.write(this.fileHash) as unknown as Buffer);
      }
      if (this.secret !== undefined) {
        b.write(Primitive.Bytes.write(this.secret) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputSecureFile extends TLObject {
    id!: long;
    accessHash!: long;

    constructor(params: { id: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputSecureFile';
      this.constructorId = 0x5367e5be;
      this.subclassOfId = 0xdac8adfc;
      this._slots = ['id', 'accessHash'];
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputSecureFile> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputSecureFile({ id: id, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureFileEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureFileEmpty';
      this.constructorId = 0x64199744;
      this.subclassOfId = 0x5db8dbc7;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureFileEmpty> {
      // no flags

      return new Raw.SecureFileEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureFile extends TLObject {
    id!: long;
    accessHash!: long;
    size!: long;
    dcId!: int;
    date!: int;
    fileHash!: bytes;
    secret!: bytes;

    constructor(params: {
      id: long;
      accessHash: long;
      size: long;
      dcId: int;
      date: int;
      fileHash: bytes;
      secret: bytes;
    }) {
      super();
      this.classType = 'types';
      this.className = 'SecureFile';
      this.constructorId = 0x7d09c27e;
      this.subclassOfId = 0x5db8dbc7;
      this._slots = ['id', 'accessHash', 'size', 'dcId', 'date', 'fileHash', 'secret'];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.size = params.size;
      this.dcId = params.dcId;
      this.date = params.date;
      this.fileHash = params.fileHash;
      this.secret = params.secret;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureFile> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let size = await Primitive.Long.read(b);
      let dcId = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      let fileHash = await Primitive.Bytes.read(b);
      let secret = await Primitive.Bytes.read(b);
      return new Raw.SecureFile({
        id: id,
        accessHash: accessHash,
        size: size,
        dcId: dcId,
        date: date,
        fileHash: fileHash,
        secret: secret,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Long.write(this.size) as unknown as Buffer);
      }
      if (this.dcId !== undefined) {
        b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.fileHash !== undefined) {
        b.write(Primitive.Bytes.write(this.fileHash) as unknown as Buffer);
      }
      if (this.secret !== undefined) {
        b.write(Primitive.Bytes.write(this.secret) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureData extends TLObject {
    data!: bytes;
    dataHash!: bytes;
    secret!: bytes;

    constructor(params: { data: bytes; dataHash: bytes; secret: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'SecureData';
      this.constructorId = 0x8aeabec3;
      this.subclassOfId = 0x7cd41eb4;
      this._slots = ['data', 'dataHash', 'secret'];
      this.data = params.data;
      this.dataHash = params.dataHash;
      this.secret = params.secret;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureData> {
      // no flags

      let data = await Primitive.Bytes.read(b);
      let dataHash = await Primitive.Bytes.read(b);
      let secret = await Primitive.Bytes.read(b);
      return new Raw.SecureData({ data: data, dataHash: dataHash, secret: secret });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.data !== undefined) {
        b.write(Primitive.Bytes.write(this.data) as unknown as Buffer);
      }
      if (this.dataHash !== undefined) {
        b.write(Primitive.Bytes.write(this.dataHash) as unknown as Buffer);
      }
      if (this.secret !== undefined) {
        b.write(Primitive.Bytes.write(this.secret) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecurePlainPhone extends TLObject {
    phone!: string;

    constructor(params: { phone: string }) {
      super();
      this.classType = 'types';
      this.className = 'SecurePlainPhone';
      this.constructorId = 0x7d6099dd;
      this.subclassOfId = 0x23b2afb6;
      this._slots = ['phone'];
      this.phone = params.phone;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecurePlainPhone> {
      // no flags

      let phone = await Primitive.String.read(b);
      return new Raw.SecurePlainPhone({ phone: phone });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.phone !== undefined) {
        b.write(Primitive.String.write(this.phone) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecurePlainEmail extends TLObject {
    email!: string;

    constructor(params: { email: string }) {
      super();
      this.classType = 'types';
      this.className = 'SecurePlainEmail';
      this.constructorId = 0x21ec5a5f;
      this.subclassOfId = 0x23b2afb6;
      this._slots = ['email'];
      this.email = params.email;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecurePlainEmail> {
      // no flags

      let email = await Primitive.String.read(b);
      return new Raw.SecurePlainEmail({ email: email });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.email !== undefined) {
        b.write(Primitive.String.write(this.email) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureValueTypePersonalDetails extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypePersonalDetails';
      this.constructorId = 0x9d2a81e3;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SecureValueTypePersonalDetails> {
      // no flags

      return new Raw.SecureValueTypePersonalDetails();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValueTypePassport extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypePassport';
      this.constructorId = 0x3dac6a00;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueTypePassport> {
      // no flags

      return new Raw.SecureValueTypePassport();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValueTypeDriverLicense extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypeDriverLicense';
      this.constructorId = 0x6e425c4;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueTypeDriverLicense> {
      // no flags

      return new Raw.SecureValueTypeDriverLicense();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValueTypeIdentityCard extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypeIdentityCard';
      this.constructorId = 0xa0d0744b;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueTypeIdentityCard> {
      // no flags

      return new Raw.SecureValueTypeIdentityCard();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValueTypeInternalPassport extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypeInternalPassport';
      this.constructorId = 0x99a48f23;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SecureValueTypeInternalPassport> {
      // no flags

      return new Raw.SecureValueTypeInternalPassport();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValueTypeAddress extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypeAddress';
      this.constructorId = 0xcbe31e26;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueTypeAddress> {
      // no flags

      return new Raw.SecureValueTypeAddress();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValueTypeUtilityBill extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypeUtilityBill';
      this.constructorId = 0xfc36954e;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueTypeUtilityBill> {
      // no flags

      return new Raw.SecureValueTypeUtilityBill();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValueTypeBankStatement extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypeBankStatement';
      this.constructorId = 0x89137c0d;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueTypeBankStatement> {
      // no flags

      return new Raw.SecureValueTypeBankStatement();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValueTypeRentalAgreement extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypeRentalAgreement';
      this.constructorId = 0x8b883488;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SecureValueTypeRentalAgreement> {
      // no flags

      return new Raw.SecureValueTypeRentalAgreement();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValueTypePassportRegistration extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypePassportRegistration';
      this.constructorId = 0x99e3806a;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SecureValueTypePassportRegistration> {
      // no flags

      return new Raw.SecureValueTypePassportRegistration();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValueTypeTemporaryRegistration extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypeTemporaryRegistration';
      this.constructorId = 0xea02ec33;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SecureValueTypeTemporaryRegistration> {
      // no flags

      return new Raw.SecureValueTypeTemporaryRegistration();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValueTypePhone extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypePhone';
      this.constructorId = 0xb320aadb;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueTypePhone> {
      // no flags

      return new Raw.SecureValueTypePhone();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValueTypeEmail extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecureValueTypeEmail';
      this.constructorId = 0x8e3ca7ee;
      this.subclassOfId = 0x8893f596;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueTypeEmail> {
      // no flags

      return new Raw.SecureValueTypeEmail();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecureValue extends TLObject {
    type!: Raw.TypeSecureValueType;
    data?: Raw.TypeSecureData;
    frontSide?: Raw.TypeSecureFile;
    reverseSide?: Raw.TypeSecureFile;
    selfie?: Raw.TypeSecureFile;
    translation?: Vector<Raw.TypeSecureFile>;
    files?: Vector<Raw.TypeSecureFile>;
    plainData?: Raw.TypeSecurePlainData;
    hash!: bytes;

    constructor(params: {
      type: Raw.TypeSecureValueType;
      data?: Raw.TypeSecureData;
      frontSide?: Raw.TypeSecureFile;
      reverseSide?: Raw.TypeSecureFile;
      selfie?: Raw.TypeSecureFile;
      translation?: Vector<Raw.TypeSecureFile>;
      files?: Vector<Raw.TypeSecureFile>;
      plainData?: Raw.TypeSecurePlainData;
      hash: bytes;
    }) {
      super();
      this.classType = 'types';
      this.className = 'SecureValue';
      this.constructorId = 0x187fa0ca;
      this.subclassOfId = 0x51138ae;
      this._slots = [
        'type',
        'data',
        'frontSide',
        'reverseSide',
        'selfie',
        'translation',
        'files',
        'plainData',
        'hash',
      ];
      this.type = params.type;
      this.data = params.data;
      this.frontSide = params.frontSide;
      this.reverseSide = params.reverseSide;
      this.selfie = params.selfie;
      this.translation = params.translation;
      this.files = params.files;
      this.plainData = params.plainData;
      this.hash = params.hash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValue> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let type = await TLObject.read(b);
      let data = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let frontSide = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let reverseSide = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      let selfie = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      let translation = flags & (1 << 6) ? await TLObject.read(b) : [];
      let files = flags & (1 << 4) ? await TLObject.read(b) : [];
      let plainData = flags & (1 << 5) ? await TLObject.read(b) : undefined;
      let hash = await Primitive.Bytes.read(b);
      return new Raw.SecureValue({
        type: type,
        data: data,
        frontSide: frontSide,
        reverseSide: reverseSide,
        selfie: selfie,
        translation: translation,
        files: files,
        plainData: plainData,
        hash: hash,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.data !== undefined ? 1 << 0 : 0;
      flags |= this.frontSide !== undefined ? 1 << 1 : 0;
      flags |= this.reverseSide !== undefined ? 1 << 2 : 0;
      flags |= this.selfie !== undefined ? 1 << 3 : 0;
      flags |= this.translation ? 1 << 6 : 0;
      flags |= this.files ? 1 << 4 : 0;
      flags |= this.plainData !== undefined ? 1 << 5 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      if (this.data !== undefined) {
        b.write(this.data.write() as unknown as Buffer);
      }
      if (this.frontSide !== undefined) {
        b.write(this.frontSide.write() as unknown as Buffer);
      }
      if (this.reverseSide !== undefined) {
        b.write(this.reverseSide.write() as unknown as Buffer);
      }
      if (this.selfie !== undefined) {
        b.write(this.selfie.write() as unknown as Buffer);
      }
      if (this.translation) {
        b.write(Primitive.Vector.write(this.translation) as unknown as Buffer);
      }
      if (this.files) {
        b.write(Primitive.Vector.write(this.files) as unknown as Buffer);
      }
      if (this.plainData !== undefined) {
        b.write(this.plainData.write() as unknown as Buffer);
      }
      if (this.hash !== undefined) {
        b.write(Primitive.Bytes.write(this.hash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputSecureValue extends TLObject {
    type!: Raw.TypeSecureValueType;
    data?: Raw.TypeSecureData;
    frontSide?: Raw.TypeInputSecureFile;
    reverseSide?: Raw.TypeInputSecureFile;
    selfie?: Raw.TypeInputSecureFile;
    translation?: Vector<Raw.TypeInputSecureFile>;
    files?: Vector<Raw.TypeInputSecureFile>;
    plainData?: Raw.TypeSecurePlainData;

    constructor(params: {
      type: Raw.TypeSecureValueType;
      data?: Raw.TypeSecureData;
      frontSide?: Raw.TypeInputSecureFile;
      reverseSide?: Raw.TypeInputSecureFile;
      selfie?: Raw.TypeInputSecureFile;
      translation?: Vector<Raw.TypeInputSecureFile>;
      files?: Vector<Raw.TypeInputSecureFile>;
      plainData?: Raw.TypeSecurePlainData;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputSecureValue';
      this.constructorId = 0xdb21d0a7;
      this.subclassOfId = 0xb49da1fc;
      this._slots = [
        'type',
        'data',
        'frontSide',
        'reverseSide',
        'selfie',
        'translation',
        'files',
        'plainData',
      ];
      this.type = params.type;
      this.data = params.data;
      this.frontSide = params.frontSide;
      this.reverseSide = params.reverseSide;
      this.selfie = params.selfie;
      this.translation = params.translation;
      this.files = params.files;
      this.plainData = params.plainData;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputSecureValue> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let type = await TLObject.read(b);
      let data = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let frontSide = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let reverseSide = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      let selfie = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      let translation = flags & (1 << 6) ? await TLObject.read(b) : [];
      let files = flags & (1 << 4) ? await TLObject.read(b) : [];
      let plainData = flags & (1 << 5) ? await TLObject.read(b) : undefined;
      return new Raw.InputSecureValue({
        type: type,
        data: data,
        frontSide: frontSide,
        reverseSide: reverseSide,
        selfie: selfie,
        translation: translation,
        files: files,
        plainData: plainData,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.data !== undefined ? 1 << 0 : 0;
      flags |= this.frontSide !== undefined ? 1 << 1 : 0;
      flags |= this.reverseSide !== undefined ? 1 << 2 : 0;
      flags |= this.selfie !== undefined ? 1 << 3 : 0;
      flags |= this.translation ? 1 << 6 : 0;
      flags |= this.files ? 1 << 4 : 0;
      flags |= this.plainData !== undefined ? 1 << 5 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      if (this.data !== undefined) {
        b.write(this.data.write() as unknown as Buffer);
      }
      if (this.frontSide !== undefined) {
        b.write(this.frontSide.write() as unknown as Buffer);
      }
      if (this.reverseSide !== undefined) {
        b.write(this.reverseSide.write() as unknown as Buffer);
      }
      if (this.selfie !== undefined) {
        b.write(this.selfie.write() as unknown as Buffer);
      }
      if (this.translation) {
        b.write(Primitive.Vector.write(this.translation) as unknown as Buffer);
      }
      if (this.files) {
        b.write(Primitive.Vector.write(this.files) as unknown as Buffer);
      }
      if (this.plainData !== undefined) {
        b.write(this.plainData.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureValueHash extends TLObject {
    type!: Raw.TypeSecureValueType;
    hash!: bytes;

    constructor(params: { type: Raw.TypeSecureValueType; hash: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'SecureValueHash';
      this.constructorId = 0xed1ecdb0;
      this.subclassOfId = 0xd5f5c007;
      this._slots = ['type', 'hash'];
      this.type = params.type;
      this.hash = params.hash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueHash> {
      // no flags

      let type = await TLObject.read(b);
      let hash = await Primitive.Bytes.read(b);
      return new Raw.SecureValueHash({ type: type, hash: hash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      if (this.hash !== undefined) {
        b.write(Primitive.Bytes.write(this.hash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureValueErrorData extends TLObject {
    type!: Raw.TypeSecureValueType;
    dataHash!: bytes;
    field!: string;
    text!: string;

    constructor(params: {
      type: Raw.TypeSecureValueType;
      dataHash: bytes;
      field: string;
      text: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'SecureValueErrorData';
      this.constructorId = 0xe8a40bd9;
      this.subclassOfId = 0x6075fce;
      this._slots = ['type', 'dataHash', 'field', 'text'];
      this.type = params.type;
      this.dataHash = params.dataHash;
      this.field = params.field;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueErrorData> {
      // no flags

      let type = await TLObject.read(b);
      let dataHash = await Primitive.Bytes.read(b);
      let field = await Primitive.String.read(b);
      let text = await Primitive.String.read(b);
      return new Raw.SecureValueErrorData({
        type: type,
        dataHash: dataHash,
        field: field,
        text: text,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      if (this.dataHash !== undefined) {
        b.write(Primitive.Bytes.write(this.dataHash) as unknown as Buffer);
      }
      if (this.field !== undefined) {
        b.write(Primitive.String.write(this.field) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureValueErrorFrontSide extends TLObject {
    type!: Raw.TypeSecureValueType;
    fileHash!: bytes;
    text!: string;

    constructor(params: { type: Raw.TypeSecureValueType; fileHash: bytes; text: string }) {
      super();
      this.classType = 'types';
      this.className = 'SecureValueErrorFrontSide';
      this.constructorId = 0xbe3dfa;
      this.subclassOfId = 0x6075fce;
      this._slots = ['type', 'fileHash', 'text'];
      this.type = params.type;
      this.fileHash = params.fileHash;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueErrorFrontSide> {
      // no flags

      let type = await TLObject.read(b);
      let fileHash = await Primitive.Bytes.read(b);
      let text = await Primitive.String.read(b);
      return new Raw.SecureValueErrorFrontSide({ type: type, fileHash: fileHash, text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      if (this.fileHash !== undefined) {
        b.write(Primitive.Bytes.write(this.fileHash) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureValueErrorReverseSide extends TLObject {
    type!: Raw.TypeSecureValueType;
    fileHash!: bytes;
    text!: string;

    constructor(params: { type: Raw.TypeSecureValueType; fileHash: bytes; text: string }) {
      super();
      this.classType = 'types';
      this.className = 'SecureValueErrorReverseSide';
      this.constructorId = 0x868a2aa5;
      this.subclassOfId = 0x6075fce;
      this._slots = ['type', 'fileHash', 'text'];
      this.type = params.type;
      this.fileHash = params.fileHash;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueErrorReverseSide> {
      // no flags

      let type = await TLObject.read(b);
      let fileHash = await Primitive.Bytes.read(b);
      let text = await Primitive.String.read(b);
      return new Raw.SecureValueErrorReverseSide({ type: type, fileHash: fileHash, text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      if (this.fileHash !== undefined) {
        b.write(Primitive.Bytes.write(this.fileHash) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureValueErrorSelfie extends TLObject {
    type!: Raw.TypeSecureValueType;
    fileHash!: bytes;
    text!: string;

    constructor(params: { type: Raw.TypeSecureValueType; fileHash: bytes; text: string }) {
      super();
      this.classType = 'types';
      this.className = 'SecureValueErrorSelfie';
      this.constructorId = 0xe537ced6;
      this.subclassOfId = 0x6075fce;
      this._slots = ['type', 'fileHash', 'text'];
      this.type = params.type;
      this.fileHash = params.fileHash;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueErrorSelfie> {
      // no flags

      let type = await TLObject.read(b);
      let fileHash = await Primitive.Bytes.read(b);
      let text = await Primitive.String.read(b);
      return new Raw.SecureValueErrorSelfie({ type: type, fileHash: fileHash, text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      if (this.fileHash !== undefined) {
        b.write(Primitive.Bytes.write(this.fileHash) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureValueErrorFile extends TLObject {
    type!: Raw.TypeSecureValueType;
    fileHash!: bytes;
    text!: string;

    constructor(params: { type: Raw.TypeSecureValueType; fileHash: bytes; text: string }) {
      super();
      this.classType = 'types';
      this.className = 'SecureValueErrorFile';
      this.constructorId = 0x7a700873;
      this.subclassOfId = 0x6075fce;
      this._slots = ['type', 'fileHash', 'text'];
      this.type = params.type;
      this.fileHash = params.fileHash;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueErrorFile> {
      // no flags

      let type = await TLObject.read(b);
      let fileHash = await Primitive.Bytes.read(b);
      let text = await Primitive.String.read(b);
      return new Raw.SecureValueErrorFile({ type: type, fileHash: fileHash, text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      if (this.fileHash !== undefined) {
        b.write(Primitive.Bytes.write(this.fileHash) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureValueErrorFiles extends TLObject {
    type!: Raw.TypeSecureValueType;
    fileHash!: Vector<bytes>;
    text!: string;

    constructor(params: { type: Raw.TypeSecureValueType; fileHash: Vector<bytes>; text: string }) {
      super();
      this.classType = 'types';
      this.className = 'SecureValueErrorFiles';
      this.constructorId = 0x666220e9;
      this.subclassOfId = 0x6075fce;
      this._slots = ['type', 'fileHash', 'text'];
      this.type = params.type;
      this.fileHash = params.fileHash;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueErrorFiles> {
      // no flags

      let type = await TLObject.read(b);
      let fileHash = await TLObject.read(b, Primitive.Bytes);
      let text = await Primitive.String.read(b);
      return new Raw.SecureValueErrorFiles({ type: type, fileHash: fileHash, text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      if (this.fileHash) {
        b.write(Primitive.Vector.write(this.fileHash, Primitive.Bytes) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureValueError extends TLObject {
    type!: Raw.TypeSecureValueType;
    hash!: bytes;
    text!: string;

    constructor(params: { type: Raw.TypeSecureValueType; hash: bytes; text: string }) {
      super();
      this.classType = 'types';
      this.className = 'SecureValueError';
      this.constructorId = 0x869d758f;
      this.subclassOfId = 0x6075fce;
      this._slots = ['type', 'hash', 'text'];
      this.type = params.type;
      this.hash = params.hash;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureValueError> {
      // no flags

      let type = await TLObject.read(b);
      let hash = await Primitive.Bytes.read(b);
      let text = await Primitive.String.read(b);
      return new Raw.SecureValueError({ type: type, hash: hash, text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      if (this.hash !== undefined) {
        b.write(Primitive.Bytes.write(this.hash) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureValueErrorTranslationFile extends TLObject {
    type!: Raw.TypeSecureValueType;
    fileHash!: bytes;
    text!: string;

    constructor(params: { type: Raw.TypeSecureValueType; fileHash: bytes; text: string }) {
      super();
      this.classType = 'types';
      this.className = 'SecureValueErrorTranslationFile';
      this.constructorId = 0xa1144770;
      this.subclassOfId = 0x6075fce;
      this._slots = ['type', 'fileHash', 'text'];
      this.type = params.type;
      this.fileHash = params.fileHash;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SecureValueErrorTranslationFile> {
      // no flags

      let type = await TLObject.read(b);
      let fileHash = await Primitive.Bytes.read(b);
      let text = await Primitive.String.read(b);
      return new Raw.SecureValueErrorTranslationFile({
        type: type,
        fileHash: fileHash,
        text: text,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      if (this.fileHash !== undefined) {
        b.write(Primitive.Bytes.write(this.fileHash) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureValueErrorTranslationFiles extends TLObject {
    type!: Raw.TypeSecureValueType;
    fileHash!: Vector<bytes>;
    text!: string;

    constructor(params: { type: Raw.TypeSecureValueType; fileHash: Vector<bytes>; text: string }) {
      super();
      this.classType = 'types';
      this.className = 'SecureValueErrorTranslationFiles';
      this.constructorId = 0x34636dd8;
      this.subclassOfId = 0x6075fce;
      this._slots = ['type', 'fileHash', 'text'];
      this.type = params.type;
      this.fileHash = params.fileHash;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SecureValueErrorTranslationFiles> {
      // no flags

      let type = await TLObject.read(b);
      let fileHash = await TLObject.read(b, Primitive.Bytes);
      let text = await Primitive.String.read(b);
      return new Raw.SecureValueErrorTranslationFiles({
        type: type,
        fileHash: fileHash,
        text: text,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      if (this.fileHash) {
        b.write(Primitive.Vector.write(this.fileHash, Primitive.Bytes) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureCredentialsEncrypted extends TLObject {
    data!: bytes;
    hash!: bytes;
    secret!: bytes;

    constructor(params: { data: bytes; hash: bytes; secret: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'SecureCredentialsEncrypted';
      this.constructorId = 0x33f0ea47;
      this.subclassOfId = 0x94dc7633;
      this._slots = ['data', 'hash', 'secret'];
      this.data = params.data;
      this.hash = params.hash;
      this.secret = params.secret;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureCredentialsEncrypted> {
      // no flags

      let data = await Primitive.Bytes.read(b);
      let hash = await Primitive.Bytes.read(b);
      let secret = await Primitive.Bytes.read(b);
      return new Raw.SecureCredentialsEncrypted({ data: data, hash: hash, secret: secret });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.data !== undefined) {
        b.write(Primitive.Bytes.write(this.data) as unknown as Buffer);
      }
      if (this.hash !== undefined) {
        b.write(Primitive.Bytes.write(this.hash) as unknown as Buffer);
      }
      if (this.secret !== undefined) {
        b.write(Primitive.Bytes.write(this.secret) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SavedPhoneContact extends TLObject {
    phone!: string;
    firstName!: string;
    lastName!: string;
    date!: int;

    constructor(params: { phone: string; firstName: string; lastName: string; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'SavedPhoneContact';
      this.constructorId = 0x1142bd56;
      this.subclassOfId = 0x6db98c4;
      this._slots = ['phone', 'firstName', 'lastName', 'date'];
      this.phone = params.phone;
      this.firstName = params.firstName;
      this.lastName = params.lastName;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SavedPhoneContact> {
      // no flags

      let phone = await Primitive.String.read(b);
      let firstName = await Primitive.String.read(b);
      let lastName = await Primitive.String.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.SavedPhoneContact({
        phone: phone,
        firstName: firstName,
        lastName: lastName,
        date: date,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.phone !== undefined) {
        b.write(Primitive.String.write(this.phone) as unknown as Buffer);
      }
      if (this.firstName !== undefined) {
        b.write(Primitive.String.write(this.firstName) as unknown as Buffer);
      }
      if (this.lastName !== undefined) {
        b.write(Primitive.String.write(this.lastName) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PasswordKdfAlgoUnknown extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'PasswordKdfAlgoUnknown';
      this.constructorId = 0xd45ab096;
      this.subclassOfId = 0x37bcf5cc;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PasswordKdfAlgoUnknown> {
      // no flags

      return new Raw.PasswordKdfAlgoUnknown();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class PasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow extends TLObject {
    salt1!: bytes;
    salt2!: bytes;
    g!: int;
    p!: bytes;

    constructor(params: { salt1: bytes; salt2: bytes; g: int; p: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'PasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow';
      this.constructorId = 0x3a912d4a;
      this.subclassOfId = 0x37bcf5cc;
      this._slots = ['salt1', 'salt2', 'g', 'p'];
      this.salt1 = params.salt1;
      this.salt2 = params.salt2;
      this.g = params.g;
      this.p = params.p;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.PasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow> {
      // no flags

      let salt1 = await Primitive.Bytes.read(b);
      let salt2 = await Primitive.Bytes.read(b);
      let g = await Primitive.Int.read(b);
      let p = await Primitive.Bytes.read(b);
      return new Raw.PasswordKdfAlgoSHA256SHA256PBKDF2HMACSHA512iter100000SHA256ModPow({
        salt1: salt1,
        salt2: salt2,
        g: g,
        p: p,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.salt1 !== undefined) {
        b.write(Primitive.Bytes.write(this.salt1) as unknown as Buffer);
      }
      if (this.salt2 !== undefined) {
        b.write(Primitive.Bytes.write(this.salt2) as unknown as Buffer);
      }
      if (this.g !== undefined) {
        b.write(Primitive.Int.write(this.g) as unknown as Buffer);
      }
      if (this.p !== undefined) {
        b.write(Primitive.Bytes.write(this.p) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecurePasswordKdfAlgoUnknown extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SecurePasswordKdfAlgoUnknown';
      this.constructorId = 0x4a8537;
      this.subclassOfId = 0x77262943;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecurePasswordKdfAlgoUnknown> {
      // no flags

      return new Raw.SecurePasswordKdfAlgoUnknown();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000 extends TLObject {
    salt!: bytes;

    constructor(params: { salt: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'SecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000';
      this.constructorId = 0xbbf2dda0;
      this.subclassOfId = 0x77262943;
      this._slots = ['salt'];
      this.salt = params.salt;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000> {
      // no flags

      let salt = await Primitive.Bytes.read(b);
      return new Raw.SecurePasswordKdfAlgoPBKDF2HMACSHA512iter100000({ salt: salt });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.salt !== undefined) {
        b.write(Primitive.Bytes.write(this.salt) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecurePasswordKdfAlgoSHA512 extends TLObject {
    salt!: bytes;

    constructor(params: { salt: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'SecurePasswordKdfAlgoSHA512';
      this.constructorId = 0x86471d92;
      this.subclassOfId = 0x77262943;
      this._slots = ['salt'];
      this.salt = params.salt;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecurePasswordKdfAlgoSHA512> {
      // no flags

      let salt = await Primitive.Bytes.read(b);
      return new Raw.SecurePasswordKdfAlgoSHA512({ salt: salt });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.salt !== undefined) {
        b.write(Primitive.Bytes.write(this.salt) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureSecretSettings extends TLObject {
    secureAlgo!: Raw.TypeSecurePasswordKdfAlgo;
    secureSecret!: bytes;
    secureSecretId!: long;

    constructor(params: {
      secureAlgo: Raw.TypeSecurePasswordKdfAlgo;
      secureSecret: bytes;
      secureSecretId: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'SecureSecretSettings';
      this.constructorId = 0x1527bcac;
      this.subclassOfId = 0xc6c802fb;
      this._slots = ['secureAlgo', 'secureSecret', 'secureSecretId'];
      this.secureAlgo = params.secureAlgo;
      this.secureSecret = params.secureSecret;
      this.secureSecretId = params.secureSecretId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureSecretSettings> {
      // no flags

      let secureAlgo = await TLObject.read(b);
      let secureSecret = await Primitive.Bytes.read(b);
      let secureSecretId = await Primitive.Long.read(b);
      return new Raw.SecureSecretSettings({
        secureAlgo: secureAlgo,
        secureSecret: secureSecret,
        secureSecretId: secureSecretId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.secureAlgo !== undefined) {
        b.write(this.secureAlgo.write() as unknown as Buffer);
      }
      if (this.secureSecret !== undefined) {
        b.write(Primitive.Bytes.write(this.secureSecret) as unknown as Buffer);
      }
      if (this.secureSecretId !== undefined) {
        b.write(Primitive.Long.write(this.secureSecretId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputCheckPasswordEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InputCheckPasswordEmpty';
      this.constructorId = 0x9880f658;
      this.subclassOfId = 0xd41af560;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputCheckPasswordEmpty> {
      // no flags

      return new Raw.InputCheckPasswordEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputCheckPasswordSRP extends TLObject {
    srpId!: long;
    a!: bytes;
    m1!: bytes;

    constructor(params: { srpId: long; a: bytes; m1: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'InputCheckPasswordSRP';
      this.constructorId = 0xd27ff082;
      this.subclassOfId = 0xd41af560;
      this._slots = ['srpId', 'a', 'm1'];
      this.srpId = params.srpId;
      this.a = params.a;
      this.m1 = params.m1;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputCheckPasswordSRP> {
      // no flags

      let srpId = await Primitive.Long.read(b);
      let a = await Primitive.Bytes.read(b);
      let m1 = await Primitive.Bytes.read(b);
      return new Raw.InputCheckPasswordSRP({ srpId: srpId, a: a, m1: m1 });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.srpId !== undefined) {
        b.write(Primitive.Long.write(this.srpId) as unknown as Buffer);
      }
      if (this.a !== undefined) {
        b.write(Primitive.Bytes.write(this.a) as unknown as Buffer);
      }
      if (this.m1 !== undefined) {
        b.write(Primitive.Bytes.write(this.m1) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureRequiredType extends TLObject {
    nativeNames?: boolean;
    selfieRequired?: boolean;
    translationRequired?: boolean;
    type!: Raw.TypeSecureValueType;

    constructor(params: {
      nativeNames?: boolean;
      selfieRequired?: boolean;
      translationRequired?: boolean;
      type: Raw.TypeSecureValueType;
    }) {
      super();
      this.classType = 'types';
      this.className = 'SecureRequiredType';
      this.constructorId = 0x829d99da;
      this.subclassOfId = 0x7c7b420a;
      this._slots = ['nativeNames', 'selfieRequired', 'translationRequired', 'type'];
      this.nativeNames = params.nativeNames;
      this.selfieRequired = params.selfieRequired;
      this.translationRequired = params.translationRequired;
      this.type = params.type;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureRequiredType> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let nativeNames = flags & (1 << 0) ? true : false;
      let selfieRequired = flags & (1 << 1) ? true : false;
      let translationRequired = flags & (1 << 2) ? true : false;
      let type = await TLObject.read(b);
      return new Raw.SecureRequiredType({
        nativeNames: nativeNames,
        selfieRequired: selfieRequired,
        translationRequired: translationRequired,
        type: type,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.nativeNames ? 1 << 0 : 0;
      flags |= this.selfieRequired ? 1 << 1 : 0;
      flags |= this.translationRequired ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.type !== undefined) {
        b.write(this.type.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SecureRequiredTypeOneOf extends TLObject {
    types!: Vector<Raw.TypeSecureRequiredType>;

    constructor(params: { types: Vector<Raw.TypeSecureRequiredType> }) {
      super();
      this.classType = 'types';
      this.className = 'SecureRequiredTypeOneOf';
      this.constructorId = 0x27477b4;
      this.subclassOfId = 0x7c7b420a;
      this._slots = ['types'];
      this.types = params.types;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SecureRequiredTypeOneOf> {
      // no flags

      let types = await TLObject.read(b);
      return new Raw.SecureRequiredTypeOneOf({ types: types });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.types) {
        b.write(Primitive.Vector.write(this.types) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputAppEvent extends TLObject {
    time!: double;
    type!: string;
    peer!: long;
    data!: Raw.TypeJSONValue;

    constructor(params: { time: double; type: string; peer: long; data: Raw.TypeJSONValue }) {
      super();
      this.classType = 'types';
      this.className = 'InputAppEvent';
      this.constructorId = 0x1d1b1245;
      this.subclassOfId = 0x89322106;
      this._slots = ['time', 'type', 'peer', 'data'];
      this.time = params.time;
      this.type = params.type;
      this.peer = params.peer;
      this.data = params.data;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputAppEvent> {
      // no flags

      let time = await Primitive.Double.read(b);
      let type = await Primitive.String.read(b);
      let peer = await Primitive.Long.read(b);
      let data = await TLObject.read(b);
      return new Raw.InputAppEvent({ time: time, type: type, peer: peer, data: data });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.time !== undefined) {
        b.write(Primitive.Double.write(this.time) as unknown as Buffer);
      }
      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.peer !== undefined) {
        b.write(Primitive.Long.write(this.peer) as unknown as Buffer);
      }
      if (this.data !== undefined) {
        b.write(this.data.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class JsonObjectValue extends TLObject {
    key!: string;
    value!: Raw.TypeJSONValue;

    constructor(params: { key: string; value: Raw.TypeJSONValue }) {
      super();
      this.classType = 'types';
      this.className = 'JsonObjectValue';
      this.constructorId = 0xc0de1bd9;
      this.subclassOfId = 0x937fceb9;
      this._slots = ['key', 'value'];
      this.key = params.key;
      this.value = params.value;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.JsonObjectValue> {
      // no flags

      let key = await Primitive.String.read(b);
      let value = await TLObject.read(b);
      return new Raw.JsonObjectValue({ key: key, value: value });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.key !== undefined) {
        b.write(Primitive.String.write(this.key) as unknown as Buffer);
      }
      if (this.value !== undefined) {
        b.write(this.value.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class JsonNull extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'JsonNull';
      this.constructorId = 0x3f6d7b68;
      this.subclassOfId = 0xeb9987b3;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.JsonNull> {
      // no flags

      return new Raw.JsonNull();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class JsonBool extends TLObject {
    value!: Bool;

    constructor(params: { value: Bool }) {
      super();
      this.classType = 'types';
      this.className = 'JsonBool';
      this.constructorId = 0xc7345e6a;
      this.subclassOfId = 0xeb9987b3;
      this._slots = ['value'];
      this.value = params.value;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.JsonBool> {
      // no flags

      let value = await Primitive.Bool.read(b);
      return new Raw.JsonBool({ value: value });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.value !== undefined) {
        b.write(Primitive.Bool.write(this.value) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class JsonNumber extends TLObject {
    value!: double;

    constructor(params: { value: double }) {
      super();
      this.classType = 'types';
      this.className = 'JsonNumber';
      this.constructorId = 0x2be0dfa4;
      this.subclassOfId = 0xeb9987b3;
      this._slots = ['value'];
      this.value = params.value;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.JsonNumber> {
      // no flags

      let value = await Primitive.Double.read(b);
      return new Raw.JsonNumber({ value: value });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.value !== undefined) {
        b.write(Primitive.Double.write(this.value) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class JsonString extends TLObject {
    value!: string;

    constructor(params: { value: string }) {
      super();
      this.classType = 'types';
      this.className = 'JsonString';
      this.constructorId = 0xb71e767a;
      this.subclassOfId = 0xeb9987b3;
      this._slots = ['value'];
      this.value = params.value;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.JsonString> {
      // no flags

      let value = await Primitive.String.read(b);
      return new Raw.JsonString({ value: value });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.value !== undefined) {
        b.write(Primitive.String.write(this.value) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class JsonArray extends TLObject {
    value!: Vector<Raw.TypeJSONValue>;

    constructor(params: { value: Vector<Raw.TypeJSONValue> }) {
      super();
      this.classType = 'types';
      this.className = 'JsonArray';
      this.constructorId = 0xf7444763;
      this.subclassOfId = 0xeb9987b3;
      this._slots = ['value'];
      this.value = params.value;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.JsonArray> {
      // no flags

      let value = await TLObject.read(b);
      return new Raw.JsonArray({ value: value });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.value) {
        b.write(Primitive.Vector.write(this.value) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class JsonObject extends TLObject {
    value!: Vector<Raw.TypeJSONObjectValue>;

    constructor(params: { value: Vector<Raw.TypeJSONObjectValue> }) {
      super();
      this.classType = 'types';
      this.className = 'JsonObject';
      this.constructorId = 0x99c1d49d;
      this.subclassOfId = 0xeb9987b3;
      this._slots = ['value'];
      this.value = params.value;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.JsonObject> {
      // no flags

      let value = await TLObject.read(b);
      return new Raw.JsonObject({ value: value });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.value) {
        b.write(Primitive.Vector.write(this.value) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageTableCell extends TLObject {
    header?: boolean;
    alignCenter?: boolean;
    alignRight?: boolean;
    valignMiddle?: boolean;
    valignBottom?: boolean;
    text?: Raw.TypeRichText;
    colspan?: int;
    rowspan?: int;

    constructor(params: {
      header?: boolean;
      alignCenter?: boolean;
      alignRight?: boolean;
      valignMiddle?: boolean;
      valignBottom?: boolean;
      text?: Raw.TypeRichText;
      colspan?: int;
      rowspan?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PageTableCell';
      this.constructorId = 0x34566b6a;
      this.subclassOfId = 0xb0eb3054;
      this._slots = [
        'header',
        'alignCenter',
        'alignRight',
        'valignMiddle',
        'valignBottom',
        'text',
        'colspan',
        'rowspan',
      ];
      this.header = params.header;
      this.alignCenter = params.alignCenter;
      this.alignRight = params.alignRight;
      this.valignMiddle = params.valignMiddle;
      this.valignBottom = params.valignBottom;
      this.text = params.text;
      this.colspan = params.colspan;
      this.rowspan = params.rowspan;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageTableCell> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let header = flags & (1 << 0) ? true : false;
      let alignCenter = flags & (1 << 3) ? true : false;
      let alignRight = flags & (1 << 4) ? true : false;
      let valignMiddle = flags & (1 << 5) ? true : false;
      let valignBottom = flags & (1 << 6) ? true : false;
      let text = flags & (1 << 7) ? await TLObject.read(b) : undefined;
      let colspan = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      let rowspan = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      return new Raw.PageTableCell({
        header: header,
        alignCenter: alignCenter,
        alignRight: alignRight,
        valignMiddle: valignMiddle,
        valignBottom: valignBottom,
        text: text,
        colspan: colspan,
        rowspan: rowspan,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.header ? 1 << 0 : 0;
      flags |= this.alignCenter ? 1 << 3 : 0;
      flags |= this.alignRight ? 1 << 4 : 0;
      flags |= this.valignMiddle ? 1 << 5 : 0;
      flags |= this.valignBottom ? 1 << 6 : 0;
      flags |= this.text !== undefined ? 1 << 7 : 0;
      flags |= this.colspan !== undefined ? 1 << 1 : 0;
      flags |= this.rowspan !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      if (this.colspan !== undefined) {
        b.write(Primitive.Int.write(this.colspan) as unknown as Buffer);
      }
      if (this.rowspan !== undefined) {
        b.write(Primitive.Int.write(this.rowspan) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageTableRow extends TLObject {
    cells!: Vector<Raw.TypePageTableCell>;

    constructor(params: { cells: Vector<Raw.TypePageTableCell> }) {
      super();
      this.classType = 'types';
      this.className = 'PageTableRow';
      this.constructorId = 0xe0c0c5e5;
      this.subclassOfId = 0x59acee11;
      this._slots = ['cells'];
      this.cells = params.cells;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageTableRow> {
      // no flags

      let cells = await TLObject.read(b);
      return new Raw.PageTableRow({ cells: cells });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.cells) {
        b.write(Primitive.Vector.write(this.cells) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageCaption extends TLObject {
    text!: Raw.TypeRichText;
    credit!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText; credit: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'PageCaption';
      this.constructorId = 0x6f747657;
      this.subclassOfId = 0x29b8eeb3;
      this._slots = ['text', 'credit'];
      this.text = params.text;
      this.credit = params.credit;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageCaption> {
      // no flags

      let text = await TLObject.read(b);
      let credit = await TLObject.read(b);
      return new Raw.PageCaption({ text: text, credit: credit });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      if (this.credit !== undefined) {
        b.write(this.credit.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageListItemText extends TLObject {
    text!: Raw.TypeRichText;

    constructor(params: { text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'PageListItemText';
      this.constructorId = 0xb92fb6cd;
      this.subclassOfId = 0x8caebcb1;
      this._slots = ['text'];
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageListItemText> {
      // no flags

      let text = await TLObject.read(b);
      return new Raw.PageListItemText({ text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageListItemBlocks extends TLObject {
    blocks!: Vector<Raw.TypePageBlock>;

    constructor(params: { blocks: Vector<Raw.TypePageBlock> }) {
      super();
      this.classType = 'types';
      this.className = 'PageListItemBlocks';
      this.constructorId = 0x25e073fc;
      this.subclassOfId = 0x8caebcb1;
      this._slots = ['blocks'];
      this.blocks = params.blocks;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageListItemBlocks> {
      // no flags

      let blocks = await TLObject.read(b);
      return new Raw.PageListItemBlocks({ blocks: blocks });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.blocks) {
        b.write(Primitive.Vector.write(this.blocks) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageListOrderedItemText extends TLObject {
    num!: string;
    text!: Raw.TypeRichText;

    constructor(params: { num: string; text: Raw.TypeRichText }) {
      super();
      this.classType = 'types';
      this.className = 'PageListOrderedItemText';
      this.constructorId = 0x5e068047;
      this.subclassOfId = 0xeeda0eb8;
      this._slots = ['num', 'text'];
      this.num = params.num;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageListOrderedItemText> {
      // no flags

      let num = await Primitive.String.read(b);
      let text = await TLObject.read(b);
      return new Raw.PageListOrderedItemText({ num: num, text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.num !== undefined) {
        b.write(Primitive.String.write(this.num) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(this.text.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageListOrderedItemBlocks extends TLObject {
    num!: string;
    blocks!: Vector<Raw.TypePageBlock>;

    constructor(params: { num: string; blocks: Vector<Raw.TypePageBlock> }) {
      super();
      this.classType = 'types';
      this.className = 'PageListOrderedItemBlocks';
      this.constructorId = 0x98dd8936;
      this.subclassOfId = 0xeeda0eb8;
      this._slots = ['num', 'blocks'];
      this.num = params.num;
      this.blocks = params.blocks;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageListOrderedItemBlocks> {
      // no flags

      let num = await Primitive.String.read(b);
      let blocks = await TLObject.read(b);
      return new Raw.PageListOrderedItemBlocks({ num: num, blocks: blocks });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.num !== undefined) {
        b.write(Primitive.String.write(this.num) as unknown as Buffer);
      }
      if (this.blocks) {
        b.write(Primitive.Vector.write(this.blocks) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PageRelatedArticle extends TLObject {
    url!: string;
    webpageId!: long;
    title?: string;
    description?: string;
    photoId?: long;
    author?: string;
    publishedDate?: int;

    constructor(params: {
      url: string;
      webpageId: long;
      title?: string;
      description?: string;
      photoId?: long;
      author?: string;
      publishedDate?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PageRelatedArticle';
      this.constructorId = 0xb390dc08;
      this.subclassOfId = 0x36d05822;
      this._slots = [
        'url',
        'webpageId',
        'title',
        'description',
        'photoId',
        'author',
        'publishedDate',
      ];
      this.url = params.url;
      this.webpageId = params.webpageId;
      this.title = params.title;
      this.description = params.description;
      this.photoId = params.photoId;
      this.author = params.author;
      this.publishedDate = params.publishedDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PageRelatedArticle> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let url = await Primitive.String.read(b);
      let webpageId = await Primitive.Long.read(b);
      let title = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let description = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
      let photoId = flags & (1 << 2) ? await Primitive.Long.read(b) : undefined;
      let author = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
      let publishedDate = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      return new Raw.PageRelatedArticle({
        url: url,
        webpageId: webpageId,
        title: title,
        description: description,
        photoId: photoId,
        author: author,
        publishedDate: publishedDate,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.title !== undefined ? 1 << 0 : 0;
      flags |= this.description !== undefined ? 1 << 1 : 0;
      flags |= this.photoId !== undefined ? 1 << 2 : 0;
      flags |= this.author !== undefined ? 1 << 3 : 0;
      flags |= this.publishedDate !== undefined ? 1 << 4 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.webpageId !== undefined) {
        b.write(Primitive.Long.write(this.webpageId) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.photoId !== undefined) {
        b.write(Primitive.Long.write(this.photoId) as unknown as Buffer);
      }
      if (this.author !== undefined) {
        b.write(Primitive.String.write(this.author) as unknown as Buffer);
      }
      if (this.publishedDate !== undefined) {
        b.write(Primitive.Int.write(this.publishedDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Page extends TLObject {
    part?: boolean;
    rtl?: boolean;
    v2?: boolean;
    url!: string;
    blocks!: Vector<Raw.TypePageBlock>;
    photos!: Vector<Raw.TypePhoto>;
    documents!: Vector<Raw.TypeDocument>;
    views?: int;

    constructor(params: {
      part?: boolean;
      rtl?: boolean;
      v2?: boolean;
      url: string;
      blocks: Vector<Raw.TypePageBlock>;
      photos: Vector<Raw.TypePhoto>;
      documents: Vector<Raw.TypeDocument>;
      views?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Page';
      this.constructorId = 0x98657f0d;
      this.subclassOfId = 0xb438191e;
      this._slots = ['part', 'rtl', 'v2', 'url', 'blocks', 'photos', 'documents', 'views'];
      this.part = params.part;
      this.rtl = params.rtl;
      this.v2 = params.v2;
      this.url = params.url;
      this.blocks = params.blocks;
      this.photos = params.photos;
      this.documents = params.documents;
      this.views = params.views;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Page> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let part = flags & (1 << 0) ? true : false;
      let rtl = flags & (1 << 1) ? true : false;
      let v2 = flags & (1 << 2) ? true : false;
      let url = await Primitive.String.read(b);
      let blocks = await TLObject.read(b);
      let photos = await TLObject.read(b);
      let documents = await TLObject.read(b);
      let views = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
      return new Raw.Page({
        part: part,
        rtl: rtl,
        v2: v2,
        url: url,
        blocks: blocks,
        photos: photos,
        documents: documents,
        views: views,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.part ? 1 << 0 : 0;
      flags |= this.rtl ? 1 << 1 : 0;
      flags |= this.v2 ? 1 << 2 : 0;
      flags |= this.views !== undefined ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.blocks) {
        b.write(Primitive.Vector.write(this.blocks) as unknown as Buffer);
      }
      if (this.photos) {
        b.write(Primitive.Vector.write(this.photos) as unknown as Buffer);
      }
      if (this.documents) {
        b.write(Primitive.Vector.write(this.documents) as unknown as Buffer);
      }
      if (this.views !== undefined) {
        b.write(Primitive.Int.write(this.views) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PollAnswer extends TLObject {
    text!: string;
    option!: bytes;

    constructor(params: { text: string; option: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'PollAnswer';
      this.constructorId = 0x6ca9c2e9;
      this.subclassOfId = 0x7ea5dd9e;
      this._slots = ['text', 'option'];
      this.text = params.text;
      this.option = params.option;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PollAnswer> {
      // no flags

      let text = await Primitive.String.read(b);
      let option = await Primitive.Bytes.read(b);
      return new Raw.PollAnswer({ text: text, option: option });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.option !== undefined) {
        b.write(Primitive.Bytes.write(this.option) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Poll extends TLObject {
    id!: long;
    closed?: boolean;
    publicVoters?: boolean;
    multipleChoice?: boolean;
    quiz?: boolean;
    question!: string;
    answers!: Vector<Raw.TypePollAnswer>;
    closePeriod?: int;
    closeDate?: int;

    constructor(params: {
      id: long;
      closed?: boolean;
      publicVoters?: boolean;
      multipleChoice?: boolean;
      quiz?: boolean;
      question: string;
      answers: Vector<Raw.TypePollAnswer>;
      closePeriod?: int;
      closeDate?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Poll';
      this.constructorId = 0x86e18161;
      this.subclassOfId = 0x248e557b;
      this._slots = [
        'id',
        'closed',
        'publicVoters',
        'multipleChoice',
        'quiz',
        'question',
        'answers',
        'closePeriod',
        'closeDate',
      ];
      this.id = params.id;
      this.closed = params.closed;
      this.publicVoters = params.publicVoters;
      this.multipleChoice = params.multipleChoice;
      this.quiz = params.quiz;
      this.question = params.question;
      this.answers = params.answers;
      this.closePeriod = params.closePeriod;
      this.closeDate = params.closeDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Poll> {
      // no flags

      let id = await Primitive.Long.read(b);
      let flags = await Primitive.Int.read(b);

      let closed = flags & (1 << 0) ? true : false;
      let publicVoters = flags & (1 << 1) ? true : false;
      let multipleChoice = flags & (1 << 2) ? true : false;
      let quiz = flags & (1 << 3) ? true : false;
      let question = await Primitive.String.read(b);
      let answers = await TLObject.read(b);
      let closePeriod = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      let closeDate = flags & (1 << 5) ? await Primitive.Int.read(b) : undefined;
      return new Raw.Poll({
        id: id,
        closed: closed,
        publicVoters: publicVoters,
        multipleChoice: multipleChoice,
        quiz: quiz,
        question: question,
        answers: answers,
        closePeriod: closePeriod,
        closeDate: closeDate,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      let flags = 0;
      flags |= this.closed ? 1 << 0 : 0;
      flags |= this.publicVoters ? 1 << 1 : 0;
      flags |= this.multipleChoice ? 1 << 2 : 0;
      flags |= this.quiz ? 1 << 3 : 0;
      flags |= this.closePeriod !== undefined ? 1 << 4 : 0;
      flags |= this.closeDate !== undefined ? 1 << 5 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.question !== undefined) {
        b.write(Primitive.String.write(this.question) as unknown as Buffer);
      }
      if (this.answers) {
        b.write(Primitive.Vector.write(this.answers) as unknown as Buffer);
      }
      if (this.closePeriod !== undefined) {
        b.write(Primitive.Int.write(this.closePeriod) as unknown as Buffer);
      }
      if (this.closeDate !== undefined) {
        b.write(Primitive.Int.write(this.closeDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PollAnswerVoters extends TLObject {
    chosen?: boolean;
    correct?: boolean;
    option!: bytes;
    voters!: int;

    constructor(params: { chosen?: boolean; correct?: boolean; option: bytes; voters: int }) {
      super();
      this.classType = 'types';
      this.className = 'PollAnswerVoters';
      this.constructorId = 0x3b6ddad2;
      this.subclassOfId = 0x7ce0cf91;
      this._slots = ['chosen', 'correct', 'option', 'voters'];
      this.chosen = params.chosen;
      this.correct = params.correct;
      this.option = params.option;
      this.voters = params.voters;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PollAnswerVoters> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let chosen = flags & (1 << 0) ? true : false;
      let correct = flags & (1 << 1) ? true : false;
      let option = await Primitive.Bytes.read(b);
      let voters = await Primitive.Int.read(b);
      return new Raw.PollAnswerVoters({
        chosen: chosen,
        correct: correct,
        option: option,
        voters: voters,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.chosen ? 1 << 0 : 0;
      flags |= this.correct ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.option !== undefined) {
        b.write(Primitive.Bytes.write(this.option) as unknown as Buffer);
      }
      if (this.voters !== undefined) {
        b.write(Primitive.Int.write(this.voters) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PollResults extends TLObject {
    min?: boolean;
    results?: Vector<Raw.TypePollAnswerVoters>;
    totalVoters?: int;
    recentVoters?: Vector<Raw.TypePeer>;
    solution?: string;
    solutionEntities?: Vector<Raw.TypeMessageEntity>;

    constructor(params: {
      min?: boolean;
      results?: Vector<Raw.TypePollAnswerVoters>;
      totalVoters?: int;
      recentVoters?: Vector<Raw.TypePeer>;
      solution?: string;
      solutionEntities?: Vector<Raw.TypeMessageEntity>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PollResults';
      this.constructorId = 0x7adf2420;
      this.subclassOfId = 0xc3b4f687;
      this._slots = [
        'min',
        'results',
        'totalVoters',
        'recentVoters',
        'solution',
        'solutionEntities',
      ];
      this.min = params.min;
      this.results = params.results;
      this.totalVoters = params.totalVoters;
      this.recentVoters = params.recentVoters;
      this.solution = params.solution;
      this.solutionEntities = params.solutionEntities;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PollResults> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let min = flags & (1 << 0) ? true : false;
      let results = flags & (1 << 1) ? await TLObject.read(b) : [];
      let totalVoters = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let recentVoters = flags & (1 << 3) ? await TLObject.read(b) : [];
      let solution = flags & (1 << 4) ? await Primitive.String.read(b) : undefined;
      let solutionEntities = flags & (1 << 4) ? await TLObject.read(b) : [];
      return new Raw.PollResults({
        min: min,
        results: results,
        totalVoters: totalVoters,
        recentVoters: recentVoters,
        solution: solution,
        solutionEntities: solutionEntities,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.min ? 1 << 0 : 0;
      flags |= this.results ? 1 << 1 : 0;
      flags |= this.totalVoters !== undefined ? 1 << 2 : 0;
      flags |= this.recentVoters ? 1 << 3 : 0;
      flags |= this.solution !== undefined ? 1 << 4 : 0;
      flags |= this.solutionEntities ? 1 << 4 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.results) {
        b.write(Primitive.Vector.write(this.results) as unknown as Buffer);
      }
      if (this.totalVoters !== undefined) {
        b.write(Primitive.Int.write(this.totalVoters) as unknown as Buffer);
      }
      if (this.recentVoters) {
        b.write(Primitive.Vector.write(this.recentVoters) as unknown as Buffer);
      }
      if (this.solution !== undefined) {
        b.write(Primitive.String.write(this.solution) as unknown as Buffer);
      }
      if (this.solutionEntities) {
        b.write(Primitive.Vector.write(this.solutionEntities) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatOnlines extends TLObject {
    onlines!: int;

    constructor(params: { onlines: int }) {
      super();
      this.classType = 'types';
      this.className = 'ChatOnlines';
      this.constructorId = 0xf041e250;
      this.subclassOfId = 0x8c81903a;
      this._slots = ['onlines'];
      this.onlines = params.onlines;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatOnlines> {
      // no flags

      let onlines = await Primitive.Int.read(b);
      return new Raw.ChatOnlines({ onlines: onlines });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.onlines !== undefined) {
        b.write(Primitive.Int.write(this.onlines) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StatsURL extends TLObject {
    url!: string;

    constructor(params: { url: string }) {
      super();
      this.classType = 'types';
      this.className = 'StatsURL';
      this.constructorId = 0x47a971e0;
      this.subclassOfId = 0x8d4c94c0;
      this._slots = ['url'];
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StatsURL> {
      // no flags

      let url = await Primitive.String.read(b);
      return new Raw.StatsURL({ url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatAdminRights extends TLObject {
    changeInfo?: boolean;
    postMessages?: boolean;
    editMessages?: boolean;
    deleteMessages?: boolean;
    banUsers?: boolean;
    inviteUsers?: boolean;
    pinMessages?: boolean;
    addAdmins?: boolean;
    anonymous?: boolean;
    manageCall?: boolean;
    other?: boolean;
    manageTopics?: boolean;
    postStories?: boolean;
    editStories?: boolean;
    deleteStories?: boolean;

    constructor(params: {
      changeInfo?: boolean;
      postMessages?: boolean;
      editMessages?: boolean;
      deleteMessages?: boolean;
      banUsers?: boolean;
      inviteUsers?: boolean;
      pinMessages?: boolean;
      addAdmins?: boolean;
      anonymous?: boolean;
      manageCall?: boolean;
      other?: boolean;
      manageTopics?: boolean;
      postStories?: boolean;
      editStories?: boolean;
      deleteStories?: boolean;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChatAdminRights';
      this.constructorId = 0x5fb224d5;
      this.subclassOfId = 0x863dc7c4;
      this._slots = [
        'changeInfo',
        'postMessages',
        'editMessages',
        'deleteMessages',
        'banUsers',
        'inviteUsers',
        'pinMessages',
        'addAdmins',
        'anonymous',
        'manageCall',
        'other',
        'manageTopics',
        'postStories',
        'editStories',
        'deleteStories',
      ];
      this.changeInfo = params.changeInfo;
      this.postMessages = params.postMessages;
      this.editMessages = params.editMessages;
      this.deleteMessages = params.deleteMessages;
      this.banUsers = params.banUsers;
      this.inviteUsers = params.inviteUsers;
      this.pinMessages = params.pinMessages;
      this.addAdmins = params.addAdmins;
      this.anonymous = params.anonymous;
      this.manageCall = params.manageCall;
      this.other = params.other;
      this.manageTopics = params.manageTopics;
      this.postStories = params.postStories;
      this.editStories = params.editStories;
      this.deleteStories = params.deleteStories;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatAdminRights> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let changeInfo = flags & (1 << 0) ? true : false;
      let postMessages = flags & (1 << 1) ? true : false;
      let editMessages = flags & (1 << 2) ? true : false;
      let deleteMessages = flags & (1 << 3) ? true : false;
      let banUsers = flags & (1 << 4) ? true : false;
      let inviteUsers = flags & (1 << 5) ? true : false;
      let pinMessages = flags & (1 << 7) ? true : false;
      let addAdmins = flags & (1 << 9) ? true : false;
      let anonymous = flags & (1 << 10) ? true : false;
      let manageCall = flags & (1 << 11) ? true : false;
      let other = flags & (1 << 12) ? true : false;
      let manageTopics = flags & (1 << 13) ? true : false;
      let postStories = flags & (1 << 14) ? true : false;
      let editStories = flags & (1 << 15) ? true : false;
      let deleteStories = flags & (1 << 16) ? true : false;
      return new Raw.ChatAdminRights({
        changeInfo: changeInfo,
        postMessages: postMessages,
        editMessages: editMessages,
        deleteMessages: deleteMessages,
        banUsers: banUsers,
        inviteUsers: inviteUsers,
        pinMessages: pinMessages,
        addAdmins: addAdmins,
        anonymous: anonymous,
        manageCall: manageCall,
        other: other,
        manageTopics: manageTopics,
        postStories: postStories,
        editStories: editStories,
        deleteStories: deleteStories,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.changeInfo ? 1 << 0 : 0;
      flags |= this.postMessages ? 1 << 1 : 0;
      flags |= this.editMessages ? 1 << 2 : 0;
      flags |= this.deleteMessages ? 1 << 3 : 0;
      flags |= this.banUsers ? 1 << 4 : 0;
      flags |= this.inviteUsers ? 1 << 5 : 0;
      flags |= this.pinMessages ? 1 << 7 : 0;
      flags |= this.addAdmins ? 1 << 9 : 0;
      flags |= this.anonymous ? 1 << 10 : 0;
      flags |= this.manageCall ? 1 << 11 : 0;
      flags |= this.other ? 1 << 12 : 0;
      flags |= this.manageTopics ? 1 << 13 : 0;
      flags |= this.postStories ? 1 << 14 : 0;
      flags |= this.editStories ? 1 << 15 : 0;
      flags |= this.deleteStories ? 1 << 16 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      return b.buffer;
    }
  }
  export class ChatBannedRights extends TLObject {
    viewMessages?: boolean;
    sendMessages?: boolean;
    sendMedia?: boolean;
    sendStickers?: boolean;
    sendGifs?: boolean;
    sendGames?: boolean;
    sendInline?: boolean;
    embedLinks?: boolean;
    sendPolls?: boolean;
    changeInfo?: boolean;
    inviteUsers?: boolean;
    pinMessages?: boolean;
    manageTopics?: boolean;
    sendPhotos?: boolean;
    sendVideos?: boolean;
    sendRoundvideos?: boolean;
    sendAudios?: boolean;
    sendVoices?: boolean;
    sendDocs?: boolean;
    sendPlain?: boolean;
    untilDate!: int;

    constructor(params: {
      viewMessages?: boolean;
      sendMessages?: boolean;
      sendMedia?: boolean;
      sendStickers?: boolean;
      sendGifs?: boolean;
      sendGames?: boolean;
      sendInline?: boolean;
      embedLinks?: boolean;
      sendPolls?: boolean;
      changeInfo?: boolean;
      inviteUsers?: boolean;
      pinMessages?: boolean;
      manageTopics?: boolean;
      sendPhotos?: boolean;
      sendVideos?: boolean;
      sendRoundvideos?: boolean;
      sendAudios?: boolean;
      sendVoices?: boolean;
      sendDocs?: boolean;
      sendPlain?: boolean;
      untilDate: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChatBannedRights';
      this.constructorId = 0x9f120418;
      this.subclassOfId = 0x4b5445a9;
      this._slots = [
        'viewMessages',
        'sendMessages',
        'sendMedia',
        'sendStickers',
        'sendGifs',
        'sendGames',
        'sendInline',
        'embedLinks',
        'sendPolls',
        'changeInfo',
        'inviteUsers',
        'pinMessages',
        'manageTopics',
        'sendPhotos',
        'sendVideos',
        'sendRoundvideos',
        'sendAudios',
        'sendVoices',
        'sendDocs',
        'sendPlain',
        'untilDate',
      ];
      this.viewMessages = params.viewMessages;
      this.sendMessages = params.sendMessages;
      this.sendMedia = params.sendMedia;
      this.sendStickers = params.sendStickers;
      this.sendGifs = params.sendGifs;
      this.sendGames = params.sendGames;
      this.sendInline = params.sendInline;
      this.embedLinks = params.embedLinks;
      this.sendPolls = params.sendPolls;
      this.changeInfo = params.changeInfo;
      this.inviteUsers = params.inviteUsers;
      this.pinMessages = params.pinMessages;
      this.manageTopics = params.manageTopics;
      this.sendPhotos = params.sendPhotos;
      this.sendVideos = params.sendVideos;
      this.sendRoundvideos = params.sendRoundvideos;
      this.sendAudios = params.sendAudios;
      this.sendVoices = params.sendVoices;
      this.sendDocs = params.sendDocs;
      this.sendPlain = params.sendPlain;
      this.untilDate = params.untilDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatBannedRights> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let viewMessages = flags & (1 << 0) ? true : false;
      let sendMessages = flags & (1 << 1) ? true : false;
      let sendMedia = flags & (1 << 2) ? true : false;
      let sendStickers = flags & (1 << 3) ? true : false;
      let sendGifs = flags & (1 << 4) ? true : false;
      let sendGames = flags & (1 << 5) ? true : false;
      let sendInline = flags & (1 << 6) ? true : false;
      let embedLinks = flags & (1 << 7) ? true : false;
      let sendPolls = flags & (1 << 8) ? true : false;
      let changeInfo = flags & (1 << 10) ? true : false;
      let inviteUsers = flags & (1 << 15) ? true : false;
      let pinMessages = flags & (1 << 17) ? true : false;
      let manageTopics = flags & (1 << 18) ? true : false;
      let sendPhotos = flags & (1 << 19) ? true : false;
      let sendVideos = flags & (1 << 20) ? true : false;
      let sendRoundvideos = flags & (1 << 21) ? true : false;
      let sendAudios = flags & (1 << 22) ? true : false;
      let sendVoices = flags & (1 << 23) ? true : false;
      let sendDocs = flags & (1 << 24) ? true : false;
      let sendPlain = flags & (1 << 25) ? true : false;
      let untilDate = await Primitive.Int.read(b);
      return new Raw.ChatBannedRights({
        viewMessages: viewMessages,
        sendMessages: sendMessages,
        sendMedia: sendMedia,
        sendStickers: sendStickers,
        sendGifs: sendGifs,
        sendGames: sendGames,
        sendInline: sendInline,
        embedLinks: embedLinks,
        sendPolls: sendPolls,
        changeInfo: changeInfo,
        inviteUsers: inviteUsers,
        pinMessages: pinMessages,
        manageTopics: manageTopics,
        sendPhotos: sendPhotos,
        sendVideos: sendVideos,
        sendRoundvideos: sendRoundvideos,
        sendAudios: sendAudios,
        sendVoices: sendVoices,
        sendDocs: sendDocs,
        sendPlain: sendPlain,
        untilDate: untilDate,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.viewMessages ? 1 << 0 : 0;
      flags |= this.sendMessages ? 1 << 1 : 0;
      flags |= this.sendMedia ? 1 << 2 : 0;
      flags |= this.sendStickers ? 1 << 3 : 0;
      flags |= this.sendGifs ? 1 << 4 : 0;
      flags |= this.sendGames ? 1 << 5 : 0;
      flags |= this.sendInline ? 1 << 6 : 0;
      flags |= this.embedLinks ? 1 << 7 : 0;
      flags |= this.sendPolls ? 1 << 8 : 0;
      flags |= this.changeInfo ? 1 << 10 : 0;
      flags |= this.inviteUsers ? 1 << 15 : 0;
      flags |= this.pinMessages ? 1 << 17 : 0;
      flags |= this.manageTopics ? 1 << 18 : 0;
      flags |= this.sendPhotos ? 1 << 19 : 0;
      flags |= this.sendVideos ? 1 << 20 : 0;
      flags |= this.sendRoundvideos ? 1 << 21 : 0;
      flags |= this.sendAudios ? 1 << 22 : 0;
      flags |= this.sendVoices ? 1 << 23 : 0;
      flags |= this.sendDocs ? 1 << 24 : 0;
      flags |= this.sendPlain ? 1 << 25 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.untilDate !== undefined) {
        b.write(Primitive.Int.write(this.untilDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputWallPaper extends TLObject {
    id!: long;
    accessHash!: long;

    constructor(params: { id: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputWallPaper';
      this.constructorId = 0xe630b979;
      this.subclassOfId = 0xee77201a;
      this._slots = ['id', 'accessHash'];
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputWallPaper> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputWallPaper({ id: id, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputWallPaperSlug extends TLObject {
    slug!: string;

    constructor(params: { slug: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputWallPaperSlug';
      this.constructorId = 0x72091c80;
      this.subclassOfId = 0xee77201a;
      this._slots = ['slug'];
      this.slug = params.slug;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputWallPaperSlug> {
      // no flags

      let slug = await Primitive.String.read(b);
      return new Raw.InputWallPaperSlug({ slug: slug });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.slug !== undefined) {
        b.write(Primitive.String.write(this.slug) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputWallPaperNoFile extends TLObject {
    id!: long;

    constructor(params: { id: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputWallPaperNoFile';
      this.constructorId = 0x967a462e;
      this.subclassOfId = 0xee77201a;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputWallPaperNoFile> {
      // no flags

      let id = await Primitive.Long.read(b);
      return new Raw.InputWallPaperNoFile({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class CodeSettings extends TLObject {
    allowFlashcall?: boolean;
    currentNumber?: boolean;
    allowAppHash?: boolean;
    allowMissedCall?: boolean;
    allowFirebase?: boolean;
    logoutTokens?: Vector<bytes>;
    token?: string;
    appSandbox?: Bool;

    constructor(params: {
      allowFlashcall?: boolean;
      currentNumber?: boolean;
      allowAppHash?: boolean;
      allowMissedCall?: boolean;
      allowFirebase?: boolean;
      logoutTokens?: Vector<bytes>;
      token?: string;
      appSandbox?: Bool;
    }) {
      super();
      this.classType = 'types';
      this.className = 'CodeSettings';
      this.constructorId = 0xad253d78;
      this.subclassOfId = 0x48edbc8a;
      this._slots = [
        'allowFlashcall',
        'currentNumber',
        'allowAppHash',
        'allowMissedCall',
        'allowFirebase',
        'logoutTokens',
        'token',
        'appSandbox',
      ];
      this.allowFlashcall = params.allowFlashcall;
      this.currentNumber = params.currentNumber;
      this.allowAppHash = params.allowAppHash;
      this.allowMissedCall = params.allowMissedCall;
      this.allowFirebase = params.allowFirebase;
      this.logoutTokens = params.logoutTokens;
      this.token = params.token;
      this.appSandbox = params.appSandbox;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.CodeSettings> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let allowFlashcall = flags & (1 << 0) ? true : false;
      let currentNumber = flags & (1 << 1) ? true : false;
      let allowAppHash = flags & (1 << 4) ? true : false;
      let allowMissedCall = flags & (1 << 5) ? true : false;
      let allowFirebase = flags & (1 << 7) ? true : false;
      let logoutTokens = flags & (1 << 6) ? await TLObject.read(b, Primitive.Bytes) : [];
      let token = flags & (1 << 8) ? await Primitive.String.read(b) : undefined;
      let appSandbox = flags & (1 << 8) ? await Primitive.Bool.read(b) : undefined;
      return new Raw.CodeSettings({
        allowFlashcall: allowFlashcall,
        currentNumber: currentNumber,
        allowAppHash: allowAppHash,
        allowMissedCall: allowMissedCall,
        allowFirebase: allowFirebase,
        logoutTokens: logoutTokens,
        token: token,
        appSandbox: appSandbox,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.allowFlashcall ? 1 << 0 : 0;
      flags |= this.currentNumber ? 1 << 1 : 0;
      flags |= this.allowAppHash ? 1 << 4 : 0;
      flags |= this.allowMissedCall ? 1 << 5 : 0;
      flags |= this.allowFirebase ? 1 << 7 : 0;
      flags |= this.logoutTokens ? 1 << 6 : 0;
      flags |= this.token !== undefined ? 1 << 8 : 0;
      flags |= this.appSandbox !== undefined ? 1 << 8 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.logoutTokens) {
        b.write(Primitive.Vector.write(this.logoutTokens, Primitive.Bytes) as unknown as Buffer);
      }
      if (this.token !== undefined) {
        b.write(Primitive.String.write(this.token) as unknown as Buffer);
      }
      if (this.appSandbox !== undefined) {
        b.write(Primitive.Bool.write(this.appSandbox) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WallPaperSettings extends TLObject {
    blur?: boolean;
    motion?: boolean;
    backgroundColor?: int;
    secondBackgroundColor?: int;
    thirdBackgroundColor?: int;
    fourthBackgroundColor?: int;
    intensity?: int;
    rotation?: int;

    constructor(params: {
      blur?: boolean;
      motion?: boolean;
      backgroundColor?: int;
      secondBackgroundColor?: int;
      thirdBackgroundColor?: int;
      fourthBackgroundColor?: int;
      intensity?: int;
      rotation?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'WallPaperSettings';
      this.constructorId = 0x1dc1bca4;
      this.subclassOfId = 0x4175e312;
      this._slots = [
        'blur',
        'motion',
        'backgroundColor',
        'secondBackgroundColor',
        'thirdBackgroundColor',
        'fourthBackgroundColor',
        'intensity',
        'rotation',
      ];
      this.blur = params.blur;
      this.motion = params.motion;
      this.backgroundColor = params.backgroundColor;
      this.secondBackgroundColor = params.secondBackgroundColor;
      this.thirdBackgroundColor = params.thirdBackgroundColor;
      this.fourthBackgroundColor = params.fourthBackgroundColor;
      this.intensity = params.intensity;
      this.rotation = params.rotation;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WallPaperSettings> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let blur = flags & (1 << 1) ? true : false;
      let motion = flags & (1 << 2) ? true : false;
      let backgroundColor = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let secondBackgroundColor = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      let thirdBackgroundColor = flags & (1 << 5) ? await Primitive.Int.read(b) : undefined;
      let fourthBackgroundColor = flags & (1 << 6) ? await Primitive.Int.read(b) : undefined;
      let intensity = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
      let rotation = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      return new Raw.WallPaperSettings({
        blur: blur,
        motion: motion,
        backgroundColor: backgroundColor,
        secondBackgroundColor: secondBackgroundColor,
        thirdBackgroundColor: thirdBackgroundColor,
        fourthBackgroundColor: fourthBackgroundColor,
        intensity: intensity,
        rotation: rotation,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.blur ? 1 << 1 : 0;
      flags |= this.motion ? 1 << 2 : 0;
      flags |= this.backgroundColor !== undefined ? 1 << 0 : 0;
      flags |= this.secondBackgroundColor !== undefined ? 1 << 4 : 0;
      flags |= this.thirdBackgroundColor !== undefined ? 1 << 5 : 0;
      flags |= this.fourthBackgroundColor !== undefined ? 1 << 6 : 0;
      flags |= this.intensity !== undefined ? 1 << 3 : 0;
      flags |= this.rotation !== undefined ? 1 << 4 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.backgroundColor !== undefined) {
        b.write(Primitive.Int.write(this.backgroundColor) as unknown as Buffer);
      }
      if (this.secondBackgroundColor !== undefined) {
        b.write(Primitive.Int.write(this.secondBackgroundColor) as unknown as Buffer);
      }
      if (this.thirdBackgroundColor !== undefined) {
        b.write(Primitive.Int.write(this.thirdBackgroundColor) as unknown as Buffer);
      }
      if (this.fourthBackgroundColor !== undefined) {
        b.write(Primitive.Int.write(this.fourthBackgroundColor) as unknown as Buffer);
      }
      if (this.intensity !== undefined) {
        b.write(Primitive.Int.write(this.intensity) as unknown as Buffer);
      }
      if (this.rotation !== undefined) {
        b.write(Primitive.Int.write(this.rotation) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class AutoDownloadSettings extends TLObject {
    disabled?: boolean;
    videoPreloadLarge?: boolean;
    audioPreloadNext?: boolean;
    phonecallsLessData?: boolean;
    storiesPreload?: boolean;
    photoSizeMax!: int;
    videoSizeMax!: long;
    fileSizeMax!: long;
    videoUploadMaxbitrate!: int;
    smallQueueActiveOperationsMax!: int;
    largeQueueActiveOperationsMax!: int;

    constructor(params: {
      disabled?: boolean;
      videoPreloadLarge?: boolean;
      audioPreloadNext?: boolean;
      phonecallsLessData?: boolean;
      storiesPreload?: boolean;
      photoSizeMax: int;
      videoSizeMax: long;
      fileSizeMax: long;
      videoUploadMaxbitrate: int;
      smallQueueActiveOperationsMax: int;
      largeQueueActiveOperationsMax: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'AutoDownloadSettings';
      this.constructorId = 0xbaa57628;
      this.subclassOfId = 0x512819c7;
      this._slots = [
        'disabled',
        'videoPreloadLarge',
        'audioPreloadNext',
        'phonecallsLessData',
        'storiesPreload',
        'photoSizeMax',
        'videoSizeMax',
        'fileSizeMax',
        'videoUploadMaxbitrate',
        'smallQueueActiveOperationsMax',
        'largeQueueActiveOperationsMax',
      ];
      this.disabled = params.disabled;
      this.videoPreloadLarge = params.videoPreloadLarge;
      this.audioPreloadNext = params.audioPreloadNext;
      this.phonecallsLessData = params.phonecallsLessData;
      this.storiesPreload = params.storiesPreload;
      this.photoSizeMax = params.photoSizeMax;
      this.videoSizeMax = params.videoSizeMax;
      this.fileSizeMax = params.fileSizeMax;
      this.videoUploadMaxbitrate = params.videoUploadMaxbitrate;
      this.smallQueueActiveOperationsMax = params.smallQueueActiveOperationsMax;
      this.largeQueueActiveOperationsMax = params.largeQueueActiveOperationsMax;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AutoDownloadSettings> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let disabled = flags & (1 << 0) ? true : false;
      let videoPreloadLarge = flags & (1 << 1) ? true : false;
      let audioPreloadNext = flags & (1 << 2) ? true : false;
      let phonecallsLessData = flags & (1 << 3) ? true : false;
      let storiesPreload = flags & (1 << 4) ? true : false;
      let photoSizeMax = await Primitive.Int.read(b);
      let videoSizeMax = await Primitive.Long.read(b);
      let fileSizeMax = await Primitive.Long.read(b);
      let videoUploadMaxbitrate = await Primitive.Int.read(b);
      let smallQueueActiveOperationsMax = await Primitive.Int.read(b);
      let largeQueueActiveOperationsMax = await Primitive.Int.read(b);
      return new Raw.AutoDownloadSettings({
        disabled: disabled,
        videoPreloadLarge: videoPreloadLarge,
        audioPreloadNext: audioPreloadNext,
        phonecallsLessData: phonecallsLessData,
        storiesPreload: storiesPreload,
        photoSizeMax: photoSizeMax,
        videoSizeMax: videoSizeMax,
        fileSizeMax: fileSizeMax,
        videoUploadMaxbitrate: videoUploadMaxbitrate,
        smallQueueActiveOperationsMax: smallQueueActiveOperationsMax,
        largeQueueActiveOperationsMax: largeQueueActiveOperationsMax,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.disabled ? 1 << 0 : 0;
      flags |= this.videoPreloadLarge ? 1 << 1 : 0;
      flags |= this.audioPreloadNext ? 1 << 2 : 0;
      flags |= this.phonecallsLessData ? 1 << 3 : 0;
      flags |= this.storiesPreload ? 1 << 4 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.photoSizeMax !== undefined) {
        b.write(Primitive.Int.write(this.photoSizeMax) as unknown as Buffer);
      }
      if (this.videoSizeMax !== undefined) {
        b.write(Primitive.Long.write(this.videoSizeMax) as unknown as Buffer);
      }
      if (this.fileSizeMax !== undefined) {
        b.write(Primitive.Long.write(this.fileSizeMax) as unknown as Buffer);
      }
      if (this.videoUploadMaxbitrate !== undefined) {
        b.write(Primitive.Int.write(this.videoUploadMaxbitrate) as unknown as Buffer);
      }
      if (this.smallQueueActiveOperationsMax !== undefined) {
        b.write(Primitive.Int.write(this.smallQueueActiveOperationsMax) as unknown as Buffer);
      }
      if (this.largeQueueActiveOperationsMax !== undefined) {
        b.write(Primitive.Int.write(this.largeQueueActiveOperationsMax) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmojiKeyword extends TLObject {
    keyword!: string;
    emoticons!: Vector<string>;

    constructor(params: { keyword: string; emoticons: Vector<string> }) {
      super();
      this.classType = 'types';
      this.className = 'EmojiKeyword';
      this.constructorId = 0xd5b3b9f9;
      this.subclassOfId = 0x6612a53e;
      this._slots = ['keyword', 'emoticons'];
      this.keyword = params.keyword;
      this.emoticons = params.emoticons;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmojiKeyword> {
      // no flags

      let keyword = await Primitive.String.read(b);
      let emoticons = await TLObject.read(b, Primitive.String);
      return new Raw.EmojiKeyword({ keyword: keyword, emoticons: emoticons });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.keyword !== undefined) {
        b.write(Primitive.String.write(this.keyword) as unknown as Buffer);
      }
      if (this.emoticons) {
        b.write(Primitive.Vector.write(this.emoticons, Primitive.String) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmojiKeywordDeleted extends TLObject {
    keyword!: string;
    emoticons!: Vector<string>;

    constructor(params: { keyword: string; emoticons: Vector<string> }) {
      super();
      this.classType = 'types';
      this.className = 'EmojiKeywordDeleted';
      this.constructorId = 0x236df622;
      this.subclassOfId = 0x6612a53e;
      this._slots = ['keyword', 'emoticons'];
      this.keyword = params.keyword;
      this.emoticons = params.emoticons;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmojiKeywordDeleted> {
      // no flags

      let keyword = await Primitive.String.read(b);
      let emoticons = await TLObject.read(b, Primitive.String);
      return new Raw.EmojiKeywordDeleted({ keyword: keyword, emoticons: emoticons });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.keyword !== undefined) {
        b.write(Primitive.String.write(this.keyword) as unknown as Buffer);
      }
      if (this.emoticons) {
        b.write(Primitive.Vector.write(this.emoticons, Primitive.String) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmojiKeywordsDifference extends TLObject {
    langCode!: string;
    fromVersion!: int;
    version!: int;
    keywords!: Vector<Raw.TypeEmojiKeyword>;

    constructor(params: {
      langCode: string;
      fromVersion: int;
      version: int;
      keywords: Vector<Raw.TypeEmojiKeyword>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'EmojiKeywordsDifference';
      this.constructorId = 0x5cc761bd;
      this.subclassOfId = 0xd279c672;
      this._slots = ['langCode', 'fromVersion', 'version', 'keywords'];
      this.langCode = params.langCode;
      this.fromVersion = params.fromVersion;
      this.version = params.version;
      this.keywords = params.keywords;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmojiKeywordsDifference> {
      // no flags

      let langCode = await Primitive.String.read(b);
      let fromVersion = await Primitive.Int.read(b);
      let version = await Primitive.Int.read(b);
      let keywords = await TLObject.read(b);
      return new Raw.EmojiKeywordsDifference({
        langCode: langCode,
        fromVersion: fromVersion,
        version: version,
        keywords: keywords,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.langCode !== undefined) {
        b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
      }
      if (this.fromVersion !== undefined) {
        b.write(Primitive.Int.write(this.fromVersion) as unknown as Buffer);
      }
      if (this.version !== undefined) {
        b.write(Primitive.Int.write(this.version) as unknown as Buffer);
      }
      if (this.keywords) {
        b.write(Primitive.Vector.write(this.keywords) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmojiURL extends TLObject {
    url!: string;

    constructor(params: { url: string }) {
      super();
      this.classType = 'types';
      this.className = 'EmojiURL';
      this.constructorId = 0xa575739d;
      this.subclassOfId = 0x1fa08a19;
      this._slots = ['url'];
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmojiURL> {
      // no flags

      let url = await Primitive.String.read(b);
      return new Raw.EmojiURL({ url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmojiLanguage extends TLObject {
    langCode!: string;

    constructor(params: { langCode: string }) {
      super();
      this.classType = 'types';
      this.className = 'EmojiLanguage';
      this.constructorId = 0xb3fb5361;
      this.subclassOfId = 0xa48d04ee;
      this._slots = ['langCode'];
      this.langCode = params.langCode;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmojiLanguage> {
      // no flags

      let langCode = await Primitive.String.read(b);
      return new Raw.EmojiLanguage({ langCode: langCode });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.langCode !== undefined) {
        b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Folder extends TLObject {
    autofillNewBroadcasts?: boolean;
    autofillPublicGroups?: boolean;
    autofillNewCorrespondents?: boolean;
    id!: int;
    title!: string;
    photo?: Raw.TypeChatPhoto;

    constructor(params: {
      autofillNewBroadcasts?: boolean;
      autofillPublicGroups?: boolean;
      autofillNewCorrespondents?: boolean;
      id: int;
      title: string;
      photo?: Raw.TypeChatPhoto;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Folder';
      this.constructorId = 0xff544e65;
      this.subclassOfId = 0xeb0e0cfb;
      this._slots = [
        'autofillNewBroadcasts',
        'autofillPublicGroups',
        'autofillNewCorrespondents',
        'id',
        'title',
        'photo',
      ];
      this.autofillNewBroadcasts = params.autofillNewBroadcasts;
      this.autofillPublicGroups = params.autofillPublicGroups;
      this.autofillNewCorrespondents = params.autofillNewCorrespondents;
      this.id = params.id;
      this.title = params.title;
      this.photo = params.photo;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Folder> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let autofillNewBroadcasts = flags & (1 << 0) ? true : false;
      let autofillPublicGroups = flags & (1 << 1) ? true : false;
      let autofillNewCorrespondents = flags & (1 << 2) ? true : false;
      let id = await Primitive.Int.read(b);
      let title = await Primitive.String.read(b);
      let photo = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      return new Raw.Folder({
        autofillNewBroadcasts: autofillNewBroadcasts,
        autofillPublicGroups: autofillPublicGroups,
        autofillNewCorrespondents: autofillNewCorrespondents,
        id: id,
        title: title,
        photo: photo,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.autofillNewBroadcasts ? 1 << 0 : 0;
      flags |= this.autofillPublicGroups ? 1 << 1 : 0;
      flags |= this.autofillNewCorrespondents ? 1 << 2 : 0;
      flags |= this.photo !== undefined ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputFolderPeer extends TLObject {
    peer!: Raw.TypeInputPeer;
    folderId!: int;

    constructor(params: { peer: Raw.TypeInputPeer; folderId: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputFolderPeer';
      this.constructorId = 0xfbd2c296;
      this.subclassOfId = 0x74825e00;
      this._slots = ['peer', 'folderId'];
      this.peer = params.peer;
      this.folderId = params.folderId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputFolderPeer> {
      // no flags

      let peer = await TLObject.read(b);
      let folderId = await Primitive.Int.read(b);
      return new Raw.InputFolderPeer({ peer: peer, folderId: folderId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class FolderPeer extends TLObject {
    peer!: Raw.TypePeer;
    folderId!: int;

    constructor(params: { peer: Raw.TypePeer; folderId: int }) {
      super();
      this.classType = 'types';
      this.className = 'FolderPeer';
      this.constructorId = 0xe9baa668;
      this.subclassOfId = 0xf3f2283b;
      this._slots = ['peer', 'folderId'];
      this.peer = params.peer;
      this.folderId = params.folderId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.FolderPeer> {
      // no flags

      let peer = await TLObject.read(b);
      let folderId = await Primitive.Int.read(b);
      return new Raw.FolderPeer({ peer: peer, folderId: folderId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.folderId !== undefined) {
        b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UrlAuthResultRequest extends TLObject {
    requestWriteAccess?: boolean;
    bot!: Raw.TypeUser;
    domain!: string;

    constructor(params: { requestWriteAccess?: boolean; bot: Raw.TypeUser; domain: string }) {
      super();
      this.classType = 'types';
      this.className = 'UrlAuthResultRequest';
      this.constructorId = 0x92d33a0e;
      this.subclassOfId = 0x7765cb1e;
      this._slots = ['requestWriteAccess', 'bot', 'domain'];
      this.requestWriteAccess = params.requestWriteAccess;
      this.bot = params.bot;
      this.domain = params.domain;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UrlAuthResultRequest> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let requestWriteAccess = flags & (1 << 0) ? true : false;
      let bot = await TLObject.read(b);
      let domain = await Primitive.String.read(b);
      return new Raw.UrlAuthResultRequest({
        requestWriteAccess: requestWriteAccess,
        bot: bot,
        domain: domain,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.requestWriteAccess ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.bot !== undefined) {
        b.write(this.bot.write() as unknown as Buffer);
      }
      if (this.domain !== undefined) {
        b.write(Primitive.String.write(this.domain) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UrlAuthResultAccepted extends TLObject {
    url!: string;

    constructor(params: { url: string }) {
      super();
      this.classType = 'types';
      this.className = 'UrlAuthResultAccepted';
      this.constructorId = 0x8f8c0e4e;
      this.subclassOfId = 0x7765cb1e;
      this._slots = ['url'];
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UrlAuthResultAccepted> {
      // no flags

      let url = await Primitive.String.read(b);
      return new Raw.UrlAuthResultAccepted({ url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class UrlAuthResultDefault extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'UrlAuthResultDefault';
      this.constructorId = 0xa9d6db1f;
      this.subclassOfId = 0x7765cb1e;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.UrlAuthResultDefault> {
      // no flags

      return new Raw.UrlAuthResultDefault();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChannelLocationEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'ChannelLocationEmpty';
      this.constructorId = 0xbfb5ad8b;
      this.subclassOfId = 0xec260b7f;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelLocationEmpty> {
      // no flags

      return new Raw.ChannelLocationEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChannelLocation extends TLObject {
    geoPoint!: Raw.TypeGeoPoint;
    address!: string;

    constructor(params: { geoPoint: Raw.TypeGeoPoint; address: string }) {
      super();
      this.classType = 'types';
      this.className = 'ChannelLocation';
      this.constructorId = 0x209b82db;
      this.subclassOfId = 0xec260b7f;
      this._slots = ['geoPoint', 'address'];
      this.geoPoint = params.geoPoint;
      this.address = params.address;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChannelLocation> {
      // no flags

      let geoPoint = await TLObject.read(b);
      let address = await Primitive.String.read(b);
      return new Raw.ChannelLocation({ geoPoint: geoPoint, address: address });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.geoPoint !== undefined) {
        b.write(this.geoPoint.write() as unknown as Buffer);
      }
      if (this.address !== undefined) {
        b.write(Primitive.String.write(this.address) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PeerLocated extends TLObject {
    peer!: Raw.TypePeer;
    expires!: int;
    distance!: int;

    constructor(params: { peer: Raw.TypePeer; expires: int; distance: int }) {
      super();
      this.classType = 'types';
      this.className = 'PeerLocated';
      this.constructorId = 0xca461b5d;
      this.subclassOfId = 0xfada34ac;
      this._slots = ['peer', 'expires', 'distance'];
      this.peer = params.peer;
      this.expires = params.expires;
      this.distance = params.distance;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PeerLocated> {
      // no flags

      let peer = await TLObject.read(b);
      let expires = await Primitive.Int.read(b);
      let distance = await Primitive.Int.read(b);
      return new Raw.PeerLocated({ peer: peer, expires: expires, distance: distance });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.expires !== undefined) {
        b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
      }
      if (this.distance !== undefined) {
        b.write(Primitive.Int.write(this.distance) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PeerSelfLocated extends TLObject {
    expires!: int;

    constructor(params: { expires: int }) {
      super();
      this.classType = 'types';
      this.className = 'PeerSelfLocated';
      this.constructorId = 0xf8ec284b;
      this.subclassOfId = 0xfada34ac;
      this._slots = ['expires'];
      this.expires = params.expires;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PeerSelfLocated> {
      // no flags

      let expires = await Primitive.Int.read(b);
      return new Raw.PeerSelfLocated({ expires: expires });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.expires !== undefined) {
        b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RestrictionReason extends TLObject {
    platform!: string;
    reason!: string;
    text!: string;

    constructor(params: { platform: string; reason: string; text: string }) {
      super();
      this.classType = 'types';
      this.className = 'RestrictionReason';
      this.constructorId = 0xd072acb4;
      this.subclassOfId = 0x6ad95ad;
      this._slots = ['platform', 'reason', 'text'];
      this.platform = params.platform;
      this.reason = params.reason;
      this.text = params.text;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RestrictionReason> {
      // no flags

      let platform = await Primitive.String.read(b);
      let reason = await Primitive.String.read(b);
      let text = await Primitive.String.read(b);
      return new Raw.RestrictionReason({ platform: platform, reason: reason, text: text });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.platform !== undefined) {
        b.write(Primitive.String.write(this.platform) as unknown as Buffer);
      }
      if (this.reason !== undefined) {
        b.write(Primitive.String.write(this.reason) as unknown as Buffer);
      }
      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputTheme extends TLObject {
    id!: long;
    accessHash!: long;

    constructor(params: { id: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputTheme';
      this.constructorId = 0x3c5693e9;
      this.subclassOfId = 0x7a100f0;
      this._slots = ['id', 'accessHash'];
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputTheme> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputTheme({ id: id, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputThemeSlug extends TLObject {
    slug!: string;

    constructor(params: { slug: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputThemeSlug';
      this.constructorId = 0xf5890df1;
      this.subclassOfId = 0x7a100f0;
      this._slots = ['slug'];
      this.slug = params.slug;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputThemeSlug> {
      // no flags

      let slug = await Primitive.String.read(b);
      return new Raw.InputThemeSlug({ slug: slug });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.slug !== undefined) {
        b.write(Primitive.String.write(this.slug) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Theme extends TLObject {
    creator?: boolean;
    default?: boolean;
    forChat?: boolean;
    id!: long;
    accessHash!: long;
    slug!: string;
    title!: string;
    document?: Raw.TypeDocument;
    settings?: Vector<Raw.TypeThemeSettings>;
    emoticon?: string;
    installsCount?: int;

    constructor(params: {
      creator?: boolean;
      default?: boolean;
      forChat?: boolean;
      id: long;
      accessHash: long;
      slug: string;
      title: string;
      document?: Raw.TypeDocument;
      settings?: Vector<Raw.TypeThemeSettings>;
      emoticon?: string;
      installsCount?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Theme';
      this.constructorId = 0xa00e67d6;
      this.subclassOfId = 0x56b4c80c;
      this._slots = [
        'creator',
        'default',
        'forChat',
        'id',
        'accessHash',
        'slug',
        'title',
        'document',
        'settings',
        'emoticon',
        'installsCount',
      ];
      this.creator = params.creator;
      this.default = params.default;
      this.forChat = params.forChat;
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.slug = params.slug;
      this.title = params.title;
      this.document = params.document;
      this.settings = params.settings;
      this.emoticon = params.emoticon;
      this.installsCount = params.installsCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Theme> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let creator = flags & (1 << 0) ? true : false;
      let _default = flags & (1 << 1) ? true : false;
      let forChat = flags & (1 << 5) ? true : false;
      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let slug = await Primitive.String.read(b);
      let title = await Primitive.String.read(b);
      let document = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      let settings = flags & (1 << 3) ? await TLObject.read(b) : [];
      let emoticon = flags & (1 << 6) ? await Primitive.String.read(b) : undefined;
      let installsCount = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      return new Raw.Theme({
        creator: creator,
        default: _default,
        forChat: forChat,
        id: id,
        accessHash: accessHash,
        slug: slug,
        title: title,
        document: document,
        settings: settings,
        emoticon: emoticon,
        installsCount: installsCount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.creator ? 1 << 0 : 0;
      flags |= this.default ? 1 << 1 : 0;
      flags |= this.forChat ? 1 << 5 : 0;
      flags |= this.document !== undefined ? 1 << 2 : 0;
      flags |= this.settings ? 1 << 3 : 0;
      flags |= this.emoticon !== undefined ? 1 << 6 : 0;
      flags |= this.installsCount !== undefined ? 1 << 4 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.slug !== undefined) {
        b.write(Primitive.String.write(this.slug) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.document !== undefined) {
        b.write(this.document.write() as unknown as Buffer);
      }
      if (this.settings) {
        b.write(Primitive.Vector.write(this.settings) as unknown as Buffer);
      }
      if (this.emoticon !== undefined) {
        b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
      }
      if (this.installsCount !== undefined) {
        b.write(Primitive.Int.write(this.installsCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BaseThemeClassic extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'BaseThemeClassic';
      this.constructorId = 0xc3a12462;
      this.subclassOfId = 0x1f03f444;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BaseThemeClassic> {
      // no flags

      return new Raw.BaseThemeClassic();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class BaseThemeDay extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'BaseThemeDay';
      this.constructorId = 0xfbd81688;
      this.subclassOfId = 0x1f03f444;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BaseThemeDay> {
      // no flags

      return new Raw.BaseThemeDay();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class BaseThemeNight extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'BaseThemeNight';
      this.constructorId = 0xb7b31ea8;
      this.subclassOfId = 0x1f03f444;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BaseThemeNight> {
      // no flags

      return new Raw.BaseThemeNight();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class BaseThemeTinted extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'BaseThemeTinted';
      this.constructorId = 0x6d5f77ee;
      this.subclassOfId = 0x1f03f444;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BaseThemeTinted> {
      // no flags

      return new Raw.BaseThemeTinted();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class BaseThemeArctic extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'BaseThemeArctic';
      this.constructorId = 0x5b11125a;
      this.subclassOfId = 0x1f03f444;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BaseThemeArctic> {
      // no flags

      return new Raw.BaseThemeArctic();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputThemeSettings extends TLObject {
    messageColorsAnimated?: boolean;
    baseTheme!: Raw.TypeBaseTheme;
    accentColor!: int;
    outboxAccentColor?: int;
    messageColors?: Vector<int>;
    wallpaper?: Raw.TypeInputWallPaper;
    wallpaperSettings?: Raw.TypeWallPaperSettings;

    constructor(params: {
      messageColorsAnimated?: boolean;
      baseTheme: Raw.TypeBaseTheme;
      accentColor: int;
      outboxAccentColor?: int;
      messageColors?: Vector<int>;
      wallpaper?: Raw.TypeInputWallPaper;
      wallpaperSettings?: Raw.TypeWallPaperSettings;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputThemeSettings';
      this.constructorId = 0x8fde504f;
      this.subclassOfId = 0x8338c882;
      this._slots = [
        'messageColorsAnimated',
        'baseTheme',
        'accentColor',
        'outboxAccentColor',
        'messageColors',
        'wallpaper',
        'wallpaperSettings',
      ];
      this.messageColorsAnimated = params.messageColorsAnimated;
      this.baseTheme = params.baseTheme;
      this.accentColor = params.accentColor;
      this.outboxAccentColor = params.outboxAccentColor;
      this.messageColors = params.messageColors;
      this.wallpaper = params.wallpaper;
      this.wallpaperSettings = params.wallpaperSettings;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputThemeSettings> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let messageColorsAnimated = flags & (1 << 2) ? true : false;
      let baseTheme = await TLObject.read(b);
      let accentColor = await Primitive.Int.read(b);
      let outboxAccentColor = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
      let messageColors = flags & (1 << 0) ? await TLObject.read(b, Primitive.Int) : [];
      let wallpaper = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let wallpaperSettings = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      return new Raw.InputThemeSettings({
        messageColorsAnimated: messageColorsAnimated,
        baseTheme: baseTheme,
        accentColor: accentColor,
        outboxAccentColor: outboxAccentColor,
        messageColors: messageColors,
        wallpaper: wallpaper,
        wallpaperSettings: wallpaperSettings,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.messageColorsAnimated ? 1 << 2 : 0;
      flags |= this.outboxAccentColor !== undefined ? 1 << 3 : 0;
      flags |= this.messageColors ? 1 << 0 : 0;
      flags |= this.wallpaper !== undefined ? 1 << 1 : 0;
      flags |= this.wallpaperSettings !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.baseTheme !== undefined) {
        b.write(this.baseTheme.write() as unknown as Buffer);
      }
      if (this.accentColor !== undefined) {
        b.write(Primitive.Int.write(this.accentColor) as unknown as Buffer);
      }
      if (this.outboxAccentColor !== undefined) {
        b.write(Primitive.Int.write(this.outboxAccentColor) as unknown as Buffer);
      }
      if (this.messageColors) {
        b.write(Primitive.Vector.write(this.messageColors, Primitive.Int) as unknown as Buffer);
      }
      if (this.wallpaper !== undefined) {
        b.write(this.wallpaper.write() as unknown as Buffer);
      }
      if (this.wallpaperSettings !== undefined) {
        b.write(this.wallpaperSettings.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ThemeSettings extends TLObject {
    messageColorsAnimated?: boolean;
    baseTheme!: Raw.TypeBaseTheme;
    accentColor!: int;
    outboxAccentColor?: int;
    messageColors?: Vector<int>;
    wallpaper?: Raw.TypeWallPaper;

    constructor(params: {
      messageColorsAnimated?: boolean;
      baseTheme: Raw.TypeBaseTheme;
      accentColor: int;
      outboxAccentColor?: int;
      messageColors?: Vector<int>;
      wallpaper?: Raw.TypeWallPaper;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ThemeSettings';
      this.constructorId = 0xfa58b6d4;
      this.subclassOfId = 0x82666d38;
      this._slots = [
        'messageColorsAnimated',
        'baseTheme',
        'accentColor',
        'outboxAccentColor',
        'messageColors',
        'wallpaper',
      ];
      this.messageColorsAnimated = params.messageColorsAnimated;
      this.baseTheme = params.baseTheme;
      this.accentColor = params.accentColor;
      this.outboxAccentColor = params.outboxAccentColor;
      this.messageColors = params.messageColors;
      this.wallpaper = params.wallpaper;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ThemeSettings> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let messageColorsAnimated = flags & (1 << 2) ? true : false;
      let baseTheme = await TLObject.read(b);
      let accentColor = await Primitive.Int.read(b);
      let outboxAccentColor = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
      let messageColors = flags & (1 << 0) ? await TLObject.read(b, Primitive.Int) : [];
      let wallpaper = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      return new Raw.ThemeSettings({
        messageColorsAnimated: messageColorsAnimated,
        baseTheme: baseTheme,
        accentColor: accentColor,
        outboxAccentColor: outboxAccentColor,
        messageColors: messageColors,
        wallpaper: wallpaper,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.messageColorsAnimated ? 1 << 2 : 0;
      flags |= this.outboxAccentColor !== undefined ? 1 << 3 : 0;
      flags |= this.messageColors ? 1 << 0 : 0;
      flags |= this.wallpaper !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.baseTheme !== undefined) {
        b.write(this.baseTheme.write() as unknown as Buffer);
      }
      if (this.accentColor !== undefined) {
        b.write(Primitive.Int.write(this.accentColor) as unknown as Buffer);
      }
      if (this.outboxAccentColor !== undefined) {
        b.write(Primitive.Int.write(this.outboxAccentColor) as unknown as Buffer);
      }
      if (this.messageColors) {
        b.write(Primitive.Vector.write(this.messageColors, Primitive.Int) as unknown as Buffer);
      }
      if (this.wallpaper !== undefined) {
        b.write(this.wallpaper.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WebPageAttributeTheme extends TLObject {
    documents?: Vector<Raw.TypeDocument>;
    settings?: Raw.TypeThemeSettings;

    constructor(params: {
      documents?: Vector<Raw.TypeDocument>;
      settings?: Raw.TypeThemeSettings;
    }) {
      super();
      this.classType = 'types';
      this.className = 'WebPageAttributeTheme';
      this.constructorId = 0x54b56617;
      this.subclassOfId = 0xafcfe9c7;
      this._slots = ['documents', 'settings'];
      this.documents = params.documents;
      this.settings = params.settings;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WebPageAttributeTheme> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let documents = flags & (1 << 0) ? await TLObject.read(b) : [];
      let settings = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      return new Raw.WebPageAttributeTheme({ documents: documents, settings: settings });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.documents ? 1 << 0 : 0;
      flags |= this.settings !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.documents) {
        b.write(Primitive.Vector.write(this.documents) as unknown as Buffer);
      }
      if (this.settings !== undefined) {
        b.write(this.settings.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WebPageAttributeStory extends TLObject {
    peer!: Raw.TypePeer;
    id!: int;
    story?: Raw.TypeStoryItem;

    constructor(params: { peer: Raw.TypePeer; id: int; story?: Raw.TypeStoryItem }) {
      super();
      this.classType = 'types';
      this.className = 'WebPageAttributeStory';
      this.constructorId = 0x2e94c3e7;
      this.subclassOfId = 0xafcfe9c7;
      this._slots = ['peer', 'id', 'story'];
      this.peer = params.peer;
      this.id = params.id;
      this.story = params.story;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WebPageAttributeStory> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let peer = await TLObject.read(b);
      let id = await Primitive.Int.read(b);
      let story = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      return new Raw.WebPageAttributeStory({ peer: peer, id: id, story: story });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.story !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.story !== undefined) {
        b.write(this.story.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BankCardOpenUrl extends TLObject {
    url!: string;
    name!: string;

    constructor(params: { url: string; name: string }) {
      super();
      this.classType = 'types';
      this.className = 'BankCardOpenUrl';
      this.constructorId = 0xf568028a;
      this.subclassOfId = 0xf2e2460e;
      this._slots = ['url', 'name'];
      this.url = params.url;
      this.name = params.name;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BankCardOpenUrl> {
      // no flags

      let url = await Primitive.String.read(b);
      let name = await Primitive.String.read(b);
      return new Raw.BankCardOpenUrl({ url: url, name: name });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.name !== undefined) {
        b.write(Primitive.String.write(this.name) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DialogFilter extends TLObject {
    contacts?: boolean;
    nonContacts?: boolean;
    groups?: boolean;
    broadcasts?: boolean;
    bots?: boolean;
    excludeMuted?: boolean;
    excludeRead?: boolean;
    excludeArchived?: boolean;
    id!: int;
    title!: string;
    emoticon?: string;
    pinnedPeers!: Vector<Raw.TypeInputPeer>;
    includePeers!: Vector<Raw.TypeInputPeer>;
    excludePeers!: Vector<Raw.TypeInputPeer>;

    constructor(params: {
      contacts?: boolean;
      nonContacts?: boolean;
      groups?: boolean;
      broadcasts?: boolean;
      bots?: boolean;
      excludeMuted?: boolean;
      excludeRead?: boolean;
      excludeArchived?: boolean;
      id: int;
      title: string;
      emoticon?: string;
      pinnedPeers: Vector<Raw.TypeInputPeer>;
      includePeers: Vector<Raw.TypeInputPeer>;
      excludePeers: Vector<Raw.TypeInputPeer>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DialogFilter';
      this.constructorId = 0x7438f7e8;
      this.subclassOfId = 0x692bc457;
      this._slots = [
        'contacts',
        'nonContacts',
        'groups',
        'broadcasts',
        'bots',
        'excludeMuted',
        'excludeRead',
        'excludeArchived',
        'id',
        'title',
        'emoticon',
        'pinnedPeers',
        'includePeers',
        'excludePeers',
      ];
      this.contacts = params.contacts;
      this.nonContacts = params.nonContacts;
      this.groups = params.groups;
      this.broadcasts = params.broadcasts;
      this.bots = params.bots;
      this.excludeMuted = params.excludeMuted;
      this.excludeRead = params.excludeRead;
      this.excludeArchived = params.excludeArchived;
      this.id = params.id;
      this.title = params.title;
      this.emoticon = params.emoticon;
      this.pinnedPeers = params.pinnedPeers;
      this.includePeers = params.includePeers;
      this.excludePeers = params.excludePeers;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DialogFilter> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let contacts = flags & (1 << 0) ? true : false;
      let nonContacts = flags & (1 << 1) ? true : false;
      let groups = flags & (1 << 2) ? true : false;
      let broadcasts = flags & (1 << 3) ? true : false;
      let bots = flags & (1 << 4) ? true : false;
      let excludeMuted = flags & (1 << 11) ? true : false;
      let excludeRead = flags & (1 << 12) ? true : false;
      let excludeArchived = flags & (1 << 13) ? true : false;
      let id = await Primitive.Int.read(b);
      let title = await Primitive.String.read(b);
      let emoticon = flags & (1 << 25) ? await Primitive.String.read(b) : undefined;
      let pinnedPeers = await TLObject.read(b);
      let includePeers = await TLObject.read(b);
      let excludePeers = await TLObject.read(b);
      return new Raw.DialogFilter({
        contacts: contacts,
        nonContacts: nonContacts,
        groups: groups,
        broadcasts: broadcasts,
        bots: bots,
        excludeMuted: excludeMuted,
        excludeRead: excludeRead,
        excludeArchived: excludeArchived,
        id: id,
        title: title,
        emoticon: emoticon,
        pinnedPeers: pinnedPeers,
        includePeers: includePeers,
        excludePeers: excludePeers,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.contacts ? 1 << 0 : 0;
      flags |= this.nonContacts ? 1 << 1 : 0;
      flags |= this.groups ? 1 << 2 : 0;
      flags |= this.broadcasts ? 1 << 3 : 0;
      flags |= this.bots ? 1 << 4 : 0;
      flags |= this.excludeMuted ? 1 << 11 : 0;
      flags |= this.excludeRead ? 1 << 12 : 0;
      flags |= this.excludeArchived ? 1 << 13 : 0;
      flags |= this.emoticon !== undefined ? 1 << 25 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.emoticon !== undefined) {
        b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
      }
      if (this.pinnedPeers) {
        b.write(Primitive.Vector.write(this.pinnedPeers) as unknown as Buffer);
      }
      if (this.includePeers) {
        b.write(Primitive.Vector.write(this.includePeers) as unknown as Buffer);
      }
      if (this.excludePeers) {
        b.write(Primitive.Vector.write(this.excludePeers) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DialogFilterDefault extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'DialogFilterDefault';
      this.constructorId = 0x363293ae;
      this.subclassOfId = 0x692bc457;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DialogFilterDefault> {
      // no flags

      return new Raw.DialogFilterDefault();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class DialogFilterChatlist extends TLObject {
    hasMyInvites?: boolean;
    id!: int;
    title!: string;
    emoticon?: string;
    pinnedPeers!: Vector<Raw.TypeInputPeer>;
    includePeers!: Vector<Raw.TypeInputPeer>;

    constructor(params: {
      hasMyInvites?: boolean;
      id: int;
      title: string;
      emoticon?: string;
      pinnedPeers: Vector<Raw.TypeInputPeer>;
      includePeers: Vector<Raw.TypeInputPeer>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DialogFilterChatlist';
      this.constructorId = 0xd64a04a8;
      this.subclassOfId = 0x692bc457;
      this._slots = ['hasMyInvites', 'id', 'title', 'emoticon', 'pinnedPeers', 'includePeers'];
      this.hasMyInvites = params.hasMyInvites;
      this.id = params.id;
      this.title = params.title;
      this.emoticon = params.emoticon;
      this.pinnedPeers = params.pinnedPeers;
      this.includePeers = params.includePeers;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DialogFilterChatlist> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let hasMyInvites = flags & (1 << 26) ? true : false;
      let id = await Primitive.Int.read(b);
      let title = await Primitive.String.read(b);
      let emoticon = flags & (1 << 25) ? await Primitive.String.read(b) : undefined;
      let pinnedPeers = await TLObject.read(b);
      let includePeers = await TLObject.read(b);
      return new Raw.DialogFilterChatlist({
        hasMyInvites: hasMyInvites,
        id: id,
        title: title,
        emoticon: emoticon,
        pinnedPeers: pinnedPeers,
        includePeers: includePeers,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.hasMyInvites ? 1 << 26 : 0;
      flags |= this.emoticon !== undefined ? 1 << 25 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.emoticon !== undefined) {
        b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
      }
      if (this.pinnedPeers) {
        b.write(Primitive.Vector.write(this.pinnedPeers) as unknown as Buffer);
      }
      if (this.includePeers) {
        b.write(Primitive.Vector.write(this.includePeers) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DialogFilterSuggested extends TLObject {
    filter!: Raw.TypeDialogFilter;
    description!: string;

    constructor(params: { filter: Raw.TypeDialogFilter; description: string }) {
      super();
      this.classType = 'types';
      this.className = 'DialogFilterSuggested';
      this.constructorId = 0x77744d4a;
      this.subclassOfId = 0x31ede086;
      this._slots = ['filter', 'description'];
      this.filter = params.filter;
      this.description = params.description;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DialogFilterSuggested> {
      // no flags

      let filter = await TLObject.read(b);
      let description = await Primitive.String.read(b);
      return new Raw.DialogFilterSuggested({ filter: filter, description: description });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.filter !== undefined) {
        b.write(this.filter.write() as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StatsDateRangeDays extends TLObject {
    minDate!: int;
    maxDate!: int;

    constructor(params: { minDate: int; maxDate: int }) {
      super();
      this.classType = 'types';
      this.className = 'StatsDateRangeDays';
      this.constructorId = 0xb637edaf;
      this.subclassOfId = 0x81236245;
      this._slots = ['minDate', 'maxDate'];
      this.minDate = params.minDate;
      this.maxDate = params.maxDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StatsDateRangeDays> {
      // no flags

      let minDate = await Primitive.Int.read(b);
      let maxDate = await Primitive.Int.read(b);
      return new Raw.StatsDateRangeDays({ minDate: minDate, maxDate: maxDate });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.minDate !== undefined) {
        b.write(Primitive.Int.write(this.minDate) as unknown as Buffer);
      }
      if (this.maxDate !== undefined) {
        b.write(Primitive.Int.write(this.maxDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StatsAbsValueAndPrev extends TLObject {
    current!: double;
    previous!: double;

    constructor(params: { current: double; previous: double }) {
      super();
      this.classType = 'types';
      this.className = 'StatsAbsValueAndPrev';
      this.constructorId = 0xcb43acde;
      this.subclassOfId = 0x3ebe59af;
      this._slots = ['current', 'previous'];
      this.current = params.current;
      this.previous = params.previous;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StatsAbsValueAndPrev> {
      // no flags

      let current = await Primitive.Double.read(b);
      let previous = await Primitive.Double.read(b);
      return new Raw.StatsAbsValueAndPrev({ current: current, previous: previous });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.current !== undefined) {
        b.write(Primitive.Double.write(this.current) as unknown as Buffer);
      }
      if (this.previous !== undefined) {
        b.write(Primitive.Double.write(this.previous) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StatsPercentValue extends TLObject {
    part!: double;
    total!: double;

    constructor(params: { part: double; total: double }) {
      super();
      this.classType = 'types';
      this.className = 'StatsPercentValue';
      this.constructorId = 0xcbce2fe0;
      this.subclassOfId = 0x9702c51e;
      this._slots = ['part', 'total'];
      this.part = params.part;
      this.total = params.total;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StatsPercentValue> {
      // no flags

      let part = await Primitive.Double.read(b);
      let total = await Primitive.Double.read(b);
      return new Raw.StatsPercentValue({ part: part, total: total });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.part !== undefined) {
        b.write(Primitive.Double.write(this.part) as unknown as Buffer);
      }
      if (this.total !== undefined) {
        b.write(Primitive.Double.write(this.total) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StatsGraphAsync extends TLObject {
    token!: string;

    constructor(params: { token: string }) {
      super();
      this.classType = 'types';
      this.className = 'StatsGraphAsync';
      this.constructorId = 0x4a27eb2d;
      this.subclassOfId = 0x9b903153;
      this._slots = ['token'];
      this.token = params.token;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StatsGraphAsync> {
      // no flags

      let token = await Primitive.String.read(b);
      return new Raw.StatsGraphAsync({ token: token });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.token !== undefined) {
        b.write(Primitive.String.write(this.token) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StatsGraphError extends TLObject {
    error!: string;

    constructor(params: { error: string }) {
      super();
      this.classType = 'types';
      this.className = 'StatsGraphError';
      this.constructorId = 0xbedc9822;
      this.subclassOfId = 0x9b903153;
      this._slots = ['error'];
      this.error = params.error;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StatsGraphError> {
      // no flags

      let error = await Primitive.String.read(b);
      return new Raw.StatsGraphError({ error: error });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.error !== undefined) {
        b.write(Primitive.String.write(this.error) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StatsGraph extends TLObject {
    json!: Raw.TypeDataJSON;
    zoomToken?: string;

    constructor(params: { json: Raw.TypeDataJSON; zoomToken?: string }) {
      super();
      this.classType = 'types';
      this.className = 'StatsGraph';
      this.constructorId = 0x8ea464b6;
      this.subclassOfId = 0x9b903153;
      this._slots = ['json', 'zoomToken'];
      this.json = params.json;
      this.zoomToken = params.zoomToken;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StatsGraph> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let json = await TLObject.read(b);
      let zoomToken = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      return new Raw.StatsGraph({ json: json, zoomToken: zoomToken });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.zoomToken !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.json !== undefined) {
        b.write(this.json.write() as unknown as Buffer);
      }
      if (this.zoomToken !== undefined) {
        b.write(Primitive.String.write(this.zoomToken) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageInteractionCounters extends TLObject {
    msgId!: int;
    views!: int;
    forwards!: int;

    constructor(params: { msgId: int; views: int; forwards: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageInteractionCounters';
      this.constructorId = 0xad4fc9bd;
      this.subclassOfId = 0x2638b720;
      this._slots = ['msgId', 'views', 'forwards'];
      this.msgId = params.msgId;
      this.views = params.views;
      this.forwards = params.forwards;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageInteractionCounters> {
      // no flags

      let msgId = await Primitive.Int.read(b);
      let views = await Primitive.Int.read(b);
      let forwards = await Primitive.Int.read(b);
      return new Raw.MessageInteractionCounters({ msgId: msgId, views: views, forwards: forwards });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      if (this.views !== undefined) {
        b.write(Primitive.Int.write(this.views) as unknown as Buffer);
      }
      if (this.forwards !== undefined) {
        b.write(Primitive.Int.write(this.forwards) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class VideoSize extends TLObject {
    type!: string;
    w!: int;
    h!: int;
    size!: int;
    videoStartTs?: double;

    constructor(params: { type: string; w: int; h: int; size: int; videoStartTs?: double }) {
      super();
      this.classType = 'types';
      this.className = 'VideoSize';
      this.constructorId = 0xde33b094;
      this.subclassOfId = 0x62f1d509;
      this._slots = ['type', 'w', 'h', 'size', 'videoStartTs'];
      this.type = params.type;
      this.w = params.w;
      this.h = params.h;
      this.size = params.size;
      this.videoStartTs = params.videoStartTs;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.VideoSize> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let type = await Primitive.String.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let size = await Primitive.Int.read(b);
      let videoStartTs = flags & (1 << 0) ? await Primitive.Double.read(b) : undefined;
      return new Raw.VideoSize({ type: type, w: w, h: h, size: size, videoStartTs: videoStartTs });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.videoStartTs !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.videoStartTs !== undefined) {
        b.write(Primitive.Double.write(this.videoStartTs) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class VideoSizeEmojiMarkup extends TLObject {
    emojiId!: long;
    backgroundColors!: Vector<int>;

    constructor(params: { emojiId: long; backgroundColors: Vector<int> }) {
      super();
      this.classType = 'types';
      this.className = 'VideoSizeEmojiMarkup';
      this.constructorId = 0xf85c413c;
      this.subclassOfId = 0x62f1d509;
      this._slots = ['emojiId', 'backgroundColors'];
      this.emojiId = params.emojiId;
      this.backgroundColors = params.backgroundColors;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.VideoSizeEmojiMarkup> {
      // no flags

      let emojiId = await Primitive.Long.read(b);
      let backgroundColors = await TLObject.read(b, Primitive.Int);
      return new Raw.VideoSizeEmojiMarkup({ emojiId: emojiId, backgroundColors: backgroundColors });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.emojiId !== undefined) {
        b.write(Primitive.Long.write(this.emojiId) as unknown as Buffer);
      }
      if (this.backgroundColors) {
        b.write(Primitive.Vector.write(this.backgroundColors, Primitive.Int) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class VideoSizeStickerMarkup extends TLObject {
    stickerset!: Raw.TypeInputStickerSet;
    stickerId!: long;
    backgroundColors!: Vector<int>;

    constructor(params: {
      stickerset: Raw.TypeInputStickerSet;
      stickerId: long;
      backgroundColors: Vector<int>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'VideoSizeStickerMarkup';
      this.constructorId = 0xda082fe;
      this.subclassOfId = 0x62f1d509;
      this._slots = ['stickerset', 'stickerId', 'backgroundColors'];
      this.stickerset = params.stickerset;
      this.stickerId = params.stickerId;
      this.backgroundColors = params.backgroundColors;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.VideoSizeStickerMarkup> {
      // no flags

      let stickerset = await TLObject.read(b);
      let stickerId = await Primitive.Long.read(b);
      let backgroundColors = await TLObject.read(b, Primitive.Int);
      return new Raw.VideoSizeStickerMarkup({
        stickerset: stickerset,
        stickerId: stickerId,
        backgroundColors: backgroundColors,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.stickerset !== undefined) {
        b.write(this.stickerset.write() as unknown as Buffer);
      }
      if (this.stickerId !== undefined) {
        b.write(Primitive.Long.write(this.stickerId) as unknown as Buffer);
      }
      if (this.backgroundColors) {
        b.write(Primitive.Vector.write(this.backgroundColors, Primitive.Int) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StatsGroupTopPoster extends TLObject {
    userId!: long;
    messages!: int;
    avgChars!: int;

    constructor(params: { userId: long; messages: int; avgChars: int }) {
      super();
      this.classType = 'types';
      this.className = 'StatsGroupTopPoster';
      this.constructorId = 0x9d04af9b;
      this.subclassOfId = 0x81c5ce23;
      this._slots = ['userId', 'messages', 'avgChars'];
      this.userId = params.userId;
      this.messages = params.messages;
      this.avgChars = params.avgChars;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StatsGroupTopPoster> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let messages = await Primitive.Int.read(b);
      let avgChars = await Primitive.Int.read(b);
      return new Raw.StatsGroupTopPoster({
        userId: userId,
        messages: messages,
        avgChars: avgChars,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.messages !== undefined) {
        b.write(Primitive.Int.write(this.messages) as unknown as Buffer);
      }
      if (this.avgChars !== undefined) {
        b.write(Primitive.Int.write(this.avgChars) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StatsGroupTopAdmin extends TLObject {
    userId!: long;
    deleted!: int;
    kicked!: int;
    banned!: int;

    constructor(params: { userId: long; deleted: int; kicked: int; banned: int }) {
      super();
      this.classType = 'types';
      this.className = 'StatsGroupTopAdmin';
      this.constructorId = 0xd7584c87;
      this.subclassOfId = 0x80359c5d;
      this._slots = ['userId', 'deleted', 'kicked', 'banned'];
      this.userId = params.userId;
      this.deleted = params.deleted;
      this.kicked = params.kicked;
      this.banned = params.banned;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StatsGroupTopAdmin> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let deleted = await Primitive.Int.read(b);
      let kicked = await Primitive.Int.read(b);
      let banned = await Primitive.Int.read(b);
      return new Raw.StatsGroupTopAdmin({
        userId: userId,
        deleted: deleted,
        kicked: kicked,
        banned: banned,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.deleted !== undefined) {
        b.write(Primitive.Int.write(this.deleted) as unknown as Buffer);
      }
      if (this.kicked !== undefined) {
        b.write(Primitive.Int.write(this.kicked) as unknown as Buffer);
      }
      if (this.banned !== undefined) {
        b.write(Primitive.Int.write(this.banned) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StatsGroupTopInviter extends TLObject {
    userId!: long;
    invitations!: int;

    constructor(params: { userId: long; invitations: int }) {
      super();
      this.classType = 'types';
      this.className = 'StatsGroupTopInviter';
      this.constructorId = 0x535f779d;
      this.subclassOfId = 0x85010c7a;
      this._slots = ['userId', 'invitations'];
      this.userId = params.userId;
      this.invitations = params.invitations;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StatsGroupTopInviter> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let invitations = await Primitive.Int.read(b);
      return new Raw.StatsGroupTopInviter({ userId: userId, invitations: invitations });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.invitations !== undefined) {
        b.write(Primitive.Int.write(this.invitations) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class GlobalPrivacySettings extends TLObject {
    archiveAndMuteNewNoncontactPeers?: boolean;
    keepArchivedUnmuted?: boolean;
    keepArchivedFolders?: boolean;

    constructor(params: {
      archiveAndMuteNewNoncontactPeers?: boolean;
      keepArchivedUnmuted?: boolean;
      keepArchivedFolders?: boolean;
    }) {
      super();
      this.classType = 'types';
      this.className = 'GlobalPrivacySettings';
      this.constructorId = 0x734c4ccb;
      this.subclassOfId = 0xc90e5770;
      this._slots = [
        'archiveAndMuteNewNoncontactPeers',
        'keepArchivedUnmuted',
        'keepArchivedFolders',
      ];
      this.archiveAndMuteNewNoncontactPeers = params.archiveAndMuteNewNoncontactPeers;
      this.keepArchivedUnmuted = params.keepArchivedUnmuted;
      this.keepArchivedFolders = params.keepArchivedFolders;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.GlobalPrivacySettings> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let archiveAndMuteNewNoncontactPeers = flags & (1 << 0) ? true : false;
      let keepArchivedUnmuted = flags & (1 << 1) ? true : false;
      let keepArchivedFolders = flags & (1 << 2) ? true : false;
      return new Raw.GlobalPrivacySettings({
        archiveAndMuteNewNoncontactPeers: archiveAndMuteNewNoncontactPeers,
        keepArchivedUnmuted: keepArchivedUnmuted,
        keepArchivedFolders: keepArchivedFolders,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.archiveAndMuteNewNoncontactPeers ? 1 << 0 : 0;
      flags |= this.keepArchivedUnmuted ? 1 << 1 : 0;
      flags |= this.keepArchivedFolders ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      return b.buffer;
    }
  }
  export class MessageViews extends TLObject {
    views?: int;
    forwards?: int;
    replies?: Raw.TypeMessageReplies;

    constructor(params: { views?: int; forwards?: int; replies?: Raw.TypeMessageReplies }) {
      super();
      this.classType = 'types';
      this.className = 'MessageViews';
      this.constructorId = 0x455b853d;
      this.subclassOfId = 0x3cb083b9;
      this._slots = ['views', 'forwards', 'replies'];
      this.views = params.views;
      this.forwards = params.forwards;
      this.replies = params.replies;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageViews> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let views = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let forwards = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      let replies = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.MessageViews({ views: views, forwards: forwards, replies: replies });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.views !== undefined ? 1 << 0 : 0;
      flags |= this.forwards !== undefined ? 1 << 1 : 0;
      flags |= this.replies !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.views !== undefined) {
        b.write(Primitive.Int.write(this.views) as unknown as Buffer);
      }
      if (this.forwards !== undefined) {
        b.write(Primitive.Int.write(this.forwards) as unknown as Buffer);
      }
      if (this.replies !== undefined) {
        b.write(this.replies.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageReplyHeader extends TLObject {
    replyToScheduled?: boolean;
    forumTopic?: boolean;
    quote?: boolean;
    replyToMsgId?: int;
    replyToPeerId?: Raw.TypePeer;
    replyFrom?: Raw.TypeMessageFwdHeader;
    replyMedia?: Raw.TypeMessageMedia;
    replyToTopId?: int;
    quoteText?: string;
    quoteEntities?: Vector<Raw.TypeMessageEntity>;

    constructor(params: {
      replyToScheduled?: boolean;
      forumTopic?: boolean;
      quote?: boolean;
      replyToMsgId?: int;
      replyToPeerId?: Raw.TypePeer;
      replyFrom?: Raw.TypeMessageFwdHeader;
      replyMedia?: Raw.TypeMessageMedia;
      replyToTopId?: int;
      quoteText?: string;
      quoteEntities?: Vector<Raw.TypeMessageEntity>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageReplyHeader';
      this.constructorId = 0x6eebcabd;
      this.subclassOfId = 0x5b4d9167;
      this._slots = [
        'replyToScheduled',
        'forumTopic',
        'quote',
        'replyToMsgId',
        'replyToPeerId',
        'replyFrom',
        'replyMedia',
        'replyToTopId',
        'quoteText',
        'quoteEntities',
      ];
      this.replyToScheduled = params.replyToScheduled;
      this.forumTopic = params.forumTopic;
      this.quote = params.quote;
      this.replyToMsgId = params.replyToMsgId;
      this.replyToPeerId = params.replyToPeerId;
      this.replyFrom = params.replyFrom;
      this.replyMedia = params.replyMedia;
      this.replyToTopId = params.replyToTopId;
      this.quoteText = params.quoteText;
      this.quoteEntities = params.quoteEntities;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageReplyHeader> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let replyToScheduled = flags & (1 << 2) ? true : false;
      let forumTopic = flags & (1 << 3) ? true : false;
      let quote = flags & (1 << 9) ? true : false;
      let replyToMsgId = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      let replyToPeerId = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let replyFrom = flags & (1 << 5) ? await TLObject.read(b) : undefined;
      let replyMedia = flags & (1 << 8) ? await TLObject.read(b) : undefined;
      let replyToTopId = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      let quoteText = flags & (1 << 6) ? await Primitive.String.read(b) : undefined;
      let quoteEntities = flags & (1 << 7) ? await TLObject.read(b) : [];
      return new Raw.MessageReplyHeader({
        replyToScheduled: replyToScheduled,
        forumTopic: forumTopic,
        quote: quote,
        replyToMsgId: replyToMsgId,
        replyToPeerId: replyToPeerId,
        replyFrom: replyFrom,
        replyMedia: replyMedia,
        replyToTopId: replyToTopId,
        quoteText: quoteText,
        quoteEntities: quoteEntities,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.replyToScheduled ? 1 << 2 : 0;
      flags |= this.forumTopic ? 1 << 3 : 0;
      flags |= this.quote ? 1 << 9 : 0;
      flags |= this.replyToMsgId !== undefined ? 1 << 4 : 0;
      flags |= this.replyToPeerId !== undefined ? 1 << 0 : 0;
      flags |= this.replyFrom !== undefined ? 1 << 5 : 0;
      flags |= this.replyMedia !== undefined ? 1 << 8 : 0;
      flags |= this.replyToTopId !== undefined ? 1 << 1 : 0;
      flags |= this.quoteText !== undefined ? 1 << 6 : 0;
      flags |= this.quoteEntities ? 1 << 7 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.replyToMsgId !== undefined) {
        b.write(Primitive.Int.write(this.replyToMsgId) as unknown as Buffer);
      }
      if (this.replyToPeerId !== undefined) {
        b.write(this.replyToPeerId.write() as unknown as Buffer);
      }
      if (this.replyFrom !== undefined) {
        b.write(this.replyFrom.write() as unknown as Buffer);
      }
      if (this.replyMedia !== undefined) {
        b.write(this.replyMedia.write() as unknown as Buffer);
      }
      if (this.replyToTopId !== undefined) {
        b.write(Primitive.Int.write(this.replyToTopId) as unknown as Buffer);
      }
      if (this.quoteText !== undefined) {
        b.write(Primitive.String.write(this.quoteText) as unknown as Buffer);
      }
      if (this.quoteEntities) {
        b.write(Primitive.Vector.write(this.quoteEntities) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageReplyStoryHeader extends TLObject {
    userId!: long;
    storyId!: int;

    constructor(params: { userId: long; storyId: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageReplyStoryHeader';
      this.constructorId = 0x9c98bfc1;
      this.subclassOfId = 0x5b4d9167;
      this._slots = ['userId', 'storyId'];
      this.userId = params.userId;
      this.storyId = params.storyId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageReplyStoryHeader> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let storyId = await Primitive.Int.read(b);
      return new Raw.MessageReplyStoryHeader({ userId: userId, storyId: storyId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.storyId !== undefined) {
        b.write(Primitive.Int.write(this.storyId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageReplies extends TLObject {
    comments?: boolean;
    replies!: int;
    repliesPts!: int;
    recentRepliers?: Vector<Raw.TypePeer>;
    channelId?: long;
    maxId?: int;
    readMaxId?: int;

    constructor(params: {
      comments?: boolean;
      replies: int;
      repliesPts: int;
      recentRepliers?: Vector<Raw.TypePeer>;
      channelId?: long;
      maxId?: int;
      readMaxId?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageReplies';
      this.constructorId = 0x83d60fc2;
      this.subclassOfId = 0x6ccd5ce2;
      this._slots = [
        'comments',
        'replies',
        'repliesPts',
        'recentRepliers',
        'channelId',
        'maxId',
        'readMaxId',
      ];
      this.comments = params.comments;
      this.replies = params.replies;
      this.repliesPts = params.repliesPts;
      this.recentRepliers = params.recentRepliers;
      this.channelId = params.channelId;
      this.maxId = params.maxId;
      this.readMaxId = params.readMaxId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageReplies> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let comments = flags & (1 << 0) ? true : false;
      let replies = await Primitive.Int.read(b);
      let repliesPts = await Primitive.Int.read(b);
      let recentRepliers = flags & (1 << 1) ? await TLObject.read(b) : [];
      let channelId = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
      let maxId = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let readMaxId = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
      return new Raw.MessageReplies({
        comments: comments,
        replies: replies,
        repliesPts: repliesPts,
        recentRepliers: recentRepliers,
        channelId: channelId,
        maxId: maxId,
        readMaxId: readMaxId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.comments ? 1 << 0 : 0;
      flags |= this.recentRepliers ? 1 << 1 : 0;
      flags |= this.channelId !== undefined ? 1 << 0 : 0;
      flags |= this.maxId !== undefined ? 1 << 2 : 0;
      flags |= this.readMaxId !== undefined ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.replies !== undefined) {
        b.write(Primitive.Int.write(this.replies) as unknown as Buffer);
      }
      if (this.repliesPts !== undefined) {
        b.write(Primitive.Int.write(this.repliesPts) as unknown as Buffer);
      }
      if (this.recentRepliers) {
        b.write(Primitive.Vector.write(this.recentRepliers) as unknown as Buffer);
      }
      if (this.channelId !== undefined) {
        b.write(Primitive.Long.write(this.channelId) as unknown as Buffer);
      }
      if (this.maxId !== undefined) {
        b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
      }
      if (this.readMaxId !== undefined) {
        b.write(Primitive.Int.write(this.readMaxId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PeerBlocked extends TLObject {
    peerId!: Raw.TypePeer;
    date!: int;

    constructor(params: { peerId: Raw.TypePeer; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'PeerBlocked';
      this.constructorId = 0xe8fd8014;
      this.subclassOfId = 0x54f2fc98;
      this._slots = ['peerId', 'date'];
      this.peerId = params.peerId;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PeerBlocked> {
      // no flags

      let peerId = await TLObject.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.PeerBlocked({ peerId: peerId, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peerId !== undefined) {
        b.write(this.peerId.write() as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class GroupCallDiscarded extends TLObject {
    id!: long;
    accessHash!: long;
    duration!: int;

    constructor(params: { id: long; accessHash: long; duration: int }) {
      super();
      this.classType = 'types';
      this.className = 'GroupCallDiscarded';
      this.constructorId = 0x7780bcb4;
      this.subclassOfId = 0x20b4f320;
      this._slots = ['id', 'accessHash', 'duration'];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.duration = params.duration;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.GroupCallDiscarded> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let duration = await Primitive.Int.read(b);
      return new Raw.GroupCallDiscarded({ id: id, accessHash: accessHash, duration: duration });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class GroupCall extends TLObject {
    joinMuted?: boolean;
    canChangeJoinMuted?: boolean;
    joinDateAsc?: boolean;
    scheduleStartSubscribed?: boolean;
    canStartVideo?: boolean;
    recordVideoActive?: boolean;
    rtmpStream?: boolean;
    listenersHidden?: boolean;
    id!: long;
    accessHash!: long;
    participantsCount!: int;
    title?: string;
    streamDcId?: int;
    recordStartDate?: int;
    scheduleDate?: int;
    unmutedVideoCount?: int;
    unmutedVideoLimit!: int;
    version!: int;

    constructor(params: {
      joinMuted?: boolean;
      canChangeJoinMuted?: boolean;
      joinDateAsc?: boolean;
      scheduleStartSubscribed?: boolean;
      canStartVideo?: boolean;
      recordVideoActive?: boolean;
      rtmpStream?: boolean;
      listenersHidden?: boolean;
      id: long;
      accessHash: long;
      participantsCount: int;
      title?: string;
      streamDcId?: int;
      recordStartDate?: int;
      scheduleDate?: int;
      unmutedVideoCount?: int;
      unmutedVideoLimit: int;
      version: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'GroupCall';
      this.constructorId = 0xd597650c;
      this.subclassOfId = 0x20b4f320;
      this._slots = [
        'joinMuted',
        'canChangeJoinMuted',
        'joinDateAsc',
        'scheduleStartSubscribed',
        'canStartVideo',
        'recordVideoActive',
        'rtmpStream',
        'listenersHidden',
        'id',
        'accessHash',
        'participantsCount',
        'title',
        'streamDcId',
        'recordStartDate',
        'scheduleDate',
        'unmutedVideoCount',
        'unmutedVideoLimit',
        'version',
      ];
      this.joinMuted = params.joinMuted;
      this.canChangeJoinMuted = params.canChangeJoinMuted;
      this.joinDateAsc = params.joinDateAsc;
      this.scheduleStartSubscribed = params.scheduleStartSubscribed;
      this.canStartVideo = params.canStartVideo;
      this.recordVideoActive = params.recordVideoActive;
      this.rtmpStream = params.rtmpStream;
      this.listenersHidden = params.listenersHidden;
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.participantsCount = params.participantsCount;
      this.title = params.title;
      this.streamDcId = params.streamDcId;
      this.recordStartDate = params.recordStartDate;
      this.scheduleDate = params.scheduleDate;
      this.unmutedVideoCount = params.unmutedVideoCount;
      this.unmutedVideoLimit = params.unmutedVideoLimit;
      this.version = params.version;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.GroupCall> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let joinMuted = flags & (1 << 1) ? true : false;
      let canChangeJoinMuted = flags & (1 << 2) ? true : false;
      let joinDateAsc = flags & (1 << 6) ? true : false;
      let scheduleStartSubscribed = flags & (1 << 8) ? true : false;
      let canStartVideo = flags & (1 << 9) ? true : false;
      let recordVideoActive = flags & (1 << 11) ? true : false;
      let rtmpStream = flags & (1 << 12) ? true : false;
      let listenersHidden = flags & (1 << 13) ? true : false;
      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let participantsCount = await Primitive.Int.read(b);
      let title = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
      let streamDcId = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      let recordStartDate = flags & (1 << 5) ? await Primitive.Int.read(b) : undefined;
      let scheduleDate = flags & (1 << 7) ? await Primitive.Int.read(b) : undefined;
      let unmutedVideoCount = flags & (1 << 10) ? await Primitive.Int.read(b) : undefined;
      let unmutedVideoLimit = await Primitive.Int.read(b);
      let version = await Primitive.Int.read(b);
      return new Raw.GroupCall({
        joinMuted: joinMuted,
        canChangeJoinMuted: canChangeJoinMuted,
        joinDateAsc: joinDateAsc,
        scheduleStartSubscribed: scheduleStartSubscribed,
        canStartVideo: canStartVideo,
        recordVideoActive: recordVideoActive,
        rtmpStream: rtmpStream,
        listenersHidden: listenersHidden,
        id: id,
        accessHash: accessHash,
        participantsCount: participantsCount,
        title: title,
        streamDcId: streamDcId,
        recordStartDate: recordStartDate,
        scheduleDate: scheduleDate,
        unmutedVideoCount: unmutedVideoCount,
        unmutedVideoLimit: unmutedVideoLimit,
        version: version,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.joinMuted ? 1 << 1 : 0;
      flags |= this.canChangeJoinMuted ? 1 << 2 : 0;
      flags |= this.joinDateAsc ? 1 << 6 : 0;
      flags |= this.scheduleStartSubscribed ? 1 << 8 : 0;
      flags |= this.canStartVideo ? 1 << 9 : 0;
      flags |= this.recordVideoActive ? 1 << 11 : 0;
      flags |= this.rtmpStream ? 1 << 12 : 0;
      flags |= this.listenersHidden ? 1 << 13 : 0;
      flags |= this.title !== undefined ? 1 << 3 : 0;
      flags |= this.streamDcId !== undefined ? 1 << 4 : 0;
      flags |= this.recordStartDate !== undefined ? 1 << 5 : 0;
      flags |= this.scheduleDate !== undefined ? 1 << 7 : 0;
      flags |= this.unmutedVideoCount !== undefined ? 1 << 10 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.participantsCount !== undefined) {
        b.write(Primitive.Int.write(this.participantsCount) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.streamDcId !== undefined) {
        b.write(Primitive.Int.write(this.streamDcId) as unknown as Buffer);
      }
      if (this.recordStartDate !== undefined) {
        b.write(Primitive.Int.write(this.recordStartDate) as unknown as Buffer);
      }
      if (this.scheduleDate !== undefined) {
        b.write(Primitive.Int.write(this.scheduleDate) as unknown as Buffer);
      }
      if (this.unmutedVideoCount !== undefined) {
        b.write(Primitive.Int.write(this.unmutedVideoCount) as unknown as Buffer);
      }
      if (this.unmutedVideoLimit !== undefined) {
        b.write(Primitive.Int.write(this.unmutedVideoLimit) as unknown as Buffer);
      }
      if (this.version !== undefined) {
        b.write(Primitive.Int.write(this.version) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputGroupCall extends TLObject {
    id!: long;
    accessHash!: long;

    constructor(params: { id: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputGroupCall';
      this.constructorId = 0xd8aa840f;
      this.subclassOfId = 0x58611ab1;
      this._slots = ['id', 'accessHash'];
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputGroupCall> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputGroupCall({ id: id, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class GroupCallParticipant extends TLObject {
    muted?: boolean;
    left?: boolean;
    canSelfUnmute?: boolean;
    justJoined?: boolean;
    versioned?: boolean;
    min?: boolean;
    mutedByYou?: boolean;
    volumeByAdmin?: boolean;
    self?: boolean;
    videoJoined?: boolean;
    peer!: Raw.TypePeer;
    date!: int;
    activeDate?: int;
    source!: int;
    volume?: int;
    about?: string;
    raiseHandRating?: long;
    video?: Raw.TypeGroupCallParticipantVideo;
    presentation?: Raw.TypeGroupCallParticipantVideo;

    constructor(params: {
      muted?: boolean;
      left?: boolean;
      canSelfUnmute?: boolean;
      justJoined?: boolean;
      versioned?: boolean;
      min?: boolean;
      mutedByYou?: boolean;
      volumeByAdmin?: boolean;
      self?: boolean;
      videoJoined?: boolean;
      peer: Raw.TypePeer;
      date: int;
      activeDate?: int;
      source: int;
      volume?: int;
      about?: string;
      raiseHandRating?: long;
      video?: Raw.TypeGroupCallParticipantVideo;
      presentation?: Raw.TypeGroupCallParticipantVideo;
    }) {
      super();
      this.classType = 'types';
      this.className = 'GroupCallParticipant';
      this.constructorId = 0xeba636fe;
      this.subclassOfId = 0xc01aaf4c;
      this._slots = [
        'muted',
        'left',
        'canSelfUnmute',
        'justJoined',
        'versioned',
        'min',
        'mutedByYou',
        'volumeByAdmin',
        'self',
        'videoJoined',
        'peer',
        'date',
        'activeDate',
        'source',
        'volume',
        'about',
        'raiseHandRating',
        'video',
        'presentation',
      ];
      this.muted = params.muted;
      this.left = params.left;
      this.canSelfUnmute = params.canSelfUnmute;
      this.justJoined = params.justJoined;
      this.versioned = params.versioned;
      this.min = params.min;
      this.mutedByYou = params.mutedByYou;
      this.volumeByAdmin = params.volumeByAdmin;
      this.self = params.self;
      this.videoJoined = params.videoJoined;
      this.peer = params.peer;
      this.date = params.date;
      this.activeDate = params.activeDate;
      this.source = params.source;
      this.volume = params.volume;
      this.about = params.about;
      this.raiseHandRating = params.raiseHandRating;
      this.video = params.video;
      this.presentation = params.presentation;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.GroupCallParticipant> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let muted = flags & (1 << 0) ? true : false;
      let left = flags & (1 << 1) ? true : false;
      let canSelfUnmute = flags & (1 << 2) ? true : false;
      let justJoined = flags & (1 << 4) ? true : false;
      let versioned = flags & (1 << 5) ? true : false;
      let min = flags & (1 << 8) ? true : false;
      let mutedByYou = flags & (1 << 9) ? true : false;
      let volumeByAdmin = flags & (1 << 10) ? true : false;
      let self = flags & (1 << 12) ? true : false;
      let videoJoined = flags & (1 << 15) ? true : false;
      let peer = await TLObject.read(b);
      let date = await Primitive.Int.read(b);
      let activeDate = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
      let source = await Primitive.Int.read(b);
      let volume = flags & (1 << 7) ? await Primitive.Int.read(b) : undefined;
      let about = flags & (1 << 11) ? await Primitive.String.read(b) : undefined;
      let raiseHandRating = flags & (1 << 13) ? await Primitive.Long.read(b) : undefined;
      let video = flags & (1 << 6) ? await TLObject.read(b) : undefined;
      let presentation = flags & (1 << 14) ? await TLObject.read(b) : undefined;
      return new Raw.GroupCallParticipant({
        muted: muted,
        left: left,
        canSelfUnmute: canSelfUnmute,
        justJoined: justJoined,
        versioned: versioned,
        min: min,
        mutedByYou: mutedByYou,
        volumeByAdmin: volumeByAdmin,
        self: self,
        videoJoined: videoJoined,
        peer: peer,
        date: date,
        activeDate: activeDate,
        source: source,
        volume: volume,
        about: about,
        raiseHandRating: raiseHandRating,
        video: video,
        presentation: presentation,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.muted ? 1 << 0 : 0;
      flags |= this.left ? 1 << 1 : 0;
      flags |= this.canSelfUnmute ? 1 << 2 : 0;
      flags |= this.justJoined ? 1 << 4 : 0;
      flags |= this.versioned ? 1 << 5 : 0;
      flags |= this.min ? 1 << 8 : 0;
      flags |= this.mutedByYou ? 1 << 9 : 0;
      flags |= this.volumeByAdmin ? 1 << 10 : 0;
      flags |= this.self ? 1 << 12 : 0;
      flags |= this.videoJoined ? 1 << 15 : 0;
      flags |= this.activeDate !== undefined ? 1 << 3 : 0;
      flags |= this.volume !== undefined ? 1 << 7 : 0;
      flags |= this.about !== undefined ? 1 << 11 : 0;
      flags |= this.raiseHandRating !== undefined ? 1 << 13 : 0;
      flags |= this.video !== undefined ? 1 << 6 : 0;
      flags |= this.presentation !== undefined ? 1 << 14 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.activeDate !== undefined) {
        b.write(Primitive.Int.write(this.activeDate) as unknown as Buffer);
      }
      if (this.source !== undefined) {
        b.write(Primitive.Int.write(this.source) as unknown as Buffer);
      }
      if (this.volume !== undefined) {
        b.write(Primitive.Int.write(this.volume) as unknown as Buffer);
      }
      if (this.about !== undefined) {
        b.write(Primitive.String.write(this.about) as unknown as Buffer);
      }
      if (this.raiseHandRating !== undefined) {
        b.write(Primitive.Long.write(this.raiseHandRating) as unknown as Buffer);
      }
      if (this.video !== undefined) {
        b.write(this.video.write() as unknown as Buffer);
      }
      if (this.presentation !== undefined) {
        b.write(this.presentation.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InlineQueryPeerTypeSameBotPM extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InlineQueryPeerTypeSameBotPM';
      this.constructorId = 0x3081ed9d;
      this.subclassOfId = 0xafb0fa1f;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InlineQueryPeerTypeSameBotPM> {
      // no flags

      return new Raw.InlineQueryPeerTypeSameBotPM();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InlineQueryPeerTypePM extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InlineQueryPeerTypePM';
      this.constructorId = 0x833c0fac;
      this.subclassOfId = 0xafb0fa1f;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InlineQueryPeerTypePM> {
      // no flags

      return new Raw.InlineQueryPeerTypePM();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InlineQueryPeerTypeChat extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InlineQueryPeerTypeChat';
      this.constructorId = 0xd766c50a;
      this.subclassOfId = 0xafb0fa1f;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InlineQueryPeerTypeChat> {
      // no flags

      return new Raw.InlineQueryPeerTypeChat();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InlineQueryPeerTypeMegagroup extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InlineQueryPeerTypeMegagroup';
      this.constructorId = 0x5ec4be43;
      this.subclassOfId = 0xafb0fa1f;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InlineQueryPeerTypeMegagroup> {
      // no flags

      return new Raw.InlineQueryPeerTypeMegagroup();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InlineQueryPeerTypeBroadcast extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InlineQueryPeerTypeBroadcast';
      this.constructorId = 0x6334ee9a;
      this.subclassOfId = 0xafb0fa1f;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InlineQueryPeerTypeBroadcast> {
      // no flags

      return new Raw.InlineQueryPeerTypeBroadcast();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InlineQueryPeerTypeBotPM extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'InlineQueryPeerTypeBotPM';
      this.constructorId = 0xe3b2d0c;
      this.subclassOfId = 0xafb0fa1f;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InlineQueryPeerTypeBotPM> {
      // no flags

      return new Raw.InlineQueryPeerTypeBotPM();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChatInviteImporter extends TLObject {
    requested?: boolean;
    viaChatlist?: boolean;
    userId!: long;
    date!: int;
    about?: string;
    approvedBy?: long;

    constructor(params: {
      requested?: boolean;
      viaChatlist?: boolean;
      userId: long;
      date: int;
      about?: string;
      approvedBy?: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ChatInviteImporter';
      this.constructorId = 0x8c5adfd9;
      this.subclassOfId = 0x5312542e;
      this._slots = ['requested', 'viaChatlist', 'userId', 'date', 'about', 'approvedBy'];
      this.requested = params.requested;
      this.viaChatlist = params.viaChatlist;
      this.userId = params.userId;
      this.date = params.date;
      this.about = params.about;
      this.approvedBy = params.approvedBy;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatInviteImporter> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let requested = flags & (1 << 0) ? true : false;
      let viaChatlist = flags & (1 << 3) ? true : false;
      let userId = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let about = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      let approvedBy = flags & (1 << 1) ? await Primitive.Long.read(b) : undefined;
      return new Raw.ChatInviteImporter({
        requested: requested,
        viaChatlist: viaChatlist,
        userId: userId,
        date: date,
        about: about,
        approvedBy: approvedBy,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.requested ? 1 << 0 : 0;
      flags |= this.viaChatlist ? 1 << 3 : 0;
      flags |= this.about !== undefined ? 1 << 2 : 0;
      flags |= this.approvedBy !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.about !== undefined) {
        b.write(Primitive.String.write(this.about) as unknown as Buffer);
      }
      if (this.approvedBy !== undefined) {
        b.write(Primitive.Long.write(this.approvedBy) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatAdminWithInvites extends TLObject {
    adminId!: long;
    invitesCount!: int;
    revokedInvitesCount!: int;

    constructor(params: { adminId: long; invitesCount: int; revokedInvitesCount: int }) {
      super();
      this.classType = 'types';
      this.className = 'ChatAdminWithInvites';
      this.constructorId = 0xf2ecef23;
      this.subclassOfId = 0x5063f398;
      this._slots = ['adminId', 'invitesCount', 'revokedInvitesCount'];
      this.adminId = params.adminId;
      this.invitesCount = params.invitesCount;
      this.revokedInvitesCount = params.revokedInvitesCount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatAdminWithInvites> {
      // no flags

      let adminId = await Primitive.Long.read(b);
      let invitesCount = await Primitive.Int.read(b);
      let revokedInvitesCount = await Primitive.Int.read(b);
      return new Raw.ChatAdminWithInvites({
        adminId: adminId,
        invitesCount: invitesCount,
        revokedInvitesCount: revokedInvitesCount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.adminId !== undefined) {
        b.write(Primitive.Long.write(this.adminId) as unknown as Buffer);
      }
      if (this.invitesCount !== undefined) {
        b.write(Primitive.Int.write(this.invitesCount) as unknown as Buffer);
      }
      if (this.revokedInvitesCount !== undefined) {
        b.write(Primitive.Int.write(this.revokedInvitesCount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class GroupCallParticipantVideoSourceGroup extends TLObject {
    semantics!: string;
    sources!: Vector<int>;

    constructor(params: { semantics: string; sources: Vector<int> }) {
      super();
      this.classType = 'types';
      this.className = 'GroupCallParticipantVideoSourceGroup';
      this.constructorId = 0xdcb118b7;
      this.subclassOfId = 0x3015f87c;
      this._slots = ['semantics', 'sources'];
      this.semantics = params.semantics;
      this.sources = params.sources;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.GroupCallParticipantVideoSourceGroup> {
      // no flags

      let semantics = await Primitive.String.read(b);
      let sources = await TLObject.read(b, Primitive.Int);
      return new Raw.GroupCallParticipantVideoSourceGroup({
        semantics: semantics,
        sources: sources,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.semantics !== undefined) {
        b.write(Primitive.String.write(this.semantics) as unknown as Buffer);
      }
      if (this.sources) {
        b.write(Primitive.Vector.write(this.sources, Primitive.Int) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class GroupCallParticipantVideo extends TLObject {
    paused?: boolean;
    endpoint!: string;
    sourceGroups!: Vector<Raw.TypeGroupCallParticipantVideoSourceGroup>;
    audioSource?: int;

    constructor(params: {
      paused?: boolean;
      endpoint: string;
      sourceGroups: Vector<Raw.TypeGroupCallParticipantVideoSourceGroup>;
      audioSource?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'GroupCallParticipantVideo';
      this.constructorId = 0x67753ac8;
      this.subclassOfId = 0xef46b8db;
      this._slots = ['paused', 'endpoint', 'sourceGroups', 'audioSource'];
      this.paused = params.paused;
      this.endpoint = params.endpoint;
      this.sourceGroups = params.sourceGroups;
      this.audioSource = params.audioSource;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.GroupCallParticipantVideo> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let paused = flags & (1 << 0) ? true : false;
      let endpoint = await Primitive.String.read(b);
      let sourceGroups = await TLObject.read(b);
      let audioSource = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      return new Raw.GroupCallParticipantVideo({
        paused: paused,
        endpoint: endpoint,
        sourceGroups: sourceGroups,
        audioSource: audioSource,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.paused ? 1 << 0 : 0;
      flags |= this.audioSource !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.endpoint !== undefined) {
        b.write(Primitive.String.write(this.endpoint) as unknown as Buffer);
      }
      if (this.sourceGroups) {
        b.write(Primitive.Vector.write(this.sourceGroups) as unknown as Buffer);
      }
      if (this.audioSource !== undefined) {
        b.write(Primitive.Int.write(this.audioSource) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotCommandScopeDefault extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'BotCommandScopeDefault';
      this.constructorId = 0x2f6cb2ab;
      this.subclassOfId = 0x4baf5d10;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotCommandScopeDefault> {
      // no flags

      return new Raw.BotCommandScopeDefault();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class BotCommandScopeUsers extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'BotCommandScopeUsers';
      this.constructorId = 0x3c4f04d8;
      this.subclassOfId = 0x4baf5d10;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotCommandScopeUsers> {
      // no flags

      return new Raw.BotCommandScopeUsers();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class BotCommandScopeChats extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'BotCommandScopeChats';
      this.constructorId = 0x6fe1a881;
      this.subclassOfId = 0x4baf5d10;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotCommandScopeChats> {
      // no flags

      return new Raw.BotCommandScopeChats();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class BotCommandScopeChatAdmins extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'BotCommandScopeChatAdmins';
      this.constructorId = 0xb9aa606a;
      this.subclassOfId = 0x4baf5d10;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotCommandScopeChatAdmins> {
      // no flags

      return new Raw.BotCommandScopeChatAdmins();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class BotCommandScopePeer extends TLObject {
    peer!: Raw.TypeInputPeer;

    constructor(params: { peer: Raw.TypeInputPeer }) {
      super();
      this.classType = 'types';
      this.className = 'BotCommandScopePeer';
      this.constructorId = 0xdb9d897d;
      this.subclassOfId = 0x4baf5d10;
      this._slots = ['peer'];
      this.peer = params.peer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotCommandScopePeer> {
      // no flags

      let peer = await TLObject.read(b);
      return new Raw.BotCommandScopePeer({ peer: peer });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotCommandScopePeerAdmins extends TLObject {
    peer!: Raw.TypeInputPeer;

    constructor(params: { peer: Raw.TypeInputPeer }) {
      super();
      this.classType = 'types';
      this.className = 'BotCommandScopePeerAdmins';
      this.constructorId = 0x3fd863d1;
      this.subclassOfId = 0x4baf5d10;
      this._slots = ['peer'];
      this.peer = params.peer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotCommandScopePeerAdmins> {
      // no flags

      let peer = await TLObject.read(b);
      return new Raw.BotCommandScopePeerAdmins({ peer: peer });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotCommandScopePeerUser extends TLObject {
    peer!: Raw.TypeInputPeer;
    userId!: Raw.TypeInputUser;

    constructor(params: { peer: Raw.TypeInputPeer; userId: Raw.TypeInputUser }) {
      super();
      this.classType = 'types';
      this.className = 'BotCommandScopePeerUser';
      this.constructorId = 0xa1321f3;
      this.subclassOfId = 0x4baf5d10;
      this._slots = ['peer', 'userId'];
      this.peer = params.peer;
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotCommandScopePeerUser> {
      // no flags

      let peer = await TLObject.read(b);
      let userId = await TLObject.read(b);
      return new Raw.BotCommandScopePeerUser({ peer: peer, userId: userId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(this.userId.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SponsoredMessage extends TLObject {
    recommended?: boolean;
    showPeerPhoto?: boolean;
    randomId!: bytes;
    fromId?: Raw.TypePeer;
    chatInvite?: Raw.TypeChatInvite;
    chatInviteHash?: string;
    channelPost?: int;
    startParam?: string;
    webpage?: Raw.TypeSponsoredWebPage;
    message!: string;
    entities?: Vector<Raw.TypeMessageEntity>;
    sponsorInfo?: string;
    additionalInfo?: string;

    constructor(params: {
      recommended?: boolean;
      showPeerPhoto?: boolean;
      randomId: bytes;
      fromId?: Raw.TypePeer;
      chatInvite?: Raw.TypeChatInvite;
      chatInviteHash?: string;
      channelPost?: int;
      startParam?: string;
      webpage?: Raw.TypeSponsoredWebPage;
      message: string;
      entities?: Vector<Raw.TypeMessageEntity>;
      sponsorInfo?: string;
      additionalInfo?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'SponsoredMessage';
      this.constructorId = 0xdaafff6b;
      this.subclassOfId = 0xe157d836;
      this._slots = [
        'recommended',
        'showPeerPhoto',
        'randomId',
        'fromId',
        'chatInvite',
        'chatInviteHash',
        'channelPost',
        'startParam',
        'webpage',
        'message',
        'entities',
        'sponsorInfo',
        'additionalInfo',
      ];
      this.recommended = params.recommended;
      this.showPeerPhoto = params.showPeerPhoto;
      this.randomId = params.randomId;
      this.fromId = params.fromId;
      this.chatInvite = params.chatInvite;
      this.chatInviteHash = params.chatInviteHash;
      this.channelPost = params.channelPost;
      this.startParam = params.startParam;
      this.webpage = params.webpage;
      this.message = params.message;
      this.entities = params.entities;
      this.sponsorInfo = params.sponsorInfo;
      this.additionalInfo = params.additionalInfo;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SponsoredMessage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let recommended = flags & (1 << 5) ? true : false;
      let showPeerPhoto = flags & (1 << 6) ? true : false;
      let randomId = await Primitive.Bytes.read(b);
      let fromId = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      let chatInvite = flags & (1 << 4) ? await TLObject.read(b) : undefined;
      let chatInviteHash = flags & (1 << 4) ? await Primitive.String.read(b) : undefined;
      let channelPost = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let startParam = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let webpage = flags & (1 << 9) ? await TLObject.read(b) : undefined;
      let message = await Primitive.String.read(b);
      let entities = flags & (1 << 1) ? await TLObject.read(b) : [];
      let sponsorInfo = flags & (1 << 7) ? await Primitive.String.read(b) : undefined;
      let additionalInfo = flags & (1 << 8) ? await Primitive.String.read(b) : undefined;
      return new Raw.SponsoredMessage({
        recommended: recommended,
        showPeerPhoto: showPeerPhoto,
        randomId: randomId,
        fromId: fromId,
        chatInvite: chatInvite,
        chatInviteHash: chatInviteHash,
        channelPost: channelPost,
        startParam: startParam,
        webpage: webpage,
        message: message,
        entities: entities,
        sponsorInfo: sponsorInfo,
        additionalInfo: additionalInfo,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.recommended ? 1 << 5 : 0;
      flags |= this.showPeerPhoto ? 1 << 6 : 0;
      flags |= this.fromId !== undefined ? 1 << 3 : 0;
      flags |= this.chatInvite !== undefined ? 1 << 4 : 0;
      flags |= this.chatInviteHash !== undefined ? 1 << 4 : 0;
      flags |= this.channelPost !== undefined ? 1 << 2 : 0;
      flags |= this.startParam !== undefined ? 1 << 0 : 0;
      flags |= this.webpage !== undefined ? 1 << 9 : 0;
      flags |= this.entities ? 1 << 1 : 0;
      flags |= this.sponsorInfo !== undefined ? 1 << 7 : 0;
      flags |= this.additionalInfo !== undefined ? 1 << 8 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.randomId !== undefined) {
        b.write(Primitive.Bytes.write(this.randomId) as unknown as Buffer);
      }
      if (this.fromId !== undefined) {
        b.write(this.fromId.write() as unknown as Buffer);
      }
      if (this.chatInvite !== undefined) {
        b.write(this.chatInvite.write() as unknown as Buffer);
      }
      if (this.chatInviteHash !== undefined) {
        b.write(Primitive.String.write(this.chatInviteHash) as unknown as Buffer);
      }
      if (this.channelPost !== undefined) {
        b.write(Primitive.Int.write(this.channelPost) as unknown as Buffer);
      }
      if (this.startParam !== undefined) {
        b.write(Primitive.String.write(this.startParam) as unknown as Buffer);
      }
      if (this.webpage !== undefined) {
        b.write(this.webpage.write() as unknown as Buffer);
      }
      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.sponsorInfo !== undefined) {
        b.write(Primitive.String.write(this.sponsorInfo) as unknown as Buffer);
      }
      if (this.additionalInfo !== undefined) {
        b.write(Primitive.String.write(this.additionalInfo) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SearchResultsCalendarPeriod extends TLObject {
    date!: int;
    minMsgId!: int;
    maxMsgId!: int;
    count!: int;

    constructor(params: { date: int; minMsgId: int; maxMsgId: int; count: int }) {
      super();
      this.classType = 'types';
      this.className = 'SearchResultsCalendarPeriod';
      this.constructorId = 0xc9b0539f;
      this.subclassOfId = 0xe25cf8ff;
      this._slots = ['date', 'minMsgId', 'maxMsgId', 'count'];
      this.date = params.date;
      this.minMsgId = params.minMsgId;
      this.maxMsgId = params.maxMsgId;
      this.count = params.count;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SearchResultsCalendarPeriod> {
      // no flags

      let date = await Primitive.Int.read(b);
      let minMsgId = await Primitive.Int.read(b);
      let maxMsgId = await Primitive.Int.read(b);
      let count = await Primitive.Int.read(b);
      return new Raw.SearchResultsCalendarPeriod({
        date: date,
        minMsgId: minMsgId,
        maxMsgId: maxMsgId,
        count: count,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.minMsgId !== undefined) {
        b.write(Primitive.Int.write(this.minMsgId) as unknown as Buffer);
      }
      if (this.maxMsgId !== undefined) {
        b.write(Primitive.Int.write(this.maxMsgId) as unknown as Buffer);
      }
      if (this.count !== undefined) {
        b.write(Primitive.Int.write(this.count) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SearchResultPosition extends TLObject {
    msgId!: int;
    date!: int;
    offset!: int;

    constructor(params: { msgId: int; date: int; offset: int }) {
      super();
      this.classType = 'types';
      this.className = 'SearchResultPosition';
      this.constructorId = 0x7f648b67;
      this.subclassOfId = 0xb8e21614;
      this._slots = ['msgId', 'date', 'offset'];
      this.msgId = params.msgId;
      this.date = params.date;
      this.offset = params.offset;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SearchResultPosition> {
      // no flags

      let msgId = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      let offset = await Primitive.Int.read(b);
      return new Raw.SearchResultPosition({ msgId: msgId, date: date, offset: offset });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.offset !== undefined) {
        b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ReactionCount extends TLObject {
    chosenOrder?: int;
    reaction!: Raw.TypeReaction;
    count!: int;

    constructor(params: { chosenOrder?: int; reaction: Raw.TypeReaction; count: int }) {
      super();
      this.classType = 'types';
      this.className = 'ReactionCount';
      this.constructorId = 0xa3d1cb80;
      this.subclassOfId = 0xd208ce3f;
      this._slots = ['chosenOrder', 'reaction', 'count'];
      this.chosenOrder = params.chosenOrder;
      this.reaction = params.reaction;
      this.count = params.count;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReactionCount> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let chosenOrder = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let reaction = await TLObject.read(b);
      let count = await Primitive.Int.read(b);
      return new Raw.ReactionCount({ chosenOrder: chosenOrder, reaction: reaction, count: count });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.chosenOrder !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.chosenOrder !== undefined) {
        b.write(Primitive.Int.write(this.chosenOrder) as unknown as Buffer);
      }
      if (this.reaction !== undefined) {
        b.write(this.reaction.write() as unknown as Buffer);
      }
      if (this.count !== undefined) {
        b.write(Primitive.Int.write(this.count) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageReactions extends TLObject {
    min?: boolean;
    canSeeList?: boolean;
    results!: Vector<Raw.TypeReactionCount>;
    recentReactions?: Vector<Raw.TypeMessagePeerReaction>;

    constructor(params: {
      min?: boolean;
      canSeeList?: boolean;
      results: Vector<Raw.TypeReactionCount>;
      recentReactions?: Vector<Raw.TypeMessagePeerReaction>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessageReactions';
      this.constructorId = 0x4f2b9479;
      this.subclassOfId = 0x8a5b071c;
      this._slots = ['min', 'canSeeList', 'results', 'recentReactions'];
      this.min = params.min;
      this.canSeeList = params.canSeeList;
      this.results = params.results;
      this.recentReactions = params.recentReactions;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageReactions> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let min = flags & (1 << 0) ? true : false;
      let canSeeList = flags & (1 << 2) ? true : false;
      let results = await TLObject.read(b);
      let recentReactions = flags & (1 << 1) ? await TLObject.read(b) : [];
      return new Raw.MessageReactions({
        min: min,
        canSeeList: canSeeList,
        results: results,
        recentReactions: recentReactions,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.min ? 1 << 0 : 0;
      flags |= this.canSeeList ? 1 << 2 : 0;
      flags |= this.recentReactions ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.results) {
        b.write(Primitive.Vector.write(this.results) as unknown as Buffer);
      }
      if (this.recentReactions) {
        b.write(Primitive.Vector.write(this.recentReactions) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class AvailableReaction extends TLObject {
    inactive?: boolean;
    premium?: boolean;
    reaction!: string;
    title!: string;
    staticIcon!: Raw.TypeDocument;
    appearAnimation!: Raw.TypeDocument;
    selectAnimation!: Raw.TypeDocument;
    activateAnimation!: Raw.TypeDocument;
    effectAnimation!: Raw.TypeDocument;
    aroundAnimation?: Raw.TypeDocument;
    centerIcon?: Raw.TypeDocument;

    constructor(params: {
      inactive?: boolean;
      premium?: boolean;
      reaction: string;
      title: string;
      staticIcon: Raw.TypeDocument;
      appearAnimation: Raw.TypeDocument;
      selectAnimation: Raw.TypeDocument;
      activateAnimation: Raw.TypeDocument;
      effectAnimation: Raw.TypeDocument;
      aroundAnimation?: Raw.TypeDocument;
      centerIcon?: Raw.TypeDocument;
    }) {
      super();
      this.classType = 'types';
      this.className = 'AvailableReaction';
      this.constructorId = 0xc077ec01;
      this.subclassOfId = 0x8c1c9d73;
      this._slots = [
        'inactive',
        'premium',
        'reaction',
        'title',
        'staticIcon',
        'appearAnimation',
        'selectAnimation',
        'activateAnimation',
        'effectAnimation',
        'aroundAnimation',
        'centerIcon',
      ];
      this.inactive = params.inactive;
      this.premium = params.premium;
      this.reaction = params.reaction;
      this.title = params.title;
      this.staticIcon = params.staticIcon;
      this.appearAnimation = params.appearAnimation;
      this.selectAnimation = params.selectAnimation;
      this.activateAnimation = params.activateAnimation;
      this.effectAnimation = params.effectAnimation;
      this.aroundAnimation = params.aroundAnimation;
      this.centerIcon = params.centerIcon;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AvailableReaction> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let inactive = flags & (1 << 0) ? true : false;
      let premium = flags & (1 << 2) ? true : false;
      let reaction = await Primitive.String.read(b);
      let title = await Primitive.String.read(b);
      let staticIcon = await TLObject.read(b);
      let appearAnimation = await TLObject.read(b);
      let selectAnimation = await TLObject.read(b);
      let activateAnimation = await TLObject.read(b);
      let effectAnimation = await TLObject.read(b);
      let aroundAnimation = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let centerIcon = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      return new Raw.AvailableReaction({
        inactive: inactive,
        premium: premium,
        reaction: reaction,
        title: title,
        staticIcon: staticIcon,
        appearAnimation: appearAnimation,
        selectAnimation: selectAnimation,
        activateAnimation: activateAnimation,
        effectAnimation: effectAnimation,
        aroundAnimation: aroundAnimation,
        centerIcon: centerIcon,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.inactive ? 1 << 0 : 0;
      flags |= this.premium ? 1 << 2 : 0;
      flags |= this.aroundAnimation !== undefined ? 1 << 1 : 0;
      flags |= this.centerIcon !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.reaction !== undefined) {
        b.write(Primitive.String.write(this.reaction) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.staticIcon !== undefined) {
        b.write(this.staticIcon.write() as unknown as Buffer);
      }
      if (this.appearAnimation !== undefined) {
        b.write(this.appearAnimation.write() as unknown as Buffer);
      }
      if (this.selectAnimation !== undefined) {
        b.write(this.selectAnimation.write() as unknown as Buffer);
      }
      if (this.activateAnimation !== undefined) {
        b.write(this.activateAnimation.write() as unknown as Buffer);
      }
      if (this.effectAnimation !== undefined) {
        b.write(this.effectAnimation.write() as unknown as Buffer);
      }
      if (this.aroundAnimation !== undefined) {
        b.write(this.aroundAnimation.write() as unknown as Buffer);
      }
      if (this.centerIcon !== undefined) {
        b.write(this.centerIcon.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessagePeerReaction extends TLObject {
    big?: boolean;
    unread?: boolean;
    my?: boolean;
    peerId!: Raw.TypePeer;
    date!: int;
    reaction!: Raw.TypeReaction;

    constructor(params: {
      big?: boolean;
      unread?: boolean;
      my?: boolean;
      peerId: Raw.TypePeer;
      date: int;
      reaction: Raw.TypeReaction;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MessagePeerReaction';
      this.constructorId = 0x8c79b63c;
      this.subclassOfId = 0xaf73a2a5;
      this._slots = ['big', 'unread', 'my', 'peerId', 'date', 'reaction'];
      this.big = params.big;
      this.unread = params.unread;
      this.my = params.my;
      this.peerId = params.peerId;
      this.date = params.date;
      this.reaction = params.reaction;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessagePeerReaction> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let big = flags & (1 << 0) ? true : false;
      let unread = flags & (1 << 1) ? true : false;
      let my = flags & (1 << 2) ? true : false;
      let peerId = await TLObject.read(b);
      let date = await Primitive.Int.read(b);
      let reaction = await TLObject.read(b);
      return new Raw.MessagePeerReaction({
        big: big,
        unread: unread,
        my: my,
        peerId: peerId,
        date: date,
        reaction: reaction,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.big ? 1 << 0 : 0;
      flags |= this.unread ? 1 << 1 : 0;
      flags |= this.my ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peerId !== undefined) {
        b.write(this.peerId.write() as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.reaction !== undefined) {
        b.write(this.reaction.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class GroupCallStreamChannel extends TLObject {
    channel!: int;
    scale!: int;
    lastTimestampMs!: long;

    constructor(params: { channel: int; scale: int; lastTimestampMs: long }) {
      super();
      this.classType = 'types';
      this.className = 'GroupCallStreamChannel';
      this.constructorId = 0x80eb48af;
      this.subclassOfId = 0xdd44b258;
      this._slots = ['channel', 'scale', 'lastTimestampMs'];
      this.channel = params.channel;
      this.scale = params.scale;
      this.lastTimestampMs = params.lastTimestampMs;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.GroupCallStreamChannel> {
      // no flags

      let channel = await Primitive.Int.read(b);
      let scale = await Primitive.Int.read(b);
      let lastTimestampMs = await Primitive.Long.read(b);
      return new Raw.GroupCallStreamChannel({
        channel: channel,
        scale: scale,
        lastTimestampMs: lastTimestampMs,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.channel !== undefined) {
        b.write(Primitive.Int.write(this.channel) as unknown as Buffer);
      }
      if (this.scale !== undefined) {
        b.write(Primitive.Int.write(this.scale) as unknown as Buffer);
      }
      if (this.lastTimestampMs !== undefined) {
        b.write(Primitive.Long.write(this.lastTimestampMs) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class AttachMenuBotIconColor extends TLObject {
    name!: string;
    color!: int;

    constructor(params: { name: string; color: int }) {
      super();
      this.classType = 'types';
      this.className = 'AttachMenuBotIconColor';
      this.constructorId = 0x4576f3f0;
      this.subclassOfId = 0xbea4cb6a;
      this._slots = ['name', 'color'];
      this.name = params.name;
      this.color = params.color;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AttachMenuBotIconColor> {
      // no flags

      let name = await Primitive.String.read(b);
      let color = await Primitive.Int.read(b);
      return new Raw.AttachMenuBotIconColor({ name: name, color: color });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.name !== undefined) {
        b.write(Primitive.String.write(this.name) as unknown as Buffer);
      }
      if (this.color !== undefined) {
        b.write(Primitive.Int.write(this.color) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class AttachMenuBotIcon extends TLObject {
    name!: string;
    icon!: Raw.TypeDocument;
    colors?: Vector<Raw.TypeAttachMenuBotIconColor>;

    constructor(params: {
      name: string;
      icon: Raw.TypeDocument;
      colors?: Vector<Raw.TypeAttachMenuBotIconColor>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'AttachMenuBotIcon';
      this.constructorId = 0xb2a7386b;
      this.subclassOfId = 0x80484555;
      this._slots = ['name', 'icon', 'colors'];
      this.name = params.name;
      this.icon = params.icon;
      this.colors = params.colors;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AttachMenuBotIcon> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let name = await Primitive.String.read(b);
      let icon = await TLObject.read(b);
      let colors = flags & (1 << 0) ? await TLObject.read(b) : [];
      return new Raw.AttachMenuBotIcon({ name: name, icon: icon, colors: colors });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.colors ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.name !== undefined) {
        b.write(Primitive.String.write(this.name) as unknown as Buffer);
      }
      if (this.icon !== undefined) {
        b.write(this.icon.write() as unknown as Buffer);
      }
      if (this.colors) {
        b.write(Primitive.Vector.write(this.colors) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class AttachMenuBot extends TLObject {
    inactive?: boolean;
    hasSettings?: boolean;
    requestWriteAccess?: boolean;
    showInAttachMenu?: boolean;
    showInSideMenu?: boolean;
    sideMenuDisclaimerNeeded?: boolean;
    botId!: long;
    shortName!: string;
    peerTypes?: Vector<Raw.TypeAttachMenuPeerType>;
    icons!: Vector<Raw.TypeAttachMenuBotIcon>;

    constructor(params: {
      inactive?: boolean;
      hasSettings?: boolean;
      requestWriteAccess?: boolean;
      showInAttachMenu?: boolean;
      showInSideMenu?: boolean;
      sideMenuDisclaimerNeeded?: boolean;
      botId: long;
      shortName: string;
      peerTypes?: Vector<Raw.TypeAttachMenuPeerType>;
      icons: Vector<Raw.TypeAttachMenuBotIcon>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'AttachMenuBot';
      this.constructorId = 0xd90d8dfe;
      this.subclassOfId = 0x9f087446;
      this._slots = [
        'inactive',
        'hasSettings',
        'requestWriteAccess',
        'showInAttachMenu',
        'showInSideMenu',
        'sideMenuDisclaimerNeeded',
        'botId',
        'shortName',
        'peerTypes',
        'icons',
      ];
      this.inactive = params.inactive;
      this.hasSettings = params.hasSettings;
      this.requestWriteAccess = params.requestWriteAccess;
      this.showInAttachMenu = params.showInAttachMenu;
      this.showInSideMenu = params.showInSideMenu;
      this.sideMenuDisclaimerNeeded = params.sideMenuDisclaimerNeeded;
      this.botId = params.botId;
      this.shortName = params.shortName;
      this.peerTypes = params.peerTypes;
      this.icons = params.icons;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AttachMenuBot> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let inactive = flags & (1 << 0) ? true : false;
      let hasSettings = flags & (1 << 1) ? true : false;
      let requestWriteAccess = flags & (1 << 2) ? true : false;
      let showInAttachMenu = flags & (1 << 3) ? true : false;
      let showInSideMenu = flags & (1 << 4) ? true : false;
      let sideMenuDisclaimerNeeded = flags & (1 << 5) ? true : false;
      let botId = await Primitive.Long.read(b);
      let shortName = await Primitive.String.read(b);
      let peerTypes = flags & (1 << 3) ? await TLObject.read(b) : [];
      let icons = await TLObject.read(b);
      return new Raw.AttachMenuBot({
        inactive: inactive,
        hasSettings: hasSettings,
        requestWriteAccess: requestWriteAccess,
        showInAttachMenu: showInAttachMenu,
        showInSideMenu: showInSideMenu,
        sideMenuDisclaimerNeeded: sideMenuDisclaimerNeeded,
        botId: botId,
        shortName: shortName,
        peerTypes: peerTypes,
        icons: icons,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.inactive ? 1 << 0 : 0;
      flags |= this.hasSettings ? 1 << 1 : 0;
      flags |= this.requestWriteAccess ? 1 << 2 : 0;
      flags |= this.showInAttachMenu ? 1 << 3 : 0;
      flags |= this.showInSideMenu ? 1 << 4 : 0;
      flags |= this.sideMenuDisclaimerNeeded ? 1 << 5 : 0;
      flags |= this.peerTypes ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.botId !== undefined) {
        b.write(Primitive.Long.write(this.botId) as unknown as Buffer);
      }
      if (this.shortName !== undefined) {
        b.write(Primitive.String.write(this.shortName) as unknown as Buffer);
      }
      if (this.peerTypes) {
        b.write(Primitive.Vector.write(this.peerTypes) as unknown as Buffer);
      }
      if (this.icons) {
        b.write(Primitive.Vector.write(this.icons) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class AttachMenuBotsNotModified extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'AttachMenuBotsNotModified';
      this.constructorId = 0xf1d88a5c;
      this.subclassOfId = 0x842e23da;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AttachMenuBotsNotModified> {
      // no flags

      return new Raw.AttachMenuBotsNotModified();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class AttachMenuBots extends TLObject {
    hash!: long;
    bots!: Vector<Raw.TypeAttachMenuBot>;
    users!: Vector<Raw.TypeUser>;

    constructor(params: {
      hash: long;
      bots: Vector<Raw.TypeAttachMenuBot>;
      users: Vector<Raw.TypeUser>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'AttachMenuBots';
      this.constructorId = 0x3c4301c0;
      this.subclassOfId = 0x842e23da;
      this._slots = ['hash', 'bots', 'users'];
      this.hash = params.hash;
      this.bots = params.bots;
      this.users = params.users;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AttachMenuBots> {
      // no flags

      let hash = await Primitive.Long.read(b);
      let bots = await TLObject.read(b);
      let users = await TLObject.read(b);
      return new Raw.AttachMenuBots({ hash: hash, bots: bots, users: users });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.hash !== undefined) {
        b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
      }
      if (this.bots) {
        b.write(Primitive.Vector.write(this.bots) as unknown as Buffer);
      }
      if (this.users) {
        b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class AttachMenuBotsBot extends TLObject {
    bot!: Raw.TypeAttachMenuBot;
    users!: Vector<Raw.TypeUser>;

    constructor(params: { bot: Raw.TypeAttachMenuBot; users: Vector<Raw.TypeUser> }) {
      super();
      this.classType = 'types';
      this.className = 'AttachMenuBotsBot';
      this.constructorId = 0x93bf667f;
      this.subclassOfId = 0xdb33883d;
      this._slots = ['bot', 'users'];
      this.bot = params.bot;
      this.users = params.users;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AttachMenuBotsBot> {
      // no flags

      let bot = await TLObject.read(b);
      let users = await TLObject.read(b);
      return new Raw.AttachMenuBotsBot({ bot: bot, users: users });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.bot !== undefined) {
        b.write(this.bot.write() as unknown as Buffer);
      }
      if (this.users) {
        b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WebViewResultUrl extends TLObject {
    queryId!: long;
    url!: string;

    constructor(params: { queryId: long; url: string }) {
      super();
      this.classType = 'types';
      this.className = 'WebViewResultUrl';
      this.constructorId = 0xc14557c;
      this.subclassOfId = 0x93cea746;
      this._slots = ['queryId', 'url'];
      this.queryId = params.queryId;
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WebViewResultUrl> {
      // no flags

      let queryId = await Primitive.Long.read(b);
      let url = await Primitive.String.read(b);
      return new Raw.WebViewResultUrl({ queryId: queryId, url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.queryId !== undefined) {
        b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SimpleWebViewResultUrl extends TLObject {
    url!: string;

    constructor(params: { url: string }) {
      super();
      this.classType = 'types';
      this.className = 'SimpleWebViewResultUrl';
      this.constructorId = 0x882f76bb;
      this.subclassOfId = 0x15eee3db;
      this._slots = ['url'];
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SimpleWebViewResultUrl> {
      // no flags

      let url = await Primitive.String.read(b);
      return new Raw.SimpleWebViewResultUrl({ url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class WebViewMessageSent extends TLObject {
    msgId?: Raw.TypeInputBotInlineMessageID;

    constructor(params: { msgId?: Raw.TypeInputBotInlineMessageID }) {
      super();
      this.classType = 'types';
      this.className = 'WebViewMessageSent';
      this.constructorId = 0xc94511c;
      this.subclassOfId = 0x75e49312;
      this._slots = ['msgId'];
      this.msgId = params.msgId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.WebViewMessageSent> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let msgId = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      return new Raw.WebViewMessageSent({ msgId: msgId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.msgId !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.msgId !== undefined) {
        b.write(this.msgId.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotMenuButtonDefault extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'BotMenuButtonDefault';
      this.constructorId = 0x7533a588;
      this.subclassOfId = 0x4c71bd3c;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotMenuButtonDefault> {
      // no flags

      return new Raw.BotMenuButtonDefault();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class BotMenuButtonCommands extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'BotMenuButtonCommands';
      this.constructorId = 0x4258c205;
      this.subclassOfId = 0x4c71bd3c;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotMenuButtonCommands> {
      // no flags

      return new Raw.BotMenuButtonCommands();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class BotMenuButton extends TLObject {
    text!: string;
    url!: string;

    constructor(params: { text: string; url: string }) {
      super();
      this.classType = 'types';
      this.className = 'BotMenuButton';
      this.constructorId = 0xc7b57ce6;
      this.subclassOfId = 0x4c71bd3c;
      this._slots = ['text', 'url'];
      this.text = params.text;
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotMenuButton> {
      // no flags

      let text = await Primitive.String.read(b);
      let url = await Primitive.String.read(b);
      return new Raw.BotMenuButton({ text: text, url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class NotificationSoundDefault extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'NotificationSoundDefault';
      this.constructorId = 0x97e8bebe;
      this.subclassOfId = 0xf2f5e55b;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.NotificationSoundDefault> {
      // no flags

      return new Raw.NotificationSoundDefault();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class NotificationSoundNone extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'NotificationSoundNone';
      this.constructorId = 0x6f0c34df;
      this.subclassOfId = 0xf2f5e55b;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.NotificationSoundNone> {
      // no flags

      return new Raw.NotificationSoundNone();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class NotificationSoundLocal extends TLObject {
    title!: string;
    data!: string;

    constructor(params: { title: string; data: string }) {
      super();
      this.classType = 'types';
      this.className = 'NotificationSoundLocal';
      this.constructorId = 0x830b9ae4;
      this.subclassOfId = 0xf2f5e55b;
      this._slots = ['title', 'data'];
      this.title = params.title;
      this.data = params.data;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.NotificationSoundLocal> {
      // no flags

      let title = await Primitive.String.read(b);
      let data = await Primitive.String.read(b);
      return new Raw.NotificationSoundLocal({ title: title, data: data });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.data !== undefined) {
        b.write(Primitive.String.write(this.data) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class NotificationSoundRingtone extends TLObject {
    id!: long;

    constructor(params: { id: long }) {
      super();
      this.classType = 'types';
      this.className = 'NotificationSoundRingtone';
      this.constructorId = 0xff6c8049;
      this.subclassOfId = 0xf2f5e55b;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.NotificationSoundRingtone> {
      // no flags

      let id = await Primitive.Long.read(b);
      return new Raw.NotificationSoundRingtone({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class AttachMenuPeerTypeSameBotPM extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'AttachMenuPeerTypeSameBotPM';
      this.constructorId = 0x7d6be90e;
      this.subclassOfId = 0xd1d886d0;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AttachMenuPeerTypeSameBotPM> {
      // no flags

      return new Raw.AttachMenuPeerTypeSameBotPM();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class AttachMenuPeerTypeBotPM extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'AttachMenuPeerTypeBotPM';
      this.constructorId = 0xc32bfa1a;
      this.subclassOfId = 0xd1d886d0;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AttachMenuPeerTypeBotPM> {
      // no flags

      return new Raw.AttachMenuPeerTypeBotPM();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class AttachMenuPeerTypePM extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'AttachMenuPeerTypePM';
      this.constructorId = 0xf146d31f;
      this.subclassOfId = 0xd1d886d0;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AttachMenuPeerTypePM> {
      // no flags

      return new Raw.AttachMenuPeerTypePM();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class AttachMenuPeerTypeChat extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'AttachMenuPeerTypeChat';
      this.constructorId = 0x509113f;
      this.subclassOfId = 0xd1d886d0;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AttachMenuPeerTypeChat> {
      // no flags

      return new Raw.AttachMenuPeerTypeChat();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class AttachMenuPeerTypeBroadcast extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'AttachMenuPeerTypeBroadcast';
      this.constructorId = 0x7bfbdefc;
      this.subclassOfId = 0xd1d886d0;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AttachMenuPeerTypeBroadcast> {
      // no flags

      return new Raw.AttachMenuPeerTypeBroadcast();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class InputInvoiceMessage extends TLObject {
    peer!: Raw.TypeInputPeer;
    msgId!: int;

    constructor(params: { peer: Raw.TypeInputPeer; msgId: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputInvoiceMessage';
      this.constructorId = 0xc5b56859;
      this.subclassOfId = 0x726e9bfe;
      this._slots = ['peer', 'msgId'];
      this.peer = params.peer;
      this.msgId = params.msgId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputInvoiceMessage> {
      // no flags

      let peer = await TLObject.read(b);
      let msgId = await Primitive.Int.read(b);
      return new Raw.InputInvoiceMessage({ peer: peer, msgId: msgId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.msgId !== undefined) {
        b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputInvoiceSlug extends TLObject {
    slug!: string;

    constructor(params: { slug: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputInvoiceSlug';
      this.constructorId = 0xc326caef;
      this.subclassOfId = 0x726e9bfe;
      this._slots = ['slug'];
      this.slug = params.slug;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputInvoiceSlug> {
      // no flags

      let slug = await Primitive.String.read(b);
      return new Raw.InputInvoiceSlug({ slug: slug });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.slug !== undefined) {
        b.write(Primitive.String.write(this.slug) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputInvoicePremiumGiftCode extends TLObject {
    purpose!: Raw.TypeInputStorePaymentPurpose;
    option!: Raw.TypePremiumGiftCodeOption;

    constructor(params: {
      purpose: Raw.TypeInputStorePaymentPurpose;
      option: Raw.TypePremiumGiftCodeOption;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputInvoicePremiumGiftCode';
      this.constructorId = 0x98986c0d;
      this.subclassOfId = 0x726e9bfe;
      this._slots = ['purpose', 'option'];
      this.purpose = params.purpose;
      this.option = params.option;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputInvoicePremiumGiftCode> {
      // no flags

      let purpose = await TLObject.read(b);
      let option = await TLObject.read(b);
      return new Raw.InputInvoicePremiumGiftCode({ purpose: purpose, option: option });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.purpose !== undefined) {
        b.write(this.purpose.write() as unknown as Buffer);
      }
      if (this.option !== undefined) {
        b.write(this.option.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputStorePaymentPremiumSubscription extends TLObject {
    restore?: boolean;
    upgrade?: boolean;

    constructor(params: { restore?: boolean; upgrade?: boolean }) {
      super();
      this.classType = 'types';
      this.className = 'InputStorePaymentPremiumSubscription';
      this.constructorId = 0xa6751e66;
      this.subclassOfId = 0xe7a4174d;
      this._slots = ['restore', 'upgrade'];
      this.restore = params.restore;
      this.upgrade = params.upgrade;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputStorePaymentPremiumSubscription> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let restore = flags & (1 << 0) ? true : false;
      let upgrade = flags & (1 << 1) ? true : false;
      return new Raw.InputStorePaymentPremiumSubscription({ restore: restore, upgrade: upgrade });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.restore ? 1 << 0 : 0;
      flags |= this.upgrade ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      return b.buffer;
    }
  }
  export class InputStorePaymentGiftPremium extends TLObject {
    userId!: Raw.TypeInputUser;
    currency!: string;
    amount!: long;

    constructor(params: { userId: Raw.TypeInputUser; currency: string; amount: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputStorePaymentGiftPremium';
      this.constructorId = 0x616f7fe8;
      this.subclassOfId = 0xe7a4174d;
      this._slots = ['userId', 'currency', 'amount'];
      this.userId = params.userId;
      this.currency = params.currency;
      this.amount = params.amount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputStorePaymentGiftPremium> {
      // no flags

      let userId = await TLObject.read(b);
      let currency = await Primitive.String.read(b);
      let amount = await Primitive.Long.read(b);
      return new Raw.InputStorePaymentGiftPremium({
        userId: userId,
        currency: currency,
        amount: amount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(this.userId.write() as unknown as Buffer);
      }
      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.amount !== undefined) {
        b.write(Primitive.Long.write(this.amount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputStorePaymentPremiumGiftCode extends TLObject {
    users!: Vector<Raw.TypeInputUser>;
    boostPeer?: Raw.TypeInputPeer;
    currency!: string;
    amount!: long;

    constructor(params: {
      users: Vector<Raw.TypeInputUser>;
      boostPeer?: Raw.TypeInputPeer;
      currency: string;
      amount: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputStorePaymentPremiumGiftCode';
      this.constructorId = 0xa3805f3f;
      this.subclassOfId = 0xe7a4174d;
      this._slots = ['users', 'boostPeer', 'currency', 'amount'];
      this.users = params.users;
      this.boostPeer = params.boostPeer;
      this.currency = params.currency;
      this.amount = params.amount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputStorePaymentPremiumGiftCode> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let users = await TLObject.read(b);
      let boostPeer = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let currency = await Primitive.String.read(b);
      let amount = await Primitive.Long.read(b);
      return new Raw.InputStorePaymentPremiumGiftCode({
        users: users,
        boostPeer: boostPeer,
        currency: currency,
        amount: amount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.boostPeer !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.users) {
        b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
      }
      if (this.boostPeer !== undefined) {
        b.write(this.boostPeer.write() as unknown as Buffer);
      }
      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.amount !== undefined) {
        b.write(Primitive.Long.write(this.amount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputStorePaymentPremiumGiveaway extends TLObject {
    onlyNewSubscribers?: boolean;
    boostPeer!: Raw.TypeInputPeer;
    additionalPeers?: Vector<Raw.TypeInputPeer>;
    countriesIso2?: Vector<string>;
    randomId!: long;
    untilDate!: int;
    currency!: string;
    amount!: long;

    constructor(params: {
      onlyNewSubscribers?: boolean;
      boostPeer: Raw.TypeInputPeer;
      additionalPeers?: Vector<Raw.TypeInputPeer>;
      countriesIso2?: Vector<string>;
      randomId: long;
      untilDate: int;
      currency: string;
      amount: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputStorePaymentPremiumGiveaway';
      this.constructorId = 0x7c9375e6;
      this.subclassOfId = 0xe7a4174d;
      this._slots = [
        'onlyNewSubscribers',
        'boostPeer',
        'additionalPeers',
        'countriesIso2',
        'randomId',
        'untilDate',
        'currency',
        'amount',
      ];
      this.onlyNewSubscribers = params.onlyNewSubscribers;
      this.boostPeer = params.boostPeer;
      this.additionalPeers = params.additionalPeers;
      this.countriesIso2 = params.countriesIso2;
      this.randomId = params.randomId;
      this.untilDate = params.untilDate;
      this.currency = params.currency;
      this.amount = params.amount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.InputStorePaymentPremiumGiveaway> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let onlyNewSubscribers = flags & (1 << 0) ? true : false;
      let boostPeer = await TLObject.read(b);
      let additionalPeers = flags & (1 << 1) ? await TLObject.read(b) : [];
      let countriesIso2 = flags & (1 << 2) ? await TLObject.read(b, Primitive.String) : [];
      let randomId = await Primitive.Long.read(b);
      let untilDate = await Primitive.Int.read(b);
      let currency = await Primitive.String.read(b);
      let amount = await Primitive.Long.read(b);
      return new Raw.InputStorePaymentPremiumGiveaway({
        onlyNewSubscribers: onlyNewSubscribers,
        boostPeer: boostPeer,
        additionalPeers: additionalPeers,
        countriesIso2: countriesIso2,
        randomId: randomId,
        untilDate: untilDate,
        currency: currency,
        amount: amount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.onlyNewSubscribers ? 1 << 0 : 0;
      flags |= this.additionalPeers ? 1 << 1 : 0;
      flags |= this.countriesIso2 ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.boostPeer !== undefined) {
        b.write(this.boostPeer.write() as unknown as Buffer);
      }
      if (this.additionalPeers) {
        b.write(Primitive.Vector.write(this.additionalPeers) as unknown as Buffer);
      }
      if (this.countriesIso2) {
        b.write(Primitive.Vector.write(this.countriesIso2, Primitive.String) as unknown as Buffer);
      }
      if (this.randomId !== undefined) {
        b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
      }
      if (this.untilDate !== undefined) {
        b.write(Primitive.Int.write(this.untilDate) as unknown as Buffer);
      }
      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.amount !== undefined) {
        b.write(Primitive.Long.write(this.amount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PremiumGiftOption extends TLObject {
    months!: int;
    currency!: string;
    amount!: long;
    botUrl!: string;
    storeProduct?: string;

    constructor(params: {
      months: int;
      currency: string;
      amount: long;
      botUrl: string;
      storeProduct?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PremiumGiftOption';
      this.constructorId = 0x74c34319;
      this.subclassOfId = 0x5182b03e;
      this._slots = ['months', 'currency', 'amount', 'botUrl', 'storeProduct'];
      this.months = params.months;
      this.currency = params.currency;
      this.amount = params.amount;
      this.botUrl = params.botUrl;
      this.storeProduct = params.storeProduct;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PremiumGiftOption> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let months = await Primitive.Int.read(b);
      let currency = await Primitive.String.read(b);
      let amount = await Primitive.Long.read(b);
      let botUrl = await Primitive.String.read(b);
      let storeProduct = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      return new Raw.PremiumGiftOption({
        months: months,
        currency: currency,
        amount: amount,
        botUrl: botUrl,
        storeProduct: storeProduct,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.storeProduct !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.months !== undefined) {
        b.write(Primitive.Int.write(this.months) as unknown as Buffer);
      }
      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.amount !== undefined) {
        b.write(Primitive.Long.write(this.amount) as unknown as Buffer);
      }
      if (this.botUrl !== undefined) {
        b.write(Primitive.String.write(this.botUrl) as unknown as Buffer);
      }
      if (this.storeProduct !== undefined) {
        b.write(Primitive.String.write(this.storeProduct) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PaymentFormMethod extends TLObject {
    url!: string;
    title!: string;

    constructor(params: { url: string; title: string }) {
      super();
      this.classType = 'types';
      this.className = 'PaymentFormMethod';
      this.constructorId = 0x88f8f21b;
      this.subclassOfId = 0x3fc1c816;
      this._slots = ['url', 'title'];
      this.url = params.url;
      this.title = params.title;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PaymentFormMethod> {
      // no flags

      let url = await Primitive.String.read(b);
      let title = await Primitive.String.read(b);
      return new Raw.PaymentFormMethod({ url: url, title: title });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmojiStatusEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'EmojiStatusEmpty';
      this.constructorId = 0x2de11aae;
      this.subclassOfId = 0xf930b138;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmojiStatusEmpty> {
      // no flags

      return new Raw.EmojiStatusEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class EmojiStatus extends TLObject {
    documentId!: long;

    constructor(params: { documentId: long }) {
      super();
      this.classType = 'types';
      this.className = 'EmojiStatus';
      this.constructorId = 0x929b619d;
      this.subclassOfId = 0xf930b138;
      this._slots = ['documentId'];
      this.documentId = params.documentId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmojiStatus> {
      // no flags

      let documentId = await Primitive.Long.read(b);
      return new Raw.EmojiStatus({ documentId: documentId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.documentId !== undefined) {
        b.write(Primitive.Long.write(this.documentId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmojiStatusUntil extends TLObject {
    documentId!: long;
    until!: int;

    constructor(params: { documentId: long; until: int }) {
      super();
      this.classType = 'types';
      this.className = 'EmojiStatusUntil';
      this.constructorId = 0xfa30a8c7;
      this.subclassOfId = 0xf930b138;
      this._slots = ['documentId', 'until'];
      this.documentId = params.documentId;
      this.until = params.until;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmojiStatusUntil> {
      // no flags

      let documentId = await Primitive.Long.read(b);
      let until = await Primitive.Int.read(b);
      return new Raw.EmojiStatusUntil({ documentId: documentId, until: until });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.documentId !== undefined) {
        b.write(Primitive.Long.write(this.documentId) as unknown as Buffer);
      }
      if (this.until !== undefined) {
        b.write(Primitive.Int.write(this.until) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ReactionEmpty extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'ReactionEmpty';
      this.constructorId = 0x79f5d419;
      this.subclassOfId = 0x5da165a1;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReactionEmpty> {
      // no flags

      return new Raw.ReactionEmpty();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ReactionEmoji extends TLObject {
    emoticon!: string;

    constructor(params: { emoticon: string }) {
      super();
      this.classType = 'types';
      this.className = 'ReactionEmoji';
      this.constructorId = 0x1b2286b8;
      this.subclassOfId = 0x5da165a1;
      this._slots = ['emoticon'];
      this.emoticon = params.emoticon;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReactionEmoji> {
      // no flags

      let emoticon = await Primitive.String.read(b);
      return new Raw.ReactionEmoji({ emoticon: emoticon });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.emoticon !== undefined) {
        b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ReactionCustomEmoji extends TLObject {
    documentId!: long;

    constructor(params: { documentId: long }) {
      super();
      this.classType = 'types';
      this.className = 'ReactionCustomEmoji';
      this.constructorId = 0x8935fc73;
      this.subclassOfId = 0x5da165a1;
      this._slots = ['documentId'];
      this.documentId = params.documentId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReactionCustomEmoji> {
      // no flags

      let documentId = await Primitive.Long.read(b);
      return new Raw.ReactionCustomEmoji({ documentId: documentId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.documentId !== undefined) {
        b.write(Primitive.Long.write(this.documentId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ChatReactionsNone extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'ChatReactionsNone';
      this.constructorId = 0xeafc32bc;
      this.subclassOfId = 0x131e24b5;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatReactionsNone> {
      // no flags

      return new Raw.ChatReactionsNone();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class ChatReactionsAll extends TLObject {
    allowCustom?: boolean;

    constructor(params: { allowCustom?: boolean }) {
      super();
      this.classType = 'types';
      this.className = 'ChatReactionsAll';
      this.constructorId = 0x52928bca;
      this.subclassOfId = 0x131e24b5;
      this._slots = ['allowCustom'];
      this.allowCustom = params.allowCustom;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatReactionsAll> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let allowCustom = flags & (1 << 0) ? true : false;
      return new Raw.ChatReactionsAll({ allowCustom: allowCustom });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.allowCustom ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      return b.buffer;
    }
  }
  export class ChatReactionsSome extends TLObject {
    reactions!: Vector<Raw.TypeReaction>;

    constructor(params: { reactions: Vector<Raw.TypeReaction> }) {
      super();
      this.classType = 'types';
      this.className = 'ChatReactionsSome';
      this.constructorId = 0x661d4037;
      this.subclassOfId = 0x131e24b5;
      this._slots = ['reactions'];
      this.reactions = params.reactions;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ChatReactionsSome> {
      // no flags

      let reactions = await TLObject.read(b);
      return new Raw.ChatReactionsSome({ reactions: reactions });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.reactions) {
        b.write(Primitive.Vector.write(this.reactions) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmailVerifyPurposeLoginSetup extends TLObject {
    phoneNumber!: string;
    phoneCodeHash!: string;

    constructor(params: { phoneNumber: string; phoneCodeHash: string }) {
      super();
      this.classType = 'types';
      this.className = 'EmailVerifyPurposeLoginSetup';
      this.constructorId = 0x4345be73;
      this.subclassOfId = 0xb9686ae8;
      this._slots = ['phoneNumber', 'phoneCodeHash'];
      this.phoneNumber = params.phoneNumber;
      this.phoneCodeHash = params.phoneCodeHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmailVerifyPurposeLoginSetup> {
      // no flags

      let phoneNumber = await Primitive.String.read(b);
      let phoneCodeHash = await Primitive.String.read(b);
      return new Raw.EmailVerifyPurposeLoginSetup({
        phoneNumber: phoneNumber,
        phoneCodeHash: phoneCodeHash,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.phoneNumber !== undefined) {
        b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
      }
      if (this.phoneCodeHash !== undefined) {
        b.write(Primitive.String.write(this.phoneCodeHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmailVerifyPurposeLoginChange extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'EmailVerifyPurposeLoginChange';
      this.constructorId = 0x527d22eb;
      this.subclassOfId = 0xb9686ae8;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmailVerifyPurposeLoginChange> {
      // no flags

      return new Raw.EmailVerifyPurposeLoginChange();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class EmailVerifyPurposePassport extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'EmailVerifyPurposePassport';
      this.constructorId = 0xbbf51685;
      this.subclassOfId = 0xb9686ae8;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmailVerifyPurposePassport> {
      // no flags

      return new Raw.EmailVerifyPurposePassport();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class EmailVerificationCode extends TLObject {
    code!: string;

    constructor(params: { code: string }) {
      super();
      this.classType = 'types';
      this.className = 'EmailVerificationCode';
      this.constructorId = 0x922e55a9;
      this.subclassOfId = 0x241ee240;
      this._slots = ['code'];
      this.code = params.code;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmailVerificationCode> {
      // no flags

      let code = await Primitive.String.read(b);
      return new Raw.EmailVerificationCode({ code: code });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.code !== undefined) {
        b.write(Primitive.String.write(this.code) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmailVerificationGoogle extends TLObject {
    token!: string;

    constructor(params: { token: string }) {
      super();
      this.classType = 'types';
      this.className = 'EmailVerificationGoogle';
      this.constructorId = 0xdb909ec2;
      this.subclassOfId = 0x241ee240;
      this._slots = ['token'];
      this.token = params.token;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmailVerificationGoogle> {
      // no flags

      let token = await Primitive.String.read(b);
      return new Raw.EmailVerificationGoogle({ token: token });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.token !== undefined) {
        b.write(Primitive.String.write(this.token) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmailVerificationApple extends TLObject {
    token!: string;

    constructor(params: { token: string }) {
      super();
      this.classType = 'types';
      this.className = 'EmailVerificationApple';
      this.constructorId = 0x96d074fd;
      this.subclassOfId = 0x241ee240;
      this._slots = ['token'];
      this.token = params.token;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmailVerificationApple> {
      // no flags

      let token = await Primitive.String.read(b);
      return new Raw.EmailVerificationApple({ token: token });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.token !== undefined) {
        b.write(Primitive.String.write(this.token) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PremiumSubscriptionOption extends TLObject {
    current?: boolean;
    canPurchaseUpgrade?: boolean;
    transaction?: string;
    months!: int;
    currency!: string;
    amount!: long;
    botUrl!: string;
    storeProduct?: string;

    constructor(params: {
      current?: boolean;
      canPurchaseUpgrade?: boolean;
      transaction?: string;
      months: int;
      currency: string;
      amount: long;
      botUrl: string;
      storeProduct?: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PremiumSubscriptionOption';
      this.constructorId = 0x5f2d1df2;
      this.subclassOfId = 0x2e2dc73f;
      this._slots = [
        'current',
        'canPurchaseUpgrade',
        'transaction',
        'months',
        'currency',
        'amount',
        'botUrl',
        'storeProduct',
      ];
      this.current = params.current;
      this.canPurchaseUpgrade = params.canPurchaseUpgrade;
      this.transaction = params.transaction;
      this.months = params.months;
      this.currency = params.currency;
      this.amount = params.amount;
      this.botUrl = params.botUrl;
      this.storeProduct = params.storeProduct;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PremiumSubscriptionOption> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let current = flags & (1 << 1) ? true : false;
      let canPurchaseUpgrade = flags & (1 << 2) ? true : false;
      let transaction = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
      let months = await Primitive.Int.read(b);
      let currency = await Primitive.String.read(b);
      let amount = await Primitive.Long.read(b);
      let botUrl = await Primitive.String.read(b);
      let storeProduct = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      return new Raw.PremiumSubscriptionOption({
        current: current,
        canPurchaseUpgrade: canPurchaseUpgrade,
        transaction: transaction,
        months: months,
        currency: currency,
        amount: amount,
        botUrl: botUrl,
        storeProduct: storeProduct,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.current ? 1 << 1 : 0;
      flags |= this.canPurchaseUpgrade ? 1 << 2 : 0;
      flags |= this.transaction !== undefined ? 1 << 3 : 0;
      flags |= this.storeProduct !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.transaction !== undefined) {
        b.write(Primitive.String.write(this.transaction) as unknown as Buffer);
      }
      if (this.months !== undefined) {
        b.write(Primitive.Int.write(this.months) as unknown as Buffer);
      }
      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.amount !== undefined) {
        b.write(Primitive.Long.write(this.amount) as unknown as Buffer);
      }
      if (this.botUrl !== undefined) {
        b.write(Primitive.String.write(this.botUrl) as unknown as Buffer);
      }
      if (this.storeProduct !== undefined) {
        b.write(Primitive.String.write(this.storeProduct) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SendAsPeer extends TLObject {
    premiumRequired?: boolean;
    peer!: Raw.TypePeer;

    constructor(params: { premiumRequired?: boolean; peer: Raw.TypePeer }) {
      super();
      this.classType = 'types';
      this.className = 'SendAsPeer';
      this.constructorId = 0xb81c7034;
      this.subclassOfId = 0x442381e4;
      this._slots = ['premiumRequired', 'peer'];
      this.premiumRequired = params.premiumRequired;
      this.peer = params.peer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SendAsPeer> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let premiumRequired = flags & (1 << 0) ? true : false;
      let peer = await TLObject.read(b);
      return new Raw.SendAsPeer({ premiumRequired: premiumRequired, peer: peer });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.premiumRequired ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageExtendedMediaPreview extends TLObject {
    w?: int;
    h?: int;
    thumb?: Raw.TypePhotoSize;
    videoDuration?: int;

    constructor(params: { w?: int; h?: int; thumb?: Raw.TypePhotoSize; videoDuration?: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessageExtendedMediaPreview';
      this.constructorId = 0xad628cc8;
      this.subclassOfId = 0x9727d95d;
      this._slots = ['w', 'h', 'thumb', 'videoDuration'];
      this.w = params.w;
      this.h = params.h;
      this.thumb = params.thumb;
      this.videoDuration = params.videoDuration;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageExtendedMediaPreview> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let w = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let h = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let thumb = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let videoDuration = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      return new Raw.MessageExtendedMediaPreview({
        w: w,
        h: h,
        thumb: thumb,
        videoDuration: videoDuration,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.w !== undefined ? 1 << 0 : 0;
      flags |= this.h !== undefined ? 1 << 0 : 0;
      flags |= this.thumb !== undefined ? 1 << 1 : 0;
      flags |= this.videoDuration !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.thumb !== undefined) {
        b.write(this.thumb.write() as unknown as Buffer);
      }
      if (this.videoDuration !== undefined) {
        b.write(Primitive.Int.write(this.videoDuration) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessageExtendedMedia extends TLObject {
    media!: Raw.TypeMessageMedia;

    constructor(params: { media: Raw.TypeMessageMedia }) {
      super();
      this.classType = 'types';
      this.className = 'MessageExtendedMedia';
      this.constructorId = 0xee479c64;
      this.subclassOfId = 0x9727d95d;
      this._slots = ['media'];
      this.media = params.media;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessageExtendedMedia> {
      // no flags

      let media = await TLObject.read(b);
      return new Raw.MessageExtendedMedia({ media: media });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.media !== undefined) {
        b.write(this.media.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StickerKeyword extends TLObject {
    documentId!: long;
    keyword!: Vector<string>;

    constructor(params: { documentId: long; keyword: Vector<string> }) {
      super();
      this.classType = 'types';
      this.className = 'StickerKeyword';
      this.constructorId = 0xfcfeb29c;
      this.subclassOfId = 0x55951d6b;
      this._slots = ['documentId', 'keyword'];
      this.documentId = params.documentId;
      this.keyword = params.keyword;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StickerKeyword> {
      // no flags

      let documentId = await Primitive.Long.read(b);
      let keyword = await TLObject.read(b, Primitive.String);
      return new Raw.StickerKeyword({ documentId: documentId, keyword: keyword });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.documentId !== undefined) {
        b.write(Primitive.Long.write(this.documentId) as unknown as Buffer);
      }
      if (this.keyword) {
        b.write(Primitive.Vector.write(this.keyword, Primitive.String) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Username extends TLObject {
    editable?: boolean;
    active?: boolean;
    username!: string;

    constructor(params: { editable?: boolean; active?: boolean; username: string }) {
      super();
      this.classType = 'types';
      this.className = 'Username';
      this.constructorId = 0xb4073647;
      this.subclassOfId = 0x1286421;
      this._slots = ['editable', 'active', 'username'];
      this.editable = params.editable;
      this.active = params.active;
      this.username = params.username;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Username> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let editable = flags & (1 << 0) ? true : false;
      let active = flags & (1 << 1) ? true : false;
      let username = await Primitive.String.read(b);
      return new Raw.Username({ editable: editable, active: active, username: username });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.editable ? 1 << 0 : 0;
      flags |= this.active ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.username !== undefined) {
        b.write(Primitive.String.write(this.username) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ForumTopicDeleted extends TLObject {
    id!: int;

    constructor(params: { id: int }) {
      super();
      this.classType = 'types';
      this.className = 'ForumTopicDeleted';
      this.constructorId = 0x23f109b;
      this.subclassOfId = 0x8d182203;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ForumTopicDeleted> {
      // no flags

      let id = await Primitive.Int.read(b);
      return new Raw.ForumTopicDeleted({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ForumTopic extends TLObject {
    my?: boolean;
    closed?: boolean;
    pinned?: boolean;
    short?: boolean;
    hidden?: boolean;
    id!: int;
    date!: int;
    title!: string;
    iconColor!: int;
    iconEmojiId?: long;
    topMessage!: int;
    readInboxMaxId!: int;
    readOutboxMaxId!: int;
    unreadCount!: int;
    unreadMentionsCount!: int;
    unreadReactionsCount!: int;
    fromId!: Raw.TypePeer;
    notifySettings!: Raw.TypePeerNotifySettings;
    draft?: Raw.TypeDraftMessage;

    constructor(params: {
      my?: boolean;
      closed?: boolean;
      pinned?: boolean;
      short?: boolean;
      hidden?: boolean;
      id: int;
      date: int;
      title: string;
      iconColor: int;
      iconEmojiId?: long;
      topMessage: int;
      readInboxMaxId: int;
      readOutboxMaxId: int;
      unreadCount: int;
      unreadMentionsCount: int;
      unreadReactionsCount: int;
      fromId: Raw.TypePeer;
      notifySettings: Raw.TypePeerNotifySettings;
      draft?: Raw.TypeDraftMessage;
    }) {
      super();
      this.classType = 'types';
      this.className = 'ForumTopic';
      this.constructorId = 0x71701da9;
      this.subclassOfId = 0x8d182203;
      this._slots = [
        'my',
        'closed',
        'pinned',
        'short',
        'hidden',
        'id',
        'date',
        'title',
        'iconColor',
        'iconEmojiId',
        'topMessage',
        'readInboxMaxId',
        'readOutboxMaxId',
        'unreadCount',
        'unreadMentionsCount',
        'unreadReactionsCount',
        'fromId',
        'notifySettings',
        'draft',
      ];
      this.my = params.my;
      this.closed = params.closed;
      this.pinned = params.pinned;
      this.short = params.short;
      this.hidden = params.hidden;
      this.id = params.id;
      this.date = params.date;
      this.title = params.title;
      this.iconColor = params.iconColor;
      this.iconEmojiId = params.iconEmojiId;
      this.topMessage = params.topMessage;
      this.readInboxMaxId = params.readInboxMaxId;
      this.readOutboxMaxId = params.readOutboxMaxId;
      this.unreadCount = params.unreadCount;
      this.unreadMentionsCount = params.unreadMentionsCount;
      this.unreadReactionsCount = params.unreadReactionsCount;
      this.fromId = params.fromId;
      this.notifySettings = params.notifySettings;
      this.draft = params.draft;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ForumTopic> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let my = flags & (1 << 1) ? true : false;
      let closed = flags & (1 << 2) ? true : false;
      let pinned = flags & (1 << 3) ? true : false;
      let short = flags & (1 << 5) ? true : false;
      let hidden = flags & (1 << 6) ? true : false;
      let id = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      let title = await Primitive.String.read(b);
      let iconColor = await Primitive.Int.read(b);
      let iconEmojiId = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
      let topMessage = await Primitive.Int.read(b);
      let readInboxMaxId = await Primitive.Int.read(b);
      let readOutboxMaxId = await Primitive.Int.read(b);
      let unreadCount = await Primitive.Int.read(b);
      let unreadMentionsCount = await Primitive.Int.read(b);
      let unreadReactionsCount = await Primitive.Int.read(b);
      let fromId = await TLObject.read(b);
      let notifySettings = await TLObject.read(b);
      let draft = flags & (1 << 4) ? await TLObject.read(b) : undefined;
      return new Raw.ForumTopic({
        my: my,
        closed: closed,
        pinned: pinned,
        short: short,
        hidden: hidden,
        id: id,
        date: date,
        title: title,
        iconColor: iconColor,
        iconEmojiId: iconEmojiId,
        topMessage: topMessage,
        readInboxMaxId: readInboxMaxId,
        readOutboxMaxId: readOutboxMaxId,
        unreadCount: unreadCount,
        unreadMentionsCount: unreadMentionsCount,
        unreadReactionsCount: unreadReactionsCount,
        fromId: fromId,
        notifySettings: notifySettings,
        draft: draft,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.my ? 1 << 1 : 0;
      flags |= this.closed ? 1 << 2 : 0;
      flags |= this.pinned ? 1 << 3 : 0;
      flags |= this.short ? 1 << 5 : 0;
      flags |= this.hidden ? 1 << 6 : 0;
      flags |= this.iconEmojiId !== undefined ? 1 << 0 : 0;
      flags |= this.draft !== undefined ? 1 << 4 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.iconColor !== undefined) {
        b.write(Primitive.Int.write(this.iconColor) as unknown as Buffer);
      }
      if (this.iconEmojiId !== undefined) {
        b.write(Primitive.Long.write(this.iconEmojiId) as unknown as Buffer);
      }
      if (this.topMessage !== undefined) {
        b.write(Primitive.Int.write(this.topMessage) as unknown as Buffer);
      }
      if (this.readInboxMaxId !== undefined) {
        b.write(Primitive.Int.write(this.readInboxMaxId) as unknown as Buffer);
      }
      if (this.readOutboxMaxId !== undefined) {
        b.write(Primitive.Int.write(this.readOutboxMaxId) as unknown as Buffer);
      }
      if (this.unreadCount !== undefined) {
        b.write(Primitive.Int.write(this.unreadCount) as unknown as Buffer);
      }
      if (this.unreadMentionsCount !== undefined) {
        b.write(Primitive.Int.write(this.unreadMentionsCount) as unknown as Buffer);
      }
      if (this.unreadReactionsCount !== undefined) {
        b.write(Primitive.Int.write(this.unreadReactionsCount) as unknown as Buffer);
      }
      if (this.fromId !== undefined) {
        b.write(this.fromId.write() as unknown as Buffer);
      }
      if (this.notifySettings !== undefined) {
        b.write(this.notifySettings.write() as unknown as Buffer);
      }
      if (this.draft !== undefined) {
        b.write(this.draft.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DefaultHistoryTTL extends TLObject {
    period!: int;

    constructor(params: { period: int }) {
      super();
      this.classType = 'types';
      this.className = 'DefaultHistoryTTL';
      this.constructorId = 0x43b46b20;
      this.subclassOfId = 0xf00d3367;
      this._slots = ['period'];
      this.period = params.period;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DefaultHistoryTTL> {
      // no flags

      let period = await Primitive.Int.read(b);
      return new Raw.DefaultHistoryTTL({ period: period });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.period !== undefined) {
        b.write(Primitive.Int.write(this.period) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ExportedContactToken extends TLObject {
    url!: string;
    expires!: int;

    constructor(params: { url: string; expires: int }) {
      super();
      this.classType = 'types';
      this.className = 'ExportedContactToken';
      this.constructorId = 0x41bf109b;
      this.subclassOfId = 0x86ddbed1;
      this._slots = ['url', 'expires'];
      this.url = params.url;
      this.expires = params.expires;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ExportedContactToken> {
      // no flags

      let url = await Primitive.String.read(b);
      let expires = await Primitive.Int.read(b);
      return new Raw.ExportedContactToken({ url: url, expires: expires });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.expires !== undefined) {
        b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RequestPeerTypeUser extends TLObject {
    bot?: Bool;
    premium?: Bool;

    constructor(params: { bot?: Bool; premium?: Bool }) {
      super();
      this.classType = 'types';
      this.className = 'RequestPeerTypeUser';
      this.constructorId = 0x5f3b8a00;
      this.subclassOfId = 0xe9a0e814;
      this._slots = ['bot', 'premium'];
      this.bot = params.bot;
      this.premium = params.premium;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RequestPeerTypeUser> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let bot = flags & (1 << 0) ? await Primitive.Bool.read(b) : undefined;
      let premium = flags & (1 << 1) ? await Primitive.Bool.read(b) : undefined;
      return new Raw.RequestPeerTypeUser({ bot: bot, premium: premium });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.bot !== undefined ? 1 << 0 : 0;
      flags |= this.premium !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.bot !== undefined) {
        b.write(Primitive.Bool.write(this.bot) as unknown as Buffer);
      }
      if (this.premium !== undefined) {
        b.write(Primitive.Bool.write(this.premium) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RequestPeerTypeChat extends TLObject {
    creator?: boolean;
    botParticipant?: boolean;
    hasUsername?: Bool;
    forum?: Bool;
    userAdminRights?: Raw.TypeChatAdminRights;
    botAdminRights?: Raw.TypeChatAdminRights;

    constructor(params: {
      creator?: boolean;
      botParticipant?: boolean;
      hasUsername?: Bool;
      forum?: Bool;
      userAdminRights?: Raw.TypeChatAdminRights;
      botAdminRights?: Raw.TypeChatAdminRights;
    }) {
      super();
      this.classType = 'types';
      this.className = 'RequestPeerTypeChat';
      this.constructorId = 0xc9f06e1b;
      this.subclassOfId = 0xe9a0e814;
      this._slots = [
        'creator',
        'botParticipant',
        'hasUsername',
        'forum',
        'userAdminRights',
        'botAdminRights',
      ];
      this.creator = params.creator;
      this.botParticipant = params.botParticipant;
      this.hasUsername = params.hasUsername;
      this.forum = params.forum;
      this.userAdminRights = params.userAdminRights;
      this.botAdminRights = params.botAdminRights;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RequestPeerTypeChat> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let creator = flags & (1 << 0) ? true : false;
      let botParticipant = flags & (1 << 5) ? true : false;
      let hasUsername = flags & (1 << 3) ? await Primitive.Bool.read(b) : undefined;
      let forum = flags & (1 << 4) ? await Primitive.Bool.read(b) : undefined;
      let userAdminRights = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let botAdminRights = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.RequestPeerTypeChat({
        creator: creator,
        botParticipant: botParticipant,
        hasUsername: hasUsername,
        forum: forum,
        userAdminRights: userAdminRights,
        botAdminRights: botAdminRights,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.creator ? 1 << 0 : 0;
      flags |= this.botParticipant ? 1 << 5 : 0;
      flags |= this.hasUsername !== undefined ? 1 << 3 : 0;
      flags |= this.forum !== undefined ? 1 << 4 : 0;
      flags |= this.userAdminRights !== undefined ? 1 << 1 : 0;
      flags |= this.botAdminRights !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.hasUsername !== undefined) {
        b.write(Primitive.Bool.write(this.hasUsername) as unknown as Buffer);
      }
      if (this.forum !== undefined) {
        b.write(Primitive.Bool.write(this.forum) as unknown as Buffer);
      }
      if (this.userAdminRights !== undefined) {
        b.write(this.userAdminRights.write() as unknown as Buffer);
      }
      if (this.botAdminRights !== undefined) {
        b.write(this.botAdminRights.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class RequestPeerTypeBroadcast extends TLObject {
    creator?: boolean;
    hasUsername?: Bool;
    userAdminRights?: Raw.TypeChatAdminRights;
    botAdminRights?: Raw.TypeChatAdminRights;

    constructor(params: {
      creator?: boolean;
      hasUsername?: Bool;
      userAdminRights?: Raw.TypeChatAdminRights;
      botAdminRights?: Raw.TypeChatAdminRights;
    }) {
      super();
      this.classType = 'types';
      this.className = 'RequestPeerTypeBroadcast';
      this.constructorId = 0x339bef6c;
      this.subclassOfId = 0xe9a0e814;
      this._slots = ['creator', 'hasUsername', 'userAdminRights', 'botAdminRights'];
      this.creator = params.creator;
      this.hasUsername = params.hasUsername;
      this.userAdminRights = params.userAdminRights;
      this.botAdminRights = params.botAdminRights;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.RequestPeerTypeBroadcast> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let creator = flags & (1 << 0) ? true : false;
      let hasUsername = flags & (1 << 3) ? await Primitive.Bool.read(b) : undefined;
      let userAdminRights = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let botAdminRights = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.RequestPeerTypeBroadcast({
        creator: creator,
        hasUsername: hasUsername,
        userAdminRights: userAdminRights,
        botAdminRights: botAdminRights,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.creator ? 1 << 0 : 0;
      flags |= this.hasUsername !== undefined ? 1 << 3 : 0;
      flags |= this.userAdminRights !== undefined ? 1 << 1 : 0;
      flags |= this.botAdminRights !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.hasUsername !== undefined) {
        b.write(Primitive.Bool.write(this.hasUsername) as unknown as Buffer);
      }
      if (this.userAdminRights !== undefined) {
        b.write(this.userAdminRights.write() as unknown as Buffer);
      }
      if (this.botAdminRights !== undefined) {
        b.write(this.botAdminRights.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmojiListNotModified extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'EmojiListNotModified';
      this.constructorId = 0x481eadfa;
      this.subclassOfId = 0xbcef6aba;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmojiListNotModified> {
      // no flags

      return new Raw.EmojiListNotModified();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class EmojiList extends TLObject {
    hash!: long;
    documentId!: Vector<long>;

    constructor(params: { hash: long; documentId: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'EmojiList';
      this.constructorId = 0x7a1e11d1;
      this.subclassOfId = 0xbcef6aba;
      this._slots = ['hash', 'documentId'];
      this.hash = params.hash;
      this.documentId = params.documentId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmojiList> {
      // no flags

      let hash = await Primitive.Long.read(b);
      let documentId = await TLObject.read(b, Primitive.Long);
      return new Raw.EmojiList({ hash: hash, documentId: documentId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.hash !== undefined) {
        b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
      }
      if (this.documentId) {
        b.write(Primitive.Vector.write(this.documentId, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class EmojiGroup extends TLObject {
    title!: string;
    iconEmojiId!: long;
    emoticons!: Vector<string>;

    constructor(params: { title: string; iconEmojiId: long; emoticons: Vector<string> }) {
      super();
      this.classType = 'types';
      this.className = 'EmojiGroup';
      this.constructorId = 0x7a9abda9;
      this.subclassOfId = 0x55e0a193;
      this._slots = ['title', 'iconEmojiId', 'emoticons'];
      this.title = params.title;
      this.iconEmojiId = params.iconEmojiId;
      this.emoticons = params.emoticons;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.EmojiGroup> {
      // no flags

      let title = await Primitive.String.read(b);
      let iconEmojiId = await Primitive.Long.read(b);
      let emoticons = await TLObject.read(b, Primitive.String);
      return new Raw.EmojiGroup({ title: title, iconEmojiId: iconEmojiId, emoticons: emoticons });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.iconEmojiId !== undefined) {
        b.write(Primitive.Long.write(this.iconEmojiId) as unknown as Buffer);
      }
      if (this.emoticons) {
        b.write(Primitive.Vector.write(this.emoticons, Primitive.String) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class TextWithEntities extends TLObject {
    text!: string;
    entities!: Vector<Raw.TypeMessageEntity>;

    constructor(params: { text: string; entities: Vector<Raw.TypeMessageEntity> }) {
      super();
      this.classType = 'types';
      this.className = 'TextWithEntities';
      this.constructorId = 0x751f3146;
      this.subclassOfId = 0x95ca4b05;
      this._slots = ['text', 'entities'];
      this.text = params.text;
      this.entities = params.entities;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.TextWithEntities> {
      // no flags

      let text = await Primitive.String.read(b);
      let entities = await TLObject.read(b);
      return new Raw.TextWithEntities({ text: text, entities: entities });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class AutoSaveSettings extends TLObject {
    photos?: boolean;
    videos?: boolean;
    videoMaxSize?: long;

    constructor(params: { photos?: boolean; videos?: boolean; videoMaxSize?: long }) {
      super();
      this.classType = 'types';
      this.className = 'AutoSaveSettings';
      this.constructorId = 0xc84834ce;
      this.subclassOfId = 0xcd3b96e6;
      this._slots = ['photos', 'videos', 'videoMaxSize'];
      this.photos = params.photos;
      this.videos = params.videos;
      this.videoMaxSize = params.videoMaxSize;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AutoSaveSettings> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let photos = flags & (1 << 0) ? true : false;
      let videos = flags & (1 << 1) ? true : false;
      let videoMaxSize = flags & (1 << 2) ? await Primitive.Long.read(b) : undefined;
      return new Raw.AutoSaveSettings({
        photos: photos,
        videos: videos,
        videoMaxSize: videoMaxSize,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.photos ? 1 << 0 : 0;
      flags |= this.videos ? 1 << 1 : 0;
      flags |= this.videoMaxSize !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.videoMaxSize !== undefined) {
        b.write(Primitive.Long.write(this.videoMaxSize) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class AutoSaveException extends TLObject {
    peer!: Raw.TypePeer;
    settings!: Raw.TypeAutoSaveSettings;

    constructor(params: { peer: Raw.TypePeer; settings: Raw.TypeAutoSaveSettings }) {
      super();
      this.classType = 'types';
      this.className = 'AutoSaveException';
      this.constructorId = 0x81602d47;
      this.subclassOfId = 0xdd868129;
      this._slots = ['peer', 'settings'];
      this.peer = params.peer;
      this.settings = params.settings;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AutoSaveException> {
      // no flags

      let peer = await TLObject.read(b);
      let settings = await TLObject.read(b);
      return new Raw.AutoSaveException({ peer: peer, settings: settings });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.settings !== undefined) {
        b.write(this.settings.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotAppID extends TLObject {
    id!: long;
    accessHash!: long;

    constructor(params: { id: long; accessHash: long }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotAppID';
      this.constructorId = 0xa920bd7a;
      this.subclassOfId = 0xb6559951;
      this._slots = ['id', 'accessHash'];
      this.id = params.id;
      this.accessHash = params.accessHash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputBotAppID> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      return new Raw.InputBotAppID({ id: id, accessHash: accessHash });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputBotAppShortName extends TLObject {
    botId!: Raw.TypeInputUser;
    shortName!: string;

    constructor(params: { botId: Raw.TypeInputUser; shortName: string }) {
      super();
      this.classType = 'types';
      this.className = 'InputBotAppShortName';
      this.constructorId = 0x908c0407;
      this.subclassOfId = 0xb6559951;
      this._slots = ['botId', 'shortName'];
      this.botId = params.botId;
      this.shortName = params.shortName;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputBotAppShortName> {
      // no flags

      let botId = await TLObject.read(b);
      let shortName = await Primitive.String.read(b);
      return new Raw.InputBotAppShortName({ botId: botId, shortName: shortName });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.botId !== undefined) {
        b.write(this.botId.write() as unknown as Buffer);
      }
      if (this.shortName !== undefined) {
        b.write(Primitive.String.write(this.shortName) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class BotAppNotModified extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'BotAppNotModified';
      this.constructorId = 0x5da674b7;
      this.subclassOfId = 0x20f32ae;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotAppNotModified> {
      // no flags

      return new Raw.BotAppNotModified();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class BotApp extends TLObject {
    id!: long;
    accessHash!: long;
    shortName!: string;
    title!: string;
    description!: string;
    photo!: Raw.TypePhoto;
    document?: Raw.TypeDocument;
    hash!: long;

    constructor(params: {
      id: long;
      accessHash: long;
      shortName: string;
      title: string;
      description: string;
      photo: Raw.TypePhoto;
      document?: Raw.TypeDocument;
      hash: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'BotApp';
      this.constructorId = 0x95fcd1d6;
      this.subclassOfId = 0x20f32ae;
      this._slots = [
        'id',
        'accessHash',
        'shortName',
        'title',
        'description',
        'photo',
        'document',
        'hash',
      ];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.shortName = params.shortName;
      this.title = params.title;
      this.description = params.description;
      this.photo = params.photo;
      this.document = params.document;
      this.hash = params.hash;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.BotApp> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let shortName = await Primitive.String.read(b);
      let title = await Primitive.String.read(b);
      let description = await Primitive.String.read(b);
      let photo = await TLObject.read(b);
      let document = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let hash = await Primitive.Long.read(b);
      return new Raw.BotApp({
        id: id,
        accessHash: accessHash,
        shortName: shortName,
        title: title,
        description: description,
        photo: photo,
        document: document,
        hash: hash,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.document !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.shortName !== undefined) {
        b.write(Primitive.String.write(this.shortName) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.description !== undefined) {
        b.write(Primitive.String.write(this.description) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      if (this.document !== undefined) {
        b.write(this.document.write() as unknown as Buffer);
      }
      if (this.hash !== undefined) {
        b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class AppWebViewResultUrl extends TLObject {
    url!: string;

    constructor(params: { url: string }) {
      super();
      this.classType = 'types';
      this.className = 'AppWebViewResultUrl';
      this.constructorId = 0x3c1b4f0d;
      this.subclassOfId = 0x1c24a413;
      this._slots = ['url'];
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.AppWebViewResultUrl> {
      // no flags

      let url = await Primitive.String.read(b);
      return new Raw.AppWebViewResultUrl({ url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InlineBotWebView extends TLObject {
    text!: string;
    url!: string;

    constructor(params: { text: string; url: string }) {
      super();
      this.classType = 'types';
      this.className = 'InlineBotWebView';
      this.constructorId = 0xb57295d5;
      this.subclassOfId = 0x6ce015ea;
      this._slots = ['text', 'url'];
      this.text = params.text;
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InlineBotWebView> {
      // no flags

      let text = await Primitive.String.read(b);
      let url = await Primitive.String.read(b);
      return new Raw.InlineBotWebView({ text: text, url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.text !== undefined) {
        b.write(Primitive.String.write(this.text) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ReadParticipantDate extends TLObject {
    userId!: long;
    date!: int;

    constructor(params: { userId: long; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'ReadParticipantDate';
      this.constructorId = 0x4a4ff172;
      this.subclassOfId = 0xfd078ce2;
      this._slots = ['userId', 'date'];
      this.userId = params.userId;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ReadParticipantDate> {
      // no flags

      let userId = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.ReadParticipantDate({ userId: userId, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputChatlistDialogFilter extends TLObject {
    filterId!: int;

    constructor(params: { filterId: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputChatlistDialogFilter';
      this.constructorId = 0xf3e0da33;
      this.subclassOfId = 0x23f9659;
      this._slots = ['filterId'];
      this.filterId = params.filterId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputChatlistDialogFilter> {
      // no flags

      let filterId = await Primitive.Int.read(b);
      return new Raw.InputChatlistDialogFilter({ filterId: filterId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.filterId !== undefined) {
        b.write(Primitive.Int.write(this.filterId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ExportedChatlistInvite extends TLObject {
    title!: string;
    url!: string;
    peers!: Vector<Raw.TypePeer>;

    constructor(params: { title: string; url: string; peers: Vector<Raw.TypePeer> }) {
      super();
      this.classType = 'types';
      this.className = 'ExportedChatlistInvite';
      this.constructorId = 0xc5181ac;
      this.subclassOfId = 0x7711f8ff;
      this._slots = ['title', 'url', 'peers'];
      this.title = params.title;
      this.url = params.url;
      this.peers = params.peers;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ExportedChatlistInvite> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let title = await Primitive.String.read(b);
      let url = await Primitive.String.read(b);
      let peers = await TLObject.read(b);
      return new Raw.ExportedChatlistInvite({ title: title, url: url, peers: peers });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;

      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.peers) {
        b.write(Primitive.Vector.write(this.peers) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessagePeerVote extends TLObject {
    peer!: Raw.TypePeer;
    option!: bytes;
    date!: int;

    constructor(params: { peer: Raw.TypePeer; option: bytes; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessagePeerVote';
      this.constructorId = 0xb6cc2d5c;
      this.subclassOfId = 0x85c27202;
      this._slots = ['peer', 'option', 'date'];
      this.peer = params.peer;
      this.option = params.option;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessagePeerVote> {
      // no flags

      let peer = await TLObject.read(b);
      let option = await Primitive.Bytes.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.MessagePeerVote({ peer: peer, option: option, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.option !== undefined) {
        b.write(Primitive.Bytes.write(this.option) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessagePeerVoteInputOption extends TLObject {
    peer!: Raw.TypePeer;
    date!: int;

    constructor(params: { peer: Raw.TypePeer; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessagePeerVoteInputOption';
      this.constructorId = 0x74cda504;
      this.subclassOfId = 0x85c27202;
      this._slots = ['peer', 'date'];
      this.peer = params.peer;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessagePeerVoteInputOption> {
      // no flags

      let peer = await TLObject.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.MessagePeerVoteInputOption({ peer: peer, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MessagePeerVoteMultiple extends TLObject {
    peer!: Raw.TypePeer;
    options!: Vector<bytes>;
    date!: int;

    constructor(params: { peer: Raw.TypePeer; options: Vector<bytes>; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'MessagePeerVoteMultiple';
      this.constructorId = 0x4628f6e6;
      this.subclassOfId = 0x85c27202;
      this._slots = ['peer', 'options', 'date'];
      this.peer = params.peer;
      this.options = params.options;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MessagePeerVoteMultiple> {
      // no flags

      let peer = await TLObject.read(b);
      let options = await TLObject.read(b, Primitive.Bytes);
      let date = await Primitive.Int.read(b);
      return new Raw.MessagePeerVoteMultiple({ peer: peer, options: options, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.options) {
        b.write(Primitive.Vector.write(this.options, Primitive.Bytes) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SponsoredWebPage extends TLObject {
    url!: string;
    siteName!: string;
    photo?: Raw.TypePhoto;

    constructor(params: { url: string; siteName: string; photo?: Raw.TypePhoto }) {
      super();
      this.classType = 'types';
      this.className = 'SponsoredWebPage';
      this.constructorId = 0x3db8ec63;
      this.subclassOfId = 0xcdfea554;
      this._slots = ['url', 'siteName', 'photo'];
      this.url = params.url;
      this.siteName = params.siteName;
      this.photo = params.photo;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.SponsoredWebPage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let url = await Primitive.String.read(b);
      let siteName = await Primitive.String.read(b);
      let photo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      return new Raw.SponsoredWebPage({ url: url, siteName: siteName, photo: photo });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.photo !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      if (this.siteName !== undefined) {
        b.write(Primitive.String.write(this.siteName) as unknown as Buffer);
      }
      if (this.photo !== undefined) {
        b.write(this.photo.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StoryViews extends TLObject {
    hasViewers?: boolean;
    viewsCount!: int;
    forwardsCount?: int;
    reactions?: Vector<Raw.TypeReactionCount>;
    reactionsCount?: int;
    recentViewers?: Vector<long>;

    constructor(params: {
      hasViewers?: boolean;
      viewsCount: int;
      forwardsCount?: int;
      reactions?: Vector<Raw.TypeReactionCount>;
      reactionsCount?: int;
      recentViewers?: Vector<long>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'StoryViews';
      this.constructorId = 0x8d595cd6;
      this.subclassOfId = 0x54e4ac66;
      this._slots = [
        'hasViewers',
        'viewsCount',
        'forwardsCount',
        'reactions',
        'reactionsCount',
        'recentViewers',
      ];
      this.hasViewers = params.hasViewers;
      this.viewsCount = params.viewsCount;
      this.forwardsCount = params.forwardsCount;
      this.reactions = params.reactions;
      this.reactionsCount = params.reactionsCount;
      this.recentViewers = params.recentViewers;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StoryViews> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let hasViewers = flags & (1 << 1) ? true : false;
      let viewsCount = await Primitive.Int.read(b);
      let forwardsCount = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let reactions = flags & (1 << 3) ? await TLObject.read(b) : [];
      let reactionsCount = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
      let recentViewers = flags & (1 << 0) ? await TLObject.read(b, Primitive.Long) : [];
      return new Raw.StoryViews({
        hasViewers: hasViewers,
        viewsCount: viewsCount,
        forwardsCount: forwardsCount,
        reactions: reactions,
        reactionsCount: reactionsCount,
        recentViewers: recentViewers,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.hasViewers ? 1 << 1 : 0;
      flags |= this.forwardsCount !== undefined ? 1 << 2 : 0;
      flags |= this.reactions ? 1 << 3 : 0;
      flags |= this.reactionsCount !== undefined ? 1 << 4 : 0;
      flags |= this.recentViewers ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.viewsCount !== undefined) {
        b.write(Primitive.Int.write(this.viewsCount) as unknown as Buffer);
      }
      if (this.forwardsCount !== undefined) {
        b.write(Primitive.Int.write(this.forwardsCount) as unknown as Buffer);
      }
      if (this.reactions) {
        b.write(Primitive.Vector.write(this.reactions) as unknown as Buffer);
      }
      if (this.reactionsCount !== undefined) {
        b.write(Primitive.Int.write(this.reactionsCount) as unknown as Buffer);
      }
      if (this.recentViewers) {
        b.write(Primitive.Vector.write(this.recentViewers, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StoryItemDeleted extends TLObject {
    id!: int;

    constructor(params: { id: int }) {
      super();
      this.classType = 'types';
      this.className = 'StoryItemDeleted';
      this.constructorId = 0x51e6ee4f;
      this.subclassOfId = 0xd477b133;
      this._slots = ['id'];
      this.id = params.id;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StoryItemDeleted> {
      // no flags

      let id = await Primitive.Int.read(b);
      return new Raw.StoryItemDeleted({ id: id });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StoryItemSkipped extends TLObject {
    closeFriends?: boolean;
    id!: int;
    date!: int;
    expireDate!: int;

    constructor(params: { closeFriends?: boolean; id: int; date: int; expireDate: int }) {
      super();
      this.classType = 'types';
      this.className = 'StoryItemSkipped';
      this.constructorId = 0xffadc913;
      this.subclassOfId = 0xd477b133;
      this._slots = ['closeFriends', 'id', 'date', 'expireDate'];
      this.closeFriends = params.closeFriends;
      this.id = params.id;
      this.date = params.date;
      this.expireDate = params.expireDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StoryItemSkipped> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let closeFriends = flags & (1 << 8) ? true : false;
      let id = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      let expireDate = await Primitive.Int.read(b);
      return new Raw.StoryItemSkipped({
        closeFriends: closeFriends,
        id: id,
        date: date,
        expireDate: expireDate,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.closeFriends ? 1 << 8 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.expireDate !== undefined) {
        b.write(Primitive.Int.write(this.expireDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StoryItem extends TLObject {
    pinned?: boolean;
    public?: boolean;
    closeFriends?: boolean;
    min?: boolean;
    noforwards?: boolean;
    edited?: boolean;
    contacts?: boolean;
    selectedContacts?: boolean;
    out?: boolean;
    id!: int;
    date!: int;
    expireDate!: int;
    caption?: string;
    entities?: Vector<Raw.TypeMessageEntity>;
    media!: Raw.TypeMessageMedia;
    mediaAreas?: Vector<Raw.TypeMediaArea>;
    privacy?: Vector<Raw.TypePrivacyRule>;
    views?: Raw.TypeStoryViews;
    sentReaction?: Raw.TypeReaction;

    constructor(params: {
      pinned?: boolean;
      public?: boolean;
      closeFriends?: boolean;
      min?: boolean;
      noforwards?: boolean;
      edited?: boolean;
      contacts?: boolean;
      selectedContacts?: boolean;
      out?: boolean;
      id: int;
      date: int;
      expireDate: int;
      caption?: string;
      entities?: Vector<Raw.TypeMessageEntity>;
      media: Raw.TypeMessageMedia;
      mediaAreas?: Vector<Raw.TypeMediaArea>;
      privacy?: Vector<Raw.TypePrivacyRule>;
      views?: Raw.TypeStoryViews;
      sentReaction?: Raw.TypeReaction;
    }) {
      super();
      this.classType = 'types';
      this.className = 'StoryItem';
      this.constructorId = 0x44c457ce;
      this.subclassOfId = 0xd477b133;
      this._slots = [
        'pinned',
        'public',
        'closeFriends',
        'min',
        'noforwards',
        'edited',
        'contacts',
        'selectedContacts',
        'out',
        'id',
        'date',
        'expireDate',
        'caption',
        'entities',
        'media',
        'mediaAreas',
        'privacy',
        'views',
        'sentReaction',
      ];
      this.pinned = params.pinned;
      this.public = params.public;
      this.closeFriends = params.closeFriends;
      this.min = params.min;
      this.noforwards = params.noforwards;
      this.edited = params.edited;
      this.contacts = params.contacts;
      this.selectedContacts = params.selectedContacts;
      this.out = params.out;
      this.id = params.id;
      this.date = params.date;
      this.expireDate = params.expireDate;
      this.caption = params.caption;
      this.entities = params.entities;
      this.media = params.media;
      this.mediaAreas = params.mediaAreas;
      this.privacy = params.privacy;
      this.views = params.views;
      this.sentReaction = params.sentReaction;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StoryItem> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let pinned = flags & (1 << 5) ? true : false;
      let _public = flags & (1 << 7) ? true : false;
      let closeFriends = flags & (1 << 8) ? true : false;
      let min = flags & (1 << 9) ? true : false;
      let noforwards = flags & (1 << 10) ? true : false;
      let edited = flags & (1 << 11) ? true : false;
      let contacts = flags & (1 << 12) ? true : false;
      let selectedContacts = flags & (1 << 13) ? true : false;
      let out = flags & (1 << 16) ? true : false;
      let id = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      let expireDate = await Primitive.Int.read(b);
      let caption = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let entities = flags & (1 << 1) ? await TLObject.read(b) : [];
      let media = await TLObject.read(b);
      let mediaAreas = flags & (1 << 14) ? await TLObject.read(b) : [];
      let privacy = flags & (1 << 2) ? await TLObject.read(b) : [];
      let views = flags & (1 << 3) ? await TLObject.read(b) : undefined;
      let sentReaction = flags & (1 << 15) ? await TLObject.read(b) : undefined;
      return new Raw.StoryItem({
        pinned: pinned,
        public: _public,
        closeFriends: closeFriends,
        min: min,
        noforwards: noforwards,
        edited: edited,
        contacts: contacts,
        selectedContacts: selectedContacts,
        out: out,
        id: id,
        date: date,
        expireDate: expireDate,
        caption: caption,
        entities: entities,
        media: media,
        mediaAreas: mediaAreas,
        privacy: privacy,
        views: views,
        sentReaction: sentReaction,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.pinned ? 1 << 5 : 0;
      flags |= this.public ? 1 << 7 : 0;
      flags |= this.closeFriends ? 1 << 8 : 0;
      flags |= this.min ? 1 << 9 : 0;
      flags |= this.noforwards ? 1 << 10 : 0;
      flags |= this.edited ? 1 << 11 : 0;
      flags |= this.contacts ? 1 << 12 : 0;
      flags |= this.selectedContacts ? 1 << 13 : 0;
      flags |= this.out ? 1 << 16 : 0;
      flags |= this.caption !== undefined ? 1 << 0 : 0;
      flags |= this.entities ? 1 << 1 : 0;
      flags |= this.mediaAreas ? 1 << 14 : 0;
      flags |= this.privacy ? 1 << 2 : 0;
      flags |= this.views !== undefined ? 1 << 3 : 0;
      flags |= this.sentReaction !== undefined ? 1 << 15 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.Int.write(this.id) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.expireDate !== undefined) {
        b.write(Primitive.Int.write(this.expireDate) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(Primitive.String.write(this.caption) as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.media !== undefined) {
        b.write(this.media.write() as unknown as Buffer);
      }
      if (this.mediaAreas) {
        b.write(Primitive.Vector.write(this.mediaAreas) as unknown as Buffer);
      }
      if (this.privacy) {
        b.write(Primitive.Vector.write(this.privacy) as unknown as Buffer);
      }
      if (this.views !== undefined) {
        b.write(this.views.write() as unknown as Buffer);
      }
      if (this.sentReaction !== undefined) {
        b.write(this.sentReaction.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StoryView extends TLObject {
    blocked?: boolean;
    blockedMyStoriesFrom?: boolean;
    userId!: long;
    date!: int;
    reaction?: Raw.TypeReaction;

    constructor(params: {
      blocked?: boolean;
      blockedMyStoriesFrom?: boolean;
      userId: long;
      date: int;
      reaction?: Raw.TypeReaction;
    }) {
      super();
      this.classType = 'types';
      this.className = 'StoryView';
      this.constructorId = 0xb0bdeac5;
      this.subclassOfId = 0x35913fa3;
      this._slots = ['blocked', 'blockedMyStoriesFrom', 'userId', 'date', 'reaction'];
      this.blocked = params.blocked;
      this.blockedMyStoriesFrom = params.blockedMyStoriesFrom;
      this.userId = params.userId;
      this.date = params.date;
      this.reaction = params.reaction;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StoryView> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let blocked = flags & (1 << 0) ? true : false;
      let blockedMyStoriesFrom = flags & (1 << 1) ? true : false;
      let userId = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let reaction = flags & (1 << 2) ? await TLObject.read(b) : undefined;
      return new Raw.StoryView({
        blocked: blocked,
        blockedMyStoriesFrom: blockedMyStoriesFrom,
        userId: userId,
        date: date,
        reaction: reaction,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.blocked ? 1 << 0 : 0;
      flags |= this.blockedMyStoriesFrom ? 1 << 1 : 0;
      flags |= this.reaction !== undefined ? 1 << 2 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.reaction !== undefined) {
        b.write(this.reaction.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputReplyToMessage extends TLObject {
    replyToMsgId!: int;
    topMsgId?: int;
    replyToPeerId?: Raw.TypeInputPeer;
    quoteText?: string;
    quoteEntities?: Vector<Raw.TypeMessageEntity>;

    constructor(params: {
      replyToMsgId: int;
      topMsgId?: int;
      replyToPeerId?: Raw.TypeInputPeer;
      quoteText?: string;
      quoteEntities?: Vector<Raw.TypeMessageEntity>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputReplyToMessage';
      this.constructorId = 0x73ec805;
      this.subclassOfId = 0x8c71131d;
      this._slots = ['replyToMsgId', 'topMsgId', 'replyToPeerId', 'quoteText', 'quoteEntities'];
      this.replyToMsgId = params.replyToMsgId;
      this.topMsgId = params.topMsgId;
      this.replyToPeerId = params.replyToPeerId;
      this.quoteText = params.quoteText;
      this.quoteEntities = params.quoteEntities;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputReplyToMessage> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let replyToMsgId = await Primitive.Int.read(b);
      let topMsgId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let replyToPeerId = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let quoteText = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
      let quoteEntities = flags & (1 << 3) ? await TLObject.read(b) : [];
      return new Raw.InputReplyToMessage({
        replyToMsgId: replyToMsgId,
        topMsgId: topMsgId,
        replyToPeerId: replyToPeerId,
        quoteText: quoteText,
        quoteEntities: quoteEntities,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.topMsgId !== undefined ? 1 << 0 : 0;
      flags |= this.replyToPeerId !== undefined ? 1 << 1 : 0;
      flags |= this.quoteText !== undefined ? 1 << 2 : 0;
      flags |= this.quoteEntities ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.replyToMsgId !== undefined) {
        b.write(Primitive.Int.write(this.replyToMsgId) as unknown as Buffer);
      }
      if (this.topMsgId !== undefined) {
        b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
      }
      if (this.replyToPeerId !== undefined) {
        b.write(this.replyToPeerId.write() as unknown as Buffer);
      }
      if (this.quoteText !== undefined) {
        b.write(Primitive.String.write(this.quoteText) as unknown as Buffer);
      }
      if (this.quoteEntities) {
        b.write(Primitive.Vector.write(this.quoteEntities) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputReplyToStory extends TLObject {
    userId!: Raw.TypeInputUser;
    storyId!: int;

    constructor(params: { userId: Raw.TypeInputUser; storyId: int }) {
      super();
      this.classType = 'types';
      this.className = 'InputReplyToStory';
      this.constructorId = 0x15b0f283;
      this.subclassOfId = 0x8c71131d;
      this._slots = ['userId', 'storyId'];
      this.userId = params.userId;
      this.storyId = params.storyId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputReplyToStory> {
      // no flags

      let userId = await TLObject.read(b);
      let storyId = await Primitive.Int.read(b);
      return new Raw.InputReplyToStory({ userId: userId, storyId: storyId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.userId !== undefined) {
        b.write(this.userId.write() as unknown as Buffer);
      }
      if (this.storyId !== undefined) {
        b.write(Primitive.Int.write(this.storyId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class ExportedStoryLink extends TLObject {
    link!: string;

    constructor(params: { link: string }) {
      super();
      this.classType = 'types';
      this.className = 'ExportedStoryLink';
      this.constructorId = 0x3fc9053b;
      this.subclassOfId = 0xfc541a6;
      this._slots = ['link'];
      this.link = params.link;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.ExportedStoryLink> {
      // no flags

      let link = await Primitive.String.read(b);
      return new Raw.ExportedStoryLink({ link: link });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.link !== undefined) {
        b.write(Primitive.String.write(this.link) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class StoriesStealthMode extends TLObject {
    activeUntilDate?: int;
    cooldownUntilDate?: int;

    constructor(params: { activeUntilDate?: int; cooldownUntilDate?: int }) {
      super();
      this.classType = 'types';
      this.className = 'StoriesStealthMode';
      this.constructorId = 0x712e27fd;
      this.subclassOfId = 0x2ed8401;
      this._slots = ['activeUntilDate', 'cooldownUntilDate'];
      this.activeUntilDate = params.activeUntilDate;
      this.cooldownUntilDate = params.cooldownUntilDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.StoriesStealthMode> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let activeUntilDate = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let cooldownUntilDate = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      return new Raw.StoriesStealthMode({
        activeUntilDate: activeUntilDate,
        cooldownUntilDate: cooldownUntilDate,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.activeUntilDate !== undefined ? 1 << 0 : 0;
      flags |= this.cooldownUntilDate !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.activeUntilDate !== undefined) {
        b.write(Primitive.Int.write(this.activeUntilDate) as unknown as Buffer);
      }
      if (this.cooldownUntilDate !== undefined) {
        b.write(Primitive.Int.write(this.cooldownUntilDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MediaAreaCoordinates extends TLObject {
    x!: double;
    y!: double;
    w!: double;
    h!: double;
    rotation!: double;

    constructor(params: { x: double; y: double; w: double; h: double; rotation: double }) {
      super();
      this.classType = 'types';
      this.className = 'MediaAreaCoordinates';
      this.constructorId = 0x3d1ea4e;
      this.subclassOfId = 0x1d448c39;
      this._slots = ['x', 'y', 'w', 'h', 'rotation'];
      this.x = params.x;
      this.y = params.y;
      this.w = params.w;
      this.h = params.h;
      this.rotation = params.rotation;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MediaAreaCoordinates> {
      // no flags

      let x = await Primitive.Double.read(b);
      let y = await Primitive.Double.read(b);
      let w = await Primitive.Double.read(b);
      let h = await Primitive.Double.read(b);
      let rotation = await Primitive.Double.read(b);
      return new Raw.MediaAreaCoordinates({ x: x, y: y, w: w, h: h, rotation: rotation });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.x !== undefined) {
        b.write(Primitive.Double.write(this.x) as unknown as Buffer);
      }
      if (this.y !== undefined) {
        b.write(Primitive.Double.write(this.y) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Double.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Double.write(this.h) as unknown as Buffer);
      }
      if (this.rotation !== undefined) {
        b.write(Primitive.Double.write(this.rotation) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MediaAreaVenue extends TLObject {
    coordinates!: Raw.TypeMediaAreaCoordinates;
    geo!: Raw.TypeGeoPoint;
    title!: string;
    address!: string;
    provider!: string;
    venueId!: string;
    venueType!: string;

    constructor(params: {
      coordinates: Raw.TypeMediaAreaCoordinates;
      geo: Raw.TypeGeoPoint;
      title: string;
      address: string;
      provider: string;
      venueId: string;
      venueType: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MediaAreaVenue';
      this.constructorId = 0xbe82db9c;
      this.subclassOfId = 0xf36d7bf2;
      this._slots = ['coordinates', 'geo', 'title', 'address', 'provider', 'venueId', 'venueType'];
      this.coordinates = params.coordinates;
      this.geo = params.geo;
      this.title = params.title;
      this.address = params.address;
      this.provider = params.provider;
      this.venueId = params.venueId;
      this.venueType = params.venueType;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MediaAreaVenue> {
      // no flags

      let coordinates = await TLObject.read(b);
      let geo = await TLObject.read(b);
      let title = await Primitive.String.read(b);
      let address = await Primitive.String.read(b);
      let provider = await Primitive.String.read(b);
      let venueId = await Primitive.String.read(b);
      let venueType = await Primitive.String.read(b);
      return new Raw.MediaAreaVenue({
        coordinates: coordinates,
        geo: geo,
        title: title,
        address: address,
        provider: provider,
        venueId: venueId,
        venueType: venueType,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.coordinates !== undefined) {
        b.write(this.coordinates.write() as unknown as Buffer);
      }
      if (this.geo !== undefined) {
        b.write(this.geo.write() as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.address !== undefined) {
        b.write(Primitive.String.write(this.address) as unknown as Buffer);
      }
      if (this.provider !== undefined) {
        b.write(Primitive.String.write(this.provider) as unknown as Buffer);
      }
      if (this.venueId !== undefined) {
        b.write(Primitive.String.write(this.venueId) as unknown as Buffer);
      }
      if (this.venueType !== undefined) {
        b.write(Primitive.String.write(this.venueType) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InputMediaAreaVenue extends TLObject {
    coordinates!: Raw.TypeMediaAreaCoordinates;
    queryId!: long;
    resultId!: string;

    constructor(params: {
      coordinates: Raw.TypeMediaAreaCoordinates;
      queryId: long;
      resultId: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'InputMediaAreaVenue';
      this.constructorId = 0xb282217f;
      this.subclassOfId = 0xf36d7bf2;
      this._slots = ['coordinates', 'queryId', 'resultId'];
      this.coordinates = params.coordinates;
      this.queryId = params.queryId;
      this.resultId = params.resultId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InputMediaAreaVenue> {
      // no flags

      let coordinates = await TLObject.read(b);
      let queryId = await Primitive.Long.read(b);
      let resultId = await Primitive.String.read(b);
      return new Raw.InputMediaAreaVenue({
        coordinates: coordinates,
        queryId: queryId,
        resultId: resultId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.coordinates !== undefined) {
        b.write(this.coordinates.write() as unknown as Buffer);
      }
      if (this.queryId !== undefined) {
        b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
      }
      if (this.resultId !== undefined) {
        b.write(Primitive.String.write(this.resultId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MediaAreaGeoPoint extends TLObject {
    coordinates!: Raw.TypeMediaAreaCoordinates;
    geo!: Raw.TypeGeoPoint;

    constructor(params: { coordinates: Raw.TypeMediaAreaCoordinates; geo: Raw.TypeGeoPoint }) {
      super();
      this.classType = 'types';
      this.className = 'MediaAreaGeoPoint';
      this.constructorId = 0xdf8b3b22;
      this.subclassOfId = 0xf36d7bf2;
      this._slots = ['coordinates', 'geo'];
      this.coordinates = params.coordinates;
      this.geo = params.geo;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MediaAreaGeoPoint> {
      // no flags

      let coordinates = await TLObject.read(b);
      let geo = await TLObject.read(b);
      return new Raw.MediaAreaGeoPoint({ coordinates: coordinates, geo: geo });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.coordinates !== undefined) {
        b.write(this.coordinates.write() as unknown as Buffer);
      }
      if (this.geo !== undefined) {
        b.write(this.geo.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MediaAreaSuggestedReaction extends TLObject {
    dark?: boolean;
    flipped?: boolean;
    coordinates!: Raw.TypeMediaAreaCoordinates;
    reaction!: Raw.TypeReaction;

    constructor(params: {
      dark?: boolean;
      flipped?: boolean;
      coordinates: Raw.TypeMediaAreaCoordinates;
      reaction: Raw.TypeReaction;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MediaAreaSuggestedReaction';
      this.constructorId = 0x14455871;
      this.subclassOfId = 0xf36d7bf2;
      this._slots = ['dark', 'flipped', 'coordinates', 'reaction'];
      this.dark = params.dark;
      this.flipped = params.flipped;
      this.coordinates = params.coordinates;
      this.reaction = params.reaction;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MediaAreaSuggestedReaction> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let dark = flags & (1 << 0) ? true : false;
      let flipped = flags & (1 << 1) ? true : false;
      let coordinates = await TLObject.read(b);
      let reaction = await TLObject.read(b);
      return new Raw.MediaAreaSuggestedReaction({
        dark: dark,
        flipped: flipped,
        coordinates: coordinates,
        reaction: reaction,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.dark ? 1 << 0 : 0;
      flags |= this.flipped ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.coordinates !== undefined) {
        b.write(this.coordinates.write() as unknown as Buffer);
      }
      if (this.reaction !== undefined) {
        b.write(this.reaction.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PeerStories extends TLObject {
    peer!: Raw.TypePeer;
    maxReadId?: int;
    stories!: Vector<Raw.TypeStoryItem>;

    constructor(params: {
      peer: Raw.TypePeer;
      maxReadId?: int;
      stories: Vector<Raw.TypeStoryItem>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PeerStories';
      this.constructorId = 0x9a35e999;
      this.subclassOfId = 0x122c8a47;
      this._slots = ['peer', 'maxReadId', 'stories'];
      this.peer = params.peer;
      this.maxReadId = params.maxReadId;
      this.stories = params.stories;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PeerStories> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let peer = await TLObject.read(b);
      let maxReadId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
      let stories = await TLObject.read(b);
      return new Raw.PeerStories({ peer: peer, maxReadId: maxReadId, stories: stories });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.maxReadId !== undefined ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.maxReadId !== undefined) {
        b.write(Primitive.Int.write(this.maxReadId) as unknown as Buffer);
      }
      if (this.stories) {
        b.write(Primitive.Vector.write(this.stories) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PremiumGiftCodeOption extends TLObject {
    users!: int;
    months!: int;
    storeProduct?: string;
    storeQuantity?: int;
    currency!: string;
    amount!: long;

    constructor(params: {
      users: int;
      months: int;
      storeProduct?: string;
      storeQuantity?: int;
      currency: string;
      amount: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PremiumGiftCodeOption';
      this.constructorId = 0x257e962b;
      this.subclassOfId = 0x21d3c2;
      this._slots = ['users', 'months', 'storeProduct', 'storeQuantity', 'currency', 'amount'];
      this.users = params.users;
      this.months = params.months;
      this.storeProduct = params.storeProduct;
      this.storeQuantity = params.storeQuantity;
      this.currency = params.currency;
      this.amount = params.amount;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PremiumGiftCodeOption> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let users = await Primitive.Int.read(b);
      let months = await Primitive.Int.read(b);
      let storeProduct = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
      let storeQuantity = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      let currency = await Primitive.String.read(b);
      let amount = await Primitive.Long.read(b);
      return new Raw.PremiumGiftCodeOption({
        users: users,
        months: months,
        storeProduct: storeProduct,
        storeQuantity: storeQuantity,
        currency: currency,
        amount: amount,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.storeProduct !== undefined ? 1 << 0 : 0;
      flags |= this.storeQuantity !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.users !== undefined) {
        b.write(Primitive.Int.write(this.users) as unknown as Buffer);
      }
      if (this.months !== undefined) {
        b.write(Primitive.Int.write(this.months) as unknown as Buffer);
      }
      if (this.storeProduct !== undefined) {
        b.write(Primitive.String.write(this.storeProduct) as unknown as Buffer);
      }
      if (this.storeQuantity !== undefined) {
        b.write(Primitive.Int.write(this.storeQuantity) as unknown as Buffer);
      }
      if (this.currency !== undefined) {
        b.write(Primitive.String.write(this.currency) as unknown as Buffer);
      }
      if (this.amount !== undefined) {
        b.write(Primitive.Long.write(this.amount) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PrepaidGiveaway extends TLObject {
    id!: long;
    months!: int;
    quantity!: int;
    date!: int;

    constructor(params: { id: long; months: int; quantity: int; date: int }) {
      super();
      this.classType = 'types';
      this.className = 'PrepaidGiveaway';
      this.constructorId = 0xb2539d54;
      this.subclassOfId = 0xee3e6780;
      this._slots = ['id', 'months', 'quantity', 'date'];
      this.id = params.id;
      this.months = params.months;
      this.quantity = params.quantity;
      this.date = params.date;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PrepaidGiveaway> {
      // no flags

      let id = await Primitive.Long.read(b);
      let months = await Primitive.Int.read(b);
      let quantity = await Primitive.Int.read(b);
      let date = await Primitive.Int.read(b);
      return new Raw.PrepaidGiveaway({ id: id, months: months, quantity: quantity, date: date });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.months !== undefined) {
        b.write(Primitive.Int.write(this.months) as unknown as Buffer);
      }
      if (this.quantity !== undefined) {
        b.write(Primitive.Int.write(this.quantity) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class Boost extends TLObject {
    gift?: boolean;
    giveaway?: boolean;
    unclaimed?: boolean;
    id!: string;
    userId?: long;
    giveawayMsgId?: int;
    date!: int;
    expires!: int;
    usedGiftSlug?: string;
    multiplier?: int;

    constructor(params: {
      gift?: boolean;
      giveaway?: boolean;
      unclaimed?: boolean;
      id: string;
      userId?: long;
      giveawayMsgId?: int;
      date: int;
      expires: int;
      usedGiftSlug?: string;
      multiplier?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'Boost';
      this.constructorId = 0x2a1c8c71;
      this.subclassOfId = 0x97a5086c;
      this._slots = [
        'gift',
        'giveaway',
        'unclaimed',
        'id',
        'userId',
        'giveawayMsgId',
        'date',
        'expires',
        'usedGiftSlug',
        'multiplier',
      ];
      this.gift = params.gift;
      this.giveaway = params.giveaway;
      this.unclaimed = params.unclaimed;
      this.id = params.id;
      this.userId = params.userId;
      this.giveawayMsgId = params.giveawayMsgId;
      this.date = params.date;
      this.expires = params.expires;
      this.usedGiftSlug = params.usedGiftSlug;
      this.multiplier = params.multiplier;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.Boost> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let gift = flags & (1 << 1) ? true : false;
      let giveaway = flags & (1 << 2) ? true : false;
      let unclaimed = flags & (1 << 3) ? true : false;
      let id = await Primitive.String.read(b);
      let userId = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
      let giveawayMsgId = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
      let date = await Primitive.Int.read(b);
      let expires = await Primitive.Int.read(b);
      let usedGiftSlug = flags & (1 << 4) ? await Primitive.String.read(b) : undefined;
      let multiplier = flags & (1 << 5) ? await Primitive.Int.read(b) : undefined;
      return new Raw.Boost({
        gift: gift,
        giveaway: giveaway,
        unclaimed: unclaimed,
        id: id,
        userId: userId,
        giveawayMsgId: giveawayMsgId,
        date: date,
        expires: expires,
        usedGiftSlug: usedGiftSlug,
        multiplier: multiplier,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.gift ? 1 << 1 : 0;
      flags |= this.giveaway ? 1 << 2 : 0;
      flags |= this.unclaimed ? 1 << 3 : 0;
      flags |= this.userId !== undefined ? 1 << 0 : 0;
      flags |= this.giveawayMsgId !== undefined ? 1 << 2 : 0;
      flags |= this.usedGiftSlug !== undefined ? 1 << 4 : 0;
      flags |= this.multiplier !== undefined ? 1 << 5 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.id !== undefined) {
        b.write(Primitive.String.write(this.id) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Long.write(this.userId) as unknown as Buffer);
      }
      if (this.giveawayMsgId !== undefined) {
        b.write(Primitive.Int.write(this.giveawayMsgId) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.expires !== undefined) {
        b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
      }
      if (this.usedGiftSlug !== undefined) {
        b.write(Primitive.String.write(this.usedGiftSlug) as unknown as Buffer);
      }
      if (this.multiplier !== undefined) {
        b.write(Primitive.Int.write(this.multiplier) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class MyBoost extends TLObject {
    slot!: int;
    peer?: Raw.TypePeer;
    date!: int;
    expires!: int;
    cooldownUntilDate?: int;

    constructor(params: {
      slot: int;
      peer?: Raw.TypePeer;
      date: int;
      expires: int;
      cooldownUntilDate?: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'MyBoost';
      this.constructorId = 0xc448415c;
      this.subclassOfId = 0xc51a68bf;
      this._slots = ['slot', 'peer', 'date', 'expires', 'cooldownUntilDate'];
      this.slot = params.slot;
      this.peer = params.peer;
      this.date = params.date;
      this.expires = params.expires;
      this.cooldownUntilDate = params.cooldownUntilDate;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.MyBoost> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let slot = await Primitive.Int.read(b);
      let peer = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let date = await Primitive.Int.read(b);
      let expires = await Primitive.Int.read(b);
      let cooldownUntilDate = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
      return new Raw.MyBoost({
        slot: slot,
        peer: peer,
        date: date,
        expires: expires,
        cooldownUntilDate: cooldownUntilDate,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.peer !== undefined ? 1 << 0 : 0;
      flags |= this.cooldownUntilDate !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.slot !== undefined) {
        b.write(Primitive.Int.write(this.slot) as unknown as Buffer);
      }
      if (this.peer !== undefined) {
        b.write(this.peer.write() as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.expires !== undefined) {
        b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
      }
      if (this.cooldownUntilDate !== undefined) {
        b.write(Primitive.Int.write(this.cooldownUntilDate) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InvokeAfterMsg extends TLObject {
    __response__!: X;
    msgId!: long;
    query!: X;

    constructor(params: { msgId: long; query: X }) {
      super();
      this.classType = 'functions';
      this.className = 'InvokeAfterMsg';
      this.constructorId = 0xcb9f372d;
      this.subclassOfId = 0xb7b2364b;
      this._slots = ['msgId', 'query'];
      this.msgId = params.msgId;
      this.query = params.query;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InvokeAfterMsg> {
      // no flags

      let msgId = await Primitive.Long.read(b);
      let query = await TLObject.read(b);
      return new Raw.InvokeAfterMsg({ msgId: msgId, query: query });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.msgId !== undefined) {
        b.write(Primitive.Long.write(this.msgId) as unknown as Buffer);
      }
      if (this.query !== undefined) {
        b.write(this.query.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InvokeAfterMsgs extends TLObject {
    __response__!: X;
    msgIds!: Vector<long>;
    query!: X;

    constructor(params: { msgIds: Vector<long>; query: X }) {
      super();
      this.classType = 'functions';
      this.className = 'InvokeAfterMsgs';
      this.constructorId = 0x3dc4b4f0;
      this.subclassOfId = 0xb7b2364b;
      this._slots = ['msgIds', 'query'];
      this.msgIds = params.msgIds;
      this.query = params.query;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InvokeAfterMsgs> {
      // no flags

      let msgIds = await TLObject.read(b, Primitive.Long);
      let query = await TLObject.read(b);
      return new Raw.InvokeAfterMsgs({ msgIds: msgIds, query: query });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.msgIds) {
        b.write(Primitive.Vector.write(this.msgIds, Primitive.Long) as unknown as Buffer);
      }
      if (this.query !== undefined) {
        b.write(this.query.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InitConnection extends TLObject {
    __response__!: X;
    apiId!: int;
    deviceModel!: string;
    systemVersion!: string;
    appVersion!: string;
    systemLangCode!: string;
    langPack!: string;
    langCode!: string;
    proxy?: Raw.TypeInputClientProxy;
    params?: Raw.TypeJSONValue;
    query!: X;

    constructor(params: {
      apiId: int;
      deviceModel: string;
      systemVersion: string;
      appVersion: string;
      systemLangCode: string;
      langPack: string;
      langCode: string;
      proxy?: Raw.TypeInputClientProxy;
      params?: Raw.TypeJSONValue;
      query: X;
    }) {
      super();
      this.classType = 'functions';
      this.className = 'InitConnection';
      this.constructorId = 0xc1cd5ea9;
      this.subclassOfId = 0xb7b2364b;
      this._slots = [
        'apiId',
        'deviceModel',
        'systemVersion',
        'appVersion',
        'systemLangCode',
        'langPack',
        'langCode',
        'proxy',
        'params',
        'query',
      ];
      this.apiId = params.apiId;
      this.deviceModel = params.deviceModel;
      this.systemVersion = params.systemVersion;
      this.appVersion = params.appVersion;
      this.systemLangCode = params.systemLangCode;
      this.langPack = params.langPack;
      this.langCode = params.langCode;
      this.proxy = params.proxy;
      this.params = params.params;
      this.query = params.query;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InitConnection> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let apiId = await Primitive.Int.read(b);
      let deviceModel = await Primitive.String.read(b);
      let systemVersion = await Primitive.String.read(b);
      let appVersion = await Primitive.String.read(b);
      let systemLangCode = await Primitive.String.read(b);
      let langPack = await Primitive.String.read(b);
      let langCode = await Primitive.String.read(b);
      let proxy = flags & (1 << 0) ? await TLObject.read(b) : undefined;
      let params = flags & (1 << 1) ? await TLObject.read(b) : undefined;
      let query = await TLObject.read(b);
      return new Raw.InitConnection({
        apiId: apiId,
        deviceModel: deviceModel,
        systemVersion: systemVersion,
        appVersion: appVersion,
        systemLangCode: systemLangCode,
        langPack: langPack,
        langCode: langCode,
        proxy: proxy,
        params: params,
        query: query,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.proxy !== undefined ? 1 << 0 : 0;
      flags |= this.params !== undefined ? 1 << 1 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.apiId !== undefined) {
        b.write(Primitive.Int.write(this.apiId) as unknown as Buffer);
      }
      if (this.deviceModel !== undefined) {
        b.write(Primitive.String.write(this.deviceModel) as unknown as Buffer);
      }
      if (this.systemVersion !== undefined) {
        b.write(Primitive.String.write(this.systemVersion) as unknown as Buffer);
      }
      if (this.appVersion !== undefined) {
        b.write(Primitive.String.write(this.appVersion) as unknown as Buffer);
      }
      if (this.systemLangCode !== undefined) {
        b.write(Primitive.String.write(this.systemLangCode) as unknown as Buffer);
      }
      if (this.langPack !== undefined) {
        b.write(Primitive.String.write(this.langPack) as unknown as Buffer);
      }
      if (this.langCode !== undefined) {
        b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
      }
      if (this.proxy !== undefined) {
        b.write(this.proxy.write() as unknown as Buffer);
      }
      if (this.params !== undefined) {
        b.write(this.params.write() as unknown as Buffer);
      }
      if (this.query !== undefined) {
        b.write(this.query.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InvokeWithLayer extends TLObject {
    __response__!: X;
    layer!: int;
    query!: X;

    constructor(params: { layer: int; query: X }) {
      super();
      this.classType = 'functions';
      this.className = 'InvokeWithLayer';
      this.constructorId = 0xda9b0d0d;
      this.subclassOfId = 0xb7b2364b;
      this._slots = ['layer', 'query'];
      this.layer = params.layer;
      this.query = params.query;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InvokeWithLayer> {
      // no flags

      let layer = await Primitive.Int.read(b);
      let query = await TLObject.read(b);
      return new Raw.InvokeWithLayer({ layer: layer, query: query });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.layer !== undefined) {
        b.write(Primitive.Int.write(this.layer) as unknown as Buffer);
      }
      if (this.query !== undefined) {
        b.write(this.query.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InvokeWithoutUpdates extends TLObject {
    __response__!: X;
    query!: X;

    constructor(params: { query: X }) {
      super();
      this.classType = 'functions';
      this.className = 'InvokeWithoutUpdates';
      this.constructorId = 0xbf9459b7;
      this.subclassOfId = 0xb7b2364b;
      this._slots = ['query'];
      this.query = params.query;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InvokeWithoutUpdates> {
      // no flags

      let query = await TLObject.read(b);
      return new Raw.InvokeWithoutUpdates({ query: query });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.query !== undefined) {
        b.write(this.query.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InvokeWithMessagesRange extends TLObject {
    __response__!: X;
    range!: Raw.TypeMessageRange;
    query!: X;

    constructor(params: { range: Raw.TypeMessageRange; query: X }) {
      super();
      this.classType = 'functions';
      this.className = 'InvokeWithMessagesRange';
      this.constructorId = 0x365275f2;
      this.subclassOfId = 0xb7b2364b;
      this._slots = ['range', 'query'];
      this.range = params.range;
      this.query = params.query;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InvokeWithMessagesRange> {
      // no flags

      let range = await TLObject.read(b);
      let query = await TLObject.read(b);
      return new Raw.InvokeWithMessagesRange({ range: range, query: query });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.range !== undefined) {
        b.write(this.range.write() as unknown as Buffer);
      }
      if (this.query !== undefined) {
        b.write(this.query.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class InvokeWithTakeout extends TLObject {
    __response__!: X;
    takeoutId!: long;
    query!: X;

    constructor(params: { takeoutId: long; query: X }) {
      super();
      this.classType = 'functions';
      this.className = 'InvokeWithTakeout';
      this.constructorId = 0xaca9fd2e;
      this.subclassOfId = 0xb7b2364b;
      this._slots = ['takeoutId', 'query'];
      this.takeoutId = params.takeoutId;
      this.query = params.query;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.InvokeWithTakeout> {
      // no flags

      let takeoutId = await Primitive.Long.read(b);
      let query = await TLObject.read(b);
      return new Raw.InvokeWithTakeout({ takeoutId: takeoutId, query: query });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.takeoutId !== undefined) {
        b.write(Primitive.Long.write(this.takeoutId) as unknown as Buffer);
      }
      if (this.query !== undefined) {
        b.write(this.query.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessage8 extends TLObject {
    randomId!: long;
    randomBytes!: bytes;
    message!: string;
    media!: Raw.TypeDecryptedMessageMedia;

    constructor(params: {
      randomId: long;
      randomBytes: bytes;
      message: string;
      media: Raw.TypeDecryptedMessageMedia;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessage8';
      this.constructorId = 0x1f814f1f;
      this.subclassOfId = 0x5303193e;
      this._slots = ['randomId', 'randomBytes', 'message', 'media'];
      this.randomId = params.randomId;
      this.randomBytes = params.randomBytes;
      this.message = params.message;
      this.media = params.media;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessage8> {
      // no flags

      let randomId = await Primitive.Long.read(b);
      let randomBytes = await Primitive.Bytes.read(b);
      let message = await Primitive.String.read(b);
      let media = await TLObject.read(b);
      return new Raw.DecryptedMessage8({
        randomId: randomId,
        randomBytes: randomBytes,
        message: message,
        media: media,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.randomId !== undefined) {
        b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
      }
      if (this.randomBytes !== undefined) {
        b.write(Primitive.Bytes.write(this.randomBytes) as unknown as Buffer);
      }
      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.media !== undefined) {
        b.write(this.media.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageService8 extends TLObject {
    randomId!: long;
    randomBytes!: bytes;
    action!: Raw.TypeDecryptedMessageAction;

    constructor(params: {
      randomId: long;
      randomBytes: bytes;
      action: Raw.TypeDecryptedMessageAction;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageService8';
      this.constructorId = 0xaa48327d;
      this.subclassOfId = 0x5303193e;
      this._slots = ['randomId', 'randomBytes', 'action'];
      this.randomId = params.randomId;
      this.randomBytes = params.randomBytes;
      this.action = params.action;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageService8> {
      // no flags

      let randomId = await Primitive.Long.read(b);
      let randomBytes = await Primitive.Bytes.read(b);
      let action = await TLObject.read(b);
      return new Raw.DecryptedMessageService8({
        randomId: randomId,
        randomBytes: randomBytes,
        action: action,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.randomId !== undefined) {
        b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
      }
      if (this.randomBytes !== undefined) {
        b.write(Primitive.Bytes.write(this.randomBytes) as unknown as Buffer);
      }
      if (this.action !== undefined) {
        b.write(this.action.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaEmpty8 extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaEmpty8';
      this.constructorId = 0x89f5c4a;
      this.subclassOfId = 0xb3d2034;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageMediaEmpty8> {
      // no flags

      return new Raw.DecryptedMessageMediaEmpty8();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class DecryptedMessageMediaPhoto8 extends TLObject {
    thumb!: bytes;
    thumbW!: int;
    thumbH!: int;
    w!: int;
    h!: int;
    size!: int;
    key!: bytes;
    iv!: bytes;

    constructor(params: {
      thumb: bytes;
      thumbW: int;
      thumbH: int;
      w: int;
      h: int;
      size: int;
      key: bytes;
      iv: bytes;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaPhoto8';
      this.constructorId = 0x32798a8c;
      this.subclassOfId = 0xb3d2034;
      this._slots = ['thumb', 'thumbW', 'thumbH', 'w', 'h', 'size', 'key', 'iv'];
      this.thumb = params.thumb;
      this.thumbW = params.thumbW;
      this.thumbH = params.thumbH;
      this.w = params.w;
      this.h = params.h;
      this.size = params.size;
      this.key = params.key;
      this.iv = params.iv;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageMediaPhoto8> {
      // no flags

      let thumb = await Primitive.Bytes.read(b);
      let thumbW = await Primitive.Int.read(b);
      let thumbH = await Primitive.Int.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let size = await Primitive.Int.read(b);
      let key = await Primitive.Bytes.read(b);
      let iv = await Primitive.Bytes.read(b);
      return new Raw.DecryptedMessageMediaPhoto8({
        thumb: thumb,
        thumbW: thumbW,
        thumbH: thumbH,
        w: w,
        h: h,
        size: size,
        key: key,
        iv: iv,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.thumb !== undefined) {
        b.write(Primitive.Bytes.write(this.thumb) as unknown as Buffer);
      }
      if (this.thumbW !== undefined) {
        b.write(Primitive.Int.write(this.thumbW) as unknown as Buffer);
      }
      if (this.thumbH !== undefined) {
        b.write(Primitive.Int.write(this.thumbH) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.key !== undefined) {
        b.write(Primitive.Bytes.write(this.key) as unknown as Buffer);
      }
      if (this.iv !== undefined) {
        b.write(Primitive.Bytes.write(this.iv) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaVideo8 extends TLObject {
    thumb!: bytes;
    thumbW!: int;
    thumbH!: int;
    duration!: int;
    w!: int;
    h!: int;
    size!: int;
    key!: bytes;
    iv!: bytes;

    constructor(params: {
      thumb: bytes;
      thumbW: int;
      thumbH: int;
      duration: int;
      w: int;
      h: int;
      size: int;
      key: bytes;
      iv: bytes;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaVideo8';
      this.constructorId = 0x4cee6ef3;
      this.subclassOfId = 0xb3d2034;
      this._slots = ['thumb', 'thumbW', 'thumbH', 'duration', 'w', 'h', 'size', 'key', 'iv'];
      this.thumb = params.thumb;
      this.thumbW = params.thumbW;
      this.thumbH = params.thumbH;
      this.duration = params.duration;
      this.w = params.w;
      this.h = params.h;
      this.size = params.size;
      this.key = params.key;
      this.iv = params.iv;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageMediaVideo8> {
      // no flags

      let thumb = await Primitive.Bytes.read(b);
      let thumbW = await Primitive.Int.read(b);
      let thumbH = await Primitive.Int.read(b);
      let duration = await Primitive.Int.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let size = await Primitive.Int.read(b);
      let key = await Primitive.Bytes.read(b);
      let iv = await Primitive.Bytes.read(b);
      return new Raw.DecryptedMessageMediaVideo8({
        thumb: thumb,
        thumbW: thumbW,
        thumbH: thumbH,
        duration: duration,
        w: w,
        h: h,
        size: size,
        key: key,
        iv: iv,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.thumb !== undefined) {
        b.write(Primitive.Bytes.write(this.thumb) as unknown as Buffer);
      }
      if (this.thumbW !== undefined) {
        b.write(Primitive.Int.write(this.thumbW) as unknown as Buffer);
      }
      if (this.thumbH !== undefined) {
        b.write(Primitive.Int.write(this.thumbH) as unknown as Buffer);
      }
      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.key !== undefined) {
        b.write(Primitive.Bytes.write(this.key) as unknown as Buffer);
      }
      if (this.iv !== undefined) {
        b.write(Primitive.Bytes.write(this.iv) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaGeoPoint8 extends TLObject {
    lat!: double;
    long!: double;

    constructor(params: { lat: double; long: double }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaGeoPoint8';
      this.constructorId = 0x35480a59;
      this.subclassOfId = 0xb3d2034;
      this._slots = ['lat', 'long'];
      this.lat = params.lat;
      this.long = params.long;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageMediaGeoPoint8> {
      // no flags

      let lat = await Primitive.Double.read(b);
      let long = await Primitive.Double.read(b);
      return new Raw.DecryptedMessageMediaGeoPoint8({ lat: lat, long: long });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.lat !== undefined) {
        b.write(Primitive.Double.write(this.lat) as unknown as Buffer);
      }
      if (this.long !== undefined) {
        b.write(Primitive.Double.write(this.long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaContact8 extends TLObject {
    phoneNumber!: string;
    firstName!: string;
    lastName!: string;
    userId!: int;

    constructor(params: { phoneNumber: string; firstName: string; lastName: string; userId: int }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaContact8';
      this.constructorId = 0x588a0a97;
      this.subclassOfId = 0xb3d2034;
      this._slots = ['phoneNumber', 'firstName', 'lastName', 'userId'];
      this.phoneNumber = params.phoneNumber;
      this.firstName = params.firstName;
      this.lastName = params.lastName;
      this.userId = params.userId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageMediaContact8> {
      // no flags

      let phoneNumber = await Primitive.String.read(b);
      let firstName = await Primitive.String.read(b);
      let lastName = await Primitive.String.read(b);
      let userId = await Primitive.Int.read(b);
      return new Raw.DecryptedMessageMediaContact8({
        phoneNumber: phoneNumber,
        firstName: firstName,
        lastName: lastName,
        userId: userId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.phoneNumber !== undefined) {
        b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
      }
      if (this.firstName !== undefined) {
        b.write(Primitive.String.write(this.firstName) as unknown as Buffer);
      }
      if (this.lastName !== undefined) {
        b.write(Primitive.String.write(this.lastName) as unknown as Buffer);
      }
      if (this.userId !== undefined) {
        b.write(Primitive.Int.write(this.userId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageActionSetMessageTTL8 extends TLObject {
    ttlSeconds!: int;

    constructor(params: { ttlSeconds: int }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionSetMessageTTL8';
      this.constructorId = 0xa1733aec;
      this.subclassOfId = 0x6faf258d;
      this._slots = ['ttlSeconds'];
      this.ttlSeconds = params.ttlSeconds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageActionSetMessageTTL8> {
      // no flags

      let ttlSeconds = await Primitive.Int.read(b);
      return new Raw.DecryptedMessageActionSetMessageTTL8({ ttlSeconds: ttlSeconds });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.ttlSeconds !== undefined) {
        b.write(Primitive.Int.write(this.ttlSeconds) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaDocument8 extends TLObject {
    thumb!: bytes;
    thumbW!: int;
    thumbH!: int;
    fileName!: string;
    mimeType!: string;
    size!: int;
    key!: bytes;
    iv!: bytes;

    constructor(params: {
      thumb: bytes;
      thumbW: int;
      thumbH: int;
      fileName: string;
      mimeType: string;
      size: int;
      key: bytes;
      iv: bytes;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaDocument8';
      this.constructorId = 0xb095434b;
      this.subclassOfId = 0xb3d2034;
      this._slots = ['thumb', 'thumbW', 'thumbH', 'fileName', 'mimeType', 'size', 'key', 'iv'];
      this.thumb = params.thumb;
      this.thumbW = params.thumbW;
      this.thumbH = params.thumbH;
      this.fileName = params.fileName;
      this.mimeType = params.mimeType;
      this.size = params.size;
      this.key = params.key;
      this.iv = params.iv;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageMediaDocument8> {
      // no flags

      let thumb = await Primitive.Bytes.read(b);
      let thumbW = await Primitive.Int.read(b);
      let thumbH = await Primitive.Int.read(b);
      let fileName = await Primitive.String.read(b);
      let mimeType = await Primitive.String.read(b);
      let size = await Primitive.Int.read(b);
      let key = await Primitive.Bytes.read(b);
      let iv = await Primitive.Bytes.read(b);
      return new Raw.DecryptedMessageMediaDocument8({
        thumb: thumb,
        thumbW: thumbW,
        thumbH: thumbH,
        fileName: fileName,
        mimeType: mimeType,
        size: size,
        key: key,
        iv: iv,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.thumb !== undefined) {
        b.write(Primitive.Bytes.write(this.thumb) as unknown as Buffer);
      }
      if (this.thumbW !== undefined) {
        b.write(Primitive.Int.write(this.thumbW) as unknown as Buffer);
      }
      if (this.thumbH !== undefined) {
        b.write(Primitive.Int.write(this.thumbH) as unknown as Buffer);
      }
      if (this.fileName !== undefined) {
        b.write(Primitive.String.write(this.fileName) as unknown as Buffer);
      }
      if (this.mimeType !== undefined) {
        b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.key !== undefined) {
        b.write(Primitive.Bytes.write(this.key) as unknown as Buffer);
      }
      if (this.iv !== undefined) {
        b.write(Primitive.Bytes.write(this.iv) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaAudio8 extends TLObject {
    duration!: int;
    size!: int;
    key!: bytes;
    iv!: bytes;

    constructor(params: { duration: int; size: int; key: bytes; iv: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaAudio8';
      this.constructorId = 0x6080758f;
      this.subclassOfId = 0xb3d2034;
      this._slots = ['duration', 'size', 'key', 'iv'];
      this.duration = params.duration;
      this.size = params.size;
      this.key = params.key;
      this.iv = params.iv;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageMediaAudio8> {
      // no flags

      let duration = await Primitive.Int.read(b);
      let size = await Primitive.Int.read(b);
      let key = await Primitive.Bytes.read(b);
      let iv = await Primitive.Bytes.read(b);
      return new Raw.DecryptedMessageMediaAudio8({
        duration: duration,
        size: size,
        key: key,
        iv: iv,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.key !== undefined) {
        b.write(Primitive.Bytes.write(this.key) as unknown as Buffer);
      }
      if (this.iv !== undefined) {
        b.write(Primitive.Bytes.write(this.iv) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageActionReadMessages8 extends TLObject {
    randomIds!: Vector<long>;

    constructor(params: { randomIds: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionReadMessages8';
      this.constructorId = 0xc4f40be;
      this.subclassOfId = 0x6faf258d;
      this._slots = ['randomIds'];
      this.randomIds = params.randomIds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageActionReadMessages8> {
      // no flags

      let randomIds = await TLObject.read(b, Primitive.Long);
      return new Raw.DecryptedMessageActionReadMessages8({ randomIds: randomIds });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.randomIds) {
        b.write(Primitive.Vector.write(this.randomIds, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageActionDeleteMessages8 extends TLObject {
    randomIds!: Vector<long>;

    constructor(params: { randomIds: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionDeleteMessages8';
      this.constructorId = 0x65614304;
      this.subclassOfId = 0x6faf258d;
      this._slots = ['randomIds'];
      this.randomIds = params.randomIds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageActionDeleteMessages8> {
      // no flags

      let randomIds = await TLObject.read(b, Primitive.Long);
      return new Raw.DecryptedMessageActionDeleteMessages8({ randomIds: randomIds });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.randomIds) {
        b.write(Primitive.Vector.write(this.randomIds, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageActionScreenshotMessages8 extends TLObject {
    randomIds!: Vector<long>;

    constructor(params: { randomIds: Vector<long> }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionScreenshotMessages8';
      this.constructorId = 0x8ac1f475;
      this.subclassOfId = 0x6faf258d;
      this._slots = ['randomIds'];
      this.randomIds = params.randomIds;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageActionScreenshotMessages8> {
      // no flags

      let randomIds = await TLObject.read(b, Primitive.Long);
      return new Raw.DecryptedMessageActionScreenshotMessages8({ randomIds: randomIds });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.randomIds) {
        b.write(Primitive.Vector.write(this.randomIds, Primitive.Long) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageActionFlushHistory8 extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionFlushHistory8';
      this.constructorId = 0x6719e45c;
      this.subclassOfId = 0x6faf258d;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageActionFlushHistory8> {
      // no flags

      return new Raw.DecryptedMessageActionFlushHistory8();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class DecryptedMessage17 extends TLObject {
    randomId!: long;
    ttl!: int;
    message!: string;
    media!: Raw.TypeDecryptedMessageMedia;

    constructor(params: {
      randomId: long;
      ttl: int;
      message: string;
      media: Raw.TypeDecryptedMessageMedia;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessage17';
      this.constructorId = 0x204d3878;
      this.subclassOfId = 0x5303193e;
      this._slots = ['randomId', 'ttl', 'message', 'media'];
      this.randomId = params.randomId;
      this.ttl = params.ttl;
      this.message = params.message;
      this.media = params.media;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessage17> {
      // no flags

      let randomId = await Primitive.Long.read(b);
      let ttl = await Primitive.Int.read(b);
      let message = await Primitive.String.read(b);
      let media = await TLObject.read(b);
      return new Raw.DecryptedMessage17({
        randomId: randomId,
        ttl: ttl,
        message: message,
        media: media,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.randomId !== undefined) {
        b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
      }
      if (this.ttl !== undefined) {
        b.write(Primitive.Int.write(this.ttl) as unknown as Buffer);
      }
      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.media !== undefined) {
        b.write(this.media.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageService17 extends TLObject {
    randomId!: long;
    action!: Raw.TypeDecryptedMessageAction;

    constructor(params: { randomId: long; action: Raw.TypeDecryptedMessageAction }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageService17';
      this.constructorId = 0x73164160;
      this.subclassOfId = 0x5303193e;
      this._slots = ['randomId', 'action'];
      this.randomId = params.randomId;
      this.action = params.action;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageService17> {
      // no flags

      let randomId = await Primitive.Long.read(b);
      let action = await TLObject.read(b);
      return new Raw.DecryptedMessageService17({ randomId: randomId, action: action });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.randomId !== undefined) {
        b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
      }
      if (this.action !== undefined) {
        b.write(this.action.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaVideo17 extends TLObject {
    thumb!: bytes;
    thumbW!: int;
    thumbH!: int;
    duration!: int;
    mimeType!: string;
    w!: int;
    h!: int;
    size!: int;
    key!: bytes;
    iv!: bytes;

    constructor(params: {
      thumb: bytes;
      thumbW: int;
      thumbH: int;
      duration: int;
      mimeType: string;
      w: int;
      h: int;
      size: int;
      key: bytes;
      iv: bytes;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaVideo17';
      this.constructorId = 0x524a415d;
      this.subclassOfId = 0xb3d2034;
      this._slots = [
        'thumb',
        'thumbW',
        'thumbH',
        'duration',
        'mimeType',
        'w',
        'h',
        'size',
        'key',
        'iv',
      ];
      this.thumb = params.thumb;
      this.thumbW = params.thumbW;
      this.thumbH = params.thumbH;
      this.duration = params.duration;
      this.mimeType = params.mimeType;
      this.w = params.w;
      this.h = params.h;
      this.size = params.size;
      this.key = params.key;
      this.iv = params.iv;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageMediaVideo17> {
      // no flags

      let thumb = await Primitive.Bytes.read(b);
      let thumbW = await Primitive.Int.read(b);
      let thumbH = await Primitive.Int.read(b);
      let duration = await Primitive.Int.read(b);
      let mimeType = await Primitive.String.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let size = await Primitive.Int.read(b);
      let key = await Primitive.Bytes.read(b);
      let iv = await Primitive.Bytes.read(b);
      return new Raw.DecryptedMessageMediaVideo17({
        thumb: thumb,
        thumbW: thumbW,
        thumbH: thumbH,
        duration: duration,
        mimeType: mimeType,
        w: w,
        h: h,
        size: size,
        key: key,
        iv: iv,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.thumb !== undefined) {
        b.write(Primitive.Bytes.write(this.thumb) as unknown as Buffer);
      }
      if (this.thumbW !== undefined) {
        b.write(Primitive.Int.write(this.thumbW) as unknown as Buffer);
      }
      if (this.thumbH !== undefined) {
        b.write(Primitive.Int.write(this.thumbH) as unknown as Buffer);
      }
      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      if (this.mimeType !== undefined) {
        b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.key !== undefined) {
        b.write(Primitive.Bytes.write(this.key) as unknown as Buffer);
      }
      if (this.iv !== undefined) {
        b.write(Primitive.Bytes.write(this.iv) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaAudio17 extends TLObject {
    duration!: int;
    mimeType!: string;
    size!: int;
    key!: bytes;
    iv!: bytes;

    constructor(params: { duration: int; mimeType: string; size: int; key: bytes; iv: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaAudio17';
      this.constructorId = 0x57e0a9cb;
      this.subclassOfId = 0xb3d2034;
      this._slots = ['duration', 'mimeType', 'size', 'key', 'iv'];
      this.duration = params.duration;
      this.mimeType = params.mimeType;
      this.size = params.size;
      this.key = params.key;
      this.iv = params.iv;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageMediaAudio17> {
      // no flags

      let duration = await Primitive.Int.read(b);
      let mimeType = await Primitive.String.read(b);
      let size = await Primitive.Int.read(b);
      let key = await Primitive.Bytes.read(b);
      let iv = await Primitive.Bytes.read(b);
      return new Raw.DecryptedMessageMediaAudio17({
        duration: duration,
        mimeType: mimeType,
        size: size,
        key: key,
        iv: iv,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      if (this.mimeType !== undefined) {
        b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.key !== undefined) {
        b.write(Primitive.Bytes.write(this.key) as unknown as Buffer);
      }
      if (this.iv !== undefined) {
        b.write(Primitive.Bytes.write(this.iv) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageLayer17 extends TLObject {
    randomBytes!: bytes;
    layer!: int;
    inSeqNo!: int;
    outSeqNo!: int;
    message!: Raw.TypeDecryptedMessage;

    constructor(params: {
      randomBytes: bytes;
      layer: int;
      inSeqNo: int;
      outSeqNo: int;
      message: Raw.TypeDecryptedMessage;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageLayer17';
      this.constructorId = 0x1be31789;
      this.subclassOfId = 0x85caa022;
      this._slots = ['randomBytes', 'layer', 'inSeqNo', 'outSeqNo', 'message'];
      this.randomBytes = params.randomBytes;
      this.layer = params.layer;
      this.inSeqNo = params.inSeqNo;
      this.outSeqNo = params.outSeqNo;
      this.message = params.message;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageLayer17> {
      // no flags

      let randomBytes = await Primitive.Bytes.read(b);
      let layer = await Primitive.Int.read(b);
      let inSeqNo = await Primitive.Int.read(b);
      let outSeqNo = await Primitive.Int.read(b);
      let message = await TLObject.read(b);
      return new Raw.DecryptedMessageLayer17({
        randomBytes: randomBytes,
        layer: layer,
        inSeqNo: inSeqNo,
        outSeqNo: outSeqNo,
        message: message,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.randomBytes !== undefined) {
        b.write(Primitive.Bytes.write(this.randomBytes) as unknown as Buffer);
      }
      if (this.layer !== undefined) {
        b.write(Primitive.Int.write(this.layer) as unknown as Buffer);
      }
      if (this.inSeqNo !== undefined) {
        b.write(Primitive.Int.write(this.inSeqNo) as unknown as Buffer);
      }
      if (this.outSeqNo !== undefined) {
        b.write(Primitive.Int.write(this.outSeqNo) as unknown as Buffer);
      }
      if (this.message !== undefined) {
        b.write(this.message.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SendMessageUploadVideoAction17 extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageUploadVideoAction17';
      this.constructorId = 0x92042ff7;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SendMessageUploadVideoAction17> {
      // no flags

      return new Raw.SendMessageUploadVideoAction17();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageUploadAudioAction17 extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageUploadAudioAction17';
      this.constructorId = 0xe6ac8a6f;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SendMessageUploadAudioAction17> {
      // no flags

      return new Raw.SendMessageUploadAudioAction17();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageUploadPhotoAction17 extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageUploadPhotoAction17';
      this.constructorId = 0x990a3c1a;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SendMessageUploadPhotoAction17> {
      // no flags

      return new Raw.SendMessageUploadPhotoAction17();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class SendMessageUploadDocumentAction17 extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageUploadDocumentAction17';
      this.constructorId = 0x8faee98e;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SendMessageUploadDocumentAction17> {
      // no flags

      return new Raw.SendMessageUploadDocumentAction17();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class DecryptedMessageActionResend17 extends TLObject {
    startSeqNo!: int;
    endSeqNo!: int;

    constructor(params: { startSeqNo: int; endSeqNo: int }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionResend17';
      this.constructorId = 0x511110b0;
      this.subclassOfId = 0x6faf258d;
      this._slots = ['startSeqNo', 'endSeqNo'];
      this.startSeqNo = params.startSeqNo;
      this.endSeqNo = params.endSeqNo;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageActionResend17> {
      // no flags

      let startSeqNo = await Primitive.Int.read(b);
      let endSeqNo = await Primitive.Int.read(b);
      return new Raw.DecryptedMessageActionResend17({ startSeqNo: startSeqNo, endSeqNo: endSeqNo });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.startSeqNo !== undefined) {
        b.write(Primitive.Int.write(this.startSeqNo) as unknown as Buffer);
      }
      if (this.endSeqNo !== undefined) {
        b.write(Primitive.Int.write(this.endSeqNo) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageActionNotifyLayer17 extends TLObject {
    layer!: int;

    constructor(params: { layer: int }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionNotifyLayer17';
      this.constructorId = 0xf3048883;
      this.subclassOfId = 0x6faf258d;
      this._slots = ['layer'];
      this.layer = params.layer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageActionNotifyLayer17> {
      // no flags

      let layer = await Primitive.Int.read(b);
      return new Raw.DecryptedMessageActionNotifyLayer17({ layer: layer });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.layer !== undefined) {
        b.write(Primitive.Int.write(this.layer) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageActionTyping17 extends TLObject {
    action!: Raw.TypeSendMessageAction;

    constructor(params: { action: Raw.TypeSendMessageAction }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionTyping17';
      this.constructorId = 0xccb27641;
      this.subclassOfId = 0x6faf258d;
      this._slots = ['action'];
      this.action = params.action;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageActionTyping17> {
      // no flags

      let action = await TLObject.read(b);
      return new Raw.DecryptedMessageActionTyping17({ action: action });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.action !== undefined) {
        b.write(this.action.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageActionRequestKey20 extends TLObject {
    exchangeId!: long;
    gA!: bytes;

    constructor(params: { exchangeId: long; gA: bytes }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionRequestKey20';
      this.constructorId = 0xf3c9611b;
      this.subclassOfId = 0x6faf258d;
      this._slots = ['exchangeId', 'gA'];
      this.exchangeId = params.exchangeId;
      this.gA = params.gA;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageActionRequestKey20> {
      // no flags

      let exchangeId = await Primitive.Long.read(b);
      let gA = await Primitive.Bytes.read(b);
      return new Raw.DecryptedMessageActionRequestKey20({ exchangeId: exchangeId, gA: gA });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.exchangeId !== undefined) {
        b.write(Primitive.Long.write(this.exchangeId) as unknown as Buffer);
      }
      if (this.gA !== undefined) {
        b.write(Primitive.Bytes.write(this.gA) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageActionAcceptKey20 extends TLObject {
    exchangeId!: long;
    gB!: bytes;
    keyFingerprint!: long;

    constructor(params: { exchangeId: long; gB: bytes; keyFingerprint: long }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionAcceptKey20';
      this.constructorId = 0x6fe1735b;
      this.subclassOfId = 0x6faf258d;
      this._slots = ['exchangeId', 'gB', 'keyFingerprint'];
      this.exchangeId = params.exchangeId;
      this.gB = params.gB;
      this.keyFingerprint = params.keyFingerprint;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageActionAcceptKey20> {
      // no flags

      let exchangeId = await Primitive.Long.read(b);
      let gB = await Primitive.Bytes.read(b);
      let keyFingerprint = await Primitive.Long.read(b);
      return new Raw.DecryptedMessageActionAcceptKey20({
        exchangeId: exchangeId,
        gB: gB,
        keyFingerprint: keyFingerprint,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.exchangeId !== undefined) {
        b.write(Primitive.Long.write(this.exchangeId) as unknown as Buffer);
      }
      if (this.gB !== undefined) {
        b.write(Primitive.Bytes.write(this.gB) as unknown as Buffer);
      }
      if (this.keyFingerprint !== undefined) {
        b.write(Primitive.Long.write(this.keyFingerprint) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageActionAbortKey20 extends TLObject {
    exchangeId!: long;

    constructor(params: { exchangeId: long }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionAbortKey20';
      this.constructorId = 0xdd05ec6b;
      this.subclassOfId = 0x6faf258d;
      this._slots = ['exchangeId'];
      this.exchangeId = params.exchangeId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageActionAbortKey20> {
      // no flags

      let exchangeId = await Primitive.Long.read(b);
      return new Raw.DecryptedMessageActionAbortKey20({ exchangeId: exchangeId });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.exchangeId !== undefined) {
        b.write(Primitive.Long.write(this.exchangeId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageActionCommitKey20 extends TLObject {
    exchangeId!: long;
    keyFingerprint!: long;

    constructor(params: { exchangeId: long; keyFingerprint: long }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionCommitKey20';
      this.constructorId = 0xec2e0b9b;
      this.subclassOfId = 0x6faf258d;
      this._slots = ['exchangeId', 'keyFingerprint'];
      this.exchangeId = params.exchangeId;
      this.keyFingerprint = params.keyFingerprint;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageActionCommitKey20> {
      // no flags

      let exchangeId = await Primitive.Long.read(b);
      let keyFingerprint = await Primitive.Long.read(b);
      return new Raw.DecryptedMessageActionCommitKey20({
        exchangeId: exchangeId,
        keyFingerprint: keyFingerprint,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.exchangeId !== undefined) {
        b.write(Primitive.Long.write(this.exchangeId) as unknown as Buffer);
      }
      if (this.keyFingerprint !== undefined) {
        b.write(Primitive.Long.write(this.keyFingerprint) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageActionNoop20 extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageActionNoop20';
      this.constructorId = 0xa82fdd63;
      this.subclassOfId = 0x6faf258d;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageActionNoop20> {
      // no flags

      return new Raw.DecryptedMessageActionNoop20();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class DocumentAttributeSticker23 extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeSticker23';
      this.constructorId = 0xfb0a5727;
      this.subclassOfId = 0xf729eb9b;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeSticker23> {
      // no flags

      return new Raw.DocumentAttributeSticker23();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class DocumentAttributeVideo23 extends TLObject {
    duration!: int;
    w!: int;
    h!: int;

    constructor(params: { duration: int; w: int; h: int }) {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeVideo23';
      this.constructorId = 0x5910cccb;
      this.subclassOfId = 0xf729eb9b;
      this._slots = ['duration', 'w', 'h'];
      this.duration = params.duration;
      this.w = params.w;
      this.h = params.h;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeVideo23> {
      // no flags

      let duration = await Primitive.Int.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      return new Raw.DocumentAttributeVideo23({ duration: duration, w: w, h: h });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DocumentAttributeAudio23 extends TLObject {
    duration!: int;

    constructor(params: { duration: int }) {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeAudio23';
      this.constructorId = 0x51448e5;
      this.subclassOfId = 0xf729eb9b;
      this._slots = ['duration'];
      this.duration = params.duration;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeAudio23> {
      // no flags

      let duration = await Primitive.Int.read(b);
      return new Raw.DocumentAttributeAudio23({ duration: duration });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhotoSize23 extends TLObject {
    type!: string;
    location!: Raw.TypeFileLocation;
    w!: int;
    h!: int;
    size!: int;

    constructor(params: {
      type: string;
      location: Raw.TypeFileLocation;
      w: int;
      h: int;
      size: int;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PhotoSize23';
      this.constructorId = 0x77bfb61b;
      this.subclassOfId = 0x17cc29d9;
      this._slots = ['type', 'location', 'w', 'h', 'size'];
      this.type = params.type;
      this.location = params.location;
      this.w = params.w;
      this.h = params.h;
      this.size = params.size;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhotoSize23> {
      // no flags

      let type = await Primitive.String.read(b);
      let location = await TLObject.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let size = await Primitive.Int.read(b);
      return new Raw.PhotoSize23({ type: type, location: location, w: w, h: h, size: size });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.location !== undefined) {
        b.write(this.location.write() as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class PhotoCachedSize23 extends TLObject {
    type!: string;
    location!: Raw.TypeFileLocation;
    w!: int;
    h!: int;
    bytes!: bytes;

    constructor(params: {
      type: string;
      location: Raw.TypeFileLocation;
      w: int;
      h: int;
      bytes: bytes;
    }) {
      super();
      this.classType = 'types';
      this.className = 'PhotoCachedSize23';
      this.constructorId = 0xe9a734fa;
      this.subclassOfId = 0x17cc29d9;
      this._slots = ['type', 'location', 'w', 'h', 'bytes'];
      this.type = params.type;
      this.location = params.location;
      this.w = params.w;
      this.h = params.h;
      this.bytes = params.bytes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.PhotoCachedSize23> {
      // no flags

      let type = await Primitive.String.read(b);
      let location = await TLObject.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let bytes = await Primitive.Bytes.read(b);
      return new Raw.PhotoCachedSize23({
        type: type,
        location: location,
        w: w,
        h: h,
        bytes: bytes,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.type !== undefined) {
        b.write(Primitive.String.write(this.type) as unknown as Buffer);
      }
      if (this.location !== undefined) {
        b.write(this.location.write() as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.bytes !== undefined) {
        b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class FileLocationUnavailable23 extends TLObject {
    volumeId!: long;
    localId!: int;
    secret!: long;

    constructor(params: { volumeId: long; localId: int; secret: long }) {
      super();
      this.classType = 'types';
      this.className = 'FileLocationUnavailable23';
      this.constructorId = 0x7c596b46;
      this.subclassOfId = 0x90f76823;
      this._slots = ['volumeId', 'localId', 'secret'];
      this.volumeId = params.volumeId;
      this.localId = params.localId;
      this.secret = params.secret;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.FileLocationUnavailable23> {
      // no flags

      let volumeId = await Primitive.Long.read(b);
      let localId = await Primitive.Int.read(b);
      let secret = await Primitive.Long.read(b);
      return new Raw.FileLocationUnavailable23({
        volumeId: volumeId,
        localId: localId,
        secret: secret,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.volumeId !== undefined) {
        b.write(Primitive.Long.write(this.volumeId) as unknown as Buffer);
      }
      if (this.localId !== undefined) {
        b.write(Primitive.Int.write(this.localId) as unknown as Buffer);
      }
      if (this.secret !== undefined) {
        b.write(Primitive.Long.write(this.secret) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class FileLocation23 extends TLObject {
    dcId!: int;
    volumeId!: long;
    localId!: int;
    secret!: long;

    constructor(params: { dcId: int; volumeId: long; localId: int; secret: long }) {
      super();
      this.classType = 'types';
      this.className = 'FileLocation23';
      this.constructorId = 0x53d69076;
      this.subclassOfId = 0x90f76823;
      this._slots = ['dcId', 'volumeId', 'localId', 'secret'];
      this.dcId = params.dcId;
      this.volumeId = params.volumeId;
      this.localId = params.localId;
      this.secret = params.secret;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.FileLocation23> {
      // no flags

      let dcId = await Primitive.Int.read(b);
      let volumeId = await Primitive.Long.read(b);
      let localId = await Primitive.Int.read(b);
      let secret = await Primitive.Long.read(b);
      return new Raw.FileLocation23({
        dcId: dcId,
        volumeId: volumeId,
        localId: localId,
        secret: secret,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.dcId !== undefined) {
        b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
      }
      if (this.volumeId !== undefined) {
        b.write(Primitive.Long.write(this.volumeId) as unknown as Buffer);
      }
      if (this.localId !== undefined) {
        b.write(Primitive.Int.write(this.localId) as unknown as Buffer);
      }
      if (this.secret !== undefined) {
        b.write(Primitive.Long.write(this.secret) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaExternalDocument23 extends TLObject {
    id!: long;
    accessHash!: long;
    date!: int;
    mimeType!: string;
    size!: int;
    thumb!: Raw.TypePhotoSize;
    dcId!: int;
    attributes!: Vector<Raw.TypeDocumentAttribute>;

    constructor(params: {
      id: long;
      accessHash: long;
      date: int;
      mimeType: string;
      size: int;
      thumb: Raw.TypePhotoSize;
      dcId: int;
      attributes: Vector<Raw.TypeDocumentAttribute>;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaExternalDocument23';
      this.constructorId = 0xfa95b0dd;
      this.subclassOfId = 0xb3d2034;
      this._slots = ['id', 'accessHash', 'date', 'mimeType', 'size', 'thumb', 'dcId', 'attributes'];
      this.id = params.id;
      this.accessHash = params.accessHash;
      this.date = params.date;
      this.mimeType = params.mimeType;
      this.size = params.size;
      this.thumb = params.thumb;
      this.dcId = params.dcId;
      this.attributes = params.attributes;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageMediaExternalDocument23> {
      // no flags

      let id = await Primitive.Long.read(b);
      let accessHash = await Primitive.Long.read(b);
      let date = await Primitive.Int.read(b);
      let mimeType = await Primitive.String.read(b);
      let size = await Primitive.Int.read(b);
      let thumb = await TLObject.read(b);
      let dcId = await Primitive.Int.read(b);
      let attributes = await TLObject.read(b);
      return new Raw.DecryptedMessageMediaExternalDocument23({
        id: id,
        accessHash: accessHash,
        date: date,
        mimeType: mimeType,
        size: size,
        thumb: thumb,
        dcId: dcId,
        attributes: attributes,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.id !== undefined) {
        b.write(Primitive.Long.write(this.id) as unknown as Buffer);
      }
      if (this.accessHash !== undefined) {
        b.write(Primitive.Long.write(this.accessHash) as unknown as Buffer);
      }
      if (this.date !== undefined) {
        b.write(Primitive.Int.write(this.date) as unknown as Buffer);
      }
      if (this.mimeType !== undefined) {
        b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.thumb !== undefined) {
        b.write(this.thumb.write() as unknown as Buffer);
      }
      if (this.dcId !== undefined) {
        b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
      }
      if (this.attributes) {
        b.write(Primitive.Vector.write(this.attributes) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessage45 extends TLObject {
    randomId!: long;
    ttl!: int;
    message!: string;
    media?: Raw.TypeDecryptedMessageMedia;
    entities?: Vector<Raw.TypeMessageEntity>;
    viaBotName?: string;
    replyToRandomId?: long;

    constructor(params: {
      randomId: long;
      ttl: int;
      message: string;
      media?: Raw.TypeDecryptedMessageMedia;
      entities?: Vector<Raw.TypeMessageEntity>;
      viaBotName?: string;
      replyToRandomId?: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessage45';
      this.constructorId = 0x36b091de;
      this.subclassOfId = 0x5303193e;
      this._slots = [
        'randomId',
        'ttl',
        'message',
        'media',
        'entities',
        'viaBotName',
        'replyToRandomId',
      ];
      this.randomId = params.randomId;
      this.ttl = params.ttl;
      this.message = params.message;
      this.media = params.media;
      this.entities = params.entities;
      this.viaBotName = params.viaBotName;
      this.replyToRandomId = params.replyToRandomId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessage45> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let randomId = await Primitive.Long.read(b);
      let ttl = await Primitive.Int.read(b);
      let message = await Primitive.String.read(b);
      let media = flags & (1 << 9) ? await TLObject.read(b) : undefined;
      let entities = flags & (1 << 7) ? await TLObject.read(b) : [];
      let viaBotName = flags & (1 << 11) ? await Primitive.String.read(b) : undefined;
      let replyToRandomId = flags & (1 << 3) ? await Primitive.Long.read(b) : undefined;
      return new Raw.DecryptedMessage45({
        randomId: randomId,
        ttl: ttl,
        message: message,
        media: media,
        entities: entities,
        viaBotName: viaBotName,
        replyToRandomId: replyToRandomId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.media !== undefined ? 1 << 9 : 0;
      flags |= this.entities ? 1 << 7 : 0;
      flags |= this.viaBotName !== undefined ? 1 << 11 : 0;
      flags |= this.replyToRandomId !== undefined ? 1 << 3 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.randomId !== undefined) {
        b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
      }
      if (this.ttl !== undefined) {
        b.write(Primitive.Int.write(this.ttl) as unknown as Buffer);
      }
      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.media !== undefined) {
        b.write(this.media.write() as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.viaBotName !== undefined) {
        b.write(Primitive.String.write(this.viaBotName) as unknown as Buffer);
      }
      if (this.replyToRandomId !== undefined) {
        b.write(Primitive.Long.write(this.replyToRandomId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaPhoto45 extends TLObject {
    thumb!: bytes;
    thumbW!: int;
    thumbH!: int;
    w!: int;
    h!: int;
    size!: int;
    key!: bytes;
    iv!: bytes;
    caption!: string;

    constructor(params: {
      thumb: bytes;
      thumbW: int;
      thumbH: int;
      w: int;
      h: int;
      size: int;
      key: bytes;
      iv: bytes;
      caption: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaPhoto45';
      this.constructorId = 0xf1fa8d78;
      this.subclassOfId = 0xb3d2034;
      this._slots = ['thumb', 'thumbW', 'thumbH', 'w', 'h', 'size', 'key', 'iv', 'caption'];
      this.thumb = params.thumb;
      this.thumbW = params.thumbW;
      this.thumbH = params.thumbH;
      this.w = params.w;
      this.h = params.h;
      this.size = params.size;
      this.key = params.key;
      this.iv = params.iv;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageMediaPhoto45> {
      // no flags

      let thumb = await Primitive.Bytes.read(b);
      let thumbW = await Primitive.Int.read(b);
      let thumbH = await Primitive.Int.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let size = await Primitive.Int.read(b);
      let key = await Primitive.Bytes.read(b);
      let iv = await Primitive.Bytes.read(b);
      let caption = await Primitive.String.read(b);
      return new Raw.DecryptedMessageMediaPhoto45({
        thumb: thumb,
        thumbW: thumbW,
        thumbH: thumbH,
        w: w,
        h: h,
        size: size,
        key: key,
        iv: iv,
        caption: caption,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.thumb !== undefined) {
        b.write(Primitive.Bytes.write(this.thumb) as unknown as Buffer);
      }
      if (this.thumbW !== undefined) {
        b.write(Primitive.Int.write(this.thumbW) as unknown as Buffer);
      }
      if (this.thumbH !== undefined) {
        b.write(Primitive.Int.write(this.thumbH) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.key !== undefined) {
        b.write(Primitive.Bytes.write(this.key) as unknown as Buffer);
      }
      if (this.iv !== undefined) {
        b.write(Primitive.Bytes.write(this.iv) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(Primitive.String.write(this.caption) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaVideo45 extends TLObject {
    thumb!: bytes;
    thumbW!: int;
    thumbH!: int;
    duration!: int;
    mimeType!: string;
    w!: int;
    h!: int;
    size!: int;
    key!: bytes;
    iv!: bytes;
    caption!: string;

    constructor(params: {
      thumb: bytes;
      thumbW: int;
      thumbH: int;
      duration: int;
      mimeType: string;
      w: int;
      h: int;
      size: int;
      key: bytes;
      iv: bytes;
      caption: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaVideo45';
      this.constructorId = 0x970c8c0e;
      this.subclassOfId = 0xb3d2034;
      this._slots = [
        'thumb',
        'thumbW',
        'thumbH',
        'duration',
        'mimeType',
        'w',
        'h',
        'size',
        'key',
        'iv',
        'caption',
      ];
      this.thumb = params.thumb;
      this.thumbW = params.thumbW;
      this.thumbH = params.thumbH;
      this.duration = params.duration;
      this.mimeType = params.mimeType;
      this.w = params.w;
      this.h = params.h;
      this.size = params.size;
      this.key = params.key;
      this.iv = params.iv;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageMediaVideo45> {
      // no flags

      let thumb = await Primitive.Bytes.read(b);
      let thumbW = await Primitive.Int.read(b);
      let thumbH = await Primitive.Int.read(b);
      let duration = await Primitive.Int.read(b);
      let mimeType = await Primitive.String.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      let size = await Primitive.Int.read(b);
      let key = await Primitive.Bytes.read(b);
      let iv = await Primitive.Bytes.read(b);
      let caption = await Primitive.String.read(b);
      return new Raw.DecryptedMessageMediaVideo45({
        thumb: thumb,
        thumbW: thumbW,
        thumbH: thumbH,
        duration: duration,
        mimeType: mimeType,
        w: w,
        h: h,
        size: size,
        key: key,
        iv: iv,
        caption: caption,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.thumb !== undefined) {
        b.write(Primitive.Bytes.write(this.thumb) as unknown as Buffer);
      }
      if (this.thumbW !== undefined) {
        b.write(Primitive.Int.write(this.thumbW) as unknown as Buffer);
      }
      if (this.thumbH !== undefined) {
        b.write(Primitive.Int.write(this.thumbH) as unknown as Buffer);
      }
      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      if (this.mimeType !== undefined) {
        b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.key !== undefined) {
        b.write(Primitive.Bytes.write(this.key) as unknown as Buffer);
      }
      if (this.iv !== undefined) {
        b.write(Primitive.Bytes.write(this.iv) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(Primitive.String.write(this.caption) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaDocument45 extends TLObject {
    thumb!: bytes;
    thumbW!: int;
    thumbH!: int;
    mimeType!: string;
    size!: int;
    key!: bytes;
    iv!: bytes;
    attributes!: Vector<Raw.TypeDocumentAttribute>;
    caption!: string;

    constructor(params: {
      thumb: bytes;
      thumbW: int;
      thumbH: int;
      mimeType: string;
      size: int;
      key: bytes;
      iv: bytes;
      attributes: Vector<Raw.TypeDocumentAttribute>;
      caption: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaDocument45';
      this.constructorId = 0x7afe8ae2;
      this.subclassOfId = 0xb3d2034;
      this._slots = [
        'thumb',
        'thumbW',
        'thumbH',
        'mimeType',
        'size',
        'key',
        'iv',
        'attributes',
        'caption',
      ];
      this.thumb = params.thumb;
      this.thumbW = params.thumbW;
      this.thumbH = params.thumbH;
      this.mimeType = params.mimeType;
      this.size = params.size;
      this.key = params.key;
      this.iv = params.iv;
      this.attributes = params.attributes;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageMediaDocument45> {
      // no flags

      let thumb = await Primitive.Bytes.read(b);
      let thumbW = await Primitive.Int.read(b);
      let thumbH = await Primitive.Int.read(b);
      let mimeType = await Primitive.String.read(b);
      let size = await Primitive.Int.read(b);
      let key = await Primitive.Bytes.read(b);
      let iv = await Primitive.Bytes.read(b);
      let attributes = await TLObject.read(b);
      let caption = await Primitive.String.read(b);
      return new Raw.DecryptedMessageMediaDocument45({
        thumb: thumb,
        thumbW: thumbW,
        thumbH: thumbH,
        mimeType: mimeType,
        size: size,
        key: key,
        iv: iv,
        attributes: attributes,
        caption: caption,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.thumb !== undefined) {
        b.write(Primitive.Bytes.write(this.thumb) as unknown as Buffer);
      }
      if (this.thumbW !== undefined) {
        b.write(Primitive.Int.write(this.thumbW) as unknown as Buffer);
      }
      if (this.thumbH !== undefined) {
        b.write(Primitive.Int.write(this.thumbH) as unknown as Buffer);
      }
      if (this.mimeType !== undefined) {
        b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Int.write(this.size) as unknown as Buffer);
      }
      if (this.key !== undefined) {
        b.write(Primitive.Bytes.write(this.key) as unknown as Buffer);
      }
      if (this.iv !== undefined) {
        b.write(Primitive.Bytes.write(this.iv) as unknown as Buffer);
      }
      if (this.attributes) {
        b.write(Primitive.Vector.write(this.attributes) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(Primitive.String.write(this.caption) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DocumentAttributeSticker45 extends TLObject {
    alt!: string;
    stickerset!: Raw.TypeInputStickerSet;

    constructor(params: { alt: string; stickerset: Raw.TypeInputStickerSet }) {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeSticker45';
      this.constructorId = 0x3a556302;
      this.subclassOfId = 0xf729eb9b;
      this._slots = ['alt', 'stickerset'];
      this.alt = params.alt;
      this.stickerset = params.stickerset;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeSticker45> {
      // no flags

      let alt = await Primitive.String.read(b);
      let stickerset = await TLObject.read(b);
      return new Raw.DocumentAttributeSticker45({ alt: alt, stickerset: stickerset });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.alt !== undefined) {
        b.write(Primitive.String.write(this.alt) as unknown as Buffer);
      }
      if (this.stickerset !== undefined) {
        b.write(this.stickerset.write() as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DocumentAttributeAudio45 extends TLObject {
    duration!: int;
    title!: string;
    performer!: string;

    constructor(params: { duration: int; title: string; performer: string }) {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeAudio45';
      this.constructorId = 0xded218e0;
      this.subclassOfId = 0xf729eb9b;
      this._slots = ['duration', 'title', 'performer'];
      this.duration = params.duration;
      this.title = params.title;
      this.performer = params.performer;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeAudio45> {
      // no flags

      let duration = await Primitive.Int.read(b);
      let title = await Primitive.String.read(b);
      let performer = await Primitive.String.read(b);
      return new Raw.DocumentAttributeAudio45({
        duration: duration,
        title: title,
        performer: performer,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.performer !== undefined) {
        b.write(Primitive.String.write(this.performer) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaVenue45 extends TLObject {
    lat!: double;
    long!: double;
    title!: string;
    address!: string;
    provider!: string;
    venueId!: string;

    constructor(params: {
      lat: double;
      long: double;
      title: string;
      address: string;
      provider: string;
      venueId: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaVenue45';
      this.constructorId = 0x8a0df56f;
      this.subclassOfId = 0xb3d2034;
      this._slots = ['lat', 'long', 'title', 'address', 'provider', 'venueId'];
      this.lat = params.lat;
      this.long = params.long;
      this.title = params.title;
      this.address = params.address;
      this.provider = params.provider;
      this.venueId = params.venueId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessageMediaVenue45> {
      // no flags

      let lat = await Primitive.Double.read(b);
      let long = await Primitive.Double.read(b);
      let title = await Primitive.String.read(b);
      let address = await Primitive.String.read(b);
      let provider = await Primitive.String.read(b);
      let venueId = await Primitive.String.read(b);
      return new Raw.DecryptedMessageMediaVenue45({
        lat: lat,
        long: long,
        title: title,
        address: address,
        provider: provider,
        venueId: venueId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.lat !== undefined) {
        b.write(Primitive.Double.write(this.lat) as unknown as Buffer);
      }
      if (this.long !== undefined) {
        b.write(Primitive.Double.write(this.long) as unknown as Buffer);
      }
      if (this.title !== undefined) {
        b.write(Primitive.String.write(this.title) as unknown as Buffer);
      }
      if (this.address !== undefined) {
        b.write(Primitive.String.write(this.address) as unknown as Buffer);
      }
      if (this.provider !== undefined) {
        b.write(Primitive.String.write(this.provider) as unknown as Buffer);
      }
      if (this.venueId !== undefined) {
        b.write(Primitive.String.write(this.venueId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaWebPage45 extends TLObject {
    url!: string;

    constructor(params: { url: string }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaWebPage45';
      this.constructorId = 0xe50511d8;
      this.subclassOfId = 0xb3d2034;
      this._slots = ['url'];
      this.url = params.url;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageMediaWebPage45> {
      // no flags

      let url = await Primitive.String.read(b);
      return new Raw.DecryptedMessageMediaWebPage45({ url: url });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.url !== undefined) {
        b.write(Primitive.String.write(this.url) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DocumentAttributeVideo66 extends TLObject {
    roundMessage?: boolean;
    duration!: int;
    w!: int;
    h!: int;

    constructor(params: { roundMessage?: boolean; duration: int; w: int; h: int }) {
      super();
      this.classType = 'types';
      this.className = 'DocumentAttributeVideo66';
      this.constructorId = 0xef02ce6;
      this.subclassOfId = 0xf729eb9b;
      this._slots = ['roundMessage', 'duration', 'w', 'h'];
      this.roundMessage = params.roundMessage;
      this.duration = params.duration;
      this.w = params.w;
      this.h = params.h;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DocumentAttributeVideo66> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let roundMessage = flags & (1 << 0) ? true : false;
      let duration = await Primitive.Int.read(b);
      let w = await Primitive.Int.read(b);
      let h = await Primitive.Int.read(b);
      return new Raw.DocumentAttributeVideo66({
        roundMessage: roundMessage,
        duration: duration,
        w: w,
        h: h,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.roundMessage ? 1 << 0 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.duration !== undefined) {
        b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
      }
      if (this.w !== undefined) {
        b.write(Primitive.Int.write(this.w) as unknown as Buffer);
      }
      if (this.h !== undefined) {
        b.write(Primitive.Int.write(this.h) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class SendMessageUploadRoundAction66 extends TLObject {
    constructor() {
      super();
      this.classType = 'types';
      this.className = 'SendMessageUploadRoundAction66';
      this.constructorId = 0xbb718624;
      this.subclassOfId = 0x20b2cc21;
      this._slots = [];
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.SendMessageUploadRoundAction66> {
      // no flags

      return new Raw.SendMessageUploadRoundAction66();
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      return b.buffer;
    }
  }
  export class DecryptedMessage73 extends TLObject {
    noWebpage?: boolean;
    silent?: boolean;
    randomId!: long;
    ttl!: int;
    message!: string;
    media?: Raw.TypeDecryptedMessageMedia;
    entities?: Vector<Raw.TypeMessageEntity>;
    viaBotName?: string;
    replyToRandomId?: long;
    groupedId?: long;

    constructor(params: {
      noWebpage?: boolean;
      silent?: boolean;
      randomId: long;
      ttl: int;
      message: string;
      media?: Raw.TypeDecryptedMessageMedia;
      entities?: Vector<Raw.TypeMessageEntity>;
      viaBotName?: string;
      replyToRandomId?: long;
      groupedId?: long;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessage73';
      this.constructorId = 0x91cc4674;
      this.subclassOfId = 0x5303193e;
      this._slots = [
        'noWebpage',
        'silent',
        'randomId',
        'ttl',
        'message',
        'media',
        'entities',
        'viaBotName',
        'replyToRandomId',
        'groupedId',
      ];
      this.noWebpage = params.noWebpage;
      this.silent = params.silent;
      this.randomId = params.randomId;
      this.ttl = params.ttl;
      this.message = params.message;
      this.media = params.media;
      this.entities = params.entities;
      this.viaBotName = params.viaBotName;
      this.replyToRandomId = params.replyToRandomId;
      this.groupedId = params.groupedId;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.DecryptedMessage73> {
      // no flags

      let flags = await Primitive.Int.read(b);

      let noWebpage = flags & (1 << 1) ? true : false;
      let silent = flags & (1 << 5) ? true : false;
      let randomId = await Primitive.Long.read(b);
      let ttl = await Primitive.Int.read(b);
      let message = await Primitive.String.read(b);
      let media = flags & (1 << 9) ? await TLObject.read(b) : undefined;
      let entities = flags & (1 << 7) ? await TLObject.read(b) : [];
      let viaBotName = flags & (1 << 11) ? await Primitive.String.read(b) : undefined;
      let replyToRandomId = flags & (1 << 3) ? await Primitive.Long.read(b) : undefined;
      let groupedId = flags & (1 << 17) ? await Primitive.Long.read(b) : undefined;
      return new Raw.DecryptedMessage73({
        noWebpage: noWebpage,
        silent: silent,
        randomId: randomId,
        ttl: ttl,
        message: message,
        media: media,
        entities: entities,
        viaBotName: viaBotName,
        replyToRandomId: replyToRandomId,
        groupedId: groupedId,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      let flags = 0;
      flags |= this.noWebpage ? 1 << 1 : 0;
      flags |= this.silent ? 1 << 5 : 0;
      flags |= this.media !== undefined ? 1 << 9 : 0;
      flags |= this.entities ? 1 << 7 : 0;
      flags |= this.viaBotName !== undefined ? 1 << 11 : 0;
      flags |= this.replyToRandomId !== undefined ? 1 << 3 : 0;
      flags |= this.groupedId !== undefined ? 1 << 17 : 0;
      b.write(Primitive.Int.write(flags) as unknown as Buffer);

      if (this.randomId !== undefined) {
        b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
      }
      if (this.ttl !== undefined) {
        b.write(Primitive.Int.write(this.ttl) as unknown as Buffer);
      }
      if (this.message !== undefined) {
        b.write(Primitive.String.write(this.message) as unknown as Buffer);
      }
      if (this.media !== undefined) {
        b.write(this.media.write() as unknown as Buffer);
      }
      if (this.entities) {
        b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
      }
      if (this.viaBotName !== undefined) {
        b.write(Primitive.String.write(this.viaBotName) as unknown as Buffer);
      }
      if (this.replyToRandomId !== undefined) {
        b.write(Primitive.Long.write(this.replyToRandomId) as unknown as Buffer);
      }
      if (this.groupedId !== undefined) {
        b.write(Primitive.Long.write(this.groupedId) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export class DecryptedMessageMediaDocument143 extends TLObject {
    thumb!: bytes;
    thumbW!: int;
    thumbH!: int;
    mimeType!: string;
    size!: long;
    key!: bytes;
    iv!: bytes;
    attributes!: Vector<Raw.TypeDocumentAttribute>;
    caption!: string;

    constructor(params: {
      thumb: bytes;
      thumbW: int;
      thumbH: int;
      mimeType: string;
      size: long;
      key: bytes;
      iv: bytes;
      attributes: Vector<Raw.TypeDocumentAttribute>;
      caption: string;
    }) {
      super();
      this.classType = 'types';
      this.className = 'DecryptedMessageMediaDocument143';
      this.constructorId = 0x6abd9782;
      this.subclassOfId = 0xb3d2034;
      this._slots = [
        'thumb',
        'thumbW',
        'thumbH',
        'mimeType',
        'size',
        'key',
        'iv',
        'attributes',
        'caption',
      ];
      this.thumb = params.thumb;
      this.thumbW = params.thumbW;
      this.thumbH = params.thumbH;
      this.mimeType = params.mimeType;
      this.size = params.size;
      this.key = params.key;
      this.iv = params.iv;
      this.attributes = params.attributes;
      this.caption = params.caption;
    }
    /**
     * Generate the TLObject from buffer.
     * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
     */
    static async read(
      b: BytesIO,
      ...args: Array<any>
    ): Promise<Raw.DecryptedMessageMediaDocument143> {
      // no flags

      let thumb = await Primitive.Bytes.read(b);
      let thumbW = await Primitive.Int.read(b);
      let thumbH = await Primitive.Int.read(b);
      let mimeType = await Primitive.String.read(b);
      let size = await Primitive.Long.read(b);
      let key = await Primitive.Bytes.read(b);
      let iv = await Primitive.Bytes.read(b);
      let attributes = await TLObject.read(b);
      let caption = await Primitive.String.read(b);
      return new Raw.DecryptedMessageMediaDocument143({
        thumb: thumb,
        thumbW: thumbW,
        thumbH: thumbH,
        mimeType: mimeType,
        size: size,
        key: key,
        iv: iv,
        attributes: attributes,
        caption: caption,
      });
    }
    /**
     * Generate buffer from TLObject.
     */
    write(): Buffer {
      let b: BytesIO = new BytesIO();
      b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
      // no flags

      if (this.thumb !== undefined) {
        b.write(Primitive.Bytes.write(this.thumb) as unknown as Buffer);
      }
      if (this.thumbW !== undefined) {
        b.write(Primitive.Int.write(this.thumbW) as unknown as Buffer);
      }
      if (this.thumbH !== undefined) {
        b.write(Primitive.Int.write(this.thumbH) as unknown as Buffer);
      }
      if (this.mimeType !== undefined) {
        b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
      }
      if (this.size !== undefined) {
        b.write(Primitive.Long.write(this.size) as unknown as Buffer);
      }
      if (this.key !== undefined) {
        b.write(Primitive.Bytes.write(this.key) as unknown as Buffer);
      }
      if (this.iv !== undefined) {
        b.write(Primitive.Bytes.write(this.iv) as unknown as Buffer);
      }
      if (this.attributes) {
        b.write(Primitive.Vector.write(this.attributes) as unknown as Buffer);
      }
      if (this.caption !== undefined) {
        b.write(Primitive.String.write(this.caption) as unknown as Buffer);
      }
      return b.buffer;
    }
  }
  export namespace help {
    export type TypePremiumPromo = Raw.help.PremiumPromo;
    export type TypeCountriesList = Raw.help.CountriesListNotModified | Raw.help.CountriesList;
    export type TypePromoData = Raw.help.PromoDataEmpty | Raw.help.PromoData;
    export type TypeUserInfo = Raw.help.UserInfoEmpty | Raw.help.UserInfo;
    export type TypeSupportName = Raw.help.SupportName;
    export type TypePassportConfig = Raw.help.PassportConfigNotModified | Raw.help.PassportConfig;
    export type TypeAppConfig = Raw.help.AppConfigNotModified | Raw.help.AppConfig;
    export type TypeDeepLinkInfo = Raw.help.DeepLinkInfoEmpty | Raw.help.DeepLinkInfo;
    export type TypeTermsOfServiceUpdate =
      | Raw.help.TermsOfServiceUpdateEmpty
      | Raw.help.TermsOfServiceUpdate;
    export type TypeRecentMeUrls = Raw.help.RecentMeUrls;
    export type TypeSupport = Raw.help.Support;
    export type TypeInviteText = Raw.help.InviteText;
    export type TypeAppUpdate = Raw.help.AppUpdate | Raw.help.NoAppUpdate;
    export type TypeCountry = Raw.help.Country;
    export type TypeCountryCode = Raw.help.CountryCode;
    export type TypeTermsOfService = Raw.help.TermsOfService;
    export class ConfigSimple extends TLObject {
      date!: int;
      expires!: int;
      rules!: Vector<Raw.TypeAccessPointRule>;

      constructor(params: { date: int; expires: int; rules: Vector<Raw.TypeAccessPointRule> }) {
        super();
        this.classType = 'types';
        this.className = 'help.ConfigSimple';
        this.constructorId = 0x5a592a6c;
        this.subclassOfId = 0x29183ac4;
        this._slots = ['date', 'expires', 'rules'];
        this.date = params.date;
        this.expires = params.expires;
        this.rules = params.rules;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.ConfigSimple> {
        // no flags

        let date = await Primitive.Int.read(b);
        let expires = await Primitive.Int.read(b);
        let rules = await TLObject.read(b);
        return new Raw.help.ConfigSimple({ date: date, expires: expires, rules: rules });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.date !== undefined) {
          b.write(Primitive.Int.write(this.date) as unknown as Buffer);
        }
        if (this.expires !== undefined) {
          b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
        }
        if (this.rules) {
          b.write(Primitive.Vector.write(this.rules) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AppUpdate extends TLObject {
      canNotSkip?: boolean;
      id!: int;
      version!: string;
      text!: string;
      entities!: Vector<Raw.TypeMessageEntity>;
      document?: Raw.TypeDocument;
      url?: string;
      sticker?: Raw.TypeDocument;

      constructor(params: {
        canNotSkip?: boolean;
        id: int;
        version: string;
        text: string;
        entities: Vector<Raw.TypeMessageEntity>;
        document?: Raw.TypeDocument;
        url?: string;
        sticker?: Raw.TypeDocument;
      }) {
        super();
        this.classType = 'types';
        this.className = 'help.AppUpdate';
        this.constructorId = 0xccbbce30;
        this.subclassOfId = 0x5897069e;
        this._slots = [
          'canNotSkip',
          'id',
          'version',
          'text',
          'entities',
          'document',
          'url',
          'sticker',
        ];
        this.canNotSkip = params.canNotSkip;
        this.id = params.id;
        this.version = params.version;
        this.text = params.text;
        this.entities = params.entities;
        this.document = params.document;
        this.url = params.url;
        this.sticker = params.sticker;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.AppUpdate> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let canNotSkip = flags & (1 << 0) ? true : false;
        let id = await Primitive.Int.read(b);
        let version = await Primitive.String.read(b);
        let text = await Primitive.String.read(b);
        let entities = await TLObject.read(b);
        let document = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        let url = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        let sticker = flags & (1 << 3) ? await TLObject.read(b) : undefined;
        return new Raw.help.AppUpdate({
          canNotSkip: canNotSkip,
          id: id,
          version: version,
          text: text,
          entities: entities,
          document: document,
          url: url,
          sticker: sticker,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.canNotSkip ? 1 << 0 : 0;
        flags |= this.document !== undefined ? 1 << 1 : 0;
        flags |= this.url !== undefined ? 1 << 2 : 0;
        flags |= this.sticker !== undefined ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        if (this.version !== undefined) {
          b.write(Primitive.String.write(this.version) as unknown as Buffer);
        }
        if (this.text !== undefined) {
          b.write(Primitive.String.write(this.text) as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        if (this.document !== undefined) {
          b.write(this.document.write() as unknown as Buffer);
        }
        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        if (this.sticker !== undefined) {
          b.write(this.sticker.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class NoAppUpdate extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'help.NoAppUpdate';
        this.constructorId = 0xc45a6536;
        this.subclassOfId = 0x5897069e;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.NoAppUpdate> {
        // no flags

        return new Raw.help.NoAppUpdate();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class InviteText extends TLObject {
      message!: string;

      constructor(params: { message: string }) {
        super();
        this.classType = 'types';
        this.className = 'help.InviteText';
        this.constructorId = 0x18cb9f78;
        this.subclassOfId = 0xcf70aa35;
        this._slots = ['message'];
        this.message = params.message;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.InviteText> {
        // no flags

        let message = await Primitive.String.read(b);
        return new Raw.help.InviteText({ message: message });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Support extends TLObject {
      phoneNumber!: string;
      user!: Raw.TypeUser;

      constructor(params: { phoneNumber: string; user: Raw.TypeUser }) {
        super();
        this.classType = 'types';
        this.className = 'help.Support';
        this.constructorId = 0x17c6b5f6;
        this.subclassOfId = 0x7159bceb;
        this._slots = ['phoneNumber', 'user'];
        this.phoneNumber = params.phoneNumber;
        this.user = params.user;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.Support> {
        // no flags

        let phoneNumber = await Primitive.String.read(b);
        let user = await TLObject.read(b);
        return new Raw.help.Support({ phoneNumber: phoneNumber, user: user });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phoneNumber !== undefined) {
          b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
        }
        if (this.user !== undefined) {
          b.write(this.user.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TermsOfService extends TLObject {
      popup?: boolean;
      id!: Raw.TypeDataJSON;
      text!: string;
      entities!: Vector<Raw.TypeMessageEntity>;
      minAgeConfirm?: int;

      constructor(params: {
        popup?: boolean;
        id: Raw.TypeDataJSON;
        text: string;
        entities: Vector<Raw.TypeMessageEntity>;
        minAgeConfirm?: int;
      }) {
        super();
        this.classType = 'types';
        this.className = 'help.TermsOfService';
        this.constructorId = 0x780a0310;
        this.subclassOfId = 0x20ee8312;
        this._slots = ['popup', 'id', 'text', 'entities', 'minAgeConfirm'];
        this.popup = params.popup;
        this.id = params.id;
        this.text = params.text;
        this.entities = params.entities;
        this.minAgeConfirm = params.minAgeConfirm;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.TermsOfService> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let popup = flags & (1 << 0) ? true : false;
        let id = await TLObject.read(b);
        let text = await Primitive.String.read(b);
        let entities = await TLObject.read(b);
        let minAgeConfirm = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        return new Raw.help.TermsOfService({
          popup: popup,
          id: id,
          text: text,
          entities: entities,
          minAgeConfirm: minAgeConfirm,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.popup ? 1 << 0 : 0;
        flags |= this.minAgeConfirm !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        if (this.text !== undefined) {
          b.write(Primitive.String.write(this.text) as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        if (this.minAgeConfirm !== undefined) {
          b.write(Primitive.Int.write(this.minAgeConfirm) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RecentMeUrls extends TLObject {
      urls!: Vector<Raw.TypeRecentMeUrl>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        urls: Vector<Raw.TypeRecentMeUrl>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'help.RecentMeUrls';
        this.constructorId = 0xe0310d7;
        this.subclassOfId = 0xf269c477;
        this._slots = ['urls', 'chats', 'users'];
        this.urls = params.urls;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.RecentMeUrls> {
        // no flags

        let urls = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.help.RecentMeUrls({ urls: urls, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.urls) {
          b.write(Primitive.Vector.write(this.urls) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TermsOfServiceUpdateEmpty extends TLObject {
      expires!: int;

      constructor(params: { expires: int }) {
        super();
        this.classType = 'types';
        this.className = 'help.TermsOfServiceUpdateEmpty';
        this.constructorId = 0xe3309f7f;
        this.subclassOfId = 0x293c2977;
        this._slots = ['expires'];
        this.expires = params.expires;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.help.TermsOfServiceUpdateEmpty> {
        // no flags

        let expires = await Primitive.Int.read(b);
        return new Raw.help.TermsOfServiceUpdateEmpty({ expires: expires });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.expires !== undefined) {
          b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TermsOfServiceUpdate extends TLObject {
      expires!: int;
      termsOfService!: Raw.help.TypeTermsOfService;

      constructor(params: { expires: int; termsOfService: Raw.help.TypeTermsOfService }) {
        super();
        this.classType = 'types';
        this.className = 'help.TermsOfServiceUpdate';
        this.constructorId = 0x28ecf961;
        this.subclassOfId = 0x293c2977;
        this._slots = ['expires', 'termsOfService'];
        this.expires = params.expires;
        this.termsOfService = params.termsOfService;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.TermsOfServiceUpdate> {
        // no flags

        let expires = await Primitive.Int.read(b);
        let termsOfService = await TLObject.read(b);
        return new Raw.help.TermsOfServiceUpdate({
          expires: expires,
          termsOfService: termsOfService,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.expires !== undefined) {
          b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
        }
        if (this.termsOfService !== undefined) {
          b.write(this.termsOfService.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeepLinkInfoEmpty extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'help.DeepLinkInfoEmpty';
        this.constructorId = 0x66afa166;
        this.subclassOfId = 0x984aac38;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.DeepLinkInfoEmpty> {
        // no flags

        return new Raw.help.DeepLinkInfoEmpty();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class DeepLinkInfo extends TLObject {
      updateApp?: boolean;
      message!: string;
      entities?: Vector<Raw.TypeMessageEntity>;

      constructor(params: {
        updateApp?: boolean;
        message: string;
        entities?: Vector<Raw.TypeMessageEntity>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'help.DeepLinkInfo';
        this.constructorId = 0x6a4ee832;
        this.subclassOfId = 0x984aac38;
        this._slots = ['updateApp', 'message', 'entities'];
        this.updateApp = params.updateApp;
        this.message = params.message;
        this.entities = params.entities;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.DeepLinkInfo> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let updateApp = flags & (1 << 0) ? true : false;
        let message = await Primitive.String.read(b);
        let entities = flags & (1 << 1) ? await TLObject.read(b) : [];
        return new Raw.help.DeepLinkInfo({
          updateApp: updateApp,
          message: message,
          entities: entities,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.updateApp ? 1 << 0 : 0;
        flags |= this.entities ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PassportConfigNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'help.PassportConfigNotModified';
        this.constructorId = 0xbfb9f457;
        this.subclassOfId = 0xc666c0ad;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.help.PassportConfigNotModified> {
        // no flags

        return new Raw.help.PassportConfigNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class PassportConfig extends TLObject {
      hash!: int;
      countriesLangs!: Raw.TypeDataJSON;

      constructor(params: { hash: int; countriesLangs: Raw.TypeDataJSON }) {
        super();
        this.classType = 'types';
        this.className = 'help.PassportConfig';
        this.constructorId = 0xa098d6af;
        this.subclassOfId = 0xc666c0ad;
        this._slots = ['hash', 'countriesLangs'];
        this.hash = params.hash;
        this.countriesLangs = params.countriesLangs;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.PassportConfig> {
        // no flags

        let hash = await Primitive.Int.read(b);
        let countriesLangs = await TLObject.read(b);
        return new Raw.help.PassportConfig({ hash: hash, countriesLangs: countriesLangs });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        if (this.countriesLangs !== undefined) {
          b.write(this.countriesLangs.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SupportName extends TLObject {
      name!: string;

      constructor(params: { name: string }) {
        super();
        this.classType = 'types';
        this.className = 'help.SupportName';
        this.constructorId = 0x8c05f1c9;
        this.subclassOfId = 0x7f50b7c2;
        this._slots = ['name'];
        this.name = params.name;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.SupportName> {
        // no flags

        let name = await Primitive.String.read(b);
        return new Raw.help.SupportName({ name: name });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.name !== undefined) {
          b.write(Primitive.String.write(this.name) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UserInfoEmpty extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'help.UserInfoEmpty';
        this.constructorId = 0xf3ae2eed;
        this.subclassOfId = 0x5c53d7d8;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.UserInfoEmpty> {
        // no flags

        return new Raw.help.UserInfoEmpty();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class UserInfo extends TLObject {
      message!: string;
      entities!: Vector<Raw.TypeMessageEntity>;
      author!: string;
      date!: int;

      constructor(params: {
        message: string;
        entities: Vector<Raw.TypeMessageEntity>;
        author: string;
        date: int;
      }) {
        super();
        this.classType = 'types';
        this.className = 'help.UserInfo';
        this.constructorId = 0x1eb3758;
        this.subclassOfId = 0x5c53d7d8;
        this._slots = ['message', 'entities', 'author', 'date'];
        this.message = params.message;
        this.entities = params.entities;
        this.author = params.author;
        this.date = params.date;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.UserInfo> {
        // no flags

        let message = await Primitive.String.read(b);
        let entities = await TLObject.read(b);
        let author = await Primitive.String.read(b);
        let date = await Primitive.Int.read(b);
        return new Raw.help.UserInfo({
          message: message,
          entities: entities,
          author: author,
          date: date,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        if (this.author !== undefined) {
          b.write(Primitive.String.write(this.author) as unknown as Buffer);
        }
        if (this.date !== undefined) {
          b.write(Primitive.Int.write(this.date) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PromoDataEmpty extends TLObject {
      expires!: int;

      constructor(params: { expires: int }) {
        super();
        this.classType = 'types';
        this.className = 'help.PromoDataEmpty';
        this.constructorId = 0x98f6ac75;
        this.subclassOfId = 0x9d595542;
        this._slots = ['expires'];
        this.expires = params.expires;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.PromoDataEmpty> {
        // no flags

        let expires = await Primitive.Int.read(b);
        return new Raw.help.PromoDataEmpty({ expires: expires });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.expires !== undefined) {
          b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PromoData extends TLObject {
      proxy?: boolean;
      expires!: int;
      peer!: Raw.TypePeer;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;
      psaType?: string;
      psaMessage?: string;

      constructor(params: {
        proxy?: boolean;
        expires: int;
        peer: Raw.TypePeer;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
        psaType?: string;
        psaMessage?: string;
      }) {
        super();
        this.classType = 'types';
        this.className = 'help.PromoData';
        this.constructorId = 0x8c39793f;
        this.subclassOfId = 0x9d595542;
        this._slots = ['proxy', 'expires', 'peer', 'chats', 'users', 'psaType', 'psaMessage'];
        this.proxy = params.proxy;
        this.expires = params.expires;
        this.peer = params.peer;
        this.chats = params.chats;
        this.users = params.users;
        this.psaType = params.psaType;
        this.psaMessage = params.psaMessage;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.PromoData> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let proxy = flags & (1 << 0) ? true : false;
        let expires = await Primitive.Int.read(b);
        let peer = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        let psaType = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let psaMessage = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        return new Raw.help.PromoData({
          proxy: proxy,
          expires: expires,
          peer: peer,
          chats: chats,
          users: users,
          psaType: psaType,
          psaMessage: psaMessage,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.proxy ? 1 << 0 : 0;
        flags |= this.psaType !== undefined ? 1 << 1 : 0;
        flags |= this.psaMessage !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.expires !== undefined) {
          b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
        }
        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        if (this.psaType !== undefined) {
          b.write(Primitive.String.write(this.psaType) as unknown as Buffer);
        }
        if (this.psaMessage !== undefined) {
          b.write(Primitive.String.write(this.psaMessage) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CountryCode extends TLObject {
      countryCode!: string;
      prefixes?: Vector<string>;
      patterns?: Vector<string>;

      constructor(params: {
        countryCode: string;
        prefixes?: Vector<string>;
        patterns?: Vector<string>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'help.CountryCode';
        this.constructorId = 0x4203c5ef;
        this.subclassOfId = 0x76f34665;
        this._slots = ['countryCode', 'prefixes', 'patterns'];
        this.countryCode = params.countryCode;
        this.prefixes = params.prefixes;
        this.patterns = params.patterns;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.CountryCode> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let countryCode = await Primitive.String.read(b);
        let prefixes = flags & (1 << 0) ? await TLObject.read(b, Primitive.String) : [];
        let patterns = flags & (1 << 1) ? await TLObject.read(b, Primitive.String) : [];
        return new Raw.help.CountryCode({
          countryCode: countryCode,
          prefixes: prefixes,
          patterns: patterns,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.prefixes ? 1 << 0 : 0;
        flags |= this.patterns ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.countryCode !== undefined) {
          b.write(Primitive.String.write(this.countryCode) as unknown as Buffer);
        }
        if (this.prefixes) {
          b.write(Primitive.Vector.write(this.prefixes, Primitive.String) as unknown as Buffer);
        }
        if (this.patterns) {
          b.write(Primitive.Vector.write(this.patterns, Primitive.String) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Country extends TLObject {
      hidden?: boolean;
      iso2!: string;
      defaultName!: string;
      name?: string;
      countryCodes!: Vector<Raw.help.TypeCountryCode>;

      constructor(params: {
        hidden?: boolean;
        iso2: string;
        defaultName: string;
        name?: string;
        countryCodes: Vector<Raw.help.TypeCountryCode>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'help.Country';
        this.constructorId = 0xc3878e23;
        this.subclassOfId = 0xa22e9e28;
        this._slots = ['hidden', 'iso2', 'defaultName', 'name', 'countryCodes'];
        this.hidden = params.hidden;
        this.iso2 = params.iso2;
        this.defaultName = params.defaultName;
        this.name = params.name;
        this.countryCodes = params.countryCodes;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.Country> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let hidden = flags & (1 << 0) ? true : false;
        let iso2 = await Primitive.String.read(b);
        let defaultName = await Primitive.String.read(b);
        let name = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let countryCodes = await TLObject.read(b);
        return new Raw.help.Country({
          hidden: hidden,
          iso2: iso2,
          defaultName: defaultName,
          name: name,
          countryCodes: countryCodes,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.hidden ? 1 << 0 : 0;
        flags |= this.name !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.iso2 !== undefined) {
          b.write(Primitive.String.write(this.iso2) as unknown as Buffer);
        }
        if (this.defaultName !== undefined) {
          b.write(Primitive.String.write(this.defaultName) as unknown as Buffer);
        }
        if (this.name !== undefined) {
          b.write(Primitive.String.write(this.name) as unknown as Buffer);
        }
        if (this.countryCodes) {
          b.write(Primitive.Vector.write(this.countryCodes) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CountriesListNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'help.CountriesListNotModified';
        this.constructorId = 0x93cc1f32;
        this.subclassOfId = 0xea31fe88;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.help.CountriesListNotModified> {
        // no flags

        return new Raw.help.CountriesListNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class CountriesList extends TLObject {
      countries!: Vector<Raw.help.TypeCountry>;
      hash!: int;

      constructor(params: { countries: Vector<Raw.help.TypeCountry>; hash: int }) {
        super();
        this.classType = 'types';
        this.className = 'help.CountriesList';
        this.constructorId = 0x87d0759e;
        this.subclassOfId = 0xea31fe88;
        this._slots = ['countries', 'hash'];
        this.countries = params.countries;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.CountriesList> {
        // no flags

        let countries = await TLObject.read(b);
        let hash = await Primitive.Int.read(b);
        return new Raw.help.CountriesList({ countries: countries, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.countries) {
          b.write(Primitive.Vector.write(this.countries) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PremiumPromo extends TLObject {
      statusText!: string;
      statusEntities!: Vector<Raw.TypeMessageEntity>;
      videoSections!: Vector<string>;
      videos!: Vector<Raw.TypeDocument>;
      periodOptions!: Vector<Raw.TypePremiumSubscriptionOption>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        statusText: string;
        statusEntities: Vector<Raw.TypeMessageEntity>;
        videoSections: Vector<string>;
        videos: Vector<Raw.TypeDocument>;
        periodOptions: Vector<Raw.TypePremiumSubscriptionOption>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'help.PremiumPromo';
        this.constructorId = 0x5334759c;
        this.subclassOfId = 0xc987a338;
        this._slots = [
          'statusText',
          'statusEntities',
          'videoSections',
          'videos',
          'periodOptions',
          'users',
        ];
        this.statusText = params.statusText;
        this.statusEntities = params.statusEntities;
        this.videoSections = params.videoSections;
        this.videos = params.videos;
        this.periodOptions = params.periodOptions;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.PremiumPromo> {
        // no flags

        let statusText = await Primitive.String.read(b);
        let statusEntities = await TLObject.read(b);
        let videoSections = await TLObject.read(b, Primitive.String);
        let videos = await TLObject.read(b);
        let periodOptions = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.help.PremiumPromo({
          statusText: statusText,
          statusEntities: statusEntities,
          videoSections: videoSections,
          videos: videos,
          periodOptions: periodOptions,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.statusText !== undefined) {
          b.write(Primitive.String.write(this.statusText) as unknown as Buffer);
        }
        if (this.statusEntities) {
          b.write(Primitive.Vector.write(this.statusEntities) as unknown as Buffer);
        }
        if (this.videoSections) {
          b.write(
            Primitive.Vector.write(this.videoSections, Primitive.String) as unknown as Buffer,
          );
        }
        if (this.videos) {
          b.write(Primitive.Vector.write(this.videos) as unknown as Buffer);
        }
        if (this.periodOptions) {
          b.write(Primitive.Vector.write(this.periodOptions) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AppConfigNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'help.AppConfigNotModified';
        this.constructorId = 0x7cde641d;
        this.subclassOfId = 0x14381c9a;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.AppConfigNotModified> {
        // no flags

        return new Raw.help.AppConfigNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class AppConfig extends TLObject {
      hash!: int;
      config!: Raw.TypeJSONValue;

      constructor(params: { hash: int; config: Raw.TypeJSONValue }) {
        super();
        this.classType = 'types';
        this.className = 'help.AppConfig';
        this.constructorId = 0xdd18782e;
        this.subclassOfId = 0x14381c9a;
        this._slots = ['hash', 'config'];
        this.hash = params.hash;
        this.config = params.config;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.AppConfig> {
        // no flags

        let hash = await Primitive.Int.read(b);
        let config = await TLObject.read(b);
        return new Raw.help.AppConfig({ hash: hash, config: config });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        if (this.config !== undefined) {
          b.write(this.config.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetConfig extends TLObject {
      __response__!: Raw.TypeConfig;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'help.GetConfig';
        this.constructorId = 0xc4f9186b;
        this.subclassOfId = 0xd3262a4a;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetConfig> {
        // no flags

        return new Raw.help.GetConfig();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetNearestDc extends TLObject {
      __response__!: Raw.TypeNearestDc;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'help.GetNearestDc';
        this.constructorId = 0x1fb33026;
        this.subclassOfId = 0x3877045f;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetNearestDc> {
        // no flags

        return new Raw.help.GetNearestDc();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetAppUpdate extends TLObject {
      __response__!: Raw.help.TypeAppUpdate;
      source!: string;

      constructor(params: { source: string }) {
        super();
        this.classType = 'functions';
        this.className = 'help.GetAppUpdate';
        this.constructorId = 0x522d5a7d;
        this.subclassOfId = 0x5897069e;
        this._slots = ['source'];
        this.source = params.source;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetAppUpdate> {
        // no flags

        let source = await Primitive.String.read(b);
        return new Raw.help.GetAppUpdate({ source: source });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.source !== undefined) {
          b.write(Primitive.String.write(this.source) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetInviteText extends TLObject {
      __response__!: Raw.help.TypeInviteText;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'help.GetInviteText';
        this.constructorId = 0x4d392343;
        this.subclassOfId = 0xcf70aa35;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetInviteText> {
        // no flags

        return new Raw.help.GetInviteText();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetSupport extends TLObject {
      __response__!: Raw.help.TypeSupport;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'help.GetSupport';
        this.constructorId = 0x9cdf08cd;
        this.subclassOfId = 0x7159bceb;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetSupport> {
        // no flags

        return new Raw.help.GetSupport();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetAppChangelog extends TLObject {
      __response__!: Raw.TypeUpdates;
      prevAppVersion!: string;

      constructor(params: { prevAppVersion: string }) {
        super();
        this.classType = 'functions';
        this.className = 'help.GetAppChangelog';
        this.constructorId = 0x9010ef6f;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['prevAppVersion'];
        this.prevAppVersion = params.prevAppVersion;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetAppChangelog> {
        // no flags

        let prevAppVersion = await Primitive.String.read(b);
        return new Raw.help.GetAppChangelog({ prevAppVersion: prevAppVersion });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.prevAppVersion !== undefined) {
          b.write(Primitive.String.write(this.prevAppVersion) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetBotUpdatesStatus extends TLObject {
      __response__!: Bool;
      pendingUpdatesCount!: int;
      message!: string;

      constructor(params: { pendingUpdatesCount: int; message: string }) {
        super();
        this.classType = 'functions';
        this.className = 'help.SetBotUpdatesStatus';
        this.constructorId = 0xec22cfcd;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['pendingUpdatesCount', 'message'];
        this.pendingUpdatesCount = params.pendingUpdatesCount;
        this.message = params.message;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.SetBotUpdatesStatus> {
        // no flags

        let pendingUpdatesCount = await Primitive.Int.read(b);
        let message = await Primitive.String.read(b);
        return new Raw.help.SetBotUpdatesStatus({
          pendingUpdatesCount: pendingUpdatesCount,
          message: message,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.pendingUpdatesCount !== undefined) {
          b.write(Primitive.Int.write(this.pendingUpdatesCount) as unknown as Buffer);
        }
        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetCdnConfig extends TLObject {
      __response__!: Raw.TypeCdnConfig;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'help.GetCdnConfig';
        this.constructorId = 0x52029342;
        this.subclassOfId = 0xecda397c;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetCdnConfig> {
        // no flags

        return new Raw.help.GetCdnConfig();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetRecentMeUrls extends TLObject {
      __response__!: Raw.help.TypeRecentMeUrls;
      referer!: string;

      constructor(params: { referer: string }) {
        super();
        this.classType = 'functions';
        this.className = 'help.GetRecentMeUrls';
        this.constructorId = 0x3dc0f114;
        this.subclassOfId = 0xf269c477;
        this._slots = ['referer'];
        this.referer = params.referer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetRecentMeUrls> {
        // no flags

        let referer = await Primitive.String.read(b);
        return new Raw.help.GetRecentMeUrls({ referer: referer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.referer !== undefined) {
          b.write(Primitive.String.write(this.referer) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetTermsOfServiceUpdate extends TLObject {
      __response__!: Raw.help.TypeTermsOfServiceUpdate;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'help.GetTermsOfServiceUpdate';
        this.constructorId = 0x2ca51fd1;
        this.subclassOfId = 0x293c2977;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.help.GetTermsOfServiceUpdate> {
        // no flags

        return new Raw.help.GetTermsOfServiceUpdate();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class AcceptTermsOfService extends TLObject {
      __response__!: Bool;
      id!: Raw.TypeDataJSON;

      constructor(params: { id: Raw.TypeDataJSON }) {
        super();
        this.classType = 'functions';
        this.className = 'help.AcceptTermsOfService';
        this.constructorId = 0xee72f79a;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.AcceptTermsOfService> {
        // no flags

        let id = await TLObject.read(b);
        return new Raw.help.AcceptTermsOfService({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDeepLinkInfo extends TLObject {
      __response__!: Raw.help.TypeDeepLinkInfo;
      path!: string;

      constructor(params: { path: string }) {
        super();
        this.classType = 'functions';
        this.className = 'help.GetDeepLinkInfo';
        this.constructorId = 0x3fedc75f;
        this.subclassOfId = 0x984aac38;
        this._slots = ['path'];
        this.path = params.path;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetDeepLinkInfo> {
        // no flags

        let path = await Primitive.String.read(b);
        return new Raw.help.GetDeepLinkInfo({ path: path });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.path !== undefined) {
          b.write(Primitive.String.write(this.path) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAppConfig extends TLObject {
      __response__!: Raw.help.TypeAppConfig;
      hash!: int;

      constructor(params: { hash: int }) {
        super();
        this.classType = 'functions';
        this.className = 'help.GetAppConfig';
        this.constructorId = 0x61e3f854;
        this.subclassOfId = 0x14381c9a;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetAppConfig> {
        // no flags

        let hash = await Primitive.Int.read(b);
        return new Raw.help.GetAppConfig({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveAppLog extends TLObject {
      __response__!: Bool;
      events!: Vector<Raw.TypeInputAppEvent>;

      constructor(params: { events: Vector<Raw.TypeInputAppEvent> }) {
        super();
        this.classType = 'functions';
        this.className = 'help.SaveAppLog';
        this.constructorId = 0x6f02f748;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['events'];
        this.events = params.events;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.SaveAppLog> {
        // no flags

        let events = await TLObject.read(b);
        return new Raw.help.SaveAppLog({ events: events });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.events) {
          b.write(Primitive.Vector.write(this.events) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPassportConfig extends TLObject {
      __response__!: Raw.help.TypePassportConfig;
      hash!: int;

      constructor(params: { hash: int }) {
        super();
        this.classType = 'functions';
        this.className = 'help.GetPassportConfig';
        this.constructorId = 0xc661ad08;
        this.subclassOfId = 0xc666c0ad;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetPassportConfig> {
        // no flags

        let hash = await Primitive.Int.read(b);
        return new Raw.help.GetPassportConfig({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetSupportName extends TLObject {
      __response__!: Raw.help.TypeSupportName;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'help.GetSupportName';
        this.constructorId = 0xd360e72c;
        this.subclassOfId = 0x7f50b7c2;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetSupportName> {
        // no flags

        return new Raw.help.GetSupportName();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetUserInfo extends TLObject {
      __response__!: Raw.help.TypeUserInfo;
      userId!: Raw.TypeInputUser;

      constructor(params: { userId: Raw.TypeInputUser }) {
        super();
        this.classType = 'functions';
        this.className = 'help.GetUserInfo';
        this.constructorId = 0x38a08d3;
        this.subclassOfId = 0x5c53d7d8;
        this._slots = ['userId'];
        this.userId = params.userId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetUserInfo> {
        // no flags

        let userId = await TLObject.read(b);
        return new Raw.help.GetUserInfo({ userId: userId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditUserInfo extends TLObject {
      __response__!: Raw.help.TypeUserInfo;
      userId!: Raw.TypeInputUser;
      message!: string;
      entities!: Vector<Raw.TypeMessageEntity>;

      constructor(params: {
        userId: Raw.TypeInputUser;
        message: string;
        entities: Vector<Raw.TypeMessageEntity>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'help.EditUserInfo';
        this.constructorId = 0x66b91b70;
        this.subclassOfId = 0x5c53d7d8;
        this._slots = ['userId', 'message', 'entities'];
        this.userId = params.userId;
        this.message = params.message;
        this.entities = params.entities;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.EditUserInfo> {
        // no flags

        let userId = await TLObject.read(b);
        let message = await Primitive.String.read(b);
        let entities = await TLObject.read(b);
        return new Raw.help.EditUserInfo({ userId: userId, message: message, entities: entities });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPromoData extends TLObject {
      __response__!: Raw.help.TypePromoData;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'help.GetPromoData';
        this.constructorId = 0xc0977421;
        this.subclassOfId = 0x9d595542;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetPromoData> {
        // no flags

        return new Raw.help.GetPromoData();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class HidePromoData extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'help.HidePromoData';
        this.constructorId = 0x1e251c95;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.HidePromoData> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.help.HidePromoData({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DismissSuggestion extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      suggestion!: string;

      constructor(params: { peer: Raw.TypeInputPeer; suggestion: string }) {
        super();
        this.classType = 'functions';
        this.className = 'help.DismissSuggestion';
        this.constructorId = 0xf50dbaa1;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'suggestion'];
        this.peer = params.peer;
        this.suggestion = params.suggestion;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.DismissSuggestion> {
        // no flags

        let peer = await TLObject.read(b);
        let suggestion = await Primitive.String.read(b);
        return new Raw.help.DismissSuggestion({ peer: peer, suggestion: suggestion });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.suggestion !== undefined) {
          b.write(Primitive.String.write(this.suggestion) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetCountriesList extends TLObject {
      __response__!: Raw.help.TypeCountriesList;
      langCode!: string;
      hash!: int;

      constructor(params: { langCode: string; hash: int }) {
        super();
        this.classType = 'functions';
        this.className = 'help.GetCountriesList';
        this.constructorId = 0x735787a8;
        this.subclassOfId = 0xea31fe88;
        this._slots = ['langCode', 'hash'];
        this.langCode = params.langCode;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetCountriesList> {
        // no flags

        let langCode = await Primitive.String.read(b);
        let hash = await Primitive.Int.read(b);
        return new Raw.help.GetCountriesList({ langCode: langCode, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPremiumPromo extends TLObject {
      __response__!: Raw.help.TypePremiumPromo;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'help.GetPremiumPromo';
        this.constructorId = 0xb81b93d4;
        this.subclassOfId = 0xc987a338;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.help.GetPremiumPromo> {
        // no flags

        return new Raw.help.GetPremiumPromo();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
  }
  export namespace storage {
    export type TypeFileType =
      | Raw.storage.FileUnknown
      | Raw.storage.FilePartial
      | Raw.storage.FileJpeg
      | Raw.storage.FileGif
      | Raw.storage.FilePng
      | Raw.storage.FilePdf
      | Raw.storage.FileMp3
      | Raw.storage.FileMov
      | Raw.storage.FileMp4
      | Raw.storage.FileWebp;
    export class FileUnknown extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'storage.FileUnknown';
        this.constructorId = 0xaa963b05;
        this.subclassOfId = 0xf3a1e6f3;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.storage.FileUnknown> {
        // no flags

        return new Raw.storage.FileUnknown();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class FilePartial extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'storage.FilePartial';
        this.constructorId = 0x40bc6f52;
        this.subclassOfId = 0xf3a1e6f3;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.storage.FilePartial> {
        // no flags

        return new Raw.storage.FilePartial();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class FileJpeg extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'storage.FileJpeg';
        this.constructorId = 0x7efe0e;
        this.subclassOfId = 0xf3a1e6f3;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.storage.FileJpeg> {
        // no flags

        return new Raw.storage.FileJpeg();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class FileGif extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'storage.FileGif';
        this.constructorId = 0xcae1aadf;
        this.subclassOfId = 0xf3a1e6f3;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.storage.FileGif> {
        // no flags

        return new Raw.storage.FileGif();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class FilePng extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'storage.FilePng';
        this.constructorId = 0xa4f63c0;
        this.subclassOfId = 0xf3a1e6f3;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.storage.FilePng> {
        // no flags

        return new Raw.storage.FilePng();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class FilePdf extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'storage.FilePdf';
        this.constructorId = 0xae1e508d;
        this.subclassOfId = 0xf3a1e6f3;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.storage.FilePdf> {
        // no flags

        return new Raw.storage.FilePdf();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class FileMp3 extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'storage.FileMp3';
        this.constructorId = 0x528a0677;
        this.subclassOfId = 0xf3a1e6f3;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.storage.FileMp3> {
        // no flags

        return new Raw.storage.FileMp3();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class FileMov extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'storage.FileMov';
        this.constructorId = 0x4b09ebbc;
        this.subclassOfId = 0xf3a1e6f3;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.storage.FileMov> {
        // no flags

        return new Raw.storage.FileMov();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class FileMp4 extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'storage.FileMp4';
        this.constructorId = 0xb3cea0e4;
        this.subclassOfId = 0xf3a1e6f3;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.storage.FileMp4> {
        // no flags

        return new Raw.storage.FileMp4();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class FileWebp extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'storage.FileWebp';
        this.constructorId = 0x1081464c;
        this.subclassOfId = 0xf3a1e6f3;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.storage.FileWebp> {
        // no flags

        return new Raw.storage.FileWebp();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
  }
  export namespace auth {
    export type TypeLoginToken =
      | Raw.auth.LoginToken
      | Raw.auth.LoginTokenMigrateTo
      | Raw.auth.LoginTokenSuccess;
    export type TypePasswordRecovery = Raw.auth.PasswordRecovery;
    export type TypeExportedAuthorization = Raw.auth.ExportedAuthorization;
    export type TypeLoggedOut = Raw.auth.LoggedOut;
    export type TypeSentCode = Raw.auth.SentCode | Raw.auth.SentCodeSuccess;
    export type TypeAuthorization = Raw.auth.Authorization | Raw.auth.AuthorizationSignUpRequired;
    export type TypeCodeType =
      | Raw.auth.CodeTypeSms
      | Raw.auth.CodeTypeCall
      | Raw.auth.CodeTypeFlashCall
      | Raw.auth.CodeTypeMissedCall
      | Raw.auth.CodeTypeFragmentSms;
    export type TypeSentCodeType =
      | Raw.auth.SentCodeTypeApp
      | Raw.auth.SentCodeTypeSms
      | Raw.auth.SentCodeTypeCall
      | Raw.auth.SentCodeTypeFlashCall
      | Raw.auth.SentCodeTypeMissedCall
      | Raw.auth.SentCodeTypeEmailCode
      | Raw.auth.SentCodeTypeSetUpEmailRequired
      | Raw.auth.SentCodeTypeFragmentSms
      | Raw.auth.SentCodeTypeFirebaseSms;
    export class SentCode extends TLObject {
      type!: Raw.auth.TypeSentCodeType;
      phoneCodeHash!: string;
      nextType?: Raw.auth.TypeCodeType;
      timeout?: int;

      constructor(params: {
        type: Raw.auth.TypeSentCodeType;
        phoneCodeHash: string;
        nextType?: Raw.auth.TypeCodeType;
        timeout?: int;
      }) {
        super();
        this.classType = 'types';
        this.className = 'auth.SentCode';
        this.constructorId = 0x5e002502;
        this.subclassOfId = 0x6ce87081;
        this._slots = ['type', 'phoneCodeHash', 'nextType', 'timeout'];
        this.type = params.type;
        this.phoneCodeHash = params.phoneCodeHash;
        this.nextType = params.nextType;
        this.timeout = params.timeout;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.SentCode> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let type = await TLObject.read(b);
        let phoneCodeHash = await Primitive.String.read(b);
        let nextType = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        let timeout = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
        return new Raw.auth.SentCode({
          type: type,
          phoneCodeHash: phoneCodeHash,
          nextType: nextType,
          timeout: timeout,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.nextType !== undefined ? 1 << 1 : 0;
        flags |= this.timeout !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.type !== undefined) {
          b.write(this.type.write() as unknown as Buffer);
        }
        if (this.phoneCodeHash !== undefined) {
          b.write(Primitive.String.write(this.phoneCodeHash) as unknown as Buffer);
        }
        if (this.nextType !== undefined) {
          b.write(this.nextType.write() as unknown as Buffer);
        }
        if (this.timeout !== undefined) {
          b.write(Primitive.Int.write(this.timeout) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SentCodeSuccess extends TLObject {
      authorization!: Raw.auth.TypeAuthorization;

      constructor(params: { authorization: Raw.auth.TypeAuthorization }) {
        super();
        this.classType = 'types';
        this.className = 'auth.SentCodeSuccess';
        this.constructorId = 0x2390fe44;
        this.subclassOfId = 0x6ce87081;
        this._slots = ['authorization'];
        this.authorization = params.authorization;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.SentCodeSuccess> {
        // no flags

        let authorization = await TLObject.read(b);
        return new Raw.auth.SentCodeSuccess({ authorization: authorization });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.authorization !== undefined) {
          b.write(this.authorization.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Authorization extends TLObject {
      setupPasswordRequired?: boolean;
      otherwiseReloginDays?: int;
      tmpSessions?: int;
      futureAuthToken?: bytes;
      user!: Raw.TypeUser;

      constructor(params: {
        setupPasswordRequired?: boolean;
        otherwiseReloginDays?: int;
        tmpSessions?: int;
        futureAuthToken?: bytes;
        user: Raw.TypeUser;
      }) {
        super();
        this.classType = 'types';
        this.className = 'auth.Authorization';
        this.constructorId = 0x2ea2c0d4;
        this.subclassOfId = 0xb9e04e39;
        this._slots = [
          'setupPasswordRequired',
          'otherwiseReloginDays',
          'tmpSessions',
          'futureAuthToken',
          'user',
        ];
        this.setupPasswordRequired = params.setupPasswordRequired;
        this.otherwiseReloginDays = params.otherwiseReloginDays;
        this.tmpSessions = params.tmpSessions;
        this.futureAuthToken = params.futureAuthToken;
        this.user = params.user;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.Authorization> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let setupPasswordRequired = flags & (1 << 1) ? true : false;
        let otherwiseReloginDays = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let tmpSessions = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let futureAuthToken = flags & (1 << 2) ? await Primitive.Bytes.read(b) : undefined;
        let user = await TLObject.read(b);
        return new Raw.auth.Authorization({
          setupPasswordRequired: setupPasswordRequired,
          otherwiseReloginDays: otherwiseReloginDays,
          tmpSessions: tmpSessions,
          futureAuthToken: futureAuthToken,
          user: user,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.setupPasswordRequired ? 1 << 1 : 0;
        flags |= this.otherwiseReloginDays !== undefined ? 1 << 1 : 0;
        flags |= this.tmpSessions !== undefined ? 1 << 0 : 0;
        flags |= this.futureAuthToken !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.otherwiseReloginDays !== undefined) {
          b.write(Primitive.Int.write(this.otherwiseReloginDays) as unknown as Buffer);
        }
        if (this.tmpSessions !== undefined) {
          b.write(Primitive.Int.write(this.tmpSessions) as unknown as Buffer);
        }
        if (this.futureAuthToken !== undefined) {
          b.write(Primitive.Bytes.write(this.futureAuthToken) as unknown as Buffer);
        }
        if (this.user !== undefined) {
          b.write(this.user.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AuthorizationSignUpRequired extends TLObject {
      termsOfService?: Raw.help.TypeTermsOfService;

      constructor(params: { termsOfService?: Raw.help.TypeTermsOfService }) {
        super();
        this.classType = 'types';
        this.className = 'auth.AuthorizationSignUpRequired';
        this.constructorId = 0x44747e9a;
        this.subclassOfId = 0xb9e04e39;
        this._slots = ['termsOfService'];
        this.termsOfService = params.termsOfService;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.auth.AuthorizationSignUpRequired> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let termsOfService = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        return new Raw.auth.AuthorizationSignUpRequired({ termsOfService: termsOfService });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.termsOfService !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.termsOfService !== undefined) {
          b.write(this.termsOfService.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportedAuthorization extends TLObject {
      id!: long;
      bytes!: bytes;

      constructor(params: { id: long; bytes: bytes }) {
        super();
        this.classType = 'types';
        this.className = 'auth.ExportedAuthorization';
        this.constructorId = 0xb434e2b8;
        this.subclassOfId = 0x5fd1ec51;
        this._slots = ['id', 'bytes'];
        this.id = params.id;
        this.bytes = params.bytes;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.ExportedAuthorization> {
        // no flags

        let id = await Primitive.Long.read(b);
        let bytes = await Primitive.Bytes.read(b);
        return new Raw.auth.ExportedAuthorization({ id: id, bytes: bytes });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id !== undefined) {
          b.write(Primitive.Long.write(this.id) as unknown as Buffer);
        }
        if (this.bytes !== undefined) {
          b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PasswordRecovery extends TLObject {
      emailPattern!: string;

      constructor(params: { emailPattern: string }) {
        super();
        this.classType = 'types';
        this.className = 'auth.PasswordRecovery';
        this.constructorId = 0x137948a5;
        this.subclassOfId = 0xfa72d43a;
        this._slots = ['emailPattern'];
        this.emailPattern = params.emailPattern;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.PasswordRecovery> {
        // no flags

        let emailPattern = await Primitive.String.read(b);
        return new Raw.auth.PasswordRecovery({ emailPattern: emailPattern });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.emailPattern !== undefined) {
          b.write(Primitive.String.write(this.emailPattern) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CodeTypeSms extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'auth.CodeTypeSms';
        this.constructorId = 0x72a3158c;
        this.subclassOfId = 0xb3f3e401;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.CodeTypeSms> {
        // no flags

        return new Raw.auth.CodeTypeSms();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class CodeTypeCall extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'auth.CodeTypeCall';
        this.constructorId = 0x741cd3e3;
        this.subclassOfId = 0xb3f3e401;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.CodeTypeCall> {
        // no flags

        return new Raw.auth.CodeTypeCall();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class CodeTypeFlashCall extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'auth.CodeTypeFlashCall';
        this.constructorId = 0x226ccefb;
        this.subclassOfId = 0xb3f3e401;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.CodeTypeFlashCall> {
        // no flags

        return new Raw.auth.CodeTypeFlashCall();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class CodeTypeMissedCall extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'auth.CodeTypeMissedCall';
        this.constructorId = 0xd61ad6ee;
        this.subclassOfId = 0xb3f3e401;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.CodeTypeMissedCall> {
        // no flags

        return new Raw.auth.CodeTypeMissedCall();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class CodeTypeFragmentSms extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'auth.CodeTypeFragmentSms';
        this.constructorId = 0x6ed998c;
        this.subclassOfId = 0xb3f3e401;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.CodeTypeFragmentSms> {
        // no flags

        return new Raw.auth.CodeTypeFragmentSms();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SentCodeTypeApp extends TLObject {
      length!: int;

      constructor(params: { length: int }) {
        super();
        this.classType = 'types';
        this.className = 'auth.SentCodeTypeApp';
        this.constructorId = 0x3dbb5986;
        this.subclassOfId = 0xff5b158e;
        this._slots = ['length'];
        this.length = params.length;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.SentCodeTypeApp> {
        // no flags

        let length = await Primitive.Int.read(b);
        return new Raw.auth.SentCodeTypeApp({ length: length });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.length !== undefined) {
          b.write(Primitive.Int.write(this.length) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SentCodeTypeSms extends TLObject {
      length!: int;

      constructor(params: { length: int }) {
        super();
        this.classType = 'types';
        this.className = 'auth.SentCodeTypeSms';
        this.constructorId = 0xc000bba2;
        this.subclassOfId = 0xff5b158e;
        this._slots = ['length'];
        this.length = params.length;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.SentCodeTypeSms> {
        // no flags

        let length = await Primitive.Int.read(b);
        return new Raw.auth.SentCodeTypeSms({ length: length });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.length !== undefined) {
          b.write(Primitive.Int.write(this.length) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SentCodeTypeCall extends TLObject {
      length!: int;

      constructor(params: { length: int }) {
        super();
        this.classType = 'types';
        this.className = 'auth.SentCodeTypeCall';
        this.constructorId = 0x5353e5a7;
        this.subclassOfId = 0xff5b158e;
        this._slots = ['length'];
        this.length = params.length;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.SentCodeTypeCall> {
        // no flags

        let length = await Primitive.Int.read(b);
        return new Raw.auth.SentCodeTypeCall({ length: length });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.length !== undefined) {
          b.write(Primitive.Int.write(this.length) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SentCodeTypeFlashCall extends TLObject {
      pattern!: string;

      constructor(params: { pattern: string }) {
        super();
        this.classType = 'types';
        this.className = 'auth.SentCodeTypeFlashCall';
        this.constructorId = 0xab03c6d9;
        this.subclassOfId = 0xff5b158e;
        this._slots = ['pattern'];
        this.pattern = params.pattern;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.SentCodeTypeFlashCall> {
        // no flags

        let pattern = await Primitive.String.read(b);
        return new Raw.auth.SentCodeTypeFlashCall({ pattern: pattern });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.pattern !== undefined) {
          b.write(Primitive.String.write(this.pattern) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SentCodeTypeMissedCall extends TLObject {
      prefix!: string;
      length!: int;

      constructor(params: { prefix: string; length: int }) {
        super();
        this.classType = 'types';
        this.className = 'auth.SentCodeTypeMissedCall';
        this.constructorId = 0x82006484;
        this.subclassOfId = 0xff5b158e;
        this._slots = ['prefix', 'length'];
        this.prefix = params.prefix;
        this.length = params.length;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.SentCodeTypeMissedCall> {
        // no flags

        let prefix = await Primitive.String.read(b);
        let length = await Primitive.Int.read(b);
        return new Raw.auth.SentCodeTypeMissedCall({ prefix: prefix, length: length });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.prefix !== undefined) {
          b.write(Primitive.String.write(this.prefix) as unknown as Buffer);
        }
        if (this.length !== undefined) {
          b.write(Primitive.Int.write(this.length) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SentCodeTypeEmailCode extends TLObject {
      appleSigninAllowed?: boolean;
      googleSigninAllowed?: boolean;
      emailPattern!: string;
      length!: int;
      resetAvailablePeriod?: int;
      resetPendingDate?: int;

      constructor(params: {
        appleSigninAllowed?: boolean;
        googleSigninAllowed?: boolean;
        emailPattern: string;
        length: int;
        resetAvailablePeriod?: int;
        resetPendingDate?: int;
      }) {
        super();
        this.classType = 'types';
        this.className = 'auth.SentCodeTypeEmailCode';
        this.constructorId = 0xf450f59b;
        this.subclassOfId = 0xff5b158e;
        this._slots = [
          'appleSigninAllowed',
          'googleSigninAllowed',
          'emailPattern',
          'length',
          'resetAvailablePeriod',
          'resetPendingDate',
        ];
        this.appleSigninAllowed = params.appleSigninAllowed;
        this.googleSigninAllowed = params.googleSigninAllowed;
        this.emailPattern = params.emailPattern;
        this.length = params.length;
        this.resetAvailablePeriod = params.resetAvailablePeriod;
        this.resetPendingDate = params.resetPendingDate;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.SentCodeTypeEmailCode> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let appleSigninAllowed = flags & (1 << 0) ? true : false;
        let googleSigninAllowed = flags & (1 << 1) ? true : false;
        let emailPattern = await Primitive.String.read(b);
        let length = await Primitive.Int.read(b);
        let resetAvailablePeriod = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
        let resetPendingDate = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
        return new Raw.auth.SentCodeTypeEmailCode({
          appleSigninAllowed: appleSigninAllowed,
          googleSigninAllowed: googleSigninAllowed,
          emailPattern: emailPattern,
          length: length,
          resetAvailablePeriod: resetAvailablePeriod,
          resetPendingDate: resetPendingDate,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.appleSigninAllowed ? 1 << 0 : 0;
        flags |= this.googleSigninAllowed ? 1 << 1 : 0;
        flags |= this.resetAvailablePeriod !== undefined ? 1 << 3 : 0;
        flags |= this.resetPendingDate !== undefined ? 1 << 4 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.emailPattern !== undefined) {
          b.write(Primitive.String.write(this.emailPattern) as unknown as Buffer);
        }
        if (this.length !== undefined) {
          b.write(Primitive.Int.write(this.length) as unknown as Buffer);
        }
        if (this.resetAvailablePeriod !== undefined) {
          b.write(Primitive.Int.write(this.resetAvailablePeriod) as unknown as Buffer);
        }
        if (this.resetPendingDate !== undefined) {
          b.write(Primitive.Int.write(this.resetPendingDate) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SentCodeTypeSetUpEmailRequired extends TLObject {
      appleSigninAllowed?: boolean;
      googleSigninAllowed?: boolean;

      constructor(params: { appleSigninAllowed?: boolean; googleSigninAllowed?: boolean }) {
        super();
        this.classType = 'types';
        this.className = 'auth.SentCodeTypeSetUpEmailRequired';
        this.constructorId = 0xa5491dea;
        this.subclassOfId = 0xff5b158e;
        this._slots = ['appleSigninAllowed', 'googleSigninAllowed'];
        this.appleSigninAllowed = params.appleSigninAllowed;
        this.googleSigninAllowed = params.googleSigninAllowed;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.auth.SentCodeTypeSetUpEmailRequired> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let appleSigninAllowed = flags & (1 << 0) ? true : false;
        let googleSigninAllowed = flags & (1 << 1) ? true : false;
        return new Raw.auth.SentCodeTypeSetUpEmailRequired({
          appleSigninAllowed: appleSigninAllowed,
          googleSigninAllowed: googleSigninAllowed,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.appleSigninAllowed ? 1 << 0 : 0;
        flags |= this.googleSigninAllowed ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        return b.buffer;
      }
    }
    export class SentCodeTypeFragmentSms extends TLObject {
      url!: string;
      length!: int;

      constructor(params: { url: string; length: int }) {
        super();
        this.classType = 'types';
        this.className = 'auth.SentCodeTypeFragmentSms';
        this.constructorId = 0xd9565c39;
        this.subclassOfId = 0xff5b158e;
        this._slots = ['url', 'length'];
        this.url = params.url;
        this.length = params.length;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.auth.SentCodeTypeFragmentSms> {
        // no flags

        let url = await Primitive.String.read(b);
        let length = await Primitive.Int.read(b);
        return new Raw.auth.SentCodeTypeFragmentSms({ url: url, length: length });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        if (this.length !== undefined) {
          b.write(Primitive.Int.write(this.length) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SentCodeTypeFirebaseSms extends TLObject {
      nonce?: bytes;
      receipt?: string;
      pushTimeout?: int;
      length!: int;

      constructor(params: { nonce?: bytes; receipt?: string; pushTimeout?: int; length: int }) {
        super();
        this.classType = 'types';
        this.className = 'auth.SentCodeTypeFirebaseSms';
        this.constructorId = 0xe57b1432;
        this.subclassOfId = 0xff5b158e;
        this._slots = ['nonce', 'receipt', 'pushTimeout', 'length'];
        this.nonce = params.nonce;
        this.receipt = params.receipt;
        this.pushTimeout = params.pushTimeout;
        this.length = params.length;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.auth.SentCodeTypeFirebaseSms> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let nonce = flags & (1 << 0) ? await Primitive.Bytes.read(b) : undefined;
        let receipt = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let pushTimeout = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let length = await Primitive.Int.read(b);
        return new Raw.auth.SentCodeTypeFirebaseSms({
          nonce: nonce,
          receipt: receipt,
          pushTimeout: pushTimeout,
          length: length,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.nonce !== undefined ? 1 << 0 : 0;
        flags |= this.receipt !== undefined ? 1 << 1 : 0;
        flags |= this.pushTimeout !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.nonce !== undefined) {
          b.write(Primitive.Bytes.write(this.nonce) as unknown as Buffer);
        }
        if (this.receipt !== undefined) {
          b.write(Primitive.String.write(this.receipt) as unknown as Buffer);
        }
        if (this.pushTimeout !== undefined) {
          b.write(Primitive.Int.write(this.pushTimeout) as unknown as Buffer);
        }
        if (this.length !== undefined) {
          b.write(Primitive.Int.write(this.length) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class LoginToken extends TLObject {
      expires!: int;
      token!: bytes;

      constructor(params: { expires: int; token: bytes }) {
        super();
        this.classType = 'types';
        this.className = 'auth.LoginToken';
        this.constructorId = 0x629f1980;
        this.subclassOfId = 0x6b55f636;
        this._slots = ['expires', 'token'];
        this.expires = params.expires;
        this.token = params.token;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.LoginToken> {
        // no flags

        let expires = await Primitive.Int.read(b);
        let token = await Primitive.Bytes.read(b);
        return new Raw.auth.LoginToken({ expires: expires, token: token });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.expires !== undefined) {
          b.write(Primitive.Int.write(this.expires) as unknown as Buffer);
        }
        if (this.token !== undefined) {
          b.write(Primitive.Bytes.write(this.token) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class LoginTokenMigrateTo extends TLObject {
      dcId!: int;
      token!: bytes;

      constructor(params: { dcId: int; token: bytes }) {
        super();
        this.classType = 'types';
        this.className = 'auth.LoginTokenMigrateTo';
        this.constructorId = 0x68e9916;
        this.subclassOfId = 0x6b55f636;
        this._slots = ['dcId', 'token'];
        this.dcId = params.dcId;
        this.token = params.token;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.LoginTokenMigrateTo> {
        // no flags

        let dcId = await Primitive.Int.read(b);
        let token = await Primitive.Bytes.read(b);
        return new Raw.auth.LoginTokenMigrateTo({ dcId: dcId, token: token });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.dcId !== undefined) {
          b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
        }
        if (this.token !== undefined) {
          b.write(Primitive.Bytes.write(this.token) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class LoginTokenSuccess extends TLObject {
      authorization!: Raw.auth.TypeAuthorization;

      constructor(params: { authorization: Raw.auth.TypeAuthorization }) {
        super();
        this.classType = 'types';
        this.className = 'auth.LoginTokenSuccess';
        this.constructorId = 0x390d5c5e;
        this.subclassOfId = 0x6b55f636;
        this._slots = ['authorization'];
        this.authorization = params.authorization;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.LoginTokenSuccess> {
        // no flags

        let authorization = await TLObject.read(b);
        return new Raw.auth.LoginTokenSuccess({ authorization: authorization });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.authorization !== undefined) {
          b.write(this.authorization.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class LoggedOut extends TLObject {
      futureAuthToken?: bytes;

      constructor(params: { futureAuthToken?: bytes }) {
        super();
        this.classType = 'types';
        this.className = 'auth.LoggedOut';
        this.constructorId = 0xc3a2835f;
        this.subclassOfId = 0xa804315;
        this._slots = ['futureAuthToken'];
        this.futureAuthToken = params.futureAuthToken;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.LoggedOut> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let futureAuthToken = flags & (1 << 0) ? await Primitive.Bytes.read(b) : undefined;
        return new Raw.auth.LoggedOut({ futureAuthToken: futureAuthToken });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.futureAuthToken !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.futureAuthToken !== undefined) {
          b.write(Primitive.Bytes.write(this.futureAuthToken) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendCode extends TLObject {
      __response__!: Raw.auth.TypeSentCode;
      phoneNumber!: string;
      apiId!: int;
      apiHash!: string;
      settings!: Raw.TypeCodeSettings;

      constructor(params: {
        phoneNumber: string;
        apiId: int;
        apiHash: string;
        settings: Raw.TypeCodeSettings;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.SendCode';
        this.constructorId = 0xa677244f;
        this.subclassOfId = 0x6ce87081;
        this._slots = ['phoneNumber', 'apiId', 'apiHash', 'settings'];
        this.phoneNumber = params.phoneNumber;
        this.apiId = params.apiId;
        this.apiHash = params.apiHash;
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.SendCode> {
        // no flags

        let phoneNumber = await Primitive.String.read(b);
        let apiId = await Primitive.Int.read(b);
        let apiHash = await Primitive.String.read(b);
        let settings = await TLObject.read(b);
        return new Raw.auth.SendCode({
          phoneNumber: phoneNumber,
          apiId: apiId,
          apiHash: apiHash,
          settings: settings,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phoneNumber !== undefined) {
          b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
        }
        if (this.apiId !== undefined) {
          b.write(Primitive.Int.write(this.apiId) as unknown as Buffer);
        }
        if (this.apiHash !== undefined) {
          b.write(Primitive.String.write(this.apiHash) as unknown as Buffer);
        }
        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SignUp extends TLObject {
      __response__!: Raw.auth.TypeAuthorization;
      phoneNumber!: string;
      phoneCodeHash!: string;
      firstName!: string;
      lastName!: string;

      constructor(params: {
        phoneNumber: string;
        phoneCodeHash: string;
        firstName: string;
        lastName: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.SignUp';
        this.constructorId = 0x80eee427;
        this.subclassOfId = 0xb9e04e39;
        this._slots = ['phoneNumber', 'phoneCodeHash', 'firstName', 'lastName'];
        this.phoneNumber = params.phoneNumber;
        this.phoneCodeHash = params.phoneCodeHash;
        this.firstName = params.firstName;
        this.lastName = params.lastName;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.SignUp> {
        // no flags

        let phoneNumber = await Primitive.String.read(b);
        let phoneCodeHash = await Primitive.String.read(b);
        let firstName = await Primitive.String.read(b);
        let lastName = await Primitive.String.read(b);
        return new Raw.auth.SignUp({
          phoneNumber: phoneNumber,
          phoneCodeHash: phoneCodeHash,
          firstName: firstName,
          lastName: lastName,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phoneNumber !== undefined) {
          b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
        }
        if (this.phoneCodeHash !== undefined) {
          b.write(Primitive.String.write(this.phoneCodeHash) as unknown as Buffer);
        }
        if (this.firstName !== undefined) {
          b.write(Primitive.String.write(this.firstName) as unknown as Buffer);
        }
        if (this.lastName !== undefined) {
          b.write(Primitive.String.write(this.lastName) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SignIn extends TLObject {
      __response__!: Raw.auth.TypeAuthorization;
      phoneNumber!: string;
      phoneCodeHash!: string;
      phoneCode?: string;
      emailVerification?: Raw.TypeEmailVerification;

      constructor(params: {
        phoneNumber: string;
        phoneCodeHash: string;
        phoneCode?: string;
        emailVerification?: Raw.TypeEmailVerification;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.SignIn';
        this.constructorId = 0x8d52a951;
        this.subclassOfId = 0xb9e04e39;
        this._slots = ['phoneNumber', 'phoneCodeHash', 'phoneCode', 'emailVerification'];
        this.phoneNumber = params.phoneNumber;
        this.phoneCodeHash = params.phoneCodeHash;
        this.phoneCode = params.phoneCode;
        this.emailVerification = params.emailVerification;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.SignIn> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let phoneNumber = await Primitive.String.read(b);
        let phoneCodeHash = await Primitive.String.read(b);
        let phoneCode = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let emailVerification = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        return new Raw.auth.SignIn({
          phoneNumber: phoneNumber,
          phoneCodeHash: phoneCodeHash,
          phoneCode: phoneCode,
          emailVerification: emailVerification,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.phoneCode !== undefined ? 1 << 0 : 0;
        flags |= this.emailVerification !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.phoneNumber !== undefined) {
          b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
        }
        if (this.phoneCodeHash !== undefined) {
          b.write(Primitive.String.write(this.phoneCodeHash) as unknown as Buffer);
        }
        if (this.phoneCode !== undefined) {
          b.write(Primitive.String.write(this.phoneCode) as unknown as Buffer);
        }
        if (this.emailVerification !== undefined) {
          b.write(this.emailVerification.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class LogOut extends TLObject {
      __response__!: Raw.auth.TypeLoggedOut;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'auth.LogOut';
        this.constructorId = 0x3e72ba19;
        this.subclassOfId = 0xa804315;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.LogOut> {
        // no flags

        return new Raw.auth.LogOut();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class ResetAuthorizations extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'auth.ResetAuthorizations';
        this.constructorId = 0x9fab0d1a;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.ResetAuthorizations> {
        // no flags

        return new Raw.auth.ResetAuthorizations();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class ExportAuthorization extends TLObject {
      __response__!: Raw.auth.TypeExportedAuthorization;
      dcId!: int;

      constructor(params: { dcId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.ExportAuthorization';
        this.constructorId = 0xe5bfffcd;
        this.subclassOfId = 0x5fd1ec51;
        this._slots = ['dcId'];
        this.dcId = params.dcId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.ExportAuthorization> {
        // no flags

        let dcId = await Primitive.Int.read(b);
        return new Raw.auth.ExportAuthorization({ dcId: dcId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.dcId !== undefined) {
          b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ImportAuthorization extends TLObject {
      __response__!: Raw.auth.TypeAuthorization;
      id!: long;
      bytes!: bytes;

      constructor(params: { id: long; bytes: bytes }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.ImportAuthorization';
        this.constructorId = 0xa57a7dad;
        this.subclassOfId = 0xb9e04e39;
        this._slots = ['id', 'bytes'];
        this.id = params.id;
        this.bytes = params.bytes;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.ImportAuthorization> {
        // no flags

        let id = await Primitive.Long.read(b);
        let bytes = await Primitive.Bytes.read(b);
        return new Raw.auth.ImportAuthorization({ id: id, bytes: bytes });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id !== undefined) {
          b.write(Primitive.Long.write(this.id) as unknown as Buffer);
        }
        if (this.bytes !== undefined) {
          b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class BindTempAuthKey extends TLObject {
      __response__!: Bool;
      permAuthKeyId!: long;
      nonce!: long;
      expiresAt!: int;
      encryptedMessage!: bytes;

      constructor(params: {
        permAuthKeyId: long;
        nonce: long;
        expiresAt: int;
        encryptedMessage: bytes;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.BindTempAuthKey';
        this.constructorId = 0xcdd42a05;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['permAuthKeyId', 'nonce', 'expiresAt', 'encryptedMessage'];
        this.permAuthKeyId = params.permAuthKeyId;
        this.nonce = params.nonce;
        this.expiresAt = params.expiresAt;
        this.encryptedMessage = params.encryptedMessage;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.BindTempAuthKey> {
        // no flags

        let permAuthKeyId = await Primitive.Long.read(b);
        let nonce = await Primitive.Long.read(b);
        let expiresAt = await Primitive.Int.read(b);
        let encryptedMessage = await Primitive.Bytes.read(b);
        return new Raw.auth.BindTempAuthKey({
          permAuthKeyId: permAuthKeyId,
          nonce: nonce,
          expiresAt: expiresAt,
          encryptedMessage: encryptedMessage,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.permAuthKeyId !== undefined) {
          b.write(Primitive.Long.write(this.permAuthKeyId) as unknown as Buffer);
        }
        if (this.nonce !== undefined) {
          b.write(Primitive.Long.write(this.nonce) as unknown as Buffer);
        }
        if (this.expiresAt !== undefined) {
          b.write(Primitive.Int.write(this.expiresAt) as unknown as Buffer);
        }
        if (this.encryptedMessage !== undefined) {
          b.write(Primitive.Bytes.write(this.encryptedMessage) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ImportBotAuthorization extends TLObject {
      __response__!: Raw.auth.TypeAuthorization;
      flags!: int;
      apiId!: int;
      apiHash!: string;
      botAuthToken!: string;

      constructor(params: { flags: int; apiId: int; apiHash: string; botAuthToken: string }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.ImportBotAuthorization';
        this.constructorId = 0x67a3ff2c;
        this.subclassOfId = 0xb9e04e39;
        this._slots = ['flags', 'apiId', 'apiHash', 'botAuthToken'];
        this.flags = params.flags;
        this.apiId = params.apiId;
        this.apiHash = params.apiHash;
        this.botAuthToken = params.botAuthToken;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.ImportBotAuthorization> {
        // no flags

        let flags = await Primitive.Int.read(b);
        let apiId = await Primitive.Int.read(b);
        let apiHash = await Primitive.String.read(b);
        let botAuthToken = await Primitive.String.read(b);
        return new Raw.auth.ImportBotAuthorization({
          flags: flags,
          apiId: apiId,
          apiHash: apiHash,
          botAuthToken: botAuthToken,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.flags !== undefined) {
          b.write(Primitive.Int.write(this.flags) as unknown as Buffer);
        }
        if (this.apiId !== undefined) {
          b.write(Primitive.Int.write(this.apiId) as unknown as Buffer);
        }
        if (this.apiHash !== undefined) {
          b.write(Primitive.String.write(this.apiHash) as unknown as Buffer);
        }
        if (this.botAuthToken !== undefined) {
          b.write(Primitive.String.write(this.botAuthToken) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CheckPassword extends TLObject {
      __response__!: Raw.auth.TypeAuthorization;
      password!: Raw.TypeInputCheckPasswordSRP;

      constructor(params: { password: Raw.TypeInputCheckPasswordSRP }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.CheckPassword';
        this.constructorId = 0xd18b4d16;
        this.subclassOfId = 0xb9e04e39;
        this._slots = ['password'];
        this.password = params.password;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.CheckPassword> {
        // no flags

        let password = await TLObject.read(b);
        return new Raw.auth.CheckPassword({ password: password });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.password !== undefined) {
          b.write(this.password.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RequestPasswordRecovery extends TLObject {
      __response__!: Raw.auth.TypePasswordRecovery;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'auth.RequestPasswordRecovery';
        this.constructorId = 0xd897bc66;
        this.subclassOfId = 0xfa72d43a;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.auth.RequestPasswordRecovery> {
        // no flags

        return new Raw.auth.RequestPasswordRecovery();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class RecoverPassword extends TLObject {
      __response__!: Raw.auth.TypeAuthorization;
      code!: string;
      newSettings?: Raw.account.TypePasswordInputSettings;

      constructor(params: { code: string; newSettings?: Raw.account.TypePasswordInputSettings }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.RecoverPassword';
        this.constructorId = 0x37096c70;
        this.subclassOfId = 0xb9e04e39;
        this._slots = ['code', 'newSettings'];
        this.code = params.code;
        this.newSettings = params.newSettings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.RecoverPassword> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let code = await Primitive.String.read(b);
        let newSettings = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        return new Raw.auth.RecoverPassword({ code: code, newSettings: newSettings });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.newSettings !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.code !== undefined) {
          b.write(Primitive.String.write(this.code) as unknown as Buffer);
        }
        if (this.newSettings !== undefined) {
          b.write(this.newSettings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResendCode extends TLObject {
      __response__!: Raw.auth.TypeSentCode;
      phoneNumber!: string;
      phoneCodeHash!: string;

      constructor(params: { phoneNumber: string; phoneCodeHash: string }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.ResendCode';
        this.constructorId = 0x3ef1a9bf;
        this.subclassOfId = 0x6ce87081;
        this._slots = ['phoneNumber', 'phoneCodeHash'];
        this.phoneNumber = params.phoneNumber;
        this.phoneCodeHash = params.phoneCodeHash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.ResendCode> {
        // no flags

        let phoneNumber = await Primitive.String.read(b);
        let phoneCodeHash = await Primitive.String.read(b);
        return new Raw.auth.ResendCode({ phoneNumber: phoneNumber, phoneCodeHash: phoneCodeHash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phoneNumber !== undefined) {
          b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
        }
        if (this.phoneCodeHash !== undefined) {
          b.write(Primitive.String.write(this.phoneCodeHash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CancelCode extends TLObject {
      __response__!: Bool;
      phoneNumber!: string;
      phoneCodeHash!: string;

      constructor(params: { phoneNumber: string; phoneCodeHash: string }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.CancelCode';
        this.constructorId = 0x1f040578;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['phoneNumber', 'phoneCodeHash'];
        this.phoneNumber = params.phoneNumber;
        this.phoneCodeHash = params.phoneCodeHash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.CancelCode> {
        // no flags

        let phoneNumber = await Primitive.String.read(b);
        let phoneCodeHash = await Primitive.String.read(b);
        return new Raw.auth.CancelCode({ phoneNumber: phoneNumber, phoneCodeHash: phoneCodeHash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phoneNumber !== undefined) {
          b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
        }
        if (this.phoneCodeHash !== undefined) {
          b.write(Primitive.String.write(this.phoneCodeHash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DropTempAuthKeys extends TLObject {
      __response__!: Bool;
      exceptAuthKeys!: Vector<long>;

      constructor(params: { exceptAuthKeys: Vector<long> }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.DropTempAuthKeys';
        this.constructorId = 0x8e48a188;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['exceptAuthKeys'];
        this.exceptAuthKeys = params.exceptAuthKeys;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.DropTempAuthKeys> {
        // no flags

        let exceptAuthKeys = await TLObject.read(b, Primitive.Long);
        return new Raw.auth.DropTempAuthKeys({ exceptAuthKeys: exceptAuthKeys });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.exceptAuthKeys) {
          b.write(Primitive.Vector.write(this.exceptAuthKeys, Primitive.Long) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportLoginToken extends TLObject {
      __response__!: Raw.auth.TypeLoginToken;
      apiId!: int;
      apiHash!: string;
      exceptIds!: Vector<long>;

      constructor(params: { apiId: int; apiHash: string; exceptIds: Vector<long> }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.ExportLoginToken';
        this.constructorId = 0xb7e085fe;
        this.subclassOfId = 0x6b55f636;
        this._slots = ['apiId', 'apiHash', 'exceptIds'];
        this.apiId = params.apiId;
        this.apiHash = params.apiHash;
        this.exceptIds = params.exceptIds;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.ExportLoginToken> {
        // no flags

        let apiId = await Primitive.Int.read(b);
        let apiHash = await Primitive.String.read(b);
        let exceptIds = await TLObject.read(b, Primitive.Long);
        return new Raw.auth.ExportLoginToken({
          apiId: apiId,
          apiHash: apiHash,
          exceptIds: exceptIds,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.apiId !== undefined) {
          b.write(Primitive.Int.write(this.apiId) as unknown as Buffer);
        }
        if (this.apiHash !== undefined) {
          b.write(Primitive.String.write(this.apiHash) as unknown as Buffer);
        }
        if (this.exceptIds) {
          b.write(Primitive.Vector.write(this.exceptIds, Primitive.Long) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ImportLoginToken extends TLObject {
      __response__!: Raw.auth.TypeLoginToken;
      token!: bytes;

      constructor(params: { token: bytes }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.ImportLoginToken';
        this.constructorId = 0x95ac5ce4;
        this.subclassOfId = 0x6b55f636;
        this._slots = ['token'];
        this.token = params.token;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.ImportLoginToken> {
        // no flags

        let token = await Primitive.Bytes.read(b);
        return new Raw.auth.ImportLoginToken({ token: token });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.token !== undefined) {
          b.write(Primitive.Bytes.write(this.token) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AcceptLoginToken extends TLObject {
      __response__!: Raw.TypeAuthorization;
      token!: bytes;

      constructor(params: { token: bytes }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.AcceptLoginToken';
        this.constructorId = 0xe894ad4d;
        this.subclassOfId = 0xc913c01a;
        this._slots = ['token'];
        this.token = params.token;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.AcceptLoginToken> {
        // no flags

        let token = await Primitive.Bytes.read(b);
        return new Raw.auth.AcceptLoginToken({ token: token });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.token !== undefined) {
          b.write(Primitive.Bytes.write(this.token) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CheckRecoveryPassword extends TLObject {
      __response__!: Bool;
      code!: string;

      constructor(params: { code: string }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.CheckRecoveryPassword';
        this.constructorId = 0xd36bf79;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['code'];
        this.code = params.code;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.CheckRecoveryPassword> {
        // no flags

        let code = await Primitive.String.read(b);
        return new Raw.auth.CheckRecoveryPassword({ code: code });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.code !== undefined) {
          b.write(Primitive.String.write(this.code) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ImportWebTokenAuthorization extends TLObject {
      __response__!: Raw.auth.TypeAuthorization;
      apiId!: int;
      apiHash!: string;
      webAuthToken!: string;

      constructor(params: { apiId: int; apiHash: string; webAuthToken: string }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.ImportWebTokenAuthorization';
        this.constructorId = 0x2db873a9;
        this.subclassOfId = 0xb9e04e39;
        this._slots = ['apiId', 'apiHash', 'webAuthToken'];
        this.apiId = params.apiId;
        this.apiHash = params.apiHash;
        this.webAuthToken = params.webAuthToken;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.auth.ImportWebTokenAuthorization> {
        // no flags

        let apiId = await Primitive.Int.read(b);
        let apiHash = await Primitive.String.read(b);
        let webAuthToken = await Primitive.String.read(b);
        return new Raw.auth.ImportWebTokenAuthorization({
          apiId: apiId,
          apiHash: apiHash,
          webAuthToken: webAuthToken,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.apiId !== undefined) {
          b.write(Primitive.Int.write(this.apiId) as unknown as Buffer);
        }
        if (this.apiHash !== undefined) {
          b.write(Primitive.String.write(this.apiHash) as unknown as Buffer);
        }
        if (this.webAuthToken !== undefined) {
          b.write(Primitive.String.write(this.webAuthToken) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RequestFirebaseSms extends TLObject {
      __response__!: Bool;
      phoneNumber!: string;
      phoneCodeHash!: string;
      safetyNetToken?: string;
      iosPushSecret?: string;

      constructor(params: {
        phoneNumber: string;
        phoneCodeHash: string;
        safetyNetToken?: string;
        iosPushSecret?: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.RequestFirebaseSms';
        this.constructorId = 0x89464b50;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['phoneNumber', 'phoneCodeHash', 'safetyNetToken', 'iosPushSecret'];
        this.phoneNumber = params.phoneNumber;
        this.phoneCodeHash = params.phoneCodeHash;
        this.safetyNetToken = params.safetyNetToken;
        this.iosPushSecret = params.iosPushSecret;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.RequestFirebaseSms> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let phoneNumber = await Primitive.String.read(b);
        let phoneCodeHash = await Primitive.String.read(b);
        let safetyNetToken = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let iosPushSecret = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        return new Raw.auth.RequestFirebaseSms({
          phoneNumber: phoneNumber,
          phoneCodeHash: phoneCodeHash,
          safetyNetToken: safetyNetToken,
          iosPushSecret: iosPushSecret,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.safetyNetToken !== undefined ? 1 << 0 : 0;
        flags |= this.iosPushSecret !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.phoneNumber !== undefined) {
          b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
        }
        if (this.phoneCodeHash !== undefined) {
          b.write(Primitive.String.write(this.phoneCodeHash) as unknown as Buffer);
        }
        if (this.safetyNetToken !== undefined) {
          b.write(Primitive.String.write(this.safetyNetToken) as unknown as Buffer);
        }
        if (this.iosPushSecret !== undefined) {
          b.write(Primitive.String.write(this.iosPushSecret) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResetLoginEmail extends TLObject {
      __response__!: Raw.auth.TypeSentCode;
      phoneNumber!: string;
      phoneCodeHash!: string;

      constructor(params: { phoneNumber: string; phoneCodeHash: string }) {
        super();
        this.classType = 'functions';
        this.className = 'auth.ResetLoginEmail';
        this.constructorId = 0x7e960193;
        this.subclassOfId = 0x6ce87081;
        this._slots = ['phoneNumber', 'phoneCodeHash'];
        this.phoneNumber = params.phoneNumber;
        this.phoneCodeHash = params.phoneCodeHash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.auth.ResetLoginEmail> {
        // no flags

        let phoneNumber = await Primitive.String.read(b);
        let phoneCodeHash = await Primitive.String.read(b);
        return new Raw.auth.ResetLoginEmail({
          phoneNumber: phoneNumber,
          phoneCodeHash: phoneCodeHash,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phoneNumber !== undefined) {
          b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
        }
        if (this.phoneCodeHash !== undefined) {
          b.write(Primitive.String.write(this.phoneCodeHash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace contacts {
    export type TypeTopPeers =
      | Raw.contacts.TopPeersNotModified
      | Raw.contacts.TopPeers
      | Raw.contacts.TopPeersDisabled;
    export type TypeResolvedPeer = Raw.contacts.ResolvedPeer;
    export type TypeFound = Raw.contacts.Found;
    export type TypeBlocked = Raw.contacts.Blocked | Raw.contacts.BlockedSlice;
    export type TypeImportedContacts = Raw.contacts.ImportedContacts;
    export type TypeContacts = Raw.contacts.ContactsNotModified | Raw.contacts.Contacts;
    export class ContactsNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'contacts.ContactsNotModified';
        this.constructorId = 0xb74ba9d2;
        this.subclassOfId = 0x38be25f6;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.contacts.ContactsNotModified> {
        // no flags

        return new Raw.contacts.ContactsNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class Contacts extends TLObject {
      contacts!: Vector<Raw.TypeContact>;
      savedCount!: int;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        contacts: Vector<Raw.TypeContact>;
        savedCount: int;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'contacts.Contacts';
        this.constructorId = 0xeae87e42;
        this.subclassOfId = 0x38be25f6;
        this._slots = ['contacts', 'savedCount', 'users'];
        this.contacts = params.contacts;
        this.savedCount = params.savedCount;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.Contacts> {
        // no flags

        let contacts = await TLObject.read(b);
        let savedCount = await Primitive.Int.read(b);
        let users = await TLObject.read(b);
        return new Raw.contacts.Contacts({
          contacts: contacts,
          savedCount: savedCount,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.contacts) {
          b.write(Primitive.Vector.write(this.contacts) as unknown as Buffer);
        }
        if (this.savedCount !== undefined) {
          b.write(Primitive.Int.write(this.savedCount) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ImportedContacts extends TLObject {
      imported!: Vector<Raw.TypeImportedContact>;
      popularInvites!: Vector<Raw.TypePopularContact>;
      retryContacts!: Vector<long>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        imported: Vector<Raw.TypeImportedContact>;
        popularInvites: Vector<Raw.TypePopularContact>;
        retryContacts: Vector<long>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'contacts.ImportedContacts';
        this.constructorId = 0x77d01c3b;
        this.subclassOfId = 0x8172ad93;
        this._slots = ['imported', 'popularInvites', 'retryContacts', 'users'];
        this.imported = params.imported;
        this.popularInvites = params.popularInvites;
        this.retryContacts = params.retryContacts;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.ImportedContacts> {
        // no flags

        let imported = await TLObject.read(b);
        let popularInvites = await TLObject.read(b);
        let retryContacts = await TLObject.read(b, Primitive.Long);
        let users = await TLObject.read(b);
        return new Raw.contacts.ImportedContacts({
          imported: imported,
          popularInvites: popularInvites,
          retryContacts: retryContacts,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.imported) {
          b.write(Primitive.Vector.write(this.imported) as unknown as Buffer);
        }
        if (this.popularInvites) {
          b.write(Primitive.Vector.write(this.popularInvites) as unknown as Buffer);
        }
        if (this.retryContacts) {
          b.write(Primitive.Vector.write(this.retryContacts, Primitive.Long) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Blocked extends TLObject {
      blocked!: Vector<Raw.TypePeerBlocked>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        blocked: Vector<Raw.TypePeerBlocked>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'contacts.Blocked';
        this.constructorId = 0xade1591;
        this.subclassOfId = 0xffba4f4f;
        this._slots = ['blocked', 'chats', 'users'];
        this.blocked = params.blocked;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.Blocked> {
        // no flags

        let blocked = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.contacts.Blocked({ blocked: blocked, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.blocked) {
          b.write(Primitive.Vector.write(this.blocked) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class BlockedSlice extends TLObject {
      count!: int;
      blocked!: Vector<Raw.TypePeerBlocked>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        count: int;
        blocked: Vector<Raw.TypePeerBlocked>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'contacts.BlockedSlice';
        this.constructorId = 0xe1664194;
        this.subclassOfId = 0xffba4f4f;
        this._slots = ['count', 'blocked', 'chats', 'users'];
        this.count = params.count;
        this.blocked = params.blocked;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.BlockedSlice> {
        // no flags

        let count = await Primitive.Int.read(b);
        let blocked = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.contacts.BlockedSlice({
          count: count,
          blocked: blocked,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.blocked) {
          b.write(Primitive.Vector.write(this.blocked) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Found extends TLObject {
      myResults!: Vector<Raw.TypePeer>;
      results!: Vector<Raw.TypePeer>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        myResults: Vector<Raw.TypePeer>;
        results: Vector<Raw.TypePeer>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'contacts.Found';
        this.constructorId = 0xb3134d9d;
        this.subclassOfId = 0x4386a2e3;
        this._slots = ['myResults', 'results', 'chats', 'users'];
        this.myResults = params.myResults;
        this.results = params.results;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.Found> {
        // no flags

        let myResults = await TLObject.read(b);
        let results = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.contacts.Found({
          myResults: myResults,
          results: results,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.myResults) {
          b.write(Primitive.Vector.write(this.myResults) as unknown as Buffer);
        }
        if (this.results) {
          b.write(Primitive.Vector.write(this.results) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResolvedPeer extends TLObject {
      peer!: Raw.TypePeer;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        peer: Raw.TypePeer;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'contacts.ResolvedPeer';
        this.constructorId = 0x7f077ad9;
        this.subclassOfId = 0xf065b3a8;
        this._slots = ['peer', 'chats', 'users'];
        this.peer = params.peer;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.ResolvedPeer> {
        // no flags

        let peer = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.contacts.ResolvedPeer({ peer: peer, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TopPeersNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'contacts.TopPeersNotModified';
        this.constructorId = 0xde266ef5;
        this.subclassOfId = 0x9ee8bb88;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.contacts.TopPeersNotModified> {
        // no flags

        return new Raw.contacts.TopPeersNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class TopPeers extends TLObject {
      categories!: Vector<Raw.TypeTopPeerCategoryPeers>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        categories: Vector<Raw.TypeTopPeerCategoryPeers>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'contacts.TopPeers';
        this.constructorId = 0x70b772a8;
        this.subclassOfId = 0x9ee8bb88;
        this._slots = ['categories', 'chats', 'users'];
        this.categories = params.categories;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.TopPeers> {
        // no flags

        let categories = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.contacts.TopPeers({ categories: categories, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.categories) {
          b.write(Primitive.Vector.write(this.categories) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TopPeersDisabled extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'contacts.TopPeersDisabled';
        this.constructorId = 0xb52c939d;
        this.subclassOfId = 0x9ee8bb88;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.TopPeersDisabled> {
        // no flags

        return new Raw.contacts.TopPeersDisabled();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetContactIDs extends TLObject {
      __response__!: Vector<int>;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.GetContactIDs';
        this.constructorId = 0x7adc669d;
        this.subclassOfId = 0x5026710f;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.GetContactIDs> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.contacts.GetContactIDs({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetStatuses extends TLObject {
      __response__!: Vector<Raw.TypeContactStatus>;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'contacts.GetStatuses';
        this.constructorId = 0xc4a353ee;
        this.subclassOfId = 0xdf815c90;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.GetStatuses> {
        // no flags

        return new Raw.contacts.GetStatuses();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetContacts extends TLObject {
      __response__!: Raw.contacts.TypeContacts;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.GetContacts';
        this.constructorId = 0x5dd69e12;
        this.subclassOfId = 0x38be25f6;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.GetContacts> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.contacts.GetContacts({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ImportContacts extends TLObject {
      __response__!: Raw.contacts.TypeImportedContacts;
      contacts!: Vector<Raw.TypeInputContact>;

      constructor(params: { contacts: Vector<Raw.TypeInputContact> }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.ImportContacts';
        this.constructorId = 0x2c800be5;
        this.subclassOfId = 0x8172ad93;
        this._slots = ['contacts'];
        this.contacts = params.contacts;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.ImportContacts> {
        // no flags

        let contacts = await TLObject.read(b);
        return new Raw.contacts.ImportContacts({ contacts: contacts });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.contacts) {
          b.write(Primitive.Vector.write(this.contacts) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteContacts extends TLObject {
      __response__!: Raw.TypeUpdates;
      id!: Vector<Raw.TypeInputUser>;

      constructor(params: { id: Vector<Raw.TypeInputUser> }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.DeleteContacts';
        this.constructorId = 0x96a0e00;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.DeleteContacts> {
        // no flags

        let id = await TLObject.read(b);
        return new Raw.contacts.DeleteContacts({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id) {
          b.write(Primitive.Vector.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteByPhones extends TLObject {
      __response__!: Bool;
      phones!: Vector<string>;

      constructor(params: { phones: Vector<string> }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.DeleteByPhones';
        this.constructorId = 0x1013fd9e;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['phones'];
        this.phones = params.phones;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.DeleteByPhones> {
        // no flags

        let phones = await TLObject.read(b, Primitive.String);
        return new Raw.contacts.DeleteByPhones({ phones: phones });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phones) {
          b.write(Primitive.Vector.write(this.phones, Primitive.String) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Block extends TLObject {
      __response__!: Bool;
      myStoriesFrom?: boolean;
      id!: Raw.TypeInputPeer;

      constructor(params: { myStoriesFrom?: boolean; id: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.Block';
        this.constructorId = 0x2e2e8734;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['myStoriesFrom', 'id'];
        this.myStoriesFrom = params.myStoriesFrom;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.Block> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let myStoriesFrom = flags & (1 << 0) ? true : false;
        let id = await TLObject.read(b);
        return new Raw.contacts.Block({ myStoriesFrom: myStoriesFrom, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.myStoriesFrom ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Unblock extends TLObject {
      __response__!: Bool;
      myStoriesFrom?: boolean;
      id!: Raw.TypeInputPeer;

      constructor(params: { myStoriesFrom?: boolean; id: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.Unblock';
        this.constructorId = 0xb550d328;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['myStoriesFrom', 'id'];
        this.myStoriesFrom = params.myStoriesFrom;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.Unblock> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let myStoriesFrom = flags & (1 << 0) ? true : false;
        let id = await TLObject.read(b);
        return new Raw.contacts.Unblock({ myStoriesFrom: myStoriesFrom, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.myStoriesFrom ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetBlocked extends TLObject {
      __response__!: Raw.contacts.TypeBlocked;
      myStoriesFrom?: boolean;
      offset!: int;
      limit!: int;

      constructor(params: { myStoriesFrom?: boolean; offset: int; limit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.GetBlocked';
        this.constructorId = 0x9a868f80;
        this.subclassOfId = 0xffba4f4f;
        this._slots = ['myStoriesFrom', 'offset', 'limit'];
        this.myStoriesFrom = params.myStoriesFrom;
        this.offset = params.offset;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.GetBlocked> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let myStoriesFrom = flags & (1 << 0) ? true : false;
        let offset = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.contacts.GetBlocked({
          myStoriesFrom: myStoriesFrom,
          offset: offset,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.myStoriesFrom ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.offset !== undefined) {
          b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Search extends TLObject {
      __response__!: Raw.contacts.TypeFound;
      q!: string;
      limit!: int;

      constructor(params: { q: string; limit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.Search';
        this.constructorId = 0x11f812d8;
        this.subclassOfId = 0x4386a2e3;
        this._slots = ['q', 'limit'];
        this.q = params.q;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.Search> {
        // no flags

        let q = await Primitive.String.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.contacts.Search({ q: q, limit: limit });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.q !== undefined) {
          b.write(Primitive.String.write(this.q) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResolveUsername extends TLObject {
      __response__!: Raw.contacts.TypeResolvedPeer;
      username!: string;

      constructor(params: { username: string }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.ResolveUsername';
        this.constructorId = 0xf93ccba3;
        this.subclassOfId = 0xf065b3a8;
        this._slots = ['username'];
        this.username = params.username;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.ResolveUsername> {
        // no flags

        let username = await Primitive.String.read(b);
        return new Raw.contacts.ResolveUsername({ username: username });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.username !== undefined) {
          b.write(Primitive.String.write(this.username) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetTopPeers extends TLObject {
      __response__!: Raw.contacts.TypeTopPeers;
      correspondents?: boolean;
      botsPm?: boolean;
      botsInline?: boolean;
      phoneCalls?: boolean;
      forwardUsers?: boolean;
      forwardChats?: boolean;
      groups?: boolean;
      channels?: boolean;
      offset!: int;
      limit!: int;
      hash!: long;

      constructor(params: {
        correspondents?: boolean;
        botsPm?: boolean;
        botsInline?: boolean;
        phoneCalls?: boolean;
        forwardUsers?: boolean;
        forwardChats?: boolean;
        groups?: boolean;
        channels?: boolean;
        offset: int;
        limit: int;
        hash: long;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.GetTopPeers';
        this.constructorId = 0x973478b6;
        this.subclassOfId = 0x9ee8bb88;
        this._slots = [
          'correspondents',
          'botsPm',
          'botsInline',
          'phoneCalls',
          'forwardUsers',
          'forwardChats',
          'groups',
          'channels',
          'offset',
          'limit',
          'hash',
        ];
        this.correspondents = params.correspondents;
        this.botsPm = params.botsPm;
        this.botsInline = params.botsInline;
        this.phoneCalls = params.phoneCalls;
        this.forwardUsers = params.forwardUsers;
        this.forwardChats = params.forwardChats;
        this.groups = params.groups;
        this.channels = params.channels;
        this.offset = params.offset;
        this.limit = params.limit;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.GetTopPeers> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let correspondents = flags & (1 << 0) ? true : false;
        let botsPm = flags & (1 << 1) ? true : false;
        let botsInline = flags & (1 << 2) ? true : false;
        let phoneCalls = flags & (1 << 3) ? true : false;
        let forwardUsers = flags & (1 << 4) ? true : false;
        let forwardChats = flags & (1 << 5) ? true : false;
        let groups = flags & (1 << 10) ? true : false;
        let channels = flags & (1 << 15) ? true : false;
        let offset = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.contacts.GetTopPeers({
          correspondents: correspondents,
          botsPm: botsPm,
          botsInline: botsInline,
          phoneCalls: phoneCalls,
          forwardUsers: forwardUsers,
          forwardChats: forwardChats,
          groups: groups,
          channels: channels,
          offset: offset,
          limit: limit,
          hash: hash,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.correspondents ? 1 << 0 : 0;
        flags |= this.botsPm ? 1 << 1 : 0;
        flags |= this.botsInline ? 1 << 2 : 0;
        flags |= this.phoneCalls ? 1 << 3 : 0;
        flags |= this.forwardUsers ? 1 << 4 : 0;
        flags |= this.forwardChats ? 1 << 5 : 0;
        flags |= this.groups ? 1 << 10 : 0;
        flags |= this.channels ? 1 << 15 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.offset !== undefined) {
          b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResetTopPeerRating extends TLObject {
      __response__!: Bool;
      category!: Raw.TypeTopPeerCategory;
      peer!: Raw.TypeInputPeer;

      constructor(params: { category: Raw.TypeTopPeerCategory; peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.ResetTopPeerRating';
        this.constructorId = 0x1ae373ac;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['category', 'peer'];
        this.category = params.category;
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.ResetTopPeerRating> {
        // no flags

        let category = await TLObject.read(b);
        let peer = await TLObject.read(b);
        return new Raw.contacts.ResetTopPeerRating({ category: category, peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.category !== undefined) {
          b.write(this.category.write() as unknown as Buffer);
        }
        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResetSaved extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'contacts.ResetSaved';
        this.constructorId = 0x879537f1;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.ResetSaved> {
        // no flags

        return new Raw.contacts.ResetSaved();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetSaved extends TLObject {
      __response__!: Vector<Raw.TypeSavedContact>;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'contacts.GetSaved';
        this.constructorId = 0x82f1e39f;
        this.subclassOfId = 0x975dbef;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.GetSaved> {
        // no flags

        return new Raw.contacts.GetSaved();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class ToggleTopPeers extends TLObject {
      __response__!: Bool;
      enabled!: Bool;

      constructor(params: { enabled: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.ToggleTopPeers';
        this.constructorId = 0x8514bdda;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['enabled'];
        this.enabled = params.enabled;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.ToggleTopPeers> {
        // no flags

        let enabled = await Primitive.Bool.read(b);
        return new Raw.contacts.ToggleTopPeers({ enabled: enabled });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.enabled !== undefined) {
          b.write(Primitive.Bool.write(this.enabled) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AddContact extends TLObject {
      __response__!: Raw.TypeUpdates;
      addPhonePrivacyException?: boolean;
      id!: Raw.TypeInputUser;
      firstName!: string;
      lastName!: string;
      phone!: string;

      constructor(params: {
        addPhonePrivacyException?: boolean;
        id: Raw.TypeInputUser;
        firstName: string;
        lastName: string;
        phone: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.AddContact';
        this.constructorId = 0xe8f463d0;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['addPhonePrivacyException', 'id', 'firstName', 'lastName', 'phone'];
        this.addPhonePrivacyException = params.addPhonePrivacyException;
        this.id = params.id;
        this.firstName = params.firstName;
        this.lastName = params.lastName;
        this.phone = params.phone;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.AddContact> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let addPhonePrivacyException = flags & (1 << 0) ? true : false;
        let id = await TLObject.read(b);
        let firstName = await Primitive.String.read(b);
        let lastName = await Primitive.String.read(b);
        let phone = await Primitive.String.read(b);
        return new Raw.contacts.AddContact({
          addPhonePrivacyException: addPhonePrivacyException,
          id: id,
          firstName: firstName,
          lastName: lastName,
          phone: phone,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.addPhonePrivacyException ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        if (this.firstName !== undefined) {
          b.write(Primitive.String.write(this.firstName) as unknown as Buffer);
        }
        if (this.lastName !== undefined) {
          b.write(Primitive.String.write(this.lastName) as unknown as Buffer);
        }
        if (this.phone !== undefined) {
          b.write(Primitive.String.write(this.phone) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AcceptContact extends TLObject {
      __response__!: Raw.TypeUpdates;
      id!: Raw.TypeInputUser;

      constructor(params: { id: Raw.TypeInputUser }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.AcceptContact';
        this.constructorId = 0xf831a20f;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.AcceptContact> {
        // no flags

        let id = await TLObject.read(b);
        return new Raw.contacts.AcceptContact({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetLocated extends TLObject {
      __response__!: Raw.TypeUpdates;
      background?: boolean;
      geoPoint!: Raw.TypeInputGeoPoint;
      selfExpires?: int;

      constructor(params: {
        background?: boolean;
        geoPoint: Raw.TypeInputGeoPoint;
        selfExpires?: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.GetLocated';
        this.constructorId = 0xd348bc44;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['background', 'geoPoint', 'selfExpires'];
        this.background = params.background;
        this.geoPoint = params.geoPoint;
        this.selfExpires = params.selfExpires;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.GetLocated> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let background = flags & (1 << 1) ? true : false;
        let geoPoint = await TLObject.read(b);
        let selfExpires = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        return new Raw.contacts.GetLocated({
          background: background,
          geoPoint: geoPoint,
          selfExpires: selfExpires,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.background ? 1 << 1 : 0;
        flags |= this.selfExpires !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.geoPoint !== undefined) {
          b.write(this.geoPoint.write() as unknown as Buffer);
        }
        if (this.selfExpires !== undefined) {
          b.write(Primitive.Int.write(this.selfExpires) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class BlockFromReplies extends TLObject {
      __response__!: Raw.TypeUpdates;
      deleteMessage?: boolean;
      deleteHistory?: boolean;
      reportSpam?: boolean;
      msgId!: int;

      constructor(params: {
        deleteMessage?: boolean;
        deleteHistory?: boolean;
        reportSpam?: boolean;
        msgId: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.BlockFromReplies';
        this.constructorId = 0x29a8962c;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['deleteMessage', 'deleteHistory', 'reportSpam', 'msgId'];
        this.deleteMessage = params.deleteMessage;
        this.deleteHistory = params.deleteHistory;
        this.reportSpam = params.reportSpam;
        this.msgId = params.msgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.BlockFromReplies> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let deleteMessage = flags & (1 << 0) ? true : false;
        let deleteHistory = flags & (1 << 1) ? true : false;
        let reportSpam = flags & (1 << 2) ? true : false;
        let msgId = await Primitive.Int.read(b);
        return new Raw.contacts.BlockFromReplies({
          deleteMessage: deleteMessage,
          deleteHistory: deleteHistory,
          reportSpam: reportSpam,
          msgId: msgId,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.deleteMessage ? 1 << 0 : 0;
        flags |= this.deleteHistory ? 1 << 1 : 0;
        flags |= this.reportSpam ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResolvePhone extends TLObject {
      __response__!: Raw.contacts.TypeResolvedPeer;
      phone!: string;

      constructor(params: { phone: string }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.ResolvePhone';
        this.constructorId = 0x8af94344;
        this.subclassOfId = 0xf065b3a8;
        this._slots = ['phone'];
        this.phone = params.phone;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.ResolvePhone> {
        // no flags

        let phone = await Primitive.String.read(b);
        return new Raw.contacts.ResolvePhone({ phone: phone });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phone !== undefined) {
          b.write(Primitive.String.write(this.phone) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportContactToken extends TLObject {
      __response__!: Raw.TypeExportedContactToken;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'contacts.ExportContactToken';
        this.constructorId = 0xf8654027;
        this.subclassOfId = 0x86ddbed1;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.ExportContactToken> {
        // no flags

        return new Raw.contacts.ExportContactToken();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class ImportContactToken extends TLObject {
      __response__!: Raw.TypeUser;
      token!: string;

      constructor(params: { token: string }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.ImportContactToken';
        this.constructorId = 0x13005788;
        this.subclassOfId = 0x2da17977;
        this._slots = ['token'];
        this.token = params.token;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.ImportContactToken> {
        // no flags

        let token = await Primitive.String.read(b);
        return new Raw.contacts.ImportContactToken({ token: token });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.token !== undefined) {
          b.write(Primitive.String.write(this.token) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditCloseFriends extends TLObject {
      __response__!: Bool;
      id!: Vector<long>;

      constructor(params: { id: Vector<long> }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.EditCloseFriends';
        this.constructorId = 0xba6705f0;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.EditCloseFriends> {
        // no flags

        let id = await TLObject.read(b, Primitive.Long);
        return new Raw.contacts.EditCloseFriends({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Long) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetBlocked extends TLObject {
      __response__!: Bool;
      myStoriesFrom?: boolean;
      id!: Vector<Raw.TypeInputPeer>;
      limit!: int;

      constructor(params: { myStoriesFrom?: boolean; id: Vector<Raw.TypeInputPeer>; limit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'contacts.SetBlocked';
        this.constructorId = 0x94c65c76;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['myStoriesFrom', 'id', 'limit'];
        this.myStoriesFrom = params.myStoriesFrom;
        this.id = params.id;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.contacts.SetBlocked> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let myStoriesFrom = flags & (1 << 0) ? true : false;
        let id = await TLObject.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.contacts.SetBlocked({ myStoriesFrom: myStoriesFrom, id: id, limit: limit });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.myStoriesFrom ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.id) {
          b.write(Primitive.Vector.write(this.id) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace messages {
    export type TypeForumTopics = Raw.messages.ForumTopics;
    export type TypeSponsoredMessages =
      | Raw.messages.SponsoredMessages
      | Raw.messages.SponsoredMessagesEmpty;
    export type TypeInactiveChats = Raw.messages.InactiveChats;
    export type TypeBotApp = Raw.messages.BotApp;
    export type TypeEmojiGroups = Raw.messages.EmojiGroupsNotModified | Raw.messages.EmojiGroups;
    export type TypeReactions = Raw.messages.ReactionsNotModified | Raw.messages.Reactions;
    export type TypeTranscribedAudio = Raw.messages.TranscribedAudio;
    export type TypeTranslatedText = Raw.messages.TranslateResult;
    export type TypeAvailableReactions =
      | Raw.messages.AvailableReactionsNotModified
      | Raw.messages.AvailableReactions;
    export type TypeMessageReactionsList = Raw.messages.MessageReactionsList;
    export type TypeSearchResultsPositions = Raw.messages.SearchResultsPositions;
    export type TypeSearchResultsCalendar = Raw.messages.SearchResultsCalendar;
    export type TypeCheckedHistoryImportPeer = Raw.messages.CheckedHistoryImportPeer;
    export type TypeChatInviteImporters = Raw.messages.ChatInviteImporters;
    export type TypeChatAdminsWithInvites = Raw.messages.ChatAdminsWithInvites;
    export type TypeExportedChatInvite =
      | Raw.messages.ExportedChatInvite
      | Raw.messages.ExportedChatInviteReplaced;
    export type TypeExportedChatInvites = Raw.messages.ExportedChatInvites;
    export type TypeHistoryImport = Raw.messages.HistoryImport;
    export type TypeHistoryImportParsed = Raw.messages.HistoryImportParsed;
    export type TypeAffectedFoundMessages = Raw.messages.AffectedFoundMessages;
    export type TypeDiscussionMessage = Raw.messages.DiscussionMessage;
    export type TypeVotesList = Raw.messages.VotesList;
    export type TypeSearchCounter = Raw.messages.SearchCounter;
    export type TypeFoundStickerSets =
      | Raw.messages.FoundStickerSetsNotModified
      | Raw.messages.FoundStickerSets;
    export type TypeFavedStickers =
      | Raw.messages.FavedStickersNotModified
      | Raw.messages.FavedStickers;
    export type TypeWebPage = Raw.messages.WebPage;
    export type TypeHighScores = Raw.messages.HighScores;
    export type TypeArchivedStickers = Raw.messages.ArchivedStickers;
    export type TypeRecentStickers =
      | Raw.messages.RecentStickersNotModified
      | Raw.messages.RecentStickers;
    export type TypeFeaturedStickers =
      | Raw.messages.FeaturedStickersNotModified
      | Raw.messages.FeaturedStickers;
    export type TypePeerDialogs = Raw.messages.PeerDialogs;
    export type TypeBotCallbackAnswer = Raw.messages.BotCallbackAnswer;
    export type TypeMessageEditData = Raw.messages.MessageEditData;
    export type TypeBotResults = Raw.messages.BotResults;
    export type TypeSavedGifs = Raw.messages.SavedGifsNotModified | Raw.messages.SavedGifs;
    export type TypeMessageViews = Raw.messages.MessageViews;
    export type TypeStickerSetInstallResult =
      | Raw.messages.StickerSetInstallResultSuccess
      | Raw.messages.StickerSetInstallResultArchive;
    export type TypeAllStickers = Raw.messages.AllStickersNotModified | Raw.messages.AllStickers;
    export type TypeStickers = Raw.messages.StickersNotModified | Raw.messages.Stickers;
    export type TypeSentEncryptedMessage =
      | Raw.messages.SentEncryptedMessage
      | Raw.messages.SentEncryptedFile;
    export type TypeDhConfig = Raw.messages.DhConfigNotModified | Raw.messages.DhConfig;
    export type TypeChatFull = Raw.messages.ChatFull;
    export type TypeChats = Raw.messages.Chats | Raw.messages.ChatsSlice;
    export type TypePeerSettings = Raw.messages.PeerSettings;
    export type TypeAffectedHistory = Raw.messages.AffectedHistory;
    export type TypeAffectedMessages = Raw.messages.AffectedMessages;
    export type TypeDialogs =
      | Raw.messages.Dialogs
      | Raw.messages.DialogsSlice
      | Raw.messages.DialogsNotModified;
    export type TypeMessages =
      | Raw.messages.Messages
      | Raw.messages.MessagesSlice
      | Raw.messages.ChannelMessages
      | Raw.messages.MessagesNotModified;
    export type TypeStickerSet = Raw.messages.StickerSet | Raw.messages.StickerSetNotModified;
    export class Dialogs extends TLObject {
      dialogs!: Vector<Raw.TypeDialog>;
      messages!: Vector<Raw.TypeMessage>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        dialogs: Vector<Raw.TypeDialog>;
        messages: Vector<Raw.TypeMessage>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.Dialogs';
        this.constructorId = 0x15ba6c40;
        this.subclassOfId = 0xe1b52ee;
        this._slots = ['dialogs', 'messages', 'chats', 'users'];
        this.dialogs = params.dialogs;
        this.messages = params.messages;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.Dialogs> {
        // no flags

        let dialogs = await TLObject.read(b);
        let messages = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.Dialogs({
          dialogs: dialogs,
          messages: messages,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.dialogs) {
          b.write(Primitive.Vector.write(this.dialogs) as unknown as Buffer);
        }
        if (this.messages) {
          b.write(Primitive.Vector.write(this.messages) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DialogsSlice extends TLObject {
      count!: int;
      dialogs!: Vector<Raw.TypeDialog>;
      messages!: Vector<Raw.TypeMessage>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        count: int;
        dialogs: Vector<Raw.TypeDialog>;
        messages: Vector<Raw.TypeMessage>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.DialogsSlice';
        this.constructorId = 0x71e094f3;
        this.subclassOfId = 0xe1b52ee;
        this._slots = ['count', 'dialogs', 'messages', 'chats', 'users'];
        this.count = params.count;
        this.dialogs = params.dialogs;
        this.messages = params.messages;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.DialogsSlice> {
        // no flags

        let count = await Primitive.Int.read(b);
        let dialogs = await TLObject.read(b);
        let messages = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.DialogsSlice({
          count: count,
          dialogs: dialogs,
          messages: messages,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.dialogs) {
          b.write(Primitive.Vector.write(this.dialogs) as unknown as Buffer);
        }
        if (this.messages) {
          b.write(Primitive.Vector.write(this.messages) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DialogsNotModified extends TLObject {
      count!: int;

      constructor(params: { count: int }) {
        super();
        this.classType = 'types';
        this.className = 'messages.DialogsNotModified';
        this.constructorId = 0xf0e3e596;
        this.subclassOfId = 0xe1b52ee;
        this._slots = ['count'];
        this.count = params.count;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.DialogsNotModified> {
        // no flags

        let count = await Primitive.Int.read(b);
        return new Raw.messages.DialogsNotModified({ count: count });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Messages extends TLObject {
      messages!: Vector<Raw.TypeMessage>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        messages: Vector<Raw.TypeMessage>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.Messages';
        this.constructorId = 0x8c718e87;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = ['messages', 'chats', 'users'];
        this.messages = params.messages;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.Messages> {
        // no flags

        let messages = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.Messages({ messages: messages, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.messages) {
          b.write(Primitive.Vector.write(this.messages) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class MessagesSlice extends TLObject {
      inexact?: boolean;
      count!: int;
      nextRate?: int;
      offsetIdOffset?: int;
      messages!: Vector<Raw.TypeMessage>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        inexact?: boolean;
        count: int;
        nextRate?: int;
        offsetIdOffset?: int;
        messages: Vector<Raw.TypeMessage>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.MessagesSlice';
        this.constructorId = 0x3a54685e;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = [
          'inexact',
          'count',
          'nextRate',
          'offsetIdOffset',
          'messages',
          'chats',
          'users',
        ];
        this.inexact = params.inexact;
        this.count = params.count;
        this.nextRate = params.nextRate;
        this.offsetIdOffset = params.offsetIdOffset;
        this.messages = params.messages;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.MessagesSlice> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let inexact = flags & (1 << 1) ? true : false;
        let count = await Primitive.Int.read(b);
        let nextRate = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let offsetIdOffset = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
        let messages = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.MessagesSlice({
          inexact: inexact,
          count: count,
          nextRate: nextRate,
          offsetIdOffset: offsetIdOffset,
          messages: messages,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.inexact ? 1 << 1 : 0;
        flags |= this.nextRate !== undefined ? 1 << 0 : 0;
        flags |= this.offsetIdOffset !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.nextRate !== undefined) {
          b.write(Primitive.Int.write(this.nextRate) as unknown as Buffer);
        }
        if (this.offsetIdOffset !== undefined) {
          b.write(Primitive.Int.write(this.offsetIdOffset) as unknown as Buffer);
        }
        if (this.messages) {
          b.write(Primitive.Vector.write(this.messages) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChannelMessages extends TLObject {
      inexact?: boolean;
      pts!: int;
      count!: int;
      offsetIdOffset?: int;
      messages!: Vector<Raw.TypeMessage>;
      topics!: Vector<Raw.TypeForumTopic>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        inexact?: boolean;
        pts: int;
        count: int;
        offsetIdOffset?: int;
        messages: Vector<Raw.TypeMessage>;
        topics: Vector<Raw.TypeForumTopic>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.ChannelMessages';
        this.constructorId = 0xc776ba4e;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = [
          'inexact',
          'pts',
          'count',
          'offsetIdOffset',
          'messages',
          'topics',
          'chats',
          'users',
        ];
        this.inexact = params.inexact;
        this.pts = params.pts;
        this.count = params.count;
        this.offsetIdOffset = params.offsetIdOffset;
        this.messages = params.messages;
        this.topics = params.topics;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ChannelMessages> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let inexact = flags & (1 << 1) ? true : false;
        let pts = await Primitive.Int.read(b);
        let count = await Primitive.Int.read(b);
        let offsetIdOffset = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
        let messages = await TLObject.read(b);
        let topics = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.ChannelMessages({
          inexact: inexact,
          pts: pts,
          count: count,
          offsetIdOffset: offsetIdOffset,
          messages: messages,
          topics: topics,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.inexact ? 1 << 1 : 0;
        flags |= this.offsetIdOffset !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.pts !== undefined) {
          b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
        }
        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.offsetIdOffset !== undefined) {
          b.write(Primitive.Int.write(this.offsetIdOffset) as unknown as Buffer);
        }
        if (this.messages) {
          b.write(Primitive.Vector.write(this.messages) as unknown as Buffer);
        }
        if (this.topics) {
          b.write(Primitive.Vector.write(this.topics) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class MessagesNotModified extends TLObject {
      count!: int;

      constructor(params: { count: int }) {
        super();
        this.classType = 'types';
        this.className = 'messages.MessagesNotModified';
        this.constructorId = 0x74535f21;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = ['count'];
        this.count = params.count;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.MessagesNotModified> {
        // no flags

        let count = await Primitive.Int.read(b);
        return new Raw.messages.MessagesNotModified({ count: count });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Chats extends TLObject {
      chats!: Vector<Raw.TypeChat>;

      constructor(params: { chats: Vector<Raw.TypeChat> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.Chats';
        this.constructorId = 0x64ff9fd5;
        this.subclassOfId = 0x99d5cb14;
        this._slots = ['chats'];
        this.chats = params.chats;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.Chats> {
        // no flags

        let chats = await TLObject.read(b);
        return new Raw.messages.Chats({ chats: chats });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChatsSlice extends TLObject {
      count!: int;
      chats!: Vector<Raw.TypeChat>;

      constructor(params: { count: int; chats: Vector<Raw.TypeChat> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.ChatsSlice';
        this.constructorId = 0x9cd81144;
        this.subclassOfId = 0x99d5cb14;
        this._slots = ['count', 'chats'];
        this.count = params.count;
        this.chats = params.chats;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ChatsSlice> {
        // no flags

        let count = await Primitive.Int.read(b);
        let chats = await TLObject.read(b);
        return new Raw.messages.ChatsSlice({ count: count, chats: chats });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChatFull extends TLObject {
      fullChat!: Raw.TypeChatFull;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        fullChat: Raw.TypeChatFull;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.ChatFull';
        this.constructorId = 0xe5d7d19c;
        this.subclassOfId = 0x225a5109;
        this._slots = ['fullChat', 'chats', 'users'];
        this.fullChat = params.fullChat;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ChatFull> {
        // no flags

        let fullChat = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.ChatFull({ fullChat: fullChat, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.fullChat !== undefined) {
          b.write(this.fullChat.write() as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AffectedHistory extends TLObject {
      pts!: int;
      ptsCount!: int;
      offset!: int;

      constructor(params: { pts: int; ptsCount: int; offset: int }) {
        super();
        this.classType = 'types';
        this.className = 'messages.AffectedHistory';
        this.constructorId = 0xb45c69d1;
        this.subclassOfId = 0x2c49c116;
        this._slots = ['pts', 'ptsCount', 'offset'];
        this.pts = params.pts;
        this.ptsCount = params.ptsCount;
        this.offset = params.offset;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.AffectedHistory> {
        // no flags

        let pts = await Primitive.Int.read(b);
        let ptsCount = await Primitive.Int.read(b);
        let offset = await Primitive.Int.read(b);
        return new Raw.messages.AffectedHistory({ pts: pts, ptsCount: ptsCount, offset: offset });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.pts !== undefined) {
          b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
        }
        if (this.ptsCount !== undefined) {
          b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DhConfigNotModified extends TLObject {
      random!: bytes;

      constructor(params: { random: bytes }) {
        super();
        this.classType = 'types';
        this.className = 'messages.DhConfigNotModified';
        this.constructorId = 0xc0e24635;
        this.subclassOfId = 0xe488ed8b;
        this._slots = ['random'];
        this.random = params.random;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.DhConfigNotModified> {
        // no flags

        let random = await Primitive.Bytes.read(b);
        return new Raw.messages.DhConfigNotModified({ random: random });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.random !== undefined) {
          b.write(Primitive.Bytes.write(this.random) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DhConfig extends TLObject {
      g!: int;
      p!: bytes;
      version!: int;
      random!: bytes;

      constructor(params: { g: int; p: bytes; version: int; random: bytes }) {
        super();
        this.classType = 'types';
        this.className = 'messages.DhConfig';
        this.constructorId = 0x2c221edd;
        this.subclassOfId = 0xe488ed8b;
        this._slots = ['g', 'p', 'version', 'random'];
        this.g = params.g;
        this.p = params.p;
        this.version = params.version;
        this.random = params.random;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.DhConfig> {
        // no flags

        let g = await Primitive.Int.read(b);
        let p = await Primitive.Bytes.read(b);
        let version = await Primitive.Int.read(b);
        let random = await Primitive.Bytes.read(b);
        return new Raw.messages.DhConfig({ g: g, p: p, version: version, random: random });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.g !== undefined) {
          b.write(Primitive.Int.write(this.g) as unknown as Buffer);
        }
        if (this.p !== undefined) {
          b.write(Primitive.Bytes.write(this.p) as unknown as Buffer);
        }
        if (this.version !== undefined) {
          b.write(Primitive.Int.write(this.version) as unknown as Buffer);
        }
        if (this.random !== undefined) {
          b.write(Primitive.Bytes.write(this.random) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SentEncryptedMessage extends TLObject {
      date!: int;

      constructor(params: { date: int }) {
        super();
        this.classType = 'types';
        this.className = 'messages.SentEncryptedMessage';
        this.constructorId = 0x560f8935;
        this.subclassOfId = 0xc99e3e50;
        this._slots = ['date'];
        this.date = params.date;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SentEncryptedMessage> {
        // no flags

        let date = await Primitive.Int.read(b);
        return new Raw.messages.SentEncryptedMessage({ date: date });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.date !== undefined) {
          b.write(Primitive.Int.write(this.date) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SentEncryptedFile extends TLObject {
      date!: int;
      file!: Raw.TypeEncryptedFile;

      constructor(params: { date: int; file: Raw.TypeEncryptedFile }) {
        super();
        this.classType = 'types';
        this.className = 'messages.SentEncryptedFile';
        this.constructorId = 0x9493ff32;
        this.subclassOfId = 0xc99e3e50;
        this._slots = ['date', 'file'];
        this.date = params.date;
        this.file = params.file;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SentEncryptedFile> {
        // no flags

        let date = await Primitive.Int.read(b);
        let file = await TLObject.read(b);
        return new Raw.messages.SentEncryptedFile({ date: date, file: file });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.date !== undefined) {
          b.write(Primitive.Int.write(this.date) as unknown as Buffer);
        }
        if (this.file !== undefined) {
          b.write(this.file.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class StickersNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'messages.StickersNotModified';
        this.constructorId = 0xf1749a22;
        this.subclassOfId = 0xd73bb9de;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.StickersNotModified> {
        // no flags

        return new Raw.messages.StickersNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class Stickers extends TLObject {
      hash!: long;
      stickers!: Vector<Raw.TypeDocument>;

      constructor(params: { hash: long; stickers: Vector<Raw.TypeDocument> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.Stickers';
        this.constructorId = 0x30a6ec7e;
        this.subclassOfId = 0xd73bb9de;
        this._slots = ['hash', 'stickers'];
        this.hash = params.hash;
        this.stickers = params.stickers;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.Stickers> {
        // no flags

        let hash = await Primitive.Long.read(b);
        let stickers = await TLObject.read(b);
        return new Raw.messages.Stickers({ hash: hash, stickers: stickers });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.stickers) {
          b.write(Primitive.Vector.write(this.stickers) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AllStickersNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'messages.AllStickersNotModified';
        this.constructorId = 0xe86602c3;
        this.subclassOfId = 0x45834829;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.AllStickersNotModified> {
        // no flags

        return new Raw.messages.AllStickersNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class AllStickers extends TLObject {
      hash!: long;
      sets!: Vector<Raw.TypeStickerSet>;

      constructor(params: { hash: long; sets: Vector<Raw.TypeStickerSet> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.AllStickers';
        this.constructorId = 0xcdbbcebb;
        this.subclassOfId = 0x45834829;
        this._slots = ['hash', 'sets'];
        this.hash = params.hash;
        this.sets = params.sets;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.AllStickers> {
        // no flags

        let hash = await Primitive.Long.read(b);
        let sets = await TLObject.read(b);
        return new Raw.messages.AllStickers({ hash: hash, sets: sets });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.sets) {
          b.write(Primitive.Vector.write(this.sets) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AffectedMessages extends TLObject {
      pts!: int;
      ptsCount!: int;

      constructor(params: { pts: int; ptsCount: int }) {
        super();
        this.classType = 'types';
        this.className = 'messages.AffectedMessages';
        this.constructorId = 0x84d19185;
        this.subclassOfId = 0xced3c06e;
        this._slots = ['pts', 'ptsCount'];
        this.pts = params.pts;
        this.ptsCount = params.ptsCount;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.AffectedMessages> {
        // no flags

        let pts = await Primitive.Int.read(b);
        let ptsCount = await Primitive.Int.read(b);
        return new Raw.messages.AffectedMessages({ pts: pts, ptsCount: ptsCount });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.pts !== undefined) {
          b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
        }
        if (this.ptsCount !== undefined) {
          b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class StickerSet extends TLObject {
      set!: Raw.TypeStickerSet;
      packs!: Vector<Raw.TypeStickerPack>;
      keywords!: Vector<Raw.TypeStickerKeyword>;
      documents!: Vector<Raw.TypeDocument>;

      constructor(params: {
        set: Raw.TypeStickerSet;
        packs: Vector<Raw.TypeStickerPack>;
        keywords: Vector<Raw.TypeStickerKeyword>;
        documents: Vector<Raw.TypeDocument>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.StickerSet';
        this.constructorId = 0x6e153f16;
        this.subclassOfId = 0x9b704a5a;
        this._slots = ['set', 'packs', 'keywords', 'documents'];
        this.set = params.set;
        this.packs = params.packs;
        this.keywords = params.keywords;
        this.documents = params.documents;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.StickerSet> {
        // no flags

        let set = await TLObject.read(b);
        let packs = await TLObject.read(b);
        let keywords = await TLObject.read(b);
        let documents = await TLObject.read(b);
        return new Raw.messages.StickerSet({
          set: set,
          packs: packs,
          keywords: keywords,
          documents: documents,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.set !== undefined) {
          b.write(this.set.write() as unknown as Buffer);
        }
        if (this.packs) {
          b.write(Primitive.Vector.write(this.packs) as unknown as Buffer);
        }
        if (this.keywords) {
          b.write(Primitive.Vector.write(this.keywords) as unknown as Buffer);
        }
        if (this.documents) {
          b.write(Primitive.Vector.write(this.documents) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class StickerSetNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'messages.StickerSetNotModified';
        this.constructorId = 0xd3f924eb;
        this.subclassOfId = 0x9b704a5a;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.StickerSetNotModified> {
        // no flags

        return new Raw.messages.StickerSetNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SavedGifsNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'messages.SavedGifsNotModified';
        this.constructorId = 0xe8025ca2;
        this.subclassOfId = 0xa68b61f5;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SavedGifsNotModified> {
        // no flags

        return new Raw.messages.SavedGifsNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SavedGifs extends TLObject {
      hash!: long;
      gifs!: Vector<Raw.TypeDocument>;

      constructor(params: { hash: long; gifs: Vector<Raw.TypeDocument> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.SavedGifs';
        this.constructorId = 0x84a02a0d;
        this.subclassOfId = 0xa68b61f5;
        this._slots = ['hash', 'gifs'];
        this.hash = params.hash;
        this.gifs = params.gifs;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SavedGifs> {
        // no flags

        let hash = await Primitive.Long.read(b);
        let gifs = await TLObject.read(b);
        return new Raw.messages.SavedGifs({ hash: hash, gifs: gifs });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.gifs) {
          b.write(Primitive.Vector.write(this.gifs) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class BotResults extends TLObject {
      gallery?: boolean;
      queryId!: long;
      nextOffset?: string;
      switchPm?: Raw.TypeInlineBotSwitchPM;
      switchWebview?: Raw.TypeInlineBotWebView;
      results!: Vector<Raw.TypeBotInlineResult>;
      cacheTime!: int;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        gallery?: boolean;
        queryId: long;
        nextOffset?: string;
        switchPm?: Raw.TypeInlineBotSwitchPM;
        switchWebview?: Raw.TypeInlineBotWebView;
        results: Vector<Raw.TypeBotInlineResult>;
        cacheTime: int;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.BotResults';
        this.constructorId = 0xe021f2f6;
        this.subclassOfId = 0x3ed4d9c9;
        this._slots = [
          'gallery',
          'queryId',
          'nextOffset',
          'switchPm',
          'switchWebview',
          'results',
          'cacheTime',
          'users',
        ];
        this.gallery = params.gallery;
        this.queryId = params.queryId;
        this.nextOffset = params.nextOffset;
        this.switchPm = params.switchPm;
        this.switchWebview = params.switchWebview;
        this.results = params.results;
        this.cacheTime = params.cacheTime;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.BotResults> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let gallery = flags & (1 << 0) ? true : false;
        let queryId = await Primitive.Long.read(b);
        let nextOffset = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let switchPm = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let switchWebview = flags & (1 << 3) ? await TLObject.read(b) : undefined;
        let results = await TLObject.read(b);
        let cacheTime = await Primitive.Int.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.BotResults({
          gallery: gallery,
          queryId: queryId,
          nextOffset: nextOffset,
          switchPm: switchPm,
          switchWebview: switchWebview,
          results: results,
          cacheTime: cacheTime,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.gallery ? 1 << 0 : 0;
        flags |= this.nextOffset !== undefined ? 1 << 1 : 0;
        flags |= this.switchPm !== undefined ? 1 << 2 : 0;
        flags |= this.switchWebview !== undefined ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.queryId !== undefined) {
          b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
        }
        if (this.nextOffset !== undefined) {
          b.write(Primitive.String.write(this.nextOffset) as unknown as Buffer);
        }
        if (this.switchPm !== undefined) {
          b.write(this.switchPm.write() as unknown as Buffer);
        }
        if (this.switchWebview !== undefined) {
          b.write(this.switchWebview.write() as unknown as Buffer);
        }
        if (this.results) {
          b.write(Primitive.Vector.write(this.results) as unknown as Buffer);
        }
        if (this.cacheTime !== undefined) {
          b.write(Primitive.Int.write(this.cacheTime) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class BotCallbackAnswer extends TLObject {
      alert?: boolean;
      hasUrl?: boolean;
      nativeUi?: boolean;
      message?: string;
      url?: string;
      cacheTime!: int;

      constructor(params: {
        alert?: boolean;
        hasUrl?: boolean;
        nativeUi?: boolean;
        message?: string;
        url?: string;
        cacheTime: int;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.BotCallbackAnswer';
        this.constructorId = 0x36585ea4;
        this.subclassOfId = 0x6c4dd18c;
        this._slots = ['alert', 'hasUrl', 'nativeUi', 'message', 'url', 'cacheTime'];
        this.alert = params.alert;
        this.hasUrl = params.hasUrl;
        this.nativeUi = params.nativeUi;
        this.message = params.message;
        this.url = params.url;
        this.cacheTime = params.cacheTime;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.BotCallbackAnswer> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let alert = flags & (1 << 1) ? true : false;
        let hasUrl = flags & (1 << 3) ? true : false;
        let nativeUi = flags & (1 << 4) ? true : false;
        let message = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let url = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        let cacheTime = await Primitive.Int.read(b);
        return new Raw.messages.BotCallbackAnswer({
          alert: alert,
          hasUrl: hasUrl,
          nativeUi: nativeUi,
          message: message,
          url: url,
          cacheTime: cacheTime,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.alert ? 1 << 1 : 0;
        flags |= this.hasUrl ? 1 << 3 : 0;
        flags |= this.nativeUi ? 1 << 4 : 0;
        flags |= this.message !== undefined ? 1 << 0 : 0;
        flags |= this.url !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        if (this.cacheTime !== undefined) {
          b.write(Primitive.Int.write(this.cacheTime) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class MessageEditData extends TLObject {
      caption?: boolean;

      constructor(params: { caption?: boolean }) {
        super();
        this.classType = 'types';
        this.className = 'messages.MessageEditData';
        this.constructorId = 0x26b5dde6;
        this.subclassOfId = 0xfb47949d;
        this._slots = ['caption'];
        this.caption = params.caption;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.MessageEditData> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let caption = flags & (1 << 0) ? true : false;
        return new Raw.messages.MessageEditData({ caption: caption });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.caption ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        return b.buffer;
      }
    }
    export class PeerDialogs extends TLObject {
      dialogs!: Vector<Raw.TypeDialog>;
      messages!: Vector<Raw.TypeMessage>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;
      state!: Raw.updates.TypeState;

      constructor(params: {
        dialogs: Vector<Raw.TypeDialog>;
        messages: Vector<Raw.TypeMessage>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
        state: Raw.updates.TypeState;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.PeerDialogs';
        this.constructorId = 0x3371c354;
        this.subclassOfId = 0x3ac70132;
        this._slots = ['dialogs', 'messages', 'chats', 'users', 'state'];
        this.dialogs = params.dialogs;
        this.messages = params.messages;
        this.chats = params.chats;
        this.users = params.users;
        this.state = params.state;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.PeerDialogs> {
        // no flags

        let dialogs = await TLObject.read(b);
        let messages = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        let state = await TLObject.read(b);
        return new Raw.messages.PeerDialogs({
          dialogs: dialogs,
          messages: messages,
          chats: chats,
          users: users,
          state: state,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.dialogs) {
          b.write(Primitive.Vector.write(this.dialogs) as unknown as Buffer);
        }
        if (this.messages) {
          b.write(Primitive.Vector.write(this.messages) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        if (this.state !== undefined) {
          b.write(this.state.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class FeaturedStickersNotModified extends TLObject {
      count!: int;

      constructor(params: { count: int }) {
        super();
        this.classType = 'types';
        this.className = 'messages.FeaturedStickersNotModified';
        this.constructorId = 0xc6dc0c66;
        this.subclassOfId = 0x2614b722;
        this._slots = ['count'];
        this.count = params.count;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.FeaturedStickersNotModified> {
        // no flags

        let count = await Primitive.Int.read(b);
        return new Raw.messages.FeaturedStickersNotModified({ count: count });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class FeaturedStickers extends TLObject {
      premium?: boolean;
      hash!: long;
      count!: int;
      sets!: Vector<Raw.TypeStickerSetCovered>;
      unread!: Vector<long>;

      constructor(params: {
        premium?: boolean;
        hash: long;
        count: int;
        sets: Vector<Raw.TypeStickerSetCovered>;
        unread: Vector<long>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.FeaturedStickers';
        this.constructorId = 0xbe382906;
        this.subclassOfId = 0x2614b722;
        this._slots = ['premium', 'hash', 'count', 'sets', 'unread'];
        this.premium = params.premium;
        this.hash = params.hash;
        this.count = params.count;
        this.sets = params.sets;
        this.unread = params.unread;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.FeaturedStickers> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let premium = flags & (1 << 0) ? true : false;
        let hash = await Primitive.Long.read(b);
        let count = await Primitive.Int.read(b);
        let sets = await TLObject.read(b);
        let unread = await TLObject.read(b, Primitive.Long);
        return new Raw.messages.FeaturedStickers({
          premium: premium,
          hash: hash,
          count: count,
          sets: sets,
          unread: unread,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.premium ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.sets) {
          b.write(Primitive.Vector.write(this.sets) as unknown as Buffer);
        }
        if (this.unread) {
          b.write(Primitive.Vector.write(this.unread, Primitive.Long) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RecentStickersNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'messages.RecentStickersNotModified';
        this.constructorId = 0xb17f890;
        this.subclassOfId = 0xf76f8683;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.RecentStickersNotModified> {
        // no flags

        return new Raw.messages.RecentStickersNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class RecentStickers extends TLObject {
      hash!: long;
      packs!: Vector<Raw.TypeStickerPack>;
      stickers!: Vector<Raw.TypeDocument>;
      dates!: Vector<int>;

      constructor(params: {
        hash: long;
        packs: Vector<Raw.TypeStickerPack>;
        stickers: Vector<Raw.TypeDocument>;
        dates: Vector<int>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.RecentStickers';
        this.constructorId = 0x88d37c56;
        this.subclassOfId = 0xf76f8683;
        this._slots = ['hash', 'packs', 'stickers', 'dates'];
        this.hash = params.hash;
        this.packs = params.packs;
        this.stickers = params.stickers;
        this.dates = params.dates;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.RecentStickers> {
        // no flags

        let hash = await Primitive.Long.read(b);
        let packs = await TLObject.read(b);
        let stickers = await TLObject.read(b);
        let dates = await TLObject.read(b, Primitive.Int);
        return new Raw.messages.RecentStickers({
          hash: hash,
          packs: packs,
          stickers: stickers,
          dates: dates,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.packs) {
          b.write(Primitive.Vector.write(this.packs) as unknown as Buffer);
        }
        if (this.stickers) {
          b.write(Primitive.Vector.write(this.stickers) as unknown as Buffer);
        }
        if (this.dates) {
          b.write(Primitive.Vector.write(this.dates, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ArchivedStickers extends TLObject {
      count!: int;
      sets!: Vector<Raw.TypeStickerSetCovered>;

      constructor(params: { count: int; sets: Vector<Raw.TypeStickerSetCovered> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.ArchivedStickers';
        this.constructorId = 0x4fcba9c8;
        this.subclassOfId = 0x7296d771;
        this._slots = ['count', 'sets'];
        this.count = params.count;
        this.sets = params.sets;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ArchivedStickers> {
        // no flags

        let count = await Primitive.Int.read(b);
        let sets = await TLObject.read(b);
        return new Raw.messages.ArchivedStickers({ count: count, sets: sets });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.sets) {
          b.write(Primitive.Vector.write(this.sets) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class StickerSetInstallResultSuccess extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'messages.StickerSetInstallResultSuccess';
        this.constructorId = 0x38641628;
        this.subclassOfId = 0x67cb3fe8;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.StickerSetInstallResultSuccess> {
        // no flags

        return new Raw.messages.StickerSetInstallResultSuccess();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class StickerSetInstallResultArchive extends TLObject {
      sets!: Vector<Raw.TypeStickerSetCovered>;

      constructor(params: { sets: Vector<Raw.TypeStickerSetCovered> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.StickerSetInstallResultArchive';
        this.constructorId = 0x35e410a8;
        this.subclassOfId = 0x67cb3fe8;
        this._slots = ['sets'];
        this.sets = params.sets;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.StickerSetInstallResultArchive> {
        // no flags

        let sets = await TLObject.read(b);
        return new Raw.messages.StickerSetInstallResultArchive({ sets: sets });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.sets) {
          b.write(Primitive.Vector.write(this.sets) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class HighScores extends TLObject {
      scores!: Vector<Raw.TypeHighScore>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: { scores: Vector<Raw.TypeHighScore>; users: Vector<Raw.TypeUser> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.HighScores';
        this.constructorId = 0x9a3bfd99;
        this.subclassOfId = 0x6ccd95fd;
        this._slots = ['scores', 'users'];
        this.scores = params.scores;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.HighScores> {
        // no flags

        let scores = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.HighScores({ scores: scores, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.scores) {
          b.write(Primitive.Vector.write(this.scores) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class FavedStickersNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'messages.FavedStickersNotModified';
        this.constructorId = 0x9e8fa6d3;
        this.subclassOfId = 0x8e736fb9;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.FavedStickersNotModified> {
        // no flags

        return new Raw.messages.FavedStickersNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class FavedStickers extends TLObject {
      hash!: long;
      packs!: Vector<Raw.TypeStickerPack>;
      stickers!: Vector<Raw.TypeDocument>;

      constructor(params: {
        hash: long;
        packs: Vector<Raw.TypeStickerPack>;
        stickers: Vector<Raw.TypeDocument>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.FavedStickers';
        this.constructorId = 0x2cb51097;
        this.subclassOfId = 0x8e736fb9;
        this._slots = ['hash', 'packs', 'stickers'];
        this.hash = params.hash;
        this.packs = params.packs;
        this.stickers = params.stickers;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.FavedStickers> {
        // no flags

        let hash = await Primitive.Long.read(b);
        let packs = await TLObject.read(b);
        let stickers = await TLObject.read(b);
        return new Raw.messages.FavedStickers({ hash: hash, packs: packs, stickers: stickers });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.packs) {
          b.write(Primitive.Vector.write(this.packs) as unknown as Buffer);
        }
        if (this.stickers) {
          b.write(Primitive.Vector.write(this.stickers) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class FoundStickerSetsNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'messages.FoundStickerSetsNotModified';
        this.constructorId = 0xd54b65d;
        this.subclassOfId = 0x40df361;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.FoundStickerSetsNotModified> {
        // no flags

        return new Raw.messages.FoundStickerSetsNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class FoundStickerSets extends TLObject {
      hash!: long;
      sets!: Vector<Raw.TypeStickerSetCovered>;

      constructor(params: { hash: long; sets: Vector<Raw.TypeStickerSetCovered> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.FoundStickerSets';
        this.constructorId = 0x8af09dd2;
        this.subclassOfId = 0x40df361;
        this._slots = ['hash', 'sets'];
        this.hash = params.hash;
        this.sets = params.sets;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.FoundStickerSets> {
        // no flags

        let hash = await Primitive.Long.read(b);
        let sets = await TLObject.read(b);
        return new Raw.messages.FoundStickerSets({ hash: hash, sets: sets });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.sets) {
          b.write(Primitive.Vector.write(this.sets) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SearchCounter extends TLObject {
      inexact?: boolean;
      filter!: Raw.TypeMessagesFilter;
      count!: int;

      constructor(params: { inexact?: boolean; filter: Raw.TypeMessagesFilter; count: int }) {
        super();
        this.classType = 'types';
        this.className = 'messages.SearchCounter';
        this.constructorId = 0xe844ebff;
        this.subclassOfId = 0xd6a7bfa2;
        this._slots = ['inexact', 'filter', 'count'];
        this.inexact = params.inexact;
        this.filter = params.filter;
        this.count = params.count;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SearchCounter> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let inexact = flags & (1 << 1) ? true : false;
        let filter = await TLObject.read(b);
        let count = await Primitive.Int.read(b);
        return new Raw.messages.SearchCounter({ inexact: inexact, filter: filter, count: count });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.inexact ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.filter !== undefined) {
          b.write(this.filter.write() as unknown as Buffer);
        }
        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class InactiveChats extends TLObject {
      dates!: Vector<int>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        dates: Vector<int>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.InactiveChats';
        this.constructorId = 0xa927fec5;
        this.subclassOfId = 0x8bf3d7d4;
        this._slots = ['dates', 'chats', 'users'];
        this.dates = params.dates;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.InactiveChats> {
        // no flags

        let dates = await TLObject.read(b, Primitive.Int);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.InactiveChats({ dates: dates, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.dates) {
          b.write(Primitive.Vector.write(this.dates, Primitive.Int) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class VotesList extends TLObject {
      count!: int;
      votes!: Vector<Raw.TypeMessagePeerVote>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;
      nextOffset?: string;

      constructor(params: {
        count: int;
        votes: Vector<Raw.TypeMessagePeerVote>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
        nextOffset?: string;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.VotesList';
        this.constructorId = 0x4899484e;
        this.subclassOfId = 0xc2199885;
        this._slots = ['count', 'votes', 'chats', 'users', 'nextOffset'];
        this.count = params.count;
        this.votes = params.votes;
        this.chats = params.chats;
        this.users = params.users;
        this.nextOffset = params.nextOffset;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.VotesList> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let count = await Primitive.Int.read(b);
        let votes = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        let nextOffset = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        return new Raw.messages.VotesList({
          count: count,
          votes: votes,
          chats: chats,
          users: users,
          nextOffset: nextOffset,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.nextOffset !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.votes) {
          b.write(Primitive.Vector.write(this.votes) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        if (this.nextOffset !== undefined) {
          b.write(Primitive.String.write(this.nextOffset) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class MessageViews extends TLObject {
      views!: Vector<Raw.TypeMessageViews>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        views: Vector<Raw.TypeMessageViews>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.MessageViews';
        this.constructorId = 0xb6c4f543;
        this.subclassOfId = 0xafb5eb9c;
        this._slots = ['views', 'chats', 'users'];
        this.views = params.views;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.MessageViews> {
        // no flags

        let views = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.MessageViews({ views: views, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.views) {
          b.write(Primitive.Vector.write(this.views) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DiscussionMessage extends TLObject {
      messages!: Vector<Raw.TypeMessage>;
      maxId?: int;
      readInboxMaxId?: int;
      readOutboxMaxId?: int;
      unreadCount!: int;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        messages: Vector<Raw.TypeMessage>;
        maxId?: int;
        readInboxMaxId?: int;
        readOutboxMaxId?: int;
        unreadCount: int;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.DiscussionMessage';
        this.constructorId = 0xa6341782;
        this.subclassOfId = 0x53f8e3e8;
        this._slots = [
          'messages',
          'maxId',
          'readInboxMaxId',
          'readOutboxMaxId',
          'unreadCount',
          'chats',
          'users',
        ];
        this.messages = params.messages;
        this.maxId = params.maxId;
        this.readInboxMaxId = params.readInboxMaxId;
        this.readOutboxMaxId = params.readOutboxMaxId;
        this.unreadCount = params.unreadCount;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.DiscussionMessage> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let messages = await TLObject.read(b);
        let maxId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let readInboxMaxId = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let readOutboxMaxId = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
        let unreadCount = await Primitive.Int.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.DiscussionMessage({
          messages: messages,
          maxId: maxId,
          readInboxMaxId: readInboxMaxId,
          readOutboxMaxId: readOutboxMaxId,
          unreadCount: unreadCount,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.maxId !== undefined ? 1 << 0 : 0;
        flags |= this.readInboxMaxId !== undefined ? 1 << 1 : 0;
        flags |= this.readOutboxMaxId !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.messages) {
          b.write(Primitive.Vector.write(this.messages) as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
        }
        if (this.readInboxMaxId !== undefined) {
          b.write(Primitive.Int.write(this.readInboxMaxId) as unknown as Buffer);
        }
        if (this.readOutboxMaxId !== undefined) {
          b.write(Primitive.Int.write(this.readOutboxMaxId) as unknown as Buffer);
        }
        if (this.unreadCount !== undefined) {
          b.write(Primitive.Int.write(this.unreadCount) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class HistoryImport extends TLObject {
      id!: long;

      constructor(params: { id: long }) {
        super();
        this.classType = 'types';
        this.className = 'messages.HistoryImport';
        this.constructorId = 0x1662af0b;
        this.subclassOfId = 0xb18bb50a;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.HistoryImport> {
        // no flags

        let id = await Primitive.Long.read(b);
        return new Raw.messages.HistoryImport({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id !== undefined) {
          b.write(Primitive.Long.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class HistoryImportParsed extends TLObject {
      pm?: boolean;
      group?: boolean;
      title?: string;

      constructor(params: { pm?: boolean; group?: boolean; title?: string }) {
        super();
        this.classType = 'types';
        this.className = 'messages.HistoryImportParsed';
        this.constructorId = 0x5e0fb7b9;
        this.subclassOfId = 0x5bb2720b;
        this._slots = ['pm', 'group', 'title'];
        this.pm = params.pm;
        this.group = params.group;
        this.title = params.title;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.HistoryImportParsed> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let pm = flags & (1 << 0) ? true : false;
        let group = flags & (1 << 1) ? true : false;
        let title = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        return new Raw.messages.HistoryImportParsed({ pm: pm, group: group, title: title });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.pm ? 1 << 0 : 0;
        flags |= this.group ? 1 << 1 : 0;
        flags |= this.title !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AffectedFoundMessages extends TLObject {
      pts!: int;
      ptsCount!: int;
      offset!: int;
      messages!: Vector<int>;

      constructor(params: { pts: int; ptsCount: int; offset: int; messages: Vector<int> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.AffectedFoundMessages';
        this.constructorId = 0xef8d3e6c;
        this.subclassOfId = 0xf817652e;
        this._slots = ['pts', 'ptsCount', 'offset', 'messages'];
        this.pts = params.pts;
        this.ptsCount = params.ptsCount;
        this.offset = params.offset;
        this.messages = params.messages;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.AffectedFoundMessages> {
        // no flags

        let pts = await Primitive.Int.read(b);
        let ptsCount = await Primitive.Int.read(b);
        let offset = await Primitive.Int.read(b);
        let messages = await TLObject.read(b, Primitive.Int);
        return new Raw.messages.AffectedFoundMessages({
          pts: pts,
          ptsCount: ptsCount,
          offset: offset,
          messages: messages,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.pts !== undefined) {
          b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
        }
        if (this.ptsCount !== undefined) {
          b.write(Primitive.Int.write(this.ptsCount) as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
        }
        if (this.messages) {
          b.write(Primitive.Vector.write(this.messages, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportedChatInvites extends TLObject {
      count!: int;
      invites!: Vector<Raw.TypeExportedChatInvite>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        count: int;
        invites: Vector<Raw.TypeExportedChatInvite>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.ExportedChatInvites';
        this.constructorId = 0xbdc62dcc;
        this.subclassOfId = 0x603d3871;
        this._slots = ['count', 'invites', 'users'];
        this.count = params.count;
        this.invites = params.invites;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ExportedChatInvites> {
        // no flags

        let count = await Primitive.Int.read(b);
        let invites = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.ExportedChatInvites({
          count: count,
          invites: invites,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.invites) {
          b.write(Primitive.Vector.write(this.invites) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportedChatInvite extends TLObject {
      invite!: Raw.TypeExportedChatInvite;
      users!: Vector<Raw.TypeUser>;

      constructor(params: { invite: Raw.TypeExportedChatInvite; users: Vector<Raw.TypeUser> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.ExportedChatInvite';
        this.constructorId = 0x1871be50;
        this.subclassOfId = 0x82dcd4ca;
        this._slots = ['invite', 'users'];
        this.invite = params.invite;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ExportedChatInvite> {
        // no flags

        let invite = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.ExportedChatInvite({ invite: invite, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.invite !== undefined) {
          b.write(this.invite.write() as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportedChatInviteReplaced extends TLObject {
      invite!: Raw.TypeExportedChatInvite;
      newInvite!: Raw.TypeExportedChatInvite;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        invite: Raw.TypeExportedChatInvite;
        newInvite: Raw.TypeExportedChatInvite;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.ExportedChatInviteReplaced';
        this.constructorId = 0x222600ef;
        this.subclassOfId = 0x82dcd4ca;
        this._slots = ['invite', 'newInvite', 'users'];
        this.invite = params.invite;
        this.newInvite = params.newInvite;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ExportedChatInviteReplaced> {
        // no flags

        let invite = await TLObject.read(b);
        let newInvite = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.ExportedChatInviteReplaced({
          invite: invite,
          newInvite: newInvite,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.invite !== undefined) {
          b.write(this.invite.write() as unknown as Buffer);
        }
        if (this.newInvite !== undefined) {
          b.write(this.newInvite.write() as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChatInviteImporters extends TLObject {
      count!: int;
      importers!: Vector<Raw.TypeChatInviteImporter>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        count: int;
        importers: Vector<Raw.TypeChatInviteImporter>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.ChatInviteImporters';
        this.constructorId = 0x81b6b00a;
        this.subclassOfId = 0xd9bc8aa6;
        this._slots = ['count', 'importers', 'users'];
        this.count = params.count;
        this.importers = params.importers;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ChatInviteImporters> {
        // no flags

        let count = await Primitive.Int.read(b);
        let importers = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.ChatInviteImporters({
          count: count,
          importers: importers,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.importers) {
          b.write(Primitive.Vector.write(this.importers) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChatAdminsWithInvites extends TLObject {
      admins!: Vector<Raw.TypeChatAdminWithInvites>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        admins: Vector<Raw.TypeChatAdminWithInvites>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.ChatAdminsWithInvites';
        this.constructorId = 0xb69b72d7;
        this.subclassOfId = 0x8f5bad2b;
        this._slots = ['admins', 'users'];
        this.admins = params.admins;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ChatAdminsWithInvites> {
        // no flags

        let admins = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.ChatAdminsWithInvites({ admins: admins, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.admins) {
          b.write(Primitive.Vector.write(this.admins) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CheckedHistoryImportPeer extends TLObject {
      confirmText!: string;

      constructor(params: { confirmText: string }) {
        super();
        this.classType = 'types';
        this.className = 'messages.CheckedHistoryImportPeer';
        this.constructorId = 0xa24de717;
        this.subclassOfId = 0xb84bb337;
        this._slots = ['confirmText'];
        this.confirmText = params.confirmText;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.CheckedHistoryImportPeer> {
        // no flags

        let confirmText = await Primitive.String.read(b);
        return new Raw.messages.CheckedHistoryImportPeer({ confirmText: confirmText });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.confirmText !== undefined) {
          b.write(Primitive.String.write(this.confirmText) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SponsoredMessages extends TLObject {
      postsBetween?: int;
      messages!: Vector<Raw.TypeSponsoredMessage>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        postsBetween?: int;
        messages: Vector<Raw.TypeSponsoredMessage>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.SponsoredMessages';
        this.constructorId = 0xc9ee1d87;
        this.subclassOfId = 0x7f4169e0;
        this._slots = ['postsBetween', 'messages', 'chats', 'users'];
        this.postsBetween = params.postsBetween;
        this.messages = params.messages;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SponsoredMessages> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let postsBetween = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let messages = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.SponsoredMessages({
          postsBetween: postsBetween,
          messages: messages,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.postsBetween !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.postsBetween !== undefined) {
          b.write(Primitive.Int.write(this.postsBetween) as unknown as Buffer);
        }
        if (this.messages) {
          b.write(Primitive.Vector.write(this.messages) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SponsoredMessagesEmpty extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'messages.SponsoredMessagesEmpty';
        this.constructorId = 0x1839490f;
        this.subclassOfId = 0x7f4169e0;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SponsoredMessagesEmpty> {
        // no flags

        return new Raw.messages.SponsoredMessagesEmpty();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SearchResultsCalendar extends TLObject {
      inexact?: boolean;
      count!: int;
      minDate!: int;
      minMsgId!: int;
      offsetIdOffset?: int;
      periods!: Vector<Raw.TypeSearchResultsCalendarPeriod>;
      messages!: Vector<Raw.TypeMessage>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        inexact?: boolean;
        count: int;
        minDate: int;
        minMsgId: int;
        offsetIdOffset?: int;
        periods: Vector<Raw.TypeSearchResultsCalendarPeriod>;
        messages: Vector<Raw.TypeMessage>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.SearchResultsCalendar';
        this.constructorId = 0x147ee23c;
        this.subclassOfId = 0x92c5640f;
        this._slots = [
          'inexact',
          'count',
          'minDate',
          'minMsgId',
          'offsetIdOffset',
          'periods',
          'messages',
          'chats',
          'users',
        ];
        this.inexact = params.inexact;
        this.count = params.count;
        this.minDate = params.minDate;
        this.minMsgId = params.minMsgId;
        this.offsetIdOffset = params.offsetIdOffset;
        this.periods = params.periods;
        this.messages = params.messages;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SearchResultsCalendar> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let inexact = flags & (1 << 0) ? true : false;
        let count = await Primitive.Int.read(b);
        let minDate = await Primitive.Int.read(b);
        let minMsgId = await Primitive.Int.read(b);
        let offsetIdOffset = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let periods = await TLObject.read(b);
        let messages = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.SearchResultsCalendar({
          inexact: inexact,
          count: count,
          minDate: minDate,
          minMsgId: minMsgId,
          offsetIdOffset: offsetIdOffset,
          periods: periods,
          messages: messages,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.inexact ? 1 << 0 : 0;
        flags |= this.offsetIdOffset !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.minDate !== undefined) {
          b.write(Primitive.Int.write(this.minDate) as unknown as Buffer);
        }
        if (this.minMsgId !== undefined) {
          b.write(Primitive.Int.write(this.minMsgId) as unknown as Buffer);
        }
        if (this.offsetIdOffset !== undefined) {
          b.write(Primitive.Int.write(this.offsetIdOffset) as unknown as Buffer);
        }
        if (this.periods) {
          b.write(Primitive.Vector.write(this.periods) as unknown as Buffer);
        }
        if (this.messages) {
          b.write(Primitive.Vector.write(this.messages) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SearchResultsPositions extends TLObject {
      count!: int;
      positions!: Vector<Raw.TypeSearchResultsPosition>;

      constructor(params: { count: int; positions: Vector<Raw.TypeSearchResultsPosition> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.SearchResultsPositions';
        this.constructorId = 0x53b22baf;
        this.subclassOfId = 0xd963708d;
        this._slots = ['count', 'positions'];
        this.count = params.count;
        this.positions = params.positions;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SearchResultsPositions> {
        // no flags

        let count = await Primitive.Int.read(b);
        let positions = await TLObject.read(b);
        return new Raw.messages.SearchResultsPositions({ count: count, positions: positions });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.positions) {
          b.write(Primitive.Vector.write(this.positions) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PeerSettings extends TLObject {
      settings!: Raw.TypePeerSettings;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        settings: Raw.TypePeerSettings;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.PeerSettings';
        this.constructorId = 0x6880b94d;
        this.subclassOfId = 0x65a2f7a1;
        this._slots = ['settings', 'chats', 'users'];
        this.settings = params.settings;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.PeerSettings> {
        // no flags

        let settings = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.PeerSettings({ settings: settings, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class MessageReactionsList extends TLObject {
      count!: int;
      reactions!: Vector<Raw.TypeMessagePeerReaction>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;
      nextOffset?: string;

      constructor(params: {
        count: int;
        reactions: Vector<Raw.TypeMessagePeerReaction>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
        nextOffset?: string;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.MessageReactionsList';
        this.constructorId = 0x31bd492d;
        this.subclassOfId = 0x60fce5e6;
        this._slots = ['count', 'reactions', 'chats', 'users', 'nextOffset'];
        this.count = params.count;
        this.reactions = params.reactions;
        this.chats = params.chats;
        this.users = params.users;
        this.nextOffset = params.nextOffset;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.MessageReactionsList> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let count = await Primitive.Int.read(b);
        let reactions = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        let nextOffset = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        return new Raw.messages.MessageReactionsList({
          count: count,
          reactions: reactions,
          chats: chats,
          users: users,
          nextOffset: nextOffset,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.nextOffset !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.reactions) {
          b.write(Primitive.Vector.write(this.reactions) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        if (this.nextOffset !== undefined) {
          b.write(Primitive.String.write(this.nextOffset) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AvailableReactionsNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'messages.AvailableReactionsNotModified';
        this.constructorId = 0x9f071957;
        this.subclassOfId = 0xe426ad82;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.AvailableReactionsNotModified> {
        // no flags

        return new Raw.messages.AvailableReactionsNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class AvailableReactions extends TLObject {
      hash!: int;
      reactions!: Vector<Raw.TypeAvailableReaction>;

      constructor(params: { hash: int; reactions: Vector<Raw.TypeAvailableReaction> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.AvailableReactions';
        this.constructorId = 0x768e3aad;
        this.subclassOfId = 0xe426ad82;
        this._slots = ['hash', 'reactions'];
        this.hash = params.hash;
        this.reactions = params.reactions;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.AvailableReactions> {
        // no flags

        let hash = await Primitive.Int.read(b);
        let reactions = await TLObject.read(b);
        return new Raw.messages.AvailableReactions({ hash: hash, reactions: reactions });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        if (this.reactions) {
          b.write(Primitive.Vector.write(this.reactions) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TranscribedAudio extends TLObject {
      pending?: boolean;
      transcriptionId!: long;
      text!: string;

      constructor(params: { pending?: boolean; transcriptionId: long; text: string }) {
        super();
        this.classType = 'types';
        this.className = 'messages.TranscribedAudio';
        this.constructorId = 0x93752c52;
        this.subclassOfId = 0x21b24936;
        this._slots = ['pending', 'transcriptionId', 'text'];
        this.pending = params.pending;
        this.transcriptionId = params.transcriptionId;
        this.text = params.text;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.TranscribedAudio> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let pending = flags & (1 << 0) ? true : false;
        let transcriptionId = await Primitive.Long.read(b);
        let text = await Primitive.String.read(b);
        return new Raw.messages.TranscribedAudio({
          pending: pending,
          transcriptionId: transcriptionId,
          text: text,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.pending ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.transcriptionId !== undefined) {
          b.write(Primitive.Long.write(this.transcriptionId) as unknown as Buffer);
        }
        if (this.text !== undefined) {
          b.write(Primitive.String.write(this.text) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReactionsNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'messages.ReactionsNotModified';
        this.constructorId = 0xb06fdbdf;
        this.subclassOfId = 0xadc38324;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ReactionsNotModified> {
        // no flags

        return new Raw.messages.ReactionsNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class Reactions extends TLObject {
      hash!: long;
      reactions!: Vector<Raw.TypeReaction>;

      constructor(params: { hash: long; reactions: Vector<Raw.TypeReaction> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.Reactions';
        this.constructorId = 0xeafdf716;
        this.subclassOfId = 0xadc38324;
        this._slots = ['hash', 'reactions'];
        this.hash = params.hash;
        this.reactions = params.reactions;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.Reactions> {
        // no flags

        let hash = await Primitive.Long.read(b);
        let reactions = await TLObject.read(b);
        return new Raw.messages.Reactions({ hash: hash, reactions: reactions });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.reactions) {
          b.write(Primitive.Vector.write(this.reactions) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ForumTopics extends TLObject {
      orderByCreateDate?: boolean;
      count!: int;
      topics!: Vector<Raw.TypeForumTopic>;
      messages!: Vector<Raw.TypeMessage>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;
      pts!: int;

      constructor(params: {
        orderByCreateDate?: boolean;
        count: int;
        topics: Vector<Raw.TypeForumTopic>;
        messages: Vector<Raw.TypeMessage>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
        pts: int;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.ForumTopics';
        this.constructorId = 0x367617d3;
        this.subclassOfId = 0x8e1d3e1e;
        this._slots = ['orderByCreateDate', 'count', 'topics', 'messages', 'chats', 'users', 'pts'];
        this.orderByCreateDate = params.orderByCreateDate;
        this.count = params.count;
        this.topics = params.topics;
        this.messages = params.messages;
        this.chats = params.chats;
        this.users = params.users;
        this.pts = params.pts;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ForumTopics> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let orderByCreateDate = flags & (1 << 0) ? true : false;
        let count = await Primitive.Int.read(b);
        let topics = await TLObject.read(b);
        let messages = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        let pts = await Primitive.Int.read(b);
        return new Raw.messages.ForumTopics({
          orderByCreateDate: orderByCreateDate,
          count: count,
          topics: topics,
          messages: messages,
          chats: chats,
          users: users,
          pts: pts,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.orderByCreateDate ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.topics) {
          b.write(Primitive.Vector.write(this.topics) as unknown as Buffer);
        }
        if (this.messages) {
          b.write(Primitive.Vector.write(this.messages) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        if (this.pts !== undefined) {
          b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EmojiGroupsNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'messages.EmojiGroupsNotModified';
        this.constructorId = 0x6fb4ad87;
        this.subclassOfId = 0x7eca55d9;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.EmojiGroupsNotModified> {
        // no flags

        return new Raw.messages.EmojiGroupsNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class EmojiGroups extends TLObject {
      hash!: int;
      groups!: Vector<Raw.TypeEmojiGroup>;

      constructor(params: { hash: int; groups: Vector<Raw.TypeEmojiGroup> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.EmojiGroups';
        this.constructorId = 0x881fb94b;
        this.subclassOfId = 0x7eca55d9;
        this._slots = ['hash', 'groups'];
        this.hash = params.hash;
        this.groups = params.groups;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.EmojiGroups> {
        // no flags

        let hash = await Primitive.Int.read(b);
        let groups = await TLObject.read(b);
        return new Raw.messages.EmojiGroups({ hash: hash, groups: groups });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        if (this.groups) {
          b.write(Primitive.Vector.write(this.groups) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TranslateResult extends TLObject {
      result!: Vector<Raw.TypeTextWithEntities>;

      constructor(params: { result: Vector<Raw.TypeTextWithEntities> }) {
        super();
        this.classType = 'types';
        this.className = 'messages.TranslateResult';
        this.constructorId = 0x33db32f8;
        this.subclassOfId = 0x24243e8;
        this._slots = ['result'];
        this.result = params.result;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.TranslateResult> {
        // no flags

        let result = await TLObject.read(b);
        return new Raw.messages.TranslateResult({ result: result });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.result) {
          b.write(Primitive.Vector.write(this.result) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class BotApp extends TLObject {
      inactive?: boolean;
      requestWriteAccess?: boolean;
      hasSettings?: boolean;
      app!: Raw.TypeBotApp;

      constructor(params: {
        inactive?: boolean;
        requestWriteAccess?: boolean;
        hasSettings?: boolean;
        app: Raw.TypeBotApp;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.BotApp';
        this.constructorId = 0xeb50adf5;
        this.subclassOfId = 0x8f7243a7;
        this._slots = ['inactive', 'requestWriteAccess', 'hasSettings', 'app'];
        this.inactive = params.inactive;
        this.requestWriteAccess = params.requestWriteAccess;
        this.hasSettings = params.hasSettings;
        this.app = params.app;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.BotApp> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let inactive = flags & (1 << 0) ? true : false;
        let requestWriteAccess = flags & (1 << 1) ? true : false;
        let hasSettings = flags & (1 << 2) ? true : false;
        let app = await TLObject.read(b);
        return new Raw.messages.BotApp({
          inactive: inactive,
          requestWriteAccess: requestWriteAccess,
          hasSettings: hasSettings,
          app: app,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.inactive ? 1 << 0 : 0;
        flags |= this.requestWriteAccess ? 1 << 1 : 0;
        flags |= this.hasSettings ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.app !== undefined) {
          b.write(this.app.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class WebPage extends TLObject {
      webpage!: Raw.TypeWebPage;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        webpage: Raw.TypeWebPage;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'messages.WebPage';
        this.constructorId = 0xfd5e12bd;
        this.subclassOfId = 0x2cf8b154;
        this._slots = ['webpage', 'chats', 'users'];
        this.webpage = params.webpage;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.WebPage> {
        // no flags

        let webpage = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.messages.WebPage({ webpage: webpage, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.webpage !== undefined) {
          b.write(this.webpage.write() as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetMessages extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      id!: Vector<Raw.TypeInputMessage>;

      constructor(params: { id: Vector<Raw.TypeInputMessage> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetMessages';
        this.constructorId = 0x63c66506;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetMessages> {
        // no flags

        let id = await TLObject.read(b);
        return new Raw.messages.GetMessages({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id) {
          b.write(Primitive.Vector.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDialogs extends TLObject {
      __response__!: Raw.messages.TypeDialogs;
      excludePinned?: boolean;
      folderId?: int;
      offsetDate!: int;
      offsetId!: int;
      offsetPeer!: Raw.TypeInputPeer;
      limit!: int;
      hash!: long;

      constructor(params: {
        excludePinned?: boolean;
        folderId?: int;
        offsetDate: int;
        offsetId: int;
        offsetPeer: Raw.TypeInputPeer;
        limit: int;
        hash: long;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetDialogs';
        this.constructorId = 0xa0f4cb4f;
        this.subclassOfId = 0xe1b52ee;
        this._slots = [
          'excludePinned',
          'folderId',
          'offsetDate',
          'offsetId',
          'offsetPeer',
          'limit',
          'hash',
        ];
        this.excludePinned = params.excludePinned;
        this.folderId = params.folderId;
        this.offsetDate = params.offsetDate;
        this.offsetId = params.offsetId;
        this.offsetPeer = params.offsetPeer;
        this.limit = params.limit;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetDialogs> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let excludePinned = flags & (1 << 0) ? true : false;
        let folderId = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let offsetDate = await Primitive.Int.read(b);
        let offsetId = await Primitive.Int.read(b);
        let offsetPeer = await TLObject.read(b);
        let limit = await Primitive.Int.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetDialogs({
          excludePinned: excludePinned,
          folderId: folderId,
          offsetDate: offsetDate,
          offsetId: offsetId,
          offsetPeer: offsetPeer,
          limit: limit,
          hash: hash,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.excludePinned ? 1 << 0 : 0;
        flags |= this.folderId !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.folderId !== undefined) {
          b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
        }
        if (this.offsetDate !== undefined) {
          b.write(Primitive.Int.write(this.offsetDate) as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.offsetPeer !== undefined) {
          b.write(this.offsetPeer.write() as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetHistory extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      peer!: Raw.TypeInputPeer;
      offsetId!: int;
      offsetDate!: int;
      addOffset!: int;
      limit!: int;
      maxId!: int;
      minId!: int;
      hash!: long;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        offsetId: int;
        offsetDate: int;
        addOffset: int;
        limit: int;
        maxId: int;
        minId: int;
        hash: long;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetHistory';
        this.constructorId = 0x4423e6c5;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = [
          'peer',
          'offsetId',
          'offsetDate',
          'addOffset',
          'limit',
          'maxId',
          'minId',
          'hash',
        ];
        this.peer = params.peer;
        this.offsetId = params.offsetId;
        this.offsetDate = params.offsetDate;
        this.addOffset = params.addOffset;
        this.limit = params.limit;
        this.maxId = params.maxId;
        this.minId = params.minId;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetHistory> {
        // no flags

        let peer = await TLObject.read(b);
        let offsetId = await Primitive.Int.read(b);
        let offsetDate = await Primitive.Int.read(b);
        let addOffset = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        let maxId = await Primitive.Int.read(b);
        let minId = await Primitive.Int.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetHistory({
          peer: peer,
          offsetId: offsetId,
          offsetDate: offsetDate,
          addOffset: addOffset,
          limit: limit,
          maxId: maxId,
          minId: minId,
          hash: hash,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.offsetDate !== undefined) {
          b.write(Primitive.Int.write(this.offsetDate) as unknown as Buffer);
        }
        if (this.addOffset !== undefined) {
          b.write(Primitive.Int.write(this.addOffset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
        }
        if (this.minId !== undefined) {
          b.write(Primitive.Int.write(this.minId) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Search extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      peer!: Raw.TypeInputPeer;
      q!: string;
      fromId?: Raw.TypeInputPeer;
      topMsgId?: int;
      filter!: Raw.TypeMessagesFilter;
      minDate!: int;
      maxDate!: int;
      offsetId!: int;
      addOffset!: int;
      limit!: int;
      maxId!: int;
      minId!: int;
      hash!: long;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        q: string;
        fromId?: Raw.TypeInputPeer;
        topMsgId?: int;
        filter: Raw.TypeMessagesFilter;
        minDate: int;
        maxDate: int;
        offsetId: int;
        addOffset: int;
        limit: int;
        maxId: int;
        minId: int;
        hash: long;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.Search';
        this.constructorId = 0xa0fda762;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = [
          'peer',
          'q',
          'fromId',
          'topMsgId',
          'filter',
          'minDate',
          'maxDate',
          'offsetId',
          'addOffset',
          'limit',
          'maxId',
          'minId',
          'hash',
        ];
        this.peer = params.peer;
        this.q = params.q;
        this.fromId = params.fromId;
        this.topMsgId = params.topMsgId;
        this.filter = params.filter;
        this.minDate = params.minDate;
        this.maxDate = params.maxDate;
        this.offsetId = params.offsetId;
        this.addOffset = params.addOffset;
        this.limit = params.limit;
        this.maxId = params.maxId;
        this.minId = params.minId;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.Search> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = await TLObject.read(b);
        let q = await Primitive.String.read(b);
        let fromId = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let topMsgId = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let filter = await TLObject.read(b);
        let minDate = await Primitive.Int.read(b);
        let maxDate = await Primitive.Int.read(b);
        let offsetId = await Primitive.Int.read(b);
        let addOffset = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        let maxId = await Primitive.Int.read(b);
        let minId = await Primitive.Int.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.Search({
          peer: peer,
          q: q,
          fromId: fromId,
          topMsgId: topMsgId,
          filter: filter,
          minDate: minDate,
          maxDate: maxDate,
          offsetId: offsetId,
          addOffset: addOffset,
          limit: limit,
          maxId: maxId,
          minId: minId,
          hash: hash,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.fromId !== undefined ? 1 << 0 : 0;
        flags |= this.topMsgId !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.q !== undefined) {
          b.write(Primitive.String.write(this.q) as unknown as Buffer);
        }
        if (this.fromId !== undefined) {
          b.write(this.fromId.write() as unknown as Buffer);
        }
        if (this.topMsgId !== undefined) {
          b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
        }
        if (this.filter !== undefined) {
          b.write(this.filter.write() as unknown as Buffer);
        }
        if (this.minDate !== undefined) {
          b.write(Primitive.Int.write(this.minDate) as unknown as Buffer);
        }
        if (this.maxDate !== undefined) {
          b.write(Primitive.Int.write(this.maxDate) as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.addOffset !== undefined) {
          b.write(Primitive.Int.write(this.addOffset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
        }
        if (this.minId !== undefined) {
          b.write(Primitive.Int.write(this.minId) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReadHistory extends TLObject {
      __response__!: Raw.messages.TypeAffectedMessages;
      peer!: Raw.TypeInputPeer;
      maxId!: int;

      constructor(params: { peer: Raw.TypeInputPeer; maxId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReadHistory';
        this.constructorId = 0xe306d3a;
        this.subclassOfId = 0xced3c06e;
        this._slots = ['peer', 'maxId'];
        this.peer = params.peer;
        this.maxId = params.maxId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ReadHistory> {
        // no flags

        let peer = await TLObject.read(b);
        let maxId = await Primitive.Int.read(b);
        return new Raw.messages.ReadHistory({ peer: peer, maxId: maxId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteHistory extends TLObject {
      __response__!: Raw.messages.TypeAffectedHistory;
      justClear?: boolean;
      revoke?: boolean;
      peer!: Raw.TypeInputPeer;
      maxId!: int;
      minDate?: int;
      maxDate?: int;

      constructor(params: {
        justClear?: boolean;
        revoke?: boolean;
        peer: Raw.TypeInputPeer;
        maxId: int;
        minDate?: int;
        maxDate?: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.DeleteHistory';
        this.constructorId = 0xb08f922a;
        this.subclassOfId = 0x2c49c116;
        this._slots = ['justClear', 'revoke', 'peer', 'maxId', 'minDate', 'maxDate'];
        this.justClear = params.justClear;
        this.revoke = params.revoke;
        this.peer = params.peer;
        this.maxId = params.maxId;
        this.minDate = params.minDate;
        this.maxDate = params.maxDate;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.DeleteHistory> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let justClear = flags & (1 << 0) ? true : false;
        let revoke = flags & (1 << 1) ? true : false;
        let peer = await TLObject.read(b);
        let maxId = await Primitive.Int.read(b);
        let minDate = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
        let maxDate = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
        return new Raw.messages.DeleteHistory({
          justClear: justClear,
          revoke: revoke,
          peer: peer,
          maxId: maxId,
          minDate: minDate,
          maxDate: maxDate,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.justClear ? 1 << 0 : 0;
        flags |= this.revoke ? 1 << 1 : 0;
        flags |= this.minDate !== undefined ? 1 << 2 : 0;
        flags |= this.maxDate !== undefined ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
        }
        if (this.minDate !== undefined) {
          b.write(Primitive.Int.write(this.minDate) as unknown as Buffer);
        }
        if (this.maxDate !== undefined) {
          b.write(Primitive.Int.write(this.maxDate) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteMessages extends TLObject {
      __response__!: Raw.messages.TypeAffectedMessages;
      revoke?: boolean;
      id!: Vector<int>;

      constructor(params: { revoke?: boolean; id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.DeleteMessages';
        this.constructorId = 0xe58e95d2;
        this.subclassOfId = 0xced3c06e;
        this._slots = ['revoke', 'id'];
        this.revoke = params.revoke;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.DeleteMessages> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let revoke = flags & (1 << 0) ? true : false;
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.messages.DeleteMessages({ revoke: revoke, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.revoke ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReceivedMessages extends TLObject {
      __response__!: Vector<Raw.TypeReceivedNotifyMessage>;
      maxId!: int;

      constructor(params: { maxId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReceivedMessages';
        this.constructorId = 0x5a954c0;
        this.subclassOfId = 0x8565f897;
        this._slots = ['maxId'];
        this.maxId = params.maxId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ReceivedMessages> {
        // no flags

        let maxId = await Primitive.Int.read(b);
        return new Raw.messages.ReceivedMessages({ maxId: maxId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.maxId !== undefined) {
          b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetTyping extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      topMsgId?: int;
      action!: Raw.TypeSendMessageAction;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        topMsgId?: int;
        action: Raw.TypeSendMessageAction;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetTyping';
        this.constructorId = 0x58943ee2;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'topMsgId', 'action'];
        this.peer = params.peer;
        this.topMsgId = params.topMsgId;
        this.action = params.action;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SetTyping> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = await TLObject.read(b);
        let topMsgId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let action = await TLObject.read(b);
        return new Raw.messages.SetTyping({ peer: peer, topMsgId: topMsgId, action: action });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.topMsgId !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.topMsgId !== undefined) {
          b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
        }
        if (this.action !== undefined) {
          b.write(this.action.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendMessage extends TLObject {
      __response__!: Raw.TypeUpdates;
      noWebpage?: boolean;
      silent?: boolean;
      background?: boolean;
      clearDraft?: boolean;
      noforwards?: boolean;
      updateStickersetsOrder?: boolean;
      invertMedia?: boolean;
      peer!: Raw.TypeInputPeer;
      replyTo?: Raw.TypeInputReplyTo;
      message!: string;
      randomId!: long;
      replyMarkup?: Raw.TypeReplyMarkup;
      entities?: Vector<Raw.TypeMessageEntity>;
      scheduleDate?: int;
      sendAs?: Raw.TypeInputPeer;

      constructor(params: {
        noWebpage?: boolean;
        silent?: boolean;
        background?: boolean;
        clearDraft?: boolean;
        noforwards?: boolean;
        updateStickersetsOrder?: boolean;
        invertMedia?: boolean;
        peer: Raw.TypeInputPeer;
        replyTo?: Raw.TypeInputReplyTo;
        message: string;
        randomId: long;
        replyMarkup?: Raw.TypeReplyMarkup;
        entities?: Vector<Raw.TypeMessageEntity>;
        scheduleDate?: int;
        sendAs?: Raw.TypeInputPeer;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendMessage';
        this.constructorId = 0x280d096f;
        this.subclassOfId = 0x8af52aac;
        this._slots = [
          'noWebpage',
          'silent',
          'background',
          'clearDraft',
          'noforwards',
          'updateStickersetsOrder',
          'invertMedia',
          'peer',
          'replyTo',
          'message',
          'randomId',
          'replyMarkup',
          'entities',
          'scheduleDate',
          'sendAs',
        ];
        this.noWebpage = params.noWebpage;
        this.silent = params.silent;
        this.background = params.background;
        this.clearDraft = params.clearDraft;
        this.noforwards = params.noforwards;
        this.updateStickersetsOrder = params.updateStickersetsOrder;
        this.invertMedia = params.invertMedia;
        this.peer = params.peer;
        this.replyTo = params.replyTo;
        this.message = params.message;
        this.randomId = params.randomId;
        this.replyMarkup = params.replyMarkup;
        this.entities = params.entities;
        this.scheduleDate = params.scheduleDate;
        this.sendAs = params.sendAs;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SendMessage> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let noWebpage = flags & (1 << 1) ? true : false;
        let silent = flags & (1 << 5) ? true : false;
        let background = flags & (1 << 6) ? true : false;
        let clearDraft = flags & (1 << 7) ? true : false;
        let noforwards = flags & (1 << 14) ? true : false;
        let updateStickersetsOrder = flags & (1 << 15) ? true : false;
        let invertMedia = flags & (1 << 16) ? true : false;
        let peer = await TLObject.read(b);
        let replyTo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let message = await Primitive.String.read(b);
        let randomId = await Primitive.Long.read(b);
        let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let entities = flags & (1 << 3) ? await TLObject.read(b) : [];
        let scheduleDate = flags & (1 << 10) ? await Primitive.Int.read(b) : undefined;
        let sendAs = flags & (1 << 13) ? await TLObject.read(b) : undefined;
        return new Raw.messages.SendMessage({
          noWebpage: noWebpage,
          silent: silent,
          background: background,
          clearDraft: clearDraft,
          noforwards: noforwards,
          updateStickersetsOrder: updateStickersetsOrder,
          invertMedia: invertMedia,
          peer: peer,
          replyTo: replyTo,
          message: message,
          randomId: randomId,
          replyMarkup: replyMarkup,
          entities: entities,
          scheduleDate: scheduleDate,
          sendAs: sendAs,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.noWebpage ? 1 << 1 : 0;
        flags |= this.silent ? 1 << 5 : 0;
        flags |= this.background ? 1 << 6 : 0;
        flags |= this.clearDraft ? 1 << 7 : 0;
        flags |= this.noforwards ? 1 << 14 : 0;
        flags |= this.updateStickersetsOrder ? 1 << 15 : 0;
        flags |= this.invertMedia ? 1 << 16 : 0;
        flags |= this.replyTo !== undefined ? 1 << 0 : 0;
        flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
        flags |= this.entities ? 1 << 3 : 0;
        flags |= this.scheduleDate !== undefined ? 1 << 10 : 0;
        flags |= this.sendAs !== undefined ? 1 << 13 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.replyTo !== undefined) {
          b.write(this.replyTo.write() as unknown as Buffer);
        }
        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
        }
        if (this.replyMarkup !== undefined) {
          b.write(this.replyMarkup.write() as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        if (this.scheduleDate !== undefined) {
          b.write(Primitive.Int.write(this.scheduleDate) as unknown as Buffer);
        }
        if (this.sendAs !== undefined) {
          b.write(this.sendAs.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendMedia extends TLObject {
      __response__!: Raw.TypeUpdates;
      silent?: boolean;
      background?: boolean;
      clearDraft?: boolean;
      noforwards?: boolean;
      updateStickersetsOrder?: boolean;
      invertMedia?: boolean;
      peer!: Raw.TypeInputPeer;
      replyTo?: Raw.TypeInputReplyTo;
      media!: Raw.TypeInputMedia;
      message!: string;
      randomId!: long;
      replyMarkup?: Raw.TypeReplyMarkup;
      entities?: Vector<Raw.TypeMessageEntity>;
      scheduleDate?: int;
      sendAs?: Raw.TypeInputPeer;

      constructor(params: {
        silent?: boolean;
        background?: boolean;
        clearDraft?: boolean;
        noforwards?: boolean;
        updateStickersetsOrder?: boolean;
        invertMedia?: boolean;
        peer: Raw.TypeInputPeer;
        replyTo?: Raw.TypeInputReplyTo;
        media: Raw.TypeInputMedia;
        message: string;
        randomId: long;
        replyMarkup?: Raw.TypeReplyMarkup;
        entities?: Vector<Raw.TypeMessageEntity>;
        scheduleDate?: int;
        sendAs?: Raw.TypeInputPeer;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendMedia';
        this.constructorId = 0x72ccc23d;
        this.subclassOfId = 0x8af52aac;
        this._slots = [
          'silent',
          'background',
          'clearDraft',
          'noforwards',
          'updateStickersetsOrder',
          'invertMedia',
          'peer',
          'replyTo',
          'media',
          'message',
          'randomId',
          'replyMarkup',
          'entities',
          'scheduleDate',
          'sendAs',
        ];
        this.silent = params.silent;
        this.background = params.background;
        this.clearDraft = params.clearDraft;
        this.noforwards = params.noforwards;
        this.updateStickersetsOrder = params.updateStickersetsOrder;
        this.invertMedia = params.invertMedia;
        this.peer = params.peer;
        this.replyTo = params.replyTo;
        this.media = params.media;
        this.message = params.message;
        this.randomId = params.randomId;
        this.replyMarkup = params.replyMarkup;
        this.entities = params.entities;
        this.scheduleDate = params.scheduleDate;
        this.sendAs = params.sendAs;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SendMedia> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let silent = flags & (1 << 5) ? true : false;
        let background = flags & (1 << 6) ? true : false;
        let clearDraft = flags & (1 << 7) ? true : false;
        let noforwards = flags & (1 << 14) ? true : false;
        let updateStickersetsOrder = flags & (1 << 15) ? true : false;
        let invertMedia = flags & (1 << 16) ? true : false;
        let peer = await TLObject.read(b);
        let replyTo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let media = await TLObject.read(b);
        let message = await Primitive.String.read(b);
        let randomId = await Primitive.Long.read(b);
        let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let entities = flags & (1 << 3) ? await TLObject.read(b) : [];
        let scheduleDate = flags & (1 << 10) ? await Primitive.Int.read(b) : undefined;
        let sendAs = flags & (1 << 13) ? await TLObject.read(b) : undefined;
        return new Raw.messages.SendMedia({
          silent: silent,
          background: background,
          clearDraft: clearDraft,
          noforwards: noforwards,
          updateStickersetsOrder: updateStickersetsOrder,
          invertMedia: invertMedia,
          peer: peer,
          replyTo: replyTo,
          media: media,
          message: message,
          randomId: randomId,
          replyMarkup: replyMarkup,
          entities: entities,
          scheduleDate: scheduleDate,
          sendAs: sendAs,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.silent ? 1 << 5 : 0;
        flags |= this.background ? 1 << 6 : 0;
        flags |= this.clearDraft ? 1 << 7 : 0;
        flags |= this.noforwards ? 1 << 14 : 0;
        flags |= this.updateStickersetsOrder ? 1 << 15 : 0;
        flags |= this.invertMedia ? 1 << 16 : 0;
        flags |= this.replyTo !== undefined ? 1 << 0 : 0;
        flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
        flags |= this.entities ? 1 << 3 : 0;
        flags |= this.scheduleDate !== undefined ? 1 << 10 : 0;
        flags |= this.sendAs !== undefined ? 1 << 13 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.replyTo !== undefined) {
          b.write(this.replyTo.write() as unknown as Buffer);
        }
        if (this.media !== undefined) {
          b.write(this.media.write() as unknown as Buffer);
        }
        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
        }
        if (this.replyMarkup !== undefined) {
          b.write(this.replyMarkup.write() as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        if (this.scheduleDate !== undefined) {
          b.write(Primitive.Int.write(this.scheduleDate) as unknown as Buffer);
        }
        if (this.sendAs !== undefined) {
          b.write(this.sendAs.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ForwardMessages extends TLObject {
      __response__!: Raw.TypeUpdates;
      silent?: boolean;
      background?: boolean;
      withMyScore?: boolean;
      dropAuthor?: boolean;
      dropMediaCaptions?: boolean;
      noforwards?: boolean;
      fromPeer!: Raw.TypeInputPeer;
      id!: Vector<int>;
      randomId!: Vector<long>;
      toPeer!: Raw.TypeInputPeer;
      topMsgId?: int;
      scheduleDate?: int;
      sendAs?: Raw.TypeInputPeer;

      constructor(params: {
        silent?: boolean;
        background?: boolean;
        withMyScore?: boolean;
        dropAuthor?: boolean;
        dropMediaCaptions?: boolean;
        noforwards?: boolean;
        fromPeer: Raw.TypeInputPeer;
        id: Vector<int>;
        randomId: Vector<long>;
        toPeer: Raw.TypeInputPeer;
        topMsgId?: int;
        scheduleDate?: int;
        sendAs?: Raw.TypeInputPeer;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ForwardMessages';
        this.constructorId = 0xc661bbc4;
        this.subclassOfId = 0x8af52aac;
        this._slots = [
          'silent',
          'background',
          'withMyScore',
          'dropAuthor',
          'dropMediaCaptions',
          'noforwards',
          'fromPeer',
          'id',
          'randomId',
          'toPeer',
          'topMsgId',
          'scheduleDate',
          'sendAs',
        ];
        this.silent = params.silent;
        this.background = params.background;
        this.withMyScore = params.withMyScore;
        this.dropAuthor = params.dropAuthor;
        this.dropMediaCaptions = params.dropMediaCaptions;
        this.noforwards = params.noforwards;
        this.fromPeer = params.fromPeer;
        this.id = params.id;
        this.randomId = params.randomId;
        this.toPeer = params.toPeer;
        this.topMsgId = params.topMsgId;
        this.scheduleDate = params.scheduleDate;
        this.sendAs = params.sendAs;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ForwardMessages> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let silent = flags & (1 << 5) ? true : false;
        let background = flags & (1 << 6) ? true : false;
        let withMyScore = flags & (1 << 8) ? true : false;
        let dropAuthor = flags & (1 << 11) ? true : false;
        let dropMediaCaptions = flags & (1 << 12) ? true : false;
        let noforwards = flags & (1 << 14) ? true : false;
        let fromPeer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        let randomId = await TLObject.read(b, Primitive.Long);
        let toPeer = await TLObject.read(b);
        let topMsgId = flags & (1 << 9) ? await Primitive.Int.read(b) : undefined;
        let scheduleDate = flags & (1 << 10) ? await Primitive.Int.read(b) : undefined;
        let sendAs = flags & (1 << 13) ? await TLObject.read(b) : undefined;
        return new Raw.messages.ForwardMessages({
          silent: silent,
          background: background,
          withMyScore: withMyScore,
          dropAuthor: dropAuthor,
          dropMediaCaptions: dropMediaCaptions,
          noforwards: noforwards,
          fromPeer: fromPeer,
          id: id,
          randomId: randomId,
          toPeer: toPeer,
          topMsgId: topMsgId,
          scheduleDate: scheduleDate,
          sendAs: sendAs,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.silent ? 1 << 5 : 0;
        flags |= this.background ? 1 << 6 : 0;
        flags |= this.withMyScore ? 1 << 8 : 0;
        flags |= this.dropAuthor ? 1 << 11 : 0;
        flags |= this.dropMediaCaptions ? 1 << 12 : 0;
        flags |= this.noforwards ? 1 << 14 : 0;
        flags |= this.topMsgId !== undefined ? 1 << 9 : 0;
        flags |= this.scheduleDate !== undefined ? 1 << 10 : 0;
        flags |= this.sendAs !== undefined ? 1 << 13 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.fromPeer !== undefined) {
          b.write(this.fromPeer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        if (this.randomId) {
          b.write(Primitive.Vector.write(this.randomId, Primitive.Long) as unknown as Buffer);
        }
        if (this.toPeer !== undefined) {
          b.write(this.toPeer.write() as unknown as Buffer);
        }
        if (this.topMsgId !== undefined) {
          b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
        }
        if (this.scheduleDate !== undefined) {
          b.write(Primitive.Int.write(this.scheduleDate) as unknown as Buffer);
        }
        if (this.sendAs !== undefined) {
          b.write(this.sendAs.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReportSpam extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReportSpam';
        this.constructorId = 0xcf1592db;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ReportSpam> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.messages.ReportSpam({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPeerSettings extends TLObject {
      __response__!: Raw.messages.TypePeerSettings;
      peer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetPeerSettings';
        this.constructorId = 0xefd9a6a2;
        this.subclassOfId = 0x65a2f7a1;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetPeerSettings> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.messages.GetPeerSettings({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Report extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;
      reason!: Raw.TypeReportReason;
      message!: string;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        id: Vector<int>;
        reason: Raw.TypeReportReason;
        message: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.Report';
        this.constructorId = 0x8953ab4e;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'id', 'reason', 'message'];
        this.peer = params.peer;
        this.id = params.id;
        this.reason = params.reason;
        this.message = params.message;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.Report> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        let reason = await TLObject.read(b);
        let message = await Primitive.String.read(b);
        return new Raw.messages.Report({ peer: peer, id: id, reason: reason, message: message });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        if (this.reason !== undefined) {
          b.write(this.reason.write() as unknown as Buffer);
        }
        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetChats extends TLObject {
      __response__!: Raw.messages.TypeChats;
      id!: Vector<long>;

      constructor(params: { id: Vector<long> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetChats';
        this.constructorId = 0x49e9528f;
        this.subclassOfId = 0x99d5cb14;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetChats> {
        // no flags

        let id = await TLObject.read(b, Primitive.Long);
        return new Raw.messages.GetChats({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Long) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetFullChat extends TLObject {
      __response__!: Raw.messages.TypeChatFull;
      chatId!: long;

      constructor(params: { chatId: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetFullChat';
        this.constructorId = 0xaeb00b34;
        this.subclassOfId = 0x225a5109;
        this._slots = ['chatId'];
        this.chatId = params.chatId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetFullChat> {
        // no flags

        let chatId = await Primitive.Long.read(b);
        return new Raw.messages.GetFullChat({ chatId: chatId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatId !== undefined) {
          b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditChatTitle extends TLObject {
      __response__!: Raw.TypeUpdates;
      chatId!: long;
      title!: string;

      constructor(params: { chatId: long; title: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.EditChatTitle';
        this.constructorId = 0x73783ffd;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['chatId', 'title'];
        this.chatId = params.chatId;
        this.title = params.title;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.EditChatTitle> {
        // no flags

        let chatId = await Primitive.Long.read(b);
        let title = await Primitive.String.read(b);
        return new Raw.messages.EditChatTitle({ chatId: chatId, title: title });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatId !== undefined) {
          b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditChatPhoto extends TLObject {
      __response__!: Raw.TypeUpdates;
      chatId!: long;
      photo!: Raw.TypeInputChatPhoto;

      constructor(params: { chatId: long; photo: Raw.TypeInputChatPhoto }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.EditChatPhoto';
        this.constructorId = 0x35ddd674;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['chatId', 'photo'];
        this.chatId = params.chatId;
        this.photo = params.photo;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.EditChatPhoto> {
        // no flags

        let chatId = await Primitive.Long.read(b);
        let photo = await TLObject.read(b);
        return new Raw.messages.EditChatPhoto({ chatId: chatId, photo: photo });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatId !== undefined) {
          b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
        }
        if (this.photo !== undefined) {
          b.write(this.photo.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AddChatUser extends TLObject {
      __response__!: Raw.TypeUpdates;
      chatId!: long;
      userId!: Raw.TypeInputUser;
      fwdLimit!: int;

      constructor(params: { chatId: long; userId: Raw.TypeInputUser; fwdLimit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.AddChatUser';
        this.constructorId = 0xf24753e3;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['chatId', 'userId', 'fwdLimit'];
        this.chatId = params.chatId;
        this.userId = params.userId;
        this.fwdLimit = params.fwdLimit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.AddChatUser> {
        // no flags

        let chatId = await Primitive.Long.read(b);
        let userId = await TLObject.read(b);
        let fwdLimit = await Primitive.Int.read(b);
        return new Raw.messages.AddChatUser({ chatId: chatId, userId: userId, fwdLimit: fwdLimit });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatId !== undefined) {
          b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
        }
        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.fwdLimit !== undefined) {
          b.write(Primitive.Int.write(this.fwdLimit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteChatUser extends TLObject {
      __response__!: Raw.TypeUpdates;
      revokeHistory?: boolean;
      chatId!: long;
      userId!: Raw.TypeInputUser;

      constructor(params: { revokeHistory?: boolean; chatId: long; userId: Raw.TypeInputUser }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.DeleteChatUser';
        this.constructorId = 0xa2185cab;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['revokeHistory', 'chatId', 'userId'];
        this.revokeHistory = params.revokeHistory;
        this.chatId = params.chatId;
        this.userId = params.userId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.DeleteChatUser> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let revokeHistory = flags & (1 << 0) ? true : false;
        let chatId = await Primitive.Long.read(b);
        let userId = await TLObject.read(b);
        return new Raw.messages.DeleteChatUser({
          revokeHistory: revokeHistory,
          chatId: chatId,
          userId: userId,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.revokeHistory ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.chatId !== undefined) {
          b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
        }
        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CreateChat extends TLObject {
      __response__!: Raw.TypeUpdates;
      users!: Vector<Raw.TypeInputUser>;
      title!: string;
      ttlPeriod?: int;

      constructor(params: { users: Vector<Raw.TypeInputUser>; title: string; ttlPeriod?: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.CreateChat';
        this.constructorId = 0x34a818;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['users', 'title', 'ttlPeriod'];
        this.users = params.users;
        this.title = params.title;
        this.ttlPeriod = params.ttlPeriod;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.CreateChat> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let users = await TLObject.read(b);
        let title = await Primitive.String.read(b);
        let ttlPeriod = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        return new Raw.messages.CreateChat({ users: users, title: title, ttlPeriod: ttlPeriod });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.ttlPeriod !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.ttlPeriod !== undefined) {
          b.write(Primitive.Int.write(this.ttlPeriod) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDhConfig extends TLObject {
      __response__!: Raw.messages.TypeDhConfig;
      version!: int;
      randomLength!: int;

      constructor(params: { version: int; randomLength: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetDhConfig';
        this.constructorId = 0x26cf8950;
        this.subclassOfId = 0xe488ed8b;
        this._slots = ['version', 'randomLength'];
        this.version = params.version;
        this.randomLength = params.randomLength;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetDhConfig> {
        // no flags

        let version = await Primitive.Int.read(b);
        let randomLength = await Primitive.Int.read(b);
        return new Raw.messages.GetDhConfig({ version: version, randomLength: randomLength });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.version !== undefined) {
          b.write(Primitive.Int.write(this.version) as unknown as Buffer);
        }
        if (this.randomLength !== undefined) {
          b.write(Primitive.Int.write(this.randomLength) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RequestEncryption extends TLObject {
      __response__!: Raw.TypeEncryptedChat;
      userId!: Raw.TypeInputUser;
      randomId!: int;
      gA!: bytes;

      constructor(params: { userId: Raw.TypeInputUser; randomId: int; gA: bytes }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.RequestEncryption';
        this.constructorId = 0xf64daf43;
        this.subclassOfId = 0x6d28a37a;
        this._slots = ['userId', 'randomId', 'gA'];
        this.userId = params.userId;
        this.randomId = params.randomId;
        this.gA = params.gA;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.RequestEncryption> {
        // no flags

        let userId = await TLObject.read(b);
        let randomId = await Primitive.Int.read(b);
        let gA = await Primitive.Bytes.read(b);
        return new Raw.messages.RequestEncryption({ userId: userId, randomId: randomId, gA: gA });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Int.write(this.randomId) as unknown as Buffer);
        }
        if (this.gA !== undefined) {
          b.write(Primitive.Bytes.write(this.gA) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AcceptEncryption extends TLObject {
      __response__!: Raw.TypeEncryptedChat;
      peer!: Raw.TypeInputEncryptedChat;
      gB!: bytes;
      keyFingerprint!: long;

      constructor(params: { peer: Raw.TypeInputEncryptedChat; gB: bytes; keyFingerprint: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.AcceptEncryption';
        this.constructorId = 0x3dbc0415;
        this.subclassOfId = 0x6d28a37a;
        this._slots = ['peer', 'gB', 'keyFingerprint'];
        this.peer = params.peer;
        this.gB = params.gB;
        this.keyFingerprint = params.keyFingerprint;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.AcceptEncryption> {
        // no flags

        let peer = await TLObject.read(b);
        let gB = await Primitive.Bytes.read(b);
        let keyFingerprint = await Primitive.Long.read(b);
        return new Raw.messages.AcceptEncryption({
          peer: peer,
          gB: gB,
          keyFingerprint: keyFingerprint,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.gB !== undefined) {
          b.write(Primitive.Bytes.write(this.gB) as unknown as Buffer);
        }
        if (this.keyFingerprint !== undefined) {
          b.write(Primitive.Long.write(this.keyFingerprint) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DiscardEncryption extends TLObject {
      __response__!: Bool;
      deleteHistory?: boolean;
      chatId!: int;

      constructor(params: { deleteHistory?: boolean; chatId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.DiscardEncryption';
        this.constructorId = 0xf393aea0;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['deleteHistory', 'chatId'];
        this.deleteHistory = params.deleteHistory;
        this.chatId = params.chatId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.DiscardEncryption> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let deleteHistory = flags & (1 << 0) ? true : false;
        let chatId = await Primitive.Int.read(b);
        return new Raw.messages.DiscardEncryption({ deleteHistory: deleteHistory, chatId: chatId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.deleteHistory ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.chatId !== undefined) {
          b.write(Primitive.Int.write(this.chatId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetEncryptedTyping extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputEncryptedChat;
      typing!: Bool;

      constructor(params: { peer: Raw.TypeInputEncryptedChat; typing: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetEncryptedTyping';
        this.constructorId = 0x791451ed;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'typing'];
        this.peer = params.peer;
        this.typing = params.typing;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SetEncryptedTyping> {
        // no flags

        let peer = await TLObject.read(b);
        let typing = await Primitive.Bool.read(b);
        return new Raw.messages.SetEncryptedTyping({ peer: peer, typing: typing });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.typing !== undefined) {
          b.write(Primitive.Bool.write(this.typing) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReadEncryptedHistory extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputEncryptedChat;
      maxDate!: int;

      constructor(params: { peer: Raw.TypeInputEncryptedChat; maxDate: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReadEncryptedHistory';
        this.constructorId = 0x7f4b690a;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'maxDate'];
        this.peer = params.peer;
        this.maxDate = params.maxDate;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ReadEncryptedHistory> {
        // no flags

        let peer = await TLObject.read(b);
        let maxDate = await Primitive.Int.read(b);
        return new Raw.messages.ReadEncryptedHistory({ peer: peer, maxDate: maxDate });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.maxDate !== undefined) {
          b.write(Primitive.Int.write(this.maxDate) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendEncrypted extends TLObject {
      __response__!: Raw.messages.TypeSentEncryptedMessage;
      silent?: boolean;
      peer!: Raw.TypeInputEncryptedChat;
      randomId!: long;
      data!: bytes;

      constructor(params: {
        silent?: boolean;
        peer: Raw.TypeInputEncryptedChat;
        randomId: long;
        data: bytes;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendEncrypted';
        this.constructorId = 0x44fa7a15;
        this.subclassOfId = 0xc99e3e50;
        this._slots = ['silent', 'peer', 'randomId', 'data'];
        this.silent = params.silent;
        this.peer = params.peer;
        this.randomId = params.randomId;
        this.data = params.data;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SendEncrypted> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let silent = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        let randomId = await Primitive.Long.read(b);
        let data = await Primitive.Bytes.read(b);
        return new Raw.messages.SendEncrypted({
          silent: silent,
          peer: peer,
          randomId: randomId,
          data: data,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.silent ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
        }
        if (this.data !== undefined) {
          b.write(Primitive.Bytes.write(this.data) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendEncryptedFile extends TLObject {
      __response__!: Raw.messages.TypeSentEncryptedMessage;
      silent?: boolean;
      peer!: Raw.TypeInputEncryptedChat;
      randomId!: long;
      data!: bytes;
      file!: Raw.TypeInputEncryptedFile;

      constructor(params: {
        silent?: boolean;
        peer: Raw.TypeInputEncryptedChat;
        randomId: long;
        data: bytes;
        file: Raw.TypeInputEncryptedFile;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendEncryptedFile';
        this.constructorId = 0x5559481d;
        this.subclassOfId = 0xc99e3e50;
        this._slots = ['silent', 'peer', 'randomId', 'data', 'file'];
        this.silent = params.silent;
        this.peer = params.peer;
        this.randomId = params.randomId;
        this.data = params.data;
        this.file = params.file;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SendEncryptedFile> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let silent = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        let randomId = await Primitive.Long.read(b);
        let data = await Primitive.Bytes.read(b);
        let file = await TLObject.read(b);
        return new Raw.messages.SendEncryptedFile({
          silent: silent,
          peer: peer,
          randomId: randomId,
          data: data,
          file: file,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.silent ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
        }
        if (this.data !== undefined) {
          b.write(Primitive.Bytes.write(this.data) as unknown as Buffer);
        }
        if (this.file !== undefined) {
          b.write(this.file.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendEncryptedService extends TLObject {
      __response__!: Raw.messages.TypeSentEncryptedMessage;
      peer!: Raw.TypeInputEncryptedChat;
      randomId!: long;
      data!: bytes;

      constructor(params: { peer: Raw.TypeInputEncryptedChat; randomId: long; data: bytes }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendEncryptedService';
        this.constructorId = 0x32d439a4;
        this.subclassOfId = 0xc99e3e50;
        this._slots = ['peer', 'randomId', 'data'];
        this.peer = params.peer;
        this.randomId = params.randomId;
        this.data = params.data;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SendEncryptedService> {
        // no flags

        let peer = await TLObject.read(b);
        let randomId = await Primitive.Long.read(b);
        let data = await Primitive.Bytes.read(b);
        return new Raw.messages.SendEncryptedService({
          peer: peer,
          randomId: randomId,
          data: data,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
        }
        if (this.data !== undefined) {
          b.write(Primitive.Bytes.write(this.data) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReceivedQueue extends TLObject {
      __response__!: Vector<long>;
      maxQts!: int;

      constructor(params: { maxQts: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReceivedQueue';
        this.constructorId = 0x55a5bb66;
        this.subclassOfId = 0x8918e168;
        this._slots = ['maxQts'];
        this.maxQts = params.maxQts;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ReceivedQueue> {
        // no flags

        let maxQts = await Primitive.Int.read(b);
        return new Raw.messages.ReceivedQueue({ maxQts: maxQts });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.maxQts !== undefined) {
          b.write(Primitive.Int.write(this.maxQts) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReportEncryptedSpam extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputEncryptedChat;

      constructor(params: { peer: Raw.TypeInputEncryptedChat }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReportEncryptedSpam';
        this.constructorId = 0x4b0c8c0f;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ReportEncryptedSpam> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.messages.ReportEncryptedSpam({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReadMessageContents extends TLObject {
      __response__!: Raw.messages.TypeAffectedMessages;
      id!: Vector<int>;

      constructor(params: { id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReadMessageContents';
        this.constructorId = 0x36a73f77;
        this.subclassOfId = 0xced3c06e;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ReadMessageContents> {
        // no flags

        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.messages.ReadMessageContents({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetStickers extends TLObject {
      __response__!: Raw.messages.TypeStickers;
      emoticon!: string;
      hash!: long;

      constructor(params: { emoticon: string; hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetStickers';
        this.constructorId = 0xd5a5d3a1;
        this.subclassOfId = 0xd73bb9de;
        this._slots = ['emoticon', 'hash'];
        this.emoticon = params.emoticon;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetStickers> {
        // no flags

        let emoticon = await Primitive.String.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetStickers({ emoticon: emoticon, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.emoticon !== undefined) {
          b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAllStickers extends TLObject {
      __response__!: Raw.messages.TypeAllStickers;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetAllStickers';
        this.constructorId = 0xb8a0a1a8;
        this.subclassOfId = 0x45834829;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetAllStickers> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetAllStickers({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetWebPagePreview extends TLObject {
      __response__!: Raw.TypeMessageMedia;
      message!: string;
      entities?: Vector<Raw.TypeMessageEntity>;

      constructor(params: { message: string; entities?: Vector<Raw.TypeMessageEntity> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetWebPagePreview';
        this.constructorId = 0x8b68b0cc;
        this.subclassOfId = 0x476cbe32;
        this._slots = ['message', 'entities'];
        this.message = params.message;
        this.entities = params.entities;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetWebPagePreview> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let message = await Primitive.String.read(b);
        let entities = flags & (1 << 3) ? await TLObject.read(b) : [];
        return new Raw.messages.GetWebPagePreview({ message: message, entities: entities });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.entities ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportChatInvite extends TLObject {
      __response__!: Raw.TypeExportedChatInvite;
      legacyRevokePermanent?: boolean;
      requestNeeded?: boolean;
      peer!: Raw.TypeInputPeer;
      expireDate?: int;
      usageLimit?: int;
      title?: string;

      constructor(params: {
        legacyRevokePermanent?: boolean;
        requestNeeded?: boolean;
        peer: Raw.TypeInputPeer;
        expireDate?: int;
        usageLimit?: int;
        title?: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ExportChatInvite';
        this.constructorId = 0xa02ce5d5;
        this.subclassOfId = 0xb4748a58;
        this._slots = [
          'legacyRevokePermanent',
          'requestNeeded',
          'peer',
          'expireDate',
          'usageLimit',
          'title',
        ];
        this.legacyRevokePermanent = params.legacyRevokePermanent;
        this.requestNeeded = params.requestNeeded;
        this.peer = params.peer;
        this.expireDate = params.expireDate;
        this.usageLimit = params.usageLimit;
        this.title = params.title;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ExportChatInvite> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let legacyRevokePermanent = flags & (1 << 2) ? true : false;
        let requestNeeded = flags & (1 << 3) ? true : false;
        let peer = await TLObject.read(b);
        let expireDate = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let usageLimit = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let title = flags & (1 << 4) ? await Primitive.String.read(b) : undefined;
        return new Raw.messages.ExportChatInvite({
          legacyRevokePermanent: legacyRevokePermanent,
          requestNeeded: requestNeeded,
          peer: peer,
          expireDate: expireDate,
          usageLimit: usageLimit,
          title: title,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.legacyRevokePermanent ? 1 << 2 : 0;
        flags |= this.requestNeeded ? 1 << 3 : 0;
        flags |= this.expireDate !== undefined ? 1 << 0 : 0;
        flags |= this.usageLimit !== undefined ? 1 << 1 : 0;
        flags |= this.title !== undefined ? 1 << 4 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.expireDate !== undefined) {
          b.write(Primitive.Int.write(this.expireDate) as unknown as Buffer);
        }
        if (this.usageLimit !== undefined) {
          b.write(Primitive.Int.write(this.usageLimit) as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CheckChatInvite extends TLObject {
      __response__!: Raw.TypeChatInvite;
      hash!: string;

      constructor(params: { hash: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.CheckChatInvite';
        this.constructorId = 0x3eadb1bb;
        this.subclassOfId = 0x4561736;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.CheckChatInvite> {
        // no flags

        let hash = await Primitive.String.read(b);
        return new Raw.messages.CheckChatInvite({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.String.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ImportChatInvite extends TLObject {
      __response__!: Raw.TypeUpdates;
      hash!: string;

      constructor(params: { hash: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ImportChatInvite';
        this.constructorId = 0x6c50051c;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ImportChatInvite> {
        // no flags

        let hash = await Primitive.String.read(b);
        return new Raw.messages.ImportChatInvite({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.String.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetStickerSet extends TLObject {
      __response__!: Raw.messages.TypeStickerSet;
      stickerset!: Raw.TypeInputStickerSet;
      hash!: int;

      constructor(params: { stickerset: Raw.TypeInputStickerSet; hash: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetStickerSet';
        this.constructorId = 0xc8a0ec74;
        this.subclassOfId = 0x9b704a5a;
        this._slots = ['stickerset', 'hash'];
        this.stickerset = params.stickerset;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetStickerSet> {
        // no flags

        let stickerset = await TLObject.read(b);
        let hash = await Primitive.Int.read(b);
        return new Raw.messages.GetStickerSet({ stickerset: stickerset, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.stickerset !== undefined) {
          b.write(this.stickerset.write() as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class InstallStickerSet extends TLObject {
      __response__!: Raw.messages.TypeStickerSetInstallResult;
      stickerset!: Raw.TypeInputStickerSet;
      archived!: Bool;

      constructor(params: { stickerset: Raw.TypeInputStickerSet; archived: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.InstallStickerSet';
        this.constructorId = 0xc78fe460;
        this.subclassOfId = 0x67cb3fe8;
        this._slots = ['stickerset', 'archived'];
        this.stickerset = params.stickerset;
        this.archived = params.archived;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.InstallStickerSet> {
        // no flags

        let stickerset = await TLObject.read(b);
        let archived = await Primitive.Bool.read(b);
        return new Raw.messages.InstallStickerSet({ stickerset: stickerset, archived: archived });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.stickerset !== undefined) {
          b.write(this.stickerset.write() as unknown as Buffer);
        }
        if (this.archived !== undefined) {
          b.write(Primitive.Bool.write(this.archived) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UninstallStickerSet extends TLObject {
      __response__!: Bool;
      stickerset!: Raw.TypeInputStickerSet;

      constructor(params: { stickerset: Raw.TypeInputStickerSet }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.UninstallStickerSet';
        this.constructorId = 0xf96e55de;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['stickerset'];
        this.stickerset = params.stickerset;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.UninstallStickerSet> {
        // no flags

        let stickerset = await TLObject.read(b);
        return new Raw.messages.UninstallStickerSet({ stickerset: stickerset });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.stickerset !== undefined) {
          b.write(this.stickerset.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class StartBot extends TLObject {
      __response__!: Raw.TypeUpdates;
      bot!: Raw.TypeInputUser;
      peer!: Raw.TypeInputPeer;
      randomId!: long;
      startParam!: string;

      constructor(params: {
        bot: Raw.TypeInputUser;
        peer: Raw.TypeInputPeer;
        randomId: long;
        startParam: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.StartBot';
        this.constructorId = 0xe6df7378;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['bot', 'peer', 'randomId', 'startParam'];
        this.bot = params.bot;
        this.peer = params.peer;
        this.randomId = params.randomId;
        this.startParam = params.startParam;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.StartBot> {
        // no flags

        let bot = await TLObject.read(b);
        let peer = await TLObject.read(b);
        let randomId = await Primitive.Long.read(b);
        let startParam = await Primitive.String.read(b);
        return new Raw.messages.StartBot({
          bot: bot,
          peer: peer,
          randomId: randomId,
          startParam: startParam,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
        }
        if (this.startParam !== undefined) {
          b.write(Primitive.String.write(this.startParam) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetMessagesViews extends TLObject {
      __response__!: Raw.messages.TypeMessageViews;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;
      increment!: Bool;

      constructor(params: { peer: Raw.TypeInputPeer; id: Vector<int>; increment: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetMessagesViews';
        this.constructorId = 0x5784d3e1;
        this.subclassOfId = 0xafb5eb9c;
        this._slots = ['peer', 'id', 'increment'];
        this.peer = params.peer;
        this.id = params.id;
        this.increment = params.increment;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetMessagesViews> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        let increment = await Primitive.Bool.read(b);
        return new Raw.messages.GetMessagesViews({ peer: peer, id: id, increment: increment });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        if (this.increment !== undefined) {
          b.write(Primitive.Bool.write(this.increment) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditChatAdmin extends TLObject {
      __response__!: Bool;
      chatId!: long;
      userId!: Raw.TypeInputUser;
      isAdmin!: Bool;

      constructor(params: { chatId: long; userId: Raw.TypeInputUser; isAdmin: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.EditChatAdmin';
        this.constructorId = 0xa85bd1c2;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['chatId', 'userId', 'isAdmin'];
        this.chatId = params.chatId;
        this.userId = params.userId;
        this.isAdmin = params.isAdmin;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.EditChatAdmin> {
        // no flags

        let chatId = await Primitive.Long.read(b);
        let userId = await TLObject.read(b);
        let isAdmin = await Primitive.Bool.read(b);
        return new Raw.messages.EditChatAdmin({ chatId: chatId, userId: userId, isAdmin: isAdmin });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatId !== undefined) {
          b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
        }
        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.isAdmin !== undefined) {
          b.write(Primitive.Bool.write(this.isAdmin) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class MigrateChat extends TLObject {
      __response__!: Raw.TypeUpdates;
      chatId!: long;

      constructor(params: { chatId: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.MigrateChat';
        this.constructorId = 0xa2875319;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['chatId'];
        this.chatId = params.chatId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.MigrateChat> {
        // no flags

        let chatId = await Primitive.Long.read(b);
        return new Raw.messages.MigrateChat({ chatId: chatId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatId !== undefined) {
          b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SearchGlobal extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      folderId?: int;
      q!: string;
      filter!: Raw.TypeMessagesFilter;
      minDate!: int;
      maxDate!: int;
      offsetRate!: int;
      offsetPeer!: Raw.TypeInputPeer;
      offsetId!: int;
      limit!: int;

      constructor(params: {
        folderId?: int;
        q: string;
        filter: Raw.TypeMessagesFilter;
        minDate: int;
        maxDate: int;
        offsetRate: int;
        offsetPeer: Raw.TypeInputPeer;
        offsetId: int;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SearchGlobal';
        this.constructorId = 0x4bc6589a;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = [
          'folderId',
          'q',
          'filter',
          'minDate',
          'maxDate',
          'offsetRate',
          'offsetPeer',
          'offsetId',
          'limit',
        ];
        this.folderId = params.folderId;
        this.q = params.q;
        this.filter = params.filter;
        this.minDate = params.minDate;
        this.maxDate = params.maxDate;
        this.offsetRate = params.offsetRate;
        this.offsetPeer = params.offsetPeer;
        this.offsetId = params.offsetId;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SearchGlobal> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let folderId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let q = await Primitive.String.read(b);
        let filter = await TLObject.read(b);
        let minDate = await Primitive.Int.read(b);
        let maxDate = await Primitive.Int.read(b);
        let offsetRate = await Primitive.Int.read(b);
        let offsetPeer = await TLObject.read(b);
        let offsetId = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.messages.SearchGlobal({
          folderId: folderId,
          q: q,
          filter: filter,
          minDate: minDate,
          maxDate: maxDate,
          offsetRate: offsetRate,
          offsetPeer: offsetPeer,
          offsetId: offsetId,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.folderId !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.folderId !== undefined) {
          b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
        }
        if (this.q !== undefined) {
          b.write(Primitive.String.write(this.q) as unknown as Buffer);
        }
        if (this.filter !== undefined) {
          b.write(this.filter.write() as unknown as Buffer);
        }
        if (this.minDate !== undefined) {
          b.write(Primitive.Int.write(this.minDate) as unknown as Buffer);
        }
        if (this.maxDate !== undefined) {
          b.write(Primitive.Int.write(this.maxDate) as unknown as Buffer);
        }
        if (this.offsetRate !== undefined) {
          b.write(Primitive.Int.write(this.offsetRate) as unknown as Buffer);
        }
        if (this.offsetPeer !== undefined) {
          b.write(this.offsetPeer.write() as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReorderStickerSets extends TLObject {
      __response__!: Bool;
      masks?: boolean;
      emojis?: boolean;
      order!: Vector<long>;

      constructor(params: { masks?: boolean; emojis?: boolean; order: Vector<long> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReorderStickerSets';
        this.constructorId = 0x78337739;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['masks', 'emojis', 'order'];
        this.masks = params.masks;
        this.emojis = params.emojis;
        this.order = params.order;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ReorderStickerSets> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let masks = flags & (1 << 0) ? true : false;
        let emojis = flags & (1 << 1) ? true : false;
        let order = await TLObject.read(b, Primitive.Long);
        return new Raw.messages.ReorderStickerSets({ masks: masks, emojis: emojis, order: order });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.masks ? 1 << 0 : 0;
        flags |= this.emojis ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.order) {
          b.write(Primitive.Vector.write(this.order, Primitive.Long) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDocumentByHash extends TLObject {
      __response__!: Raw.TypeDocument;
      sha256!: bytes;
      size!: long;
      mimeType!: string;

      constructor(params: { sha256: bytes; size: long; mimeType: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetDocumentByHash';
        this.constructorId = 0xb1f2061f;
        this.subclassOfId = 0x211fe820;
        this._slots = ['sha256', 'size', 'mimeType'];
        this.sha256 = params.sha256;
        this.size = params.size;
        this.mimeType = params.mimeType;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetDocumentByHash> {
        // no flags

        let sha256 = await Primitive.Bytes.read(b);
        let size = await Primitive.Long.read(b);
        let mimeType = await Primitive.String.read(b);
        return new Raw.messages.GetDocumentByHash({
          sha256: sha256,
          size: size,
          mimeType: mimeType,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.sha256 !== undefined) {
          b.write(Primitive.Bytes.write(this.sha256) as unknown as Buffer);
        }
        if (this.size !== undefined) {
          b.write(Primitive.Long.write(this.size) as unknown as Buffer);
        }
        if (this.mimeType !== undefined) {
          b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetSavedGifs extends TLObject {
      __response__!: Raw.messages.TypeSavedGifs;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetSavedGifs';
        this.constructorId = 0x5cf09635;
        this.subclassOfId = 0xa68b61f5;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetSavedGifs> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetSavedGifs({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveGif extends TLObject {
      __response__!: Bool;
      id!: Raw.TypeInputDocument;
      unsave!: Bool;

      constructor(params: { id: Raw.TypeInputDocument; unsave: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SaveGif';
        this.constructorId = 0x327a30cb;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['id', 'unsave'];
        this.id = params.id;
        this.unsave = params.unsave;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SaveGif> {
        // no flags

        let id = await TLObject.read(b);
        let unsave = await Primitive.Bool.read(b);
        return new Raw.messages.SaveGif({ id: id, unsave: unsave });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        if (this.unsave !== undefined) {
          b.write(Primitive.Bool.write(this.unsave) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetInlineBotResults extends TLObject {
      __response__!: Raw.messages.TypeBotResults;
      bot!: Raw.TypeInputUser;
      peer!: Raw.TypeInputPeer;
      geoPoint?: Raw.TypeInputGeoPoint;
      query!: string;
      offset!: string;

      constructor(params: {
        bot: Raw.TypeInputUser;
        peer: Raw.TypeInputPeer;
        geoPoint?: Raw.TypeInputGeoPoint;
        query: string;
        offset: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetInlineBotResults';
        this.constructorId = 0x514e999d;
        this.subclassOfId = 0x3ed4d9c9;
        this._slots = ['bot', 'peer', 'geoPoint', 'query', 'offset'];
        this.bot = params.bot;
        this.peer = params.peer;
        this.geoPoint = params.geoPoint;
        this.query = params.query;
        this.offset = params.offset;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetInlineBotResults> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let bot = await TLObject.read(b);
        let peer = await TLObject.read(b);
        let geoPoint = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let query = await Primitive.String.read(b);
        let offset = await Primitive.String.read(b);
        return new Raw.messages.GetInlineBotResults({
          bot: bot,
          peer: peer,
          geoPoint: geoPoint,
          query: query,
          offset: offset,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.geoPoint !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.geoPoint !== undefined) {
          b.write(this.geoPoint.write() as unknown as Buffer);
        }
        if (this.query !== undefined) {
          b.write(Primitive.String.write(this.query) as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.String.write(this.offset) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetInlineBotResults extends TLObject {
      __response__!: Bool;
      gallery?: boolean;
      private?: boolean;
      queryId!: long;
      results!: Vector<Raw.TypeInputBotInlineResult>;
      cacheTime!: int;
      nextOffset?: string;
      switchPm?: Raw.TypeInlineBotSwitchPM;
      switchWebview?: Raw.TypeInlineBotWebView;

      constructor(params: {
        gallery?: boolean;
        private?: boolean;
        queryId: long;
        results: Vector<Raw.TypeInputBotInlineResult>;
        cacheTime: int;
        nextOffset?: string;
        switchPm?: Raw.TypeInlineBotSwitchPM;
        switchWebview?: Raw.TypeInlineBotWebView;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetInlineBotResults';
        this.constructorId = 0xbb12a419;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [
          'gallery',
          'private',
          'queryId',
          'results',
          'cacheTime',
          'nextOffset',
          'switchPm',
          'switchWebview',
        ];
        this.gallery = params.gallery;
        this.private = params.private;
        this.queryId = params.queryId;
        this.results = params.results;
        this.cacheTime = params.cacheTime;
        this.nextOffset = params.nextOffset;
        this.switchPm = params.switchPm;
        this.switchWebview = params.switchWebview;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SetInlineBotResults> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let gallery = flags & (1 << 0) ? true : false;
        let _private = flags & (1 << 1) ? true : false;
        let queryId = await Primitive.Long.read(b);
        let results = await TLObject.read(b);
        let cacheTime = await Primitive.Int.read(b);
        let nextOffset = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        let switchPm = flags & (1 << 3) ? await TLObject.read(b) : undefined;
        let switchWebview = flags & (1 << 4) ? await TLObject.read(b) : undefined;
        return new Raw.messages.SetInlineBotResults({
          gallery: gallery,
          private: _private,
          queryId: queryId,
          results: results,
          cacheTime: cacheTime,
          nextOffset: nextOffset,
          switchPm: switchPm,
          switchWebview: switchWebview,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.gallery ? 1 << 0 : 0;
        flags |= this.private ? 1 << 1 : 0;
        flags |= this.nextOffset !== undefined ? 1 << 2 : 0;
        flags |= this.switchPm !== undefined ? 1 << 3 : 0;
        flags |= this.switchWebview !== undefined ? 1 << 4 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.queryId !== undefined) {
          b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
        }
        if (this.results) {
          b.write(Primitive.Vector.write(this.results) as unknown as Buffer);
        }
        if (this.cacheTime !== undefined) {
          b.write(Primitive.Int.write(this.cacheTime) as unknown as Buffer);
        }
        if (this.nextOffset !== undefined) {
          b.write(Primitive.String.write(this.nextOffset) as unknown as Buffer);
        }
        if (this.switchPm !== undefined) {
          b.write(this.switchPm.write() as unknown as Buffer);
        }
        if (this.switchWebview !== undefined) {
          b.write(this.switchWebview.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendInlineBotResult extends TLObject {
      __response__!: Raw.TypeUpdates;
      silent?: boolean;
      background?: boolean;
      clearDraft?: boolean;
      hideVia?: boolean;
      peer!: Raw.TypeInputPeer;
      replyTo?: Raw.TypeInputReplyTo;
      randomId!: long;
      queryId!: long;
      id!: string;
      scheduleDate?: int;
      sendAs?: Raw.TypeInputPeer;

      constructor(params: {
        silent?: boolean;
        background?: boolean;
        clearDraft?: boolean;
        hideVia?: boolean;
        peer: Raw.TypeInputPeer;
        replyTo?: Raw.TypeInputReplyTo;
        randomId: long;
        queryId: long;
        id: string;
        scheduleDate?: int;
        sendAs?: Raw.TypeInputPeer;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendInlineBotResult';
        this.constructorId = 0xf7bc68ba;
        this.subclassOfId = 0x8af52aac;
        this._slots = [
          'silent',
          'background',
          'clearDraft',
          'hideVia',
          'peer',
          'replyTo',
          'randomId',
          'queryId',
          'id',
          'scheduleDate',
          'sendAs',
        ];
        this.silent = params.silent;
        this.background = params.background;
        this.clearDraft = params.clearDraft;
        this.hideVia = params.hideVia;
        this.peer = params.peer;
        this.replyTo = params.replyTo;
        this.randomId = params.randomId;
        this.queryId = params.queryId;
        this.id = params.id;
        this.scheduleDate = params.scheduleDate;
        this.sendAs = params.sendAs;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SendInlineBotResult> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let silent = flags & (1 << 5) ? true : false;
        let background = flags & (1 << 6) ? true : false;
        let clearDraft = flags & (1 << 7) ? true : false;
        let hideVia = flags & (1 << 11) ? true : false;
        let peer = await TLObject.read(b);
        let replyTo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let randomId = await Primitive.Long.read(b);
        let queryId = await Primitive.Long.read(b);
        let id = await Primitive.String.read(b);
        let scheduleDate = flags & (1 << 10) ? await Primitive.Int.read(b) : undefined;
        let sendAs = flags & (1 << 13) ? await TLObject.read(b) : undefined;
        return new Raw.messages.SendInlineBotResult({
          silent: silent,
          background: background,
          clearDraft: clearDraft,
          hideVia: hideVia,
          peer: peer,
          replyTo: replyTo,
          randomId: randomId,
          queryId: queryId,
          id: id,
          scheduleDate: scheduleDate,
          sendAs: sendAs,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.silent ? 1 << 5 : 0;
        flags |= this.background ? 1 << 6 : 0;
        flags |= this.clearDraft ? 1 << 7 : 0;
        flags |= this.hideVia ? 1 << 11 : 0;
        flags |= this.replyTo !== undefined ? 1 << 0 : 0;
        flags |= this.scheduleDate !== undefined ? 1 << 10 : 0;
        flags |= this.sendAs !== undefined ? 1 << 13 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.replyTo !== undefined) {
          b.write(this.replyTo.write() as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
        }
        if (this.queryId !== undefined) {
          b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.String.write(this.id) as unknown as Buffer);
        }
        if (this.scheduleDate !== undefined) {
          b.write(Primitive.Int.write(this.scheduleDate) as unknown as Buffer);
        }
        if (this.sendAs !== undefined) {
          b.write(this.sendAs.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetMessageEditData extends TLObject {
      __response__!: Raw.messages.TypeMessageEditData;
      peer!: Raw.TypeInputPeer;
      id!: int;

      constructor(params: { peer: Raw.TypeInputPeer; id: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetMessageEditData';
        this.constructorId = 0xfda68d36;
        this.subclassOfId = 0xfb47949d;
        this._slots = ['peer', 'id'];
        this.peer = params.peer;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetMessageEditData> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await Primitive.Int.read(b);
        return new Raw.messages.GetMessageEditData({ peer: peer, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditMessage extends TLObject {
      __response__!: Raw.TypeUpdates;
      noWebpage?: boolean;
      invertMedia?: boolean;
      peer!: Raw.TypeInputPeer;
      id!: int;
      message?: string;
      media?: Raw.TypeInputMedia;
      replyMarkup?: Raw.TypeReplyMarkup;
      entities?: Vector<Raw.TypeMessageEntity>;
      scheduleDate?: int;

      constructor(params: {
        noWebpage?: boolean;
        invertMedia?: boolean;
        peer: Raw.TypeInputPeer;
        id: int;
        message?: string;
        media?: Raw.TypeInputMedia;
        replyMarkup?: Raw.TypeReplyMarkup;
        entities?: Vector<Raw.TypeMessageEntity>;
        scheduleDate?: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.EditMessage';
        this.constructorId = 0x48f71778;
        this.subclassOfId = 0x8af52aac;
        this._slots = [
          'noWebpage',
          'invertMedia',
          'peer',
          'id',
          'message',
          'media',
          'replyMarkup',
          'entities',
          'scheduleDate',
        ];
        this.noWebpage = params.noWebpage;
        this.invertMedia = params.invertMedia;
        this.peer = params.peer;
        this.id = params.id;
        this.message = params.message;
        this.media = params.media;
        this.replyMarkup = params.replyMarkup;
        this.entities = params.entities;
        this.scheduleDate = params.scheduleDate;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.EditMessage> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let noWebpage = flags & (1 << 1) ? true : false;
        let invertMedia = flags & (1 << 16) ? true : false;
        let peer = await TLObject.read(b);
        let id = await Primitive.Int.read(b);
        let message = flags & (1 << 11) ? await Primitive.String.read(b) : undefined;
        let media = flags & (1 << 14) ? await TLObject.read(b) : undefined;
        let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let entities = flags & (1 << 3) ? await TLObject.read(b) : [];
        let scheduleDate = flags & (1 << 15) ? await Primitive.Int.read(b) : undefined;
        return new Raw.messages.EditMessage({
          noWebpage: noWebpage,
          invertMedia: invertMedia,
          peer: peer,
          id: id,
          message: message,
          media: media,
          replyMarkup: replyMarkup,
          entities: entities,
          scheduleDate: scheduleDate,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.noWebpage ? 1 << 1 : 0;
        flags |= this.invertMedia ? 1 << 16 : 0;
        flags |= this.message !== undefined ? 1 << 11 : 0;
        flags |= this.media !== undefined ? 1 << 14 : 0;
        flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
        flags |= this.entities ? 1 << 3 : 0;
        flags |= this.scheduleDate !== undefined ? 1 << 15 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        if (this.media !== undefined) {
          b.write(this.media.write() as unknown as Buffer);
        }
        if (this.replyMarkup !== undefined) {
          b.write(this.replyMarkup.write() as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        if (this.scheduleDate !== undefined) {
          b.write(Primitive.Int.write(this.scheduleDate) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditInlineBotMessage extends TLObject {
      __response__!: Bool;
      noWebpage?: boolean;
      invertMedia?: boolean;
      id!: Raw.TypeInputBotInlineMessageID;
      message?: string;
      media?: Raw.TypeInputMedia;
      replyMarkup?: Raw.TypeReplyMarkup;
      entities?: Vector<Raw.TypeMessageEntity>;

      constructor(params: {
        noWebpage?: boolean;
        invertMedia?: boolean;
        id: Raw.TypeInputBotInlineMessageID;
        message?: string;
        media?: Raw.TypeInputMedia;
        replyMarkup?: Raw.TypeReplyMarkup;
        entities?: Vector<Raw.TypeMessageEntity>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.EditInlineBotMessage';
        this.constructorId = 0x83557dba;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [
          'noWebpage',
          'invertMedia',
          'id',
          'message',
          'media',
          'replyMarkup',
          'entities',
        ];
        this.noWebpage = params.noWebpage;
        this.invertMedia = params.invertMedia;
        this.id = params.id;
        this.message = params.message;
        this.media = params.media;
        this.replyMarkup = params.replyMarkup;
        this.entities = params.entities;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.EditInlineBotMessage> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let noWebpage = flags & (1 << 1) ? true : false;
        let invertMedia = flags & (1 << 16) ? true : false;
        let id = await TLObject.read(b);
        let message = flags & (1 << 11) ? await Primitive.String.read(b) : undefined;
        let media = flags & (1 << 14) ? await TLObject.read(b) : undefined;
        let replyMarkup = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let entities = flags & (1 << 3) ? await TLObject.read(b) : [];
        return new Raw.messages.EditInlineBotMessage({
          noWebpage: noWebpage,
          invertMedia: invertMedia,
          id: id,
          message: message,
          media: media,
          replyMarkup: replyMarkup,
          entities: entities,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.noWebpage ? 1 << 1 : 0;
        flags |= this.invertMedia ? 1 << 16 : 0;
        flags |= this.message !== undefined ? 1 << 11 : 0;
        flags |= this.media !== undefined ? 1 << 14 : 0;
        flags |= this.replyMarkup !== undefined ? 1 << 2 : 0;
        flags |= this.entities ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        if (this.media !== undefined) {
          b.write(this.media.write() as unknown as Buffer);
        }
        if (this.replyMarkup !== undefined) {
          b.write(this.replyMarkup.write() as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetBotCallbackAnswer extends TLObject {
      __response__!: Raw.messages.TypeBotCallbackAnswer;
      game?: boolean;
      peer!: Raw.TypeInputPeer;
      msgId!: int;
      data?: bytes;
      password?: Raw.TypeInputCheckPasswordSRP;

      constructor(params: {
        game?: boolean;
        peer: Raw.TypeInputPeer;
        msgId: int;
        data?: bytes;
        password?: Raw.TypeInputCheckPasswordSRP;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetBotCallbackAnswer';
        this.constructorId = 0x9342ca07;
        this.subclassOfId = 0x6c4dd18c;
        this._slots = ['game', 'peer', 'msgId', 'data', 'password'];
        this.game = params.game;
        this.peer = params.peer;
        this.msgId = params.msgId;
        this.data = params.data;
        this.password = params.password;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetBotCallbackAnswer> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let game = flags & (1 << 1) ? true : false;
        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        let data = flags & (1 << 0) ? await Primitive.Bytes.read(b) : undefined;
        let password = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        return new Raw.messages.GetBotCallbackAnswer({
          game: game,
          peer: peer,
          msgId: msgId,
          data: data,
          password: password,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.game ? 1 << 1 : 0;
        flags |= this.data !== undefined ? 1 << 0 : 0;
        flags |= this.password !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        if (this.data !== undefined) {
          b.write(Primitive.Bytes.write(this.data) as unknown as Buffer);
        }
        if (this.password !== undefined) {
          b.write(this.password.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetBotCallbackAnswer extends TLObject {
      __response__!: Bool;
      alert?: boolean;
      queryId!: long;
      message?: string;
      url?: string;
      cacheTime!: int;

      constructor(params: {
        alert?: boolean;
        queryId: long;
        message?: string;
        url?: string;
        cacheTime: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetBotCallbackAnswer';
        this.constructorId = 0xd58f130a;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['alert', 'queryId', 'message', 'url', 'cacheTime'];
        this.alert = params.alert;
        this.queryId = params.queryId;
        this.message = params.message;
        this.url = params.url;
        this.cacheTime = params.cacheTime;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SetBotCallbackAnswer> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let alert = flags & (1 << 1) ? true : false;
        let queryId = await Primitive.Long.read(b);
        let message = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let url = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        let cacheTime = await Primitive.Int.read(b);
        return new Raw.messages.SetBotCallbackAnswer({
          alert: alert,
          queryId: queryId,
          message: message,
          url: url,
          cacheTime: cacheTime,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.alert ? 1 << 1 : 0;
        flags |= this.message !== undefined ? 1 << 0 : 0;
        flags |= this.url !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.queryId !== undefined) {
          b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
        }
        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        if (this.cacheTime !== undefined) {
          b.write(Primitive.Int.write(this.cacheTime) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPeerDialogs extends TLObject {
      __response__!: Raw.messages.TypePeerDialogs;
      peers!: Vector<Raw.TypeInputDialogPeer>;

      constructor(params: { peers: Vector<Raw.TypeInputDialogPeer> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetPeerDialogs';
        this.constructorId = 0xe470bcfd;
        this.subclassOfId = 0x3ac70132;
        this._slots = ['peers'];
        this.peers = params.peers;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetPeerDialogs> {
        // no flags

        let peers = await TLObject.read(b);
        return new Raw.messages.GetPeerDialogs({ peers: peers });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peers) {
          b.write(Primitive.Vector.write(this.peers) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveDraft extends TLObject {
      __response__!: Bool;
      noWebpage?: boolean;
      invertMedia?: boolean;
      replyTo?: Raw.TypeInputReplyTo;
      peer!: Raw.TypeInputPeer;
      message!: string;
      entities?: Vector<Raw.TypeMessageEntity>;
      media?: Raw.TypeInputMedia;

      constructor(params: {
        noWebpage?: boolean;
        invertMedia?: boolean;
        replyTo?: Raw.TypeInputReplyTo;
        peer: Raw.TypeInputPeer;
        message: string;
        entities?: Vector<Raw.TypeMessageEntity>;
        media?: Raw.TypeInputMedia;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SaveDraft';
        this.constructorId = 0x7ff3b806;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [
          'noWebpage',
          'invertMedia',
          'replyTo',
          'peer',
          'message',
          'entities',
          'media',
        ];
        this.noWebpage = params.noWebpage;
        this.invertMedia = params.invertMedia;
        this.replyTo = params.replyTo;
        this.peer = params.peer;
        this.message = params.message;
        this.entities = params.entities;
        this.media = params.media;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SaveDraft> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let noWebpage = flags & (1 << 1) ? true : false;
        let invertMedia = flags & (1 << 6) ? true : false;
        let replyTo = flags & (1 << 4) ? await TLObject.read(b) : undefined;
        let peer = await TLObject.read(b);
        let message = await Primitive.String.read(b);
        let entities = flags & (1 << 3) ? await TLObject.read(b) : [];
        let media = flags & (1 << 5) ? await TLObject.read(b) : undefined;
        return new Raw.messages.SaveDraft({
          noWebpage: noWebpage,
          invertMedia: invertMedia,
          replyTo: replyTo,
          peer: peer,
          message: message,
          entities: entities,
          media: media,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.noWebpage ? 1 << 1 : 0;
        flags |= this.invertMedia ? 1 << 6 : 0;
        flags |= this.replyTo !== undefined ? 1 << 4 : 0;
        flags |= this.entities ? 1 << 3 : 0;
        flags |= this.media !== undefined ? 1 << 5 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.replyTo !== undefined) {
          b.write(this.replyTo.write() as unknown as Buffer);
        }
        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        if (this.media !== undefined) {
          b.write(this.media.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAllDrafts extends TLObject {
      __response__!: Raw.TypeUpdates;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetAllDrafts';
        this.constructorId = 0x6a3f8d65;
        this.subclassOfId = 0x8af52aac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetAllDrafts> {
        // no flags

        return new Raw.messages.GetAllDrafts();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetFeaturedStickers extends TLObject {
      __response__!: Raw.messages.TypeFeaturedStickers;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetFeaturedStickers';
        this.constructorId = 0x64780b14;
        this.subclassOfId = 0x2614b722;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetFeaturedStickers> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetFeaturedStickers({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReadFeaturedStickers extends TLObject {
      __response__!: Bool;
      id!: Vector<long>;

      constructor(params: { id: Vector<long> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReadFeaturedStickers';
        this.constructorId = 0x5b118126;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ReadFeaturedStickers> {
        // no flags

        let id = await TLObject.read(b, Primitive.Long);
        return new Raw.messages.ReadFeaturedStickers({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Long) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetRecentStickers extends TLObject {
      __response__!: Raw.messages.TypeRecentStickers;
      attached?: boolean;
      hash!: long;

      constructor(params: { attached?: boolean; hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetRecentStickers';
        this.constructorId = 0x9da9403b;
        this.subclassOfId = 0xf76f8683;
        this._slots = ['attached', 'hash'];
        this.attached = params.attached;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetRecentStickers> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let attached = flags & (1 << 0) ? true : false;
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetRecentStickers({ attached: attached, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.attached ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveRecentSticker extends TLObject {
      __response__!: Bool;
      attached?: boolean;
      id!: Raw.TypeInputDocument;
      unsave!: Bool;

      constructor(params: { attached?: boolean; id: Raw.TypeInputDocument; unsave: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SaveRecentSticker';
        this.constructorId = 0x392718f8;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['attached', 'id', 'unsave'];
        this.attached = params.attached;
        this.id = params.id;
        this.unsave = params.unsave;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SaveRecentSticker> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let attached = flags & (1 << 0) ? true : false;
        let id = await TLObject.read(b);
        let unsave = await Primitive.Bool.read(b);
        return new Raw.messages.SaveRecentSticker({ attached: attached, id: id, unsave: unsave });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.attached ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        if (this.unsave !== undefined) {
          b.write(Primitive.Bool.write(this.unsave) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ClearRecentStickers extends TLObject {
      __response__!: Bool;
      attached?: boolean;

      constructor(params: { attached?: boolean }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ClearRecentStickers';
        this.constructorId = 0x8999602d;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['attached'];
        this.attached = params.attached;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ClearRecentStickers> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let attached = flags & (1 << 0) ? true : false;
        return new Raw.messages.ClearRecentStickers({ attached: attached });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.attached ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        return b.buffer;
      }
    }
    export class GetArchivedStickers extends TLObject {
      __response__!: Raw.messages.TypeArchivedStickers;
      masks?: boolean;
      emojis?: boolean;
      offsetId!: long;
      limit!: int;

      constructor(params: { masks?: boolean; emojis?: boolean; offsetId: long; limit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetArchivedStickers';
        this.constructorId = 0x57f17692;
        this.subclassOfId = 0x7296d771;
        this._slots = ['masks', 'emojis', 'offsetId', 'limit'];
        this.masks = params.masks;
        this.emojis = params.emojis;
        this.offsetId = params.offsetId;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetArchivedStickers> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let masks = flags & (1 << 0) ? true : false;
        let emojis = flags & (1 << 1) ? true : false;
        let offsetId = await Primitive.Long.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.messages.GetArchivedStickers({
          masks: masks,
          emojis: emojis,
          offsetId: offsetId,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.masks ? 1 << 0 : 0;
        flags |= this.emojis ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.offsetId !== undefined) {
          b.write(Primitive.Long.write(this.offsetId) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetMaskStickers extends TLObject {
      __response__!: Raw.messages.TypeAllStickers;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetMaskStickers';
        this.constructorId = 0x640f82b8;
        this.subclassOfId = 0x45834829;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetMaskStickers> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetMaskStickers({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAttachedStickers extends TLObject {
      __response__!: Vector<Raw.TypeStickerSetCovered>;
      media!: Raw.TypeInputStickeredMedia;

      constructor(params: { media: Raw.TypeInputStickeredMedia }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetAttachedStickers';
        this.constructorId = 0xcc5b67cc;
        this.subclassOfId = 0xcc125f6b;
        this._slots = ['media'];
        this.media = params.media;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetAttachedStickers> {
        // no flags

        let media = await TLObject.read(b);
        return new Raw.messages.GetAttachedStickers({ media: media });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.media !== undefined) {
          b.write(this.media.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetGameScore extends TLObject {
      __response__!: Raw.TypeUpdates;
      editMessage?: boolean;
      force?: boolean;
      peer!: Raw.TypeInputPeer;
      id!: int;
      userId!: Raw.TypeInputUser;
      score!: int;

      constructor(params: {
        editMessage?: boolean;
        force?: boolean;
        peer: Raw.TypeInputPeer;
        id: int;
        userId: Raw.TypeInputUser;
        score: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetGameScore';
        this.constructorId = 0x8ef8ecc0;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['editMessage', 'force', 'peer', 'id', 'userId', 'score'];
        this.editMessage = params.editMessage;
        this.force = params.force;
        this.peer = params.peer;
        this.id = params.id;
        this.userId = params.userId;
        this.score = params.score;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SetGameScore> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let editMessage = flags & (1 << 0) ? true : false;
        let force = flags & (1 << 1) ? true : false;
        let peer = await TLObject.read(b);
        let id = await Primitive.Int.read(b);
        let userId = await TLObject.read(b);
        let score = await Primitive.Int.read(b);
        return new Raw.messages.SetGameScore({
          editMessage: editMessage,
          force: force,
          peer: peer,
          id: id,
          userId: userId,
          score: score,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.editMessage ? 1 << 0 : 0;
        flags |= this.force ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.score !== undefined) {
          b.write(Primitive.Int.write(this.score) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetInlineGameScore extends TLObject {
      __response__!: Bool;
      editMessage?: boolean;
      force?: boolean;
      id!: Raw.TypeInputBotInlineMessageID;
      userId!: Raw.TypeInputUser;
      score!: int;

      constructor(params: {
        editMessage?: boolean;
        force?: boolean;
        id: Raw.TypeInputBotInlineMessageID;
        userId: Raw.TypeInputUser;
        score: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetInlineGameScore';
        this.constructorId = 0x15ad9f64;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['editMessage', 'force', 'id', 'userId', 'score'];
        this.editMessage = params.editMessage;
        this.force = params.force;
        this.id = params.id;
        this.userId = params.userId;
        this.score = params.score;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SetInlineGameScore> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let editMessage = flags & (1 << 0) ? true : false;
        let force = flags & (1 << 1) ? true : false;
        let id = await TLObject.read(b);
        let userId = await TLObject.read(b);
        let score = await Primitive.Int.read(b);
        return new Raw.messages.SetInlineGameScore({
          editMessage: editMessage,
          force: force,
          id: id,
          userId: userId,
          score: score,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.editMessage ? 1 << 0 : 0;
        flags |= this.force ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.score !== undefined) {
          b.write(Primitive.Int.write(this.score) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetGameHighScores extends TLObject {
      __response__!: Raw.messages.TypeHighScores;
      peer!: Raw.TypeInputPeer;
      id!: int;
      userId!: Raw.TypeInputUser;

      constructor(params: { peer: Raw.TypeInputPeer; id: int; userId: Raw.TypeInputUser }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetGameHighScores';
        this.constructorId = 0xe822649d;
        this.subclassOfId = 0x6ccd95fd;
        this._slots = ['peer', 'id', 'userId'];
        this.peer = params.peer;
        this.id = params.id;
        this.userId = params.userId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetGameHighScores> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await Primitive.Int.read(b);
        let userId = await TLObject.read(b);
        return new Raw.messages.GetGameHighScores({ peer: peer, id: id, userId: userId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetInlineGameHighScores extends TLObject {
      __response__!: Raw.messages.TypeHighScores;
      id!: Raw.TypeInputBotInlineMessageID;
      userId!: Raw.TypeInputUser;

      constructor(params: { id: Raw.TypeInputBotInlineMessageID; userId: Raw.TypeInputUser }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetInlineGameHighScores';
        this.constructorId = 0xf635e1b;
        this.subclassOfId = 0x6ccd95fd;
        this._slots = ['id', 'userId'];
        this.id = params.id;
        this.userId = params.userId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetInlineGameHighScores> {
        // no flags

        let id = await TLObject.read(b);
        let userId = await TLObject.read(b);
        return new Raw.messages.GetInlineGameHighScores({ id: id, userId: userId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetCommonChats extends TLObject {
      __response__!: Raw.messages.TypeChats;
      userId!: Raw.TypeInputUser;
      maxId!: long;
      limit!: int;

      constructor(params: { userId: Raw.TypeInputUser; maxId: long; limit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetCommonChats';
        this.constructorId = 0xe40ca104;
        this.subclassOfId = 0x99d5cb14;
        this._slots = ['userId', 'maxId', 'limit'];
        this.userId = params.userId;
        this.maxId = params.maxId;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetCommonChats> {
        // no flags

        let userId = await TLObject.read(b);
        let maxId = await Primitive.Long.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.messages.GetCommonChats({ userId: userId, maxId: maxId, limit: limit });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Long.write(this.maxId) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetWebPage extends TLObject {
      __response__!: Raw.messages.TypeWebPage;
      url!: string;
      hash!: int;

      constructor(params: { url: string; hash: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetWebPage';
        this.constructorId = 0x8d9692a3;
        this.subclassOfId = 0x2cf8b154;
        this._slots = ['url', 'hash'];
        this.url = params.url;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetWebPage> {
        // no flags

        let url = await Primitive.String.read(b);
        let hash = await Primitive.Int.read(b);
        return new Raw.messages.GetWebPage({ url: url, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleDialogPin extends TLObject {
      __response__!: Bool;
      pinned?: boolean;
      peer!: Raw.TypeInputDialogPeer;

      constructor(params: { pinned?: boolean; peer: Raw.TypeInputDialogPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ToggleDialogPin';
        this.constructorId = 0xa731e257;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['pinned', 'peer'];
        this.pinned = params.pinned;
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ToggleDialogPin> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let pinned = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        return new Raw.messages.ToggleDialogPin({ pinned: pinned, peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.pinned ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReorderPinnedDialogs extends TLObject {
      __response__!: Bool;
      force?: boolean;
      folderId!: int;
      order!: Vector<Raw.TypeInputDialogPeer>;

      constructor(params: {
        force?: boolean;
        folderId: int;
        order: Vector<Raw.TypeInputDialogPeer>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReorderPinnedDialogs';
        this.constructorId = 0x3b1adf37;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['force', 'folderId', 'order'];
        this.force = params.force;
        this.folderId = params.folderId;
        this.order = params.order;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ReorderPinnedDialogs> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let force = flags & (1 << 0) ? true : false;
        let folderId = await Primitive.Int.read(b);
        let order = await TLObject.read(b);
        return new Raw.messages.ReorderPinnedDialogs({
          force: force,
          folderId: folderId,
          order: order,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.force ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.folderId !== undefined) {
          b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
        }
        if (this.order) {
          b.write(Primitive.Vector.write(this.order) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPinnedDialogs extends TLObject {
      __response__!: Raw.messages.TypePeerDialogs;
      folderId!: int;

      constructor(params: { folderId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetPinnedDialogs';
        this.constructorId = 0xd6b94df2;
        this.subclassOfId = 0x3ac70132;
        this._slots = ['folderId'];
        this.folderId = params.folderId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetPinnedDialogs> {
        // no flags

        let folderId = await Primitive.Int.read(b);
        return new Raw.messages.GetPinnedDialogs({ folderId: folderId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.folderId !== undefined) {
          b.write(Primitive.Int.write(this.folderId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetBotShippingResults extends TLObject {
      __response__!: Bool;
      queryId!: long;
      error?: string;
      shippingOptions?: Vector<Raw.TypeShippingOption>;

      constructor(params: {
        queryId: long;
        error?: string;
        shippingOptions?: Vector<Raw.TypeShippingOption>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetBotShippingResults';
        this.constructorId = 0xe5f672fa;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['queryId', 'error', 'shippingOptions'];
        this.queryId = params.queryId;
        this.error = params.error;
        this.shippingOptions = params.shippingOptions;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SetBotShippingResults> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let queryId = await Primitive.Long.read(b);
        let error = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let shippingOptions = flags & (1 << 1) ? await TLObject.read(b) : [];
        return new Raw.messages.SetBotShippingResults({
          queryId: queryId,
          error: error,
          shippingOptions: shippingOptions,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.error !== undefined ? 1 << 0 : 0;
        flags |= this.shippingOptions ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.queryId !== undefined) {
          b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
        }
        if (this.error !== undefined) {
          b.write(Primitive.String.write(this.error) as unknown as Buffer);
        }
        if (this.shippingOptions) {
          b.write(Primitive.Vector.write(this.shippingOptions) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetBotPrecheckoutResults extends TLObject {
      __response__!: Bool;
      success?: boolean;
      queryId!: long;
      error?: string;

      constructor(params: { success?: boolean; queryId: long; error?: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetBotPrecheckoutResults';
        this.constructorId = 0x9c2dd95;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['success', 'queryId', 'error'];
        this.success = params.success;
        this.queryId = params.queryId;
        this.error = params.error;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SetBotPrecheckoutResults> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let success = flags & (1 << 1) ? true : false;
        let queryId = await Primitive.Long.read(b);
        let error = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        return new Raw.messages.SetBotPrecheckoutResults({
          success: success,
          queryId: queryId,
          error: error,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.success ? 1 << 1 : 0;
        flags |= this.error !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.queryId !== undefined) {
          b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
        }
        if (this.error !== undefined) {
          b.write(Primitive.String.write(this.error) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UploadMedia extends TLObject {
      __response__!: Raw.TypeMessageMedia;
      peer!: Raw.TypeInputPeer;
      media!: Raw.TypeInputMedia;

      constructor(params: { peer: Raw.TypeInputPeer; media: Raw.TypeInputMedia }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.UploadMedia';
        this.constructorId = 0x519bc2b1;
        this.subclassOfId = 0x476cbe32;
        this._slots = ['peer', 'media'];
        this.peer = params.peer;
        this.media = params.media;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.UploadMedia> {
        // no flags

        let peer = await TLObject.read(b);
        let media = await TLObject.read(b);
        return new Raw.messages.UploadMedia({ peer: peer, media: media });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.media !== undefined) {
          b.write(this.media.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendScreenshotNotification extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      replyTo!: Raw.TypeInputReplyTo;
      randomId!: long;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        replyTo: Raw.TypeInputReplyTo;
        randomId: long;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendScreenshotNotification';
        this.constructorId = 0xa1405817;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'replyTo', 'randomId'];
        this.peer = params.peer;
        this.replyTo = params.replyTo;
        this.randomId = params.randomId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SendScreenshotNotification> {
        // no flags

        let peer = await TLObject.read(b);
        let replyTo = await TLObject.read(b);
        let randomId = await Primitive.Long.read(b);
        return new Raw.messages.SendScreenshotNotification({
          peer: peer,
          replyTo: replyTo,
          randomId: randomId,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.replyTo !== undefined) {
          b.write(this.replyTo.write() as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetFavedStickers extends TLObject {
      __response__!: Raw.messages.TypeFavedStickers;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetFavedStickers';
        this.constructorId = 0x4f1aaa9;
        this.subclassOfId = 0x8e736fb9;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetFavedStickers> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetFavedStickers({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class FaveSticker extends TLObject {
      __response__!: Bool;
      id!: Raw.TypeInputDocument;
      unfave!: Bool;

      constructor(params: { id: Raw.TypeInputDocument; unfave: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.FaveSticker';
        this.constructorId = 0xb9ffc55b;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['id', 'unfave'];
        this.id = params.id;
        this.unfave = params.unfave;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.FaveSticker> {
        // no flags

        let id = await TLObject.read(b);
        let unfave = await Primitive.Bool.read(b);
        return new Raw.messages.FaveSticker({ id: id, unfave: unfave });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        if (this.unfave !== undefined) {
          b.write(Primitive.Bool.write(this.unfave) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetUnreadMentions extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      peer!: Raw.TypeInputPeer;
      topMsgId?: int;
      offsetId!: int;
      addOffset!: int;
      limit!: int;
      maxId!: int;
      minId!: int;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        topMsgId?: int;
        offsetId: int;
        addOffset: int;
        limit: int;
        maxId: int;
        minId: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetUnreadMentions';
        this.constructorId = 0xf107e790;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = ['peer', 'topMsgId', 'offsetId', 'addOffset', 'limit', 'maxId', 'minId'];
        this.peer = params.peer;
        this.topMsgId = params.topMsgId;
        this.offsetId = params.offsetId;
        this.addOffset = params.addOffset;
        this.limit = params.limit;
        this.maxId = params.maxId;
        this.minId = params.minId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetUnreadMentions> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = await TLObject.read(b);
        let topMsgId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let offsetId = await Primitive.Int.read(b);
        let addOffset = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        let maxId = await Primitive.Int.read(b);
        let minId = await Primitive.Int.read(b);
        return new Raw.messages.GetUnreadMentions({
          peer: peer,
          topMsgId: topMsgId,
          offsetId: offsetId,
          addOffset: addOffset,
          limit: limit,
          maxId: maxId,
          minId: minId,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.topMsgId !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.topMsgId !== undefined) {
          b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.addOffset !== undefined) {
          b.write(Primitive.Int.write(this.addOffset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
        }
        if (this.minId !== undefined) {
          b.write(Primitive.Int.write(this.minId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReadMentions extends TLObject {
      __response__!: Raw.messages.TypeAffectedHistory;
      peer!: Raw.TypeInputPeer;
      topMsgId?: int;

      constructor(params: { peer: Raw.TypeInputPeer; topMsgId?: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReadMentions';
        this.constructorId = 0x36e5bf4d;
        this.subclassOfId = 0x2c49c116;
        this._slots = ['peer', 'topMsgId'];
        this.peer = params.peer;
        this.topMsgId = params.topMsgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ReadMentions> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = await TLObject.read(b);
        let topMsgId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        return new Raw.messages.ReadMentions({ peer: peer, topMsgId: topMsgId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.topMsgId !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.topMsgId !== undefined) {
          b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetRecentLocations extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      peer!: Raw.TypeInputPeer;
      limit!: int;
      hash!: long;

      constructor(params: { peer: Raw.TypeInputPeer; limit: int; hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetRecentLocations';
        this.constructorId = 0x702a40e0;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = ['peer', 'limit', 'hash'];
        this.peer = params.peer;
        this.limit = params.limit;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetRecentLocations> {
        // no flags

        let peer = await TLObject.read(b);
        let limit = await Primitive.Int.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetRecentLocations({ peer: peer, limit: limit, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendMultiMedia extends TLObject {
      __response__!: Raw.TypeUpdates;
      silent?: boolean;
      background?: boolean;
      clearDraft?: boolean;
      noforwards?: boolean;
      updateStickersetsOrder?: boolean;
      invertMedia?: boolean;
      peer!: Raw.TypeInputPeer;
      replyTo?: Raw.TypeInputReplyTo;
      multiMedia!: Vector<Raw.TypeInputSingleMedia>;
      scheduleDate?: int;
      sendAs?: Raw.TypeInputPeer;

      constructor(params: {
        silent?: boolean;
        background?: boolean;
        clearDraft?: boolean;
        noforwards?: boolean;
        updateStickersetsOrder?: boolean;
        invertMedia?: boolean;
        peer: Raw.TypeInputPeer;
        replyTo?: Raw.TypeInputReplyTo;
        multiMedia: Vector<Raw.TypeInputSingleMedia>;
        scheduleDate?: int;
        sendAs?: Raw.TypeInputPeer;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendMultiMedia';
        this.constructorId = 0x456e8987;
        this.subclassOfId = 0x8af52aac;
        this._slots = [
          'silent',
          'background',
          'clearDraft',
          'noforwards',
          'updateStickersetsOrder',
          'invertMedia',
          'peer',
          'replyTo',
          'multiMedia',
          'scheduleDate',
          'sendAs',
        ];
        this.silent = params.silent;
        this.background = params.background;
        this.clearDraft = params.clearDraft;
        this.noforwards = params.noforwards;
        this.updateStickersetsOrder = params.updateStickersetsOrder;
        this.invertMedia = params.invertMedia;
        this.peer = params.peer;
        this.replyTo = params.replyTo;
        this.multiMedia = params.multiMedia;
        this.scheduleDate = params.scheduleDate;
        this.sendAs = params.sendAs;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SendMultiMedia> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let silent = flags & (1 << 5) ? true : false;
        let background = flags & (1 << 6) ? true : false;
        let clearDraft = flags & (1 << 7) ? true : false;
        let noforwards = flags & (1 << 14) ? true : false;
        let updateStickersetsOrder = flags & (1 << 15) ? true : false;
        let invertMedia = flags & (1 << 16) ? true : false;
        let peer = await TLObject.read(b);
        let replyTo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let multiMedia = await TLObject.read(b);
        let scheduleDate = flags & (1 << 10) ? await Primitive.Int.read(b) : undefined;
        let sendAs = flags & (1 << 13) ? await TLObject.read(b) : undefined;
        return new Raw.messages.SendMultiMedia({
          silent: silent,
          background: background,
          clearDraft: clearDraft,
          noforwards: noforwards,
          updateStickersetsOrder: updateStickersetsOrder,
          invertMedia: invertMedia,
          peer: peer,
          replyTo: replyTo,
          multiMedia: multiMedia,
          scheduleDate: scheduleDate,
          sendAs: sendAs,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.silent ? 1 << 5 : 0;
        flags |= this.background ? 1 << 6 : 0;
        flags |= this.clearDraft ? 1 << 7 : 0;
        flags |= this.noforwards ? 1 << 14 : 0;
        flags |= this.updateStickersetsOrder ? 1 << 15 : 0;
        flags |= this.invertMedia ? 1 << 16 : 0;
        flags |= this.replyTo !== undefined ? 1 << 0 : 0;
        flags |= this.scheduleDate !== undefined ? 1 << 10 : 0;
        flags |= this.sendAs !== undefined ? 1 << 13 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.replyTo !== undefined) {
          b.write(this.replyTo.write() as unknown as Buffer);
        }
        if (this.multiMedia) {
          b.write(Primitive.Vector.write(this.multiMedia) as unknown as Buffer);
        }
        if (this.scheduleDate !== undefined) {
          b.write(Primitive.Int.write(this.scheduleDate) as unknown as Buffer);
        }
        if (this.sendAs !== undefined) {
          b.write(this.sendAs.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UploadEncryptedFile extends TLObject {
      __response__!: Raw.TypeEncryptedFile;
      peer!: Raw.TypeInputEncryptedChat;
      file!: Raw.TypeInputEncryptedFile;

      constructor(params: { peer: Raw.TypeInputEncryptedChat; file: Raw.TypeInputEncryptedFile }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.UploadEncryptedFile';
        this.constructorId = 0x5057c497;
        this.subclassOfId = 0x842a67c0;
        this._slots = ['peer', 'file'];
        this.peer = params.peer;
        this.file = params.file;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.UploadEncryptedFile> {
        // no flags

        let peer = await TLObject.read(b);
        let file = await TLObject.read(b);
        return new Raw.messages.UploadEncryptedFile({ peer: peer, file: file });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.file !== undefined) {
          b.write(this.file.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SearchStickerSets extends TLObject {
      __response__!: Raw.messages.TypeFoundStickerSets;
      excludeFeatured?: boolean;
      q!: string;
      hash!: long;

      constructor(params: { excludeFeatured?: boolean; q: string; hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SearchStickerSets';
        this.constructorId = 0x35705b8a;
        this.subclassOfId = 0x40df361;
        this._slots = ['excludeFeatured', 'q', 'hash'];
        this.excludeFeatured = params.excludeFeatured;
        this.q = params.q;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SearchStickerSets> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let excludeFeatured = flags & (1 << 0) ? true : false;
        let q = await Primitive.String.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.SearchStickerSets({
          excludeFeatured: excludeFeatured,
          q: q,
          hash: hash,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.excludeFeatured ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.q !== undefined) {
          b.write(Primitive.String.write(this.q) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetSplitRanges extends TLObject {
      __response__!: Vector<Raw.TypeMessageRange>;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetSplitRanges';
        this.constructorId = 0x1cff7e08;
        this.subclassOfId = 0x5ba52504;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetSplitRanges> {
        // no flags

        return new Raw.messages.GetSplitRanges();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class MarkDialogUnread extends TLObject {
      __response__!: Bool;
      unread?: boolean;
      peer!: Raw.TypeInputDialogPeer;

      constructor(params: { unread?: boolean; peer: Raw.TypeInputDialogPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.MarkDialogUnread';
        this.constructorId = 0xc286d98f;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['unread', 'peer'];
        this.unread = params.unread;
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.MarkDialogUnread> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let unread = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        return new Raw.messages.MarkDialogUnread({ unread: unread, peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.unread ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDialogUnreadMarks extends TLObject {
      __response__!: Vector<Raw.TypeDialogPeer>;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetDialogUnreadMarks';
        this.constructorId = 0x22e24e22;
        this.subclassOfId = 0xbec64ad9;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetDialogUnreadMarks> {
        // no flags

        return new Raw.messages.GetDialogUnreadMarks();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class ClearAllDrafts extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'messages.ClearAllDrafts';
        this.constructorId = 0x7e58ee9c;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ClearAllDrafts> {
        // no flags

        return new Raw.messages.ClearAllDrafts();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class UpdatePinnedMessage extends TLObject {
      __response__!: Raw.TypeUpdates;
      silent?: boolean;
      unpin?: boolean;
      pmOneside?: boolean;
      peer!: Raw.TypeInputPeer;
      id!: int;

      constructor(params: {
        silent?: boolean;
        unpin?: boolean;
        pmOneside?: boolean;
        peer: Raw.TypeInputPeer;
        id: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.UpdatePinnedMessage';
        this.constructorId = 0xd2aaf7ec;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['silent', 'unpin', 'pmOneside', 'peer', 'id'];
        this.silent = params.silent;
        this.unpin = params.unpin;
        this.pmOneside = params.pmOneside;
        this.peer = params.peer;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.UpdatePinnedMessage> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let silent = flags & (1 << 0) ? true : false;
        let unpin = flags & (1 << 1) ? true : false;
        let pmOneside = flags & (1 << 2) ? true : false;
        let peer = await TLObject.read(b);
        let id = await Primitive.Int.read(b);
        return new Raw.messages.UpdatePinnedMessage({
          silent: silent,
          unpin: unpin,
          pmOneside: pmOneside,
          peer: peer,
          id: id,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.silent ? 1 << 0 : 0;
        flags |= this.unpin ? 1 << 1 : 0;
        flags |= this.pmOneside ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendVote extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      msgId!: int;
      options!: Vector<bytes>;

      constructor(params: { peer: Raw.TypeInputPeer; msgId: int; options: Vector<bytes> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendVote';
        this.constructorId = 0x10ea6184;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'msgId', 'options'];
        this.peer = params.peer;
        this.msgId = params.msgId;
        this.options = params.options;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SendVote> {
        // no flags

        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        let options = await TLObject.read(b, Primitive.Bytes);
        return new Raw.messages.SendVote({ peer: peer, msgId: msgId, options: options });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        if (this.options) {
          b.write(Primitive.Vector.write(this.options, Primitive.Bytes) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPollResults extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      msgId!: int;

      constructor(params: { peer: Raw.TypeInputPeer; msgId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetPollResults';
        this.constructorId = 0x73bb643b;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'msgId'];
        this.peer = params.peer;
        this.msgId = params.msgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetPollResults> {
        // no flags

        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        return new Raw.messages.GetPollResults({ peer: peer, msgId: msgId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetOnlines extends TLObject {
      __response__!: Raw.TypeChatOnlines;
      peer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetOnlines';
        this.constructorId = 0x6e2be050;
        this.subclassOfId = 0x8c81903a;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetOnlines> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.messages.GetOnlines({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditChatAbout extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      about!: string;

      constructor(params: { peer: Raw.TypeInputPeer; about: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.EditChatAbout';
        this.constructorId = 0xdef60797;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'about'];
        this.peer = params.peer;
        this.about = params.about;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.EditChatAbout> {
        // no flags

        let peer = await TLObject.read(b);
        let about = await Primitive.String.read(b);
        return new Raw.messages.EditChatAbout({ peer: peer, about: about });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.about !== undefined) {
          b.write(Primitive.String.write(this.about) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditChatDefaultBannedRights extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      bannedRights!: Raw.TypeChatBannedRights;

      constructor(params: { peer: Raw.TypeInputPeer; bannedRights: Raw.TypeChatBannedRights }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.EditChatDefaultBannedRights';
        this.constructorId = 0xa5866b41;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'bannedRights'];
        this.peer = params.peer;
        this.bannedRights = params.bannedRights;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.EditChatDefaultBannedRights> {
        // no flags

        let peer = await TLObject.read(b);
        let bannedRights = await TLObject.read(b);
        return new Raw.messages.EditChatDefaultBannedRights({
          peer: peer,
          bannedRights: bannedRights,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.bannedRights !== undefined) {
          b.write(this.bannedRights.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetEmojiKeywords extends TLObject {
      __response__!: Raw.TypeEmojiKeywordsDifference;
      langCode!: string;

      constructor(params: { langCode: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetEmojiKeywords';
        this.constructorId = 0x35a0e062;
        this.subclassOfId = 0xd279c672;
        this._slots = ['langCode'];
        this.langCode = params.langCode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetEmojiKeywords> {
        // no flags

        let langCode = await Primitive.String.read(b);
        return new Raw.messages.GetEmojiKeywords({ langCode: langCode });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetEmojiKeywordsDifference extends TLObject {
      __response__!: Raw.TypeEmojiKeywordsDifference;
      langCode!: string;
      fromVersion!: int;

      constructor(params: { langCode: string; fromVersion: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetEmojiKeywordsDifference';
        this.constructorId = 0x1508b6af;
        this.subclassOfId = 0xd279c672;
        this._slots = ['langCode', 'fromVersion'];
        this.langCode = params.langCode;
        this.fromVersion = params.fromVersion;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetEmojiKeywordsDifference> {
        // no flags

        let langCode = await Primitive.String.read(b);
        let fromVersion = await Primitive.Int.read(b);
        return new Raw.messages.GetEmojiKeywordsDifference({
          langCode: langCode,
          fromVersion: fromVersion,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        if (this.fromVersion !== undefined) {
          b.write(Primitive.Int.write(this.fromVersion) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetEmojiKeywordsLanguages extends TLObject {
      __response__!: Vector<Raw.TypeEmojiLanguage>;
      langCodes!: Vector<string>;

      constructor(params: { langCodes: Vector<string> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetEmojiKeywordsLanguages';
        this.constructorId = 0x4e9963b2;
        this.subclassOfId = 0xe795d387;
        this._slots = ['langCodes'];
        this.langCodes = params.langCodes;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetEmojiKeywordsLanguages> {
        // no flags

        let langCodes = await TLObject.read(b, Primitive.String);
        return new Raw.messages.GetEmojiKeywordsLanguages({ langCodes: langCodes });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.langCodes) {
          b.write(Primitive.Vector.write(this.langCodes, Primitive.String) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetEmojiURL extends TLObject {
      __response__!: Raw.TypeEmojiURL;
      langCode!: string;

      constructor(params: { langCode: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetEmojiURL';
        this.constructorId = 0xd5b10c26;
        this.subclassOfId = 0x1fa08a19;
        this._slots = ['langCode'];
        this.langCode = params.langCode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetEmojiURL> {
        // no flags

        let langCode = await Primitive.String.read(b);
        return new Raw.messages.GetEmojiURL({ langCode: langCode });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetSearchCounters extends TLObject {
      __response__!: Vector<Raw.messages.TypeSearchCounter>;
      peer!: Raw.TypeInputPeer;
      topMsgId?: int;
      filters!: Vector<Raw.TypeMessagesFilter>;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        topMsgId?: int;
        filters: Vector<Raw.TypeMessagesFilter>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetSearchCounters';
        this.constructorId = 0xae7cc1;
        this.subclassOfId = 0x6bde3c6e;
        this._slots = ['peer', 'topMsgId', 'filters'];
        this.peer = params.peer;
        this.topMsgId = params.topMsgId;
        this.filters = params.filters;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetSearchCounters> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = await TLObject.read(b);
        let topMsgId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let filters = await TLObject.read(b);
        return new Raw.messages.GetSearchCounters({
          peer: peer,
          topMsgId: topMsgId,
          filters: filters,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.topMsgId !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.topMsgId !== undefined) {
          b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
        }
        if (this.filters) {
          b.write(Primitive.Vector.write(this.filters) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RequestUrlAuth extends TLObject {
      __response__!: Raw.TypeUrlAuthResult;
      peer?: Raw.TypeInputPeer;
      msgId?: int;
      buttonId?: int;
      url?: string;

      constructor(params: { peer?: Raw.TypeInputPeer; msgId?: int; buttonId?: int; url?: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.RequestUrlAuth';
        this.constructorId = 0x198fb446;
        this.subclassOfId = 0x7765cb1e;
        this._slots = ['peer', 'msgId', 'buttonId', 'url'];
        this.peer = params.peer;
        this.msgId = params.msgId;
        this.buttonId = params.buttonId;
        this.url = params.url;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.RequestUrlAuth> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        let msgId = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let buttonId = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let url = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        return new Raw.messages.RequestUrlAuth({
          peer: peer,
          msgId: msgId,
          buttonId: buttonId,
          url: url,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.peer !== undefined ? 1 << 1 : 0;
        flags |= this.msgId !== undefined ? 1 << 1 : 0;
        flags |= this.buttonId !== undefined ? 1 << 1 : 0;
        flags |= this.url !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        if (this.buttonId !== undefined) {
          b.write(Primitive.Int.write(this.buttonId) as unknown as Buffer);
        }
        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AcceptUrlAuth extends TLObject {
      __response__!: Raw.TypeUrlAuthResult;
      writeAllowed?: boolean;
      peer?: Raw.TypeInputPeer;
      msgId?: int;
      buttonId?: int;
      url?: string;

      constructor(params: {
        writeAllowed?: boolean;
        peer?: Raw.TypeInputPeer;
        msgId?: int;
        buttonId?: int;
        url?: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.AcceptUrlAuth';
        this.constructorId = 0xb12c7125;
        this.subclassOfId = 0x7765cb1e;
        this._slots = ['writeAllowed', 'peer', 'msgId', 'buttonId', 'url'];
        this.writeAllowed = params.writeAllowed;
        this.peer = params.peer;
        this.msgId = params.msgId;
        this.buttonId = params.buttonId;
        this.url = params.url;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.AcceptUrlAuth> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let writeAllowed = flags & (1 << 0) ? true : false;
        let peer = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        let msgId = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let buttonId = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let url = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        return new Raw.messages.AcceptUrlAuth({
          writeAllowed: writeAllowed,
          peer: peer,
          msgId: msgId,
          buttonId: buttonId,
          url: url,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.writeAllowed ? 1 << 0 : 0;
        flags |= this.peer !== undefined ? 1 << 1 : 0;
        flags |= this.msgId !== undefined ? 1 << 1 : 0;
        flags |= this.buttonId !== undefined ? 1 << 1 : 0;
        flags |= this.url !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        if (this.buttonId !== undefined) {
          b.write(Primitive.Int.write(this.buttonId) as unknown as Buffer);
        }
        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class HidePeerSettingsBar extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.HidePeerSettingsBar';
        this.constructorId = 0x4facb138;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.HidePeerSettingsBar> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.messages.HidePeerSettingsBar({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetScheduledHistory extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      peer!: Raw.TypeInputPeer;
      hash!: long;

      constructor(params: { peer: Raw.TypeInputPeer; hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetScheduledHistory';
        this.constructorId = 0xf516760b;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = ['peer', 'hash'];
        this.peer = params.peer;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetScheduledHistory> {
        // no flags

        let peer = await TLObject.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetScheduledHistory({ peer: peer, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetScheduledMessages extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;

      constructor(params: { peer: Raw.TypeInputPeer; id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetScheduledMessages';
        this.constructorId = 0xbdbb0464;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = ['peer', 'id'];
        this.peer = params.peer;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetScheduledMessages> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.messages.GetScheduledMessages({ peer: peer, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendScheduledMessages extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;

      constructor(params: { peer: Raw.TypeInputPeer; id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendScheduledMessages';
        this.constructorId = 0xbd38850a;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'id'];
        this.peer = params.peer;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SendScheduledMessages> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.messages.SendScheduledMessages({ peer: peer, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteScheduledMessages extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;

      constructor(params: { peer: Raw.TypeInputPeer; id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.DeleteScheduledMessages';
        this.constructorId = 0x59ae2b16;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'id'];
        this.peer = params.peer;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.DeleteScheduledMessages> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.messages.DeleteScheduledMessages({ peer: peer, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPollVotes extends TLObject {
      __response__!: Raw.messages.TypeVotesList;
      peer!: Raw.TypeInputPeer;
      id!: int;
      option?: bytes;
      offset?: string;
      limit!: int;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        id: int;
        option?: bytes;
        offset?: string;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetPollVotes';
        this.constructorId = 0xb86e380e;
        this.subclassOfId = 0xc2199885;
        this._slots = ['peer', 'id', 'option', 'offset', 'limit'];
        this.peer = params.peer;
        this.id = params.id;
        this.option = params.option;
        this.offset = params.offset;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetPollVotes> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = await TLObject.read(b);
        let id = await Primitive.Int.read(b);
        let option = flags & (1 << 0) ? await Primitive.Bytes.read(b) : undefined;
        let offset = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let limit = await Primitive.Int.read(b);
        return new Raw.messages.GetPollVotes({
          peer: peer,
          id: id,
          option: option,
          offset: offset,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.option !== undefined ? 1 << 0 : 0;
        flags |= this.offset !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        if (this.option !== undefined) {
          b.write(Primitive.Bytes.write(this.option) as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.String.write(this.offset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleStickerSets extends TLObject {
      __response__!: Bool;
      uninstall?: boolean;
      archive?: boolean;
      unarchive?: boolean;
      stickersets!: Vector<Raw.TypeInputStickerSet>;

      constructor(params: {
        uninstall?: boolean;
        archive?: boolean;
        unarchive?: boolean;
        stickersets: Vector<Raw.TypeInputStickerSet>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ToggleStickerSets';
        this.constructorId = 0xb5052fea;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['uninstall', 'archive', 'unarchive', 'stickersets'];
        this.uninstall = params.uninstall;
        this.archive = params.archive;
        this.unarchive = params.unarchive;
        this.stickersets = params.stickersets;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ToggleStickerSets> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let uninstall = flags & (1 << 0) ? true : false;
        let archive = flags & (1 << 1) ? true : false;
        let unarchive = flags & (1 << 2) ? true : false;
        let stickersets = await TLObject.read(b);
        return new Raw.messages.ToggleStickerSets({
          uninstall: uninstall,
          archive: archive,
          unarchive: unarchive,
          stickersets: stickersets,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.uninstall ? 1 << 0 : 0;
        flags |= this.archive ? 1 << 1 : 0;
        flags |= this.unarchive ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.stickersets) {
          b.write(Primitive.Vector.write(this.stickersets) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDialogFilters extends TLObject {
      __response__!: Vector<Raw.TypeDialogFilter>;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetDialogFilters';
        this.constructorId = 0xf19ed96d;
        this.subclassOfId = 0x601ce94d;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetDialogFilters> {
        // no flags

        return new Raw.messages.GetDialogFilters();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetSuggestedDialogFilters extends TLObject {
      __response__!: Vector<Raw.TypeDialogFilterSuggested>;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetSuggestedDialogFilters';
        this.constructorId = 0xa29cd42c;
        this.subclassOfId = 0x7b296c39;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetSuggestedDialogFilters> {
        // no flags

        return new Raw.messages.GetSuggestedDialogFilters();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class UpdateDialogFilter extends TLObject {
      __response__!: Bool;
      id!: int;
      filter?: Raw.TypeDialogFilter;

      constructor(params: { id: int; filter?: Raw.TypeDialogFilter }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.UpdateDialogFilter';
        this.constructorId = 0x1ad4a04a;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['id', 'filter'];
        this.id = params.id;
        this.filter = params.filter;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.UpdateDialogFilter> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let id = await Primitive.Int.read(b);
        let filter = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        return new Raw.messages.UpdateDialogFilter({ id: id, filter: filter });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.filter !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        if (this.filter !== undefined) {
          b.write(this.filter.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdateDialogFiltersOrder extends TLObject {
      __response__!: Bool;
      order!: Vector<int>;

      constructor(params: { order: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.UpdateDialogFiltersOrder';
        this.constructorId = 0xc563c1e4;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['order'];
        this.order = params.order;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.UpdateDialogFiltersOrder> {
        // no flags

        let order = await TLObject.read(b, Primitive.Int);
        return new Raw.messages.UpdateDialogFiltersOrder({ order: order });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.order) {
          b.write(Primitive.Vector.write(this.order, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetOldFeaturedStickers extends TLObject {
      __response__!: Raw.messages.TypeFeaturedStickers;
      offset!: int;
      limit!: int;
      hash!: long;

      constructor(params: { offset: int; limit: int; hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetOldFeaturedStickers';
        this.constructorId = 0x7ed094a1;
        this.subclassOfId = 0x2614b722;
        this._slots = ['offset', 'limit', 'hash'];
        this.offset = params.offset;
        this.limit = params.limit;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetOldFeaturedStickers> {
        // no flags

        let offset = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetOldFeaturedStickers({
          offset: offset,
          limit: limit,
          hash: hash,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.offset !== undefined) {
          b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetReplies extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      peer!: Raw.TypeInputPeer;
      msgId!: int;
      offsetId!: int;
      offsetDate!: int;
      addOffset!: int;
      limit!: int;
      maxId!: int;
      minId!: int;
      hash!: long;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        msgId: int;
        offsetId: int;
        offsetDate: int;
        addOffset: int;
        limit: int;
        maxId: int;
        minId: int;
        hash: long;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetReplies';
        this.constructorId = 0x22ddd30c;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = [
          'peer',
          'msgId',
          'offsetId',
          'offsetDate',
          'addOffset',
          'limit',
          'maxId',
          'minId',
          'hash',
        ];
        this.peer = params.peer;
        this.msgId = params.msgId;
        this.offsetId = params.offsetId;
        this.offsetDate = params.offsetDate;
        this.addOffset = params.addOffset;
        this.limit = params.limit;
        this.maxId = params.maxId;
        this.minId = params.minId;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetReplies> {
        // no flags

        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        let offsetId = await Primitive.Int.read(b);
        let offsetDate = await Primitive.Int.read(b);
        let addOffset = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        let maxId = await Primitive.Int.read(b);
        let minId = await Primitive.Int.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetReplies({
          peer: peer,
          msgId: msgId,
          offsetId: offsetId,
          offsetDate: offsetDate,
          addOffset: addOffset,
          limit: limit,
          maxId: maxId,
          minId: minId,
          hash: hash,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.offsetDate !== undefined) {
          b.write(Primitive.Int.write(this.offsetDate) as unknown as Buffer);
        }
        if (this.addOffset !== undefined) {
          b.write(Primitive.Int.write(this.addOffset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
        }
        if (this.minId !== undefined) {
          b.write(Primitive.Int.write(this.minId) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDiscussionMessage extends TLObject {
      __response__!: Raw.messages.TypeDiscussionMessage;
      peer!: Raw.TypeInputPeer;
      msgId!: int;

      constructor(params: { peer: Raw.TypeInputPeer; msgId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetDiscussionMessage';
        this.constructorId = 0x446972fd;
        this.subclassOfId = 0x53f8e3e8;
        this._slots = ['peer', 'msgId'];
        this.peer = params.peer;
        this.msgId = params.msgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetDiscussionMessage> {
        // no flags

        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        return new Raw.messages.GetDiscussionMessage({ peer: peer, msgId: msgId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReadDiscussion extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      msgId!: int;
      readMaxId!: int;

      constructor(params: { peer: Raw.TypeInputPeer; msgId: int; readMaxId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReadDiscussion';
        this.constructorId = 0xf731a9f4;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'msgId', 'readMaxId'];
        this.peer = params.peer;
        this.msgId = params.msgId;
        this.readMaxId = params.readMaxId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ReadDiscussion> {
        // no flags

        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        let readMaxId = await Primitive.Int.read(b);
        return new Raw.messages.ReadDiscussion({ peer: peer, msgId: msgId, readMaxId: readMaxId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        if (this.readMaxId !== undefined) {
          b.write(Primitive.Int.write(this.readMaxId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UnpinAllMessages extends TLObject {
      __response__!: Raw.messages.TypeAffectedHistory;
      peer!: Raw.TypeInputPeer;
      topMsgId?: int;

      constructor(params: { peer: Raw.TypeInputPeer; topMsgId?: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.UnpinAllMessages';
        this.constructorId = 0xee22b9a8;
        this.subclassOfId = 0x2c49c116;
        this._slots = ['peer', 'topMsgId'];
        this.peer = params.peer;
        this.topMsgId = params.topMsgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.UnpinAllMessages> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = await TLObject.read(b);
        let topMsgId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        return new Raw.messages.UnpinAllMessages({ peer: peer, topMsgId: topMsgId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.topMsgId !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.topMsgId !== undefined) {
          b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteChat extends TLObject {
      __response__!: Bool;
      chatId!: long;

      constructor(params: { chatId: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.DeleteChat';
        this.constructorId = 0x5bd0ee50;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['chatId'];
        this.chatId = params.chatId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.DeleteChat> {
        // no flags

        let chatId = await Primitive.Long.read(b);
        return new Raw.messages.DeleteChat({ chatId: chatId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatId !== undefined) {
          b.write(Primitive.Long.write(this.chatId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeletePhoneCallHistory extends TLObject {
      __response__!: Raw.messages.TypeAffectedFoundMessages;
      revoke?: boolean;

      constructor(params: { revoke?: boolean }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.DeletePhoneCallHistory';
        this.constructorId = 0xf9cbe409;
        this.subclassOfId = 0xf817652e;
        this._slots = ['revoke'];
        this.revoke = params.revoke;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.DeletePhoneCallHistory> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let revoke = flags & (1 << 0) ? true : false;
        return new Raw.messages.DeletePhoneCallHistory({ revoke: revoke });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.revoke ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        return b.buffer;
      }
    }
    export class CheckHistoryImport extends TLObject {
      __response__!: Raw.messages.TypeHistoryImportParsed;
      importHead!: string;

      constructor(params: { importHead: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.CheckHistoryImport';
        this.constructorId = 0x43fe19f3;
        this.subclassOfId = 0x5bb2720b;
        this._slots = ['importHead'];
        this.importHead = params.importHead;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.CheckHistoryImport> {
        // no flags

        let importHead = await Primitive.String.read(b);
        return new Raw.messages.CheckHistoryImport({ importHead: importHead });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.importHead !== undefined) {
          b.write(Primitive.String.write(this.importHead) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class InitHistoryImport extends TLObject {
      __response__!: Raw.messages.TypeHistoryImport;
      peer!: Raw.TypeInputPeer;
      file!: Raw.TypeInputFile;
      mediaCount!: int;

      constructor(params: { peer: Raw.TypeInputPeer; file: Raw.TypeInputFile; mediaCount: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.InitHistoryImport';
        this.constructorId = 0x34090c3b;
        this.subclassOfId = 0xb18bb50a;
        this._slots = ['peer', 'file', 'mediaCount'];
        this.peer = params.peer;
        this.file = params.file;
        this.mediaCount = params.mediaCount;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.InitHistoryImport> {
        // no flags

        let peer = await TLObject.read(b);
        let file = await TLObject.read(b);
        let mediaCount = await Primitive.Int.read(b);
        return new Raw.messages.InitHistoryImport({
          peer: peer,
          file: file,
          mediaCount: mediaCount,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.file !== undefined) {
          b.write(this.file.write() as unknown as Buffer);
        }
        if (this.mediaCount !== undefined) {
          b.write(Primitive.Int.write(this.mediaCount) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UploadImportedMedia extends TLObject {
      __response__!: Raw.TypeMessageMedia;
      peer!: Raw.TypeInputPeer;
      importId!: long;
      fileName!: string;
      media!: Raw.TypeInputMedia;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        importId: long;
        fileName: string;
        media: Raw.TypeInputMedia;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.UploadImportedMedia';
        this.constructorId = 0x2a862092;
        this.subclassOfId = 0x476cbe32;
        this._slots = ['peer', 'importId', 'fileName', 'media'];
        this.peer = params.peer;
        this.importId = params.importId;
        this.fileName = params.fileName;
        this.media = params.media;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.UploadImportedMedia> {
        // no flags

        let peer = await TLObject.read(b);
        let importId = await Primitive.Long.read(b);
        let fileName = await Primitive.String.read(b);
        let media = await TLObject.read(b);
        return new Raw.messages.UploadImportedMedia({
          peer: peer,
          importId: importId,
          fileName: fileName,
          media: media,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.importId !== undefined) {
          b.write(Primitive.Long.write(this.importId) as unknown as Buffer);
        }
        if (this.fileName !== undefined) {
          b.write(Primitive.String.write(this.fileName) as unknown as Buffer);
        }
        if (this.media !== undefined) {
          b.write(this.media.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class StartHistoryImport extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      importId!: long;

      constructor(params: { peer: Raw.TypeInputPeer; importId: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.StartHistoryImport';
        this.constructorId = 0xb43df344;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'importId'];
        this.peer = params.peer;
        this.importId = params.importId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.StartHistoryImport> {
        // no flags

        let peer = await TLObject.read(b);
        let importId = await Primitive.Long.read(b);
        return new Raw.messages.StartHistoryImport({ peer: peer, importId: importId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.importId !== undefined) {
          b.write(Primitive.Long.write(this.importId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetExportedChatInvites extends TLObject {
      __response__!: Raw.messages.TypeExportedChatInvites;
      revoked?: boolean;
      peer!: Raw.TypeInputPeer;
      adminId!: Raw.TypeInputUser;
      offsetDate?: int;
      offsetLink?: string;
      limit!: int;

      constructor(params: {
        revoked?: boolean;
        peer: Raw.TypeInputPeer;
        adminId: Raw.TypeInputUser;
        offsetDate?: int;
        offsetLink?: string;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetExportedChatInvites';
        this.constructorId = 0xa2b5a3f6;
        this.subclassOfId = 0x603d3871;
        this._slots = ['revoked', 'peer', 'adminId', 'offsetDate', 'offsetLink', 'limit'];
        this.revoked = params.revoked;
        this.peer = params.peer;
        this.adminId = params.adminId;
        this.offsetDate = params.offsetDate;
        this.offsetLink = params.offsetLink;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetExportedChatInvites> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let revoked = flags & (1 << 3) ? true : false;
        let peer = await TLObject.read(b);
        let adminId = await TLObject.read(b);
        let offsetDate = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
        let offsetLink = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        let limit = await Primitive.Int.read(b);
        return new Raw.messages.GetExportedChatInvites({
          revoked: revoked,
          peer: peer,
          adminId: adminId,
          offsetDate: offsetDate,
          offsetLink: offsetLink,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.revoked ? 1 << 3 : 0;
        flags |= this.offsetDate !== undefined ? 1 << 2 : 0;
        flags |= this.offsetLink !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.adminId !== undefined) {
          b.write(this.adminId.write() as unknown as Buffer);
        }
        if (this.offsetDate !== undefined) {
          b.write(Primitive.Int.write(this.offsetDate) as unknown as Buffer);
        }
        if (this.offsetLink !== undefined) {
          b.write(Primitive.String.write(this.offsetLink) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetExportedChatInvite extends TLObject {
      __response__!: Raw.messages.TypeExportedChatInvite;
      peer!: Raw.TypeInputPeer;
      link!: string;

      constructor(params: { peer: Raw.TypeInputPeer; link: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetExportedChatInvite';
        this.constructorId = 0x73746f5c;
        this.subclassOfId = 0x82dcd4ca;
        this._slots = ['peer', 'link'];
        this.peer = params.peer;
        this.link = params.link;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetExportedChatInvite> {
        // no flags

        let peer = await TLObject.read(b);
        let link = await Primitive.String.read(b);
        return new Raw.messages.GetExportedChatInvite({ peer: peer, link: link });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.link !== undefined) {
          b.write(Primitive.String.write(this.link) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditExportedChatInvite extends TLObject {
      __response__!: Raw.messages.TypeExportedChatInvite;
      revoked?: boolean;
      peer!: Raw.TypeInputPeer;
      link!: string;
      expireDate?: int;
      usageLimit?: int;
      requestNeeded?: Bool;
      title?: string;

      constructor(params: {
        revoked?: boolean;
        peer: Raw.TypeInputPeer;
        link: string;
        expireDate?: int;
        usageLimit?: int;
        requestNeeded?: Bool;
        title?: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.EditExportedChatInvite';
        this.constructorId = 0xbdca2f75;
        this.subclassOfId = 0x82dcd4ca;
        this._slots = [
          'revoked',
          'peer',
          'link',
          'expireDate',
          'usageLimit',
          'requestNeeded',
          'title',
        ];
        this.revoked = params.revoked;
        this.peer = params.peer;
        this.link = params.link;
        this.expireDate = params.expireDate;
        this.usageLimit = params.usageLimit;
        this.requestNeeded = params.requestNeeded;
        this.title = params.title;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.EditExportedChatInvite> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let revoked = flags & (1 << 2) ? true : false;
        let peer = await TLObject.read(b);
        let link = await Primitive.String.read(b);
        let expireDate = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let usageLimit = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let requestNeeded = flags & (1 << 3) ? await Primitive.Bool.read(b) : undefined;
        let title = flags & (1 << 4) ? await Primitive.String.read(b) : undefined;
        return new Raw.messages.EditExportedChatInvite({
          revoked: revoked,
          peer: peer,
          link: link,
          expireDate: expireDate,
          usageLimit: usageLimit,
          requestNeeded: requestNeeded,
          title: title,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.revoked ? 1 << 2 : 0;
        flags |= this.expireDate !== undefined ? 1 << 0 : 0;
        flags |= this.usageLimit !== undefined ? 1 << 1 : 0;
        flags |= this.requestNeeded !== undefined ? 1 << 3 : 0;
        flags |= this.title !== undefined ? 1 << 4 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.link !== undefined) {
          b.write(Primitive.String.write(this.link) as unknown as Buffer);
        }
        if (this.expireDate !== undefined) {
          b.write(Primitive.Int.write(this.expireDate) as unknown as Buffer);
        }
        if (this.usageLimit !== undefined) {
          b.write(Primitive.Int.write(this.usageLimit) as unknown as Buffer);
        }
        if (this.requestNeeded !== undefined) {
          b.write(Primitive.Bool.write(this.requestNeeded) as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteRevokedExportedChatInvites extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      adminId!: Raw.TypeInputUser;

      constructor(params: { peer: Raw.TypeInputPeer; adminId: Raw.TypeInputUser }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.DeleteRevokedExportedChatInvites';
        this.constructorId = 0x56987bd5;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'adminId'];
        this.peer = params.peer;
        this.adminId = params.adminId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.DeleteRevokedExportedChatInvites> {
        // no flags

        let peer = await TLObject.read(b);
        let adminId = await TLObject.read(b);
        return new Raw.messages.DeleteRevokedExportedChatInvites({ peer: peer, adminId: adminId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.adminId !== undefined) {
          b.write(this.adminId.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteExportedChatInvite extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      link!: string;

      constructor(params: { peer: Raw.TypeInputPeer; link: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.DeleteExportedChatInvite';
        this.constructorId = 0xd464a42b;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'link'];
        this.peer = params.peer;
        this.link = params.link;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.DeleteExportedChatInvite> {
        // no flags

        let peer = await TLObject.read(b);
        let link = await Primitive.String.read(b);
        return new Raw.messages.DeleteExportedChatInvite({ peer: peer, link: link });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.link !== undefined) {
          b.write(Primitive.String.write(this.link) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAdminsWithInvites extends TLObject {
      __response__!: Raw.messages.TypeChatAdminsWithInvites;
      peer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetAdminsWithInvites';
        this.constructorId = 0x3920e6ef;
        this.subclassOfId = 0x8f5bad2b;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetAdminsWithInvites> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.messages.GetAdminsWithInvites({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetChatInviteImporters extends TLObject {
      __response__!: Raw.messages.TypeChatInviteImporters;
      requested?: boolean;
      peer!: Raw.TypeInputPeer;
      link?: string;
      q?: string;
      offsetDate!: int;
      offsetUser!: Raw.TypeInputUser;
      limit!: int;

      constructor(params: {
        requested?: boolean;
        peer: Raw.TypeInputPeer;
        link?: string;
        q?: string;
        offsetDate: int;
        offsetUser: Raw.TypeInputUser;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetChatInviteImporters';
        this.constructorId = 0xdf04dd4e;
        this.subclassOfId = 0xd9bc8aa6;
        this._slots = ['requested', 'peer', 'link', 'q', 'offsetDate', 'offsetUser', 'limit'];
        this.requested = params.requested;
        this.peer = params.peer;
        this.link = params.link;
        this.q = params.q;
        this.offsetDate = params.offsetDate;
        this.offsetUser = params.offsetUser;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetChatInviteImporters> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let requested = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        let link = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let q = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        let offsetDate = await Primitive.Int.read(b);
        let offsetUser = await TLObject.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.messages.GetChatInviteImporters({
          requested: requested,
          peer: peer,
          link: link,
          q: q,
          offsetDate: offsetDate,
          offsetUser: offsetUser,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.requested ? 1 << 0 : 0;
        flags |= this.link !== undefined ? 1 << 1 : 0;
        flags |= this.q !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.link !== undefined) {
          b.write(Primitive.String.write(this.link) as unknown as Buffer);
        }
        if (this.q !== undefined) {
          b.write(Primitive.String.write(this.q) as unknown as Buffer);
        }
        if (this.offsetDate !== undefined) {
          b.write(Primitive.Int.write(this.offsetDate) as unknown as Buffer);
        }
        if (this.offsetUser !== undefined) {
          b.write(this.offsetUser.write() as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetHistoryTTL extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      period!: int;

      constructor(params: { peer: Raw.TypeInputPeer; period: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetHistoryTTL';
        this.constructorId = 0xb80e5fe4;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'period'];
        this.peer = params.peer;
        this.period = params.period;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SetHistoryTTL> {
        // no flags

        let peer = await TLObject.read(b);
        let period = await Primitive.Int.read(b);
        return new Raw.messages.SetHistoryTTL({ peer: peer, period: period });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.period !== undefined) {
          b.write(Primitive.Int.write(this.period) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CheckHistoryImportPeer extends TLObject {
      __response__!: Raw.messages.TypeCheckedHistoryImportPeer;
      peer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.CheckHistoryImportPeer';
        this.constructorId = 0x5dc60f03;
        this.subclassOfId = 0xb84bb337;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.CheckHistoryImportPeer> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.messages.CheckHistoryImportPeer({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetChatTheme extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      emoticon!: string;

      constructor(params: { peer: Raw.TypeInputPeer; emoticon: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetChatTheme';
        this.constructorId = 0xe63be13f;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'emoticon'];
        this.peer = params.peer;
        this.emoticon = params.emoticon;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SetChatTheme> {
        // no flags

        let peer = await TLObject.read(b);
        let emoticon = await Primitive.String.read(b);
        return new Raw.messages.SetChatTheme({ peer: peer, emoticon: emoticon });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.emoticon !== undefined) {
          b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetMessageReadParticipants extends TLObject {
      __response__!: Vector<Raw.TypeReadParticipantDate>;
      peer!: Raw.TypeInputPeer;
      msgId!: int;

      constructor(params: { peer: Raw.TypeInputPeer; msgId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetMessageReadParticipants';
        this.constructorId = 0x31c1c44f;
        this.subclassOfId = 0x21ca455b;
        this._slots = ['peer', 'msgId'];
        this.peer = params.peer;
        this.msgId = params.msgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetMessageReadParticipants> {
        // no flags

        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        return new Raw.messages.GetMessageReadParticipants({ peer: peer, msgId: msgId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetSearchResultsCalendar extends TLObject {
      __response__!: Raw.messages.TypeSearchResultsCalendar;
      peer!: Raw.TypeInputPeer;
      filter!: Raw.TypeMessagesFilter;
      offsetId!: int;
      offsetDate!: int;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        filter: Raw.TypeMessagesFilter;
        offsetId: int;
        offsetDate: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetSearchResultsCalendar';
        this.constructorId = 0x49f0bde9;
        this.subclassOfId = 0x92c5640f;
        this._slots = ['peer', 'filter', 'offsetId', 'offsetDate'];
        this.peer = params.peer;
        this.filter = params.filter;
        this.offsetId = params.offsetId;
        this.offsetDate = params.offsetDate;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetSearchResultsCalendar> {
        // no flags

        let peer = await TLObject.read(b);
        let filter = await TLObject.read(b);
        let offsetId = await Primitive.Int.read(b);
        let offsetDate = await Primitive.Int.read(b);
        return new Raw.messages.GetSearchResultsCalendar({
          peer: peer,
          filter: filter,
          offsetId: offsetId,
          offsetDate: offsetDate,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.filter !== undefined) {
          b.write(this.filter.write() as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.offsetDate !== undefined) {
          b.write(Primitive.Int.write(this.offsetDate) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetSearchResultsPositions extends TLObject {
      __response__!: Raw.messages.TypeSearchResultsPositions;
      peer!: Raw.TypeInputPeer;
      filter!: Raw.TypeMessagesFilter;
      offsetId!: int;
      limit!: int;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        filter: Raw.TypeMessagesFilter;
        offsetId: int;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetSearchResultsPositions';
        this.constructorId = 0x6e9583a3;
        this.subclassOfId = 0xd963708d;
        this._slots = ['peer', 'filter', 'offsetId', 'limit'];
        this.peer = params.peer;
        this.filter = params.filter;
        this.offsetId = params.offsetId;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetSearchResultsPositions> {
        // no flags

        let peer = await TLObject.read(b);
        let filter = await TLObject.read(b);
        let offsetId = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.messages.GetSearchResultsPositions({
          peer: peer,
          filter: filter,
          offsetId: offsetId,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.filter !== undefined) {
          b.write(this.filter.write() as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class HideChatJoinRequest extends TLObject {
      __response__!: Raw.TypeUpdates;
      approved?: boolean;
      peer!: Raw.TypeInputPeer;
      userId!: Raw.TypeInputUser;

      constructor(params: {
        approved?: boolean;
        peer: Raw.TypeInputPeer;
        userId: Raw.TypeInputUser;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.HideChatJoinRequest';
        this.constructorId = 0x7fe7e815;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['approved', 'peer', 'userId'];
        this.approved = params.approved;
        this.peer = params.peer;
        this.userId = params.userId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.HideChatJoinRequest> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let approved = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        let userId = await TLObject.read(b);
        return new Raw.messages.HideChatJoinRequest({
          approved: approved,
          peer: peer,
          userId: userId,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.approved ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class HideAllChatJoinRequests extends TLObject {
      __response__!: Raw.TypeUpdates;
      approved?: boolean;
      peer!: Raw.TypeInputPeer;
      link?: string;

      constructor(params: { approved?: boolean; peer: Raw.TypeInputPeer; link?: string }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.HideAllChatJoinRequests';
        this.constructorId = 0xe085f4ea;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['approved', 'peer', 'link'];
        this.approved = params.approved;
        this.peer = params.peer;
        this.link = params.link;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.HideAllChatJoinRequests> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let approved = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        let link = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        return new Raw.messages.HideAllChatJoinRequests({
          approved: approved,
          peer: peer,
          link: link,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.approved ? 1 << 0 : 0;
        flags |= this.link !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.link !== undefined) {
          b.write(Primitive.String.write(this.link) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleNoForwards extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      enabled!: Bool;

      constructor(params: { peer: Raw.TypeInputPeer; enabled: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ToggleNoForwards';
        this.constructorId = 0xb11eafa2;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'enabled'];
        this.peer = params.peer;
        this.enabled = params.enabled;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ToggleNoForwards> {
        // no flags

        let peer = await TLObject.read(b);
        let enabled = await Primitive.Bool.read(b);
        return new Raw.messages.ToggleNoForwards({ peer: peer, enabled: enabled });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.enabled !== undefined) {
          b.write(Primitive.Bool.write(this.enabled) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveDefaultSendAs extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      sendAs!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer; sendAs: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SaveDefaultSendAs';
        this.constructorId = 0xccfddf96;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'sendAs'];
        this.peer = params.peer;
        this.sendAs = params.sendAs;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SaveDefaultSendAs> {
        // no flags

        let peer = await TLObject.read(b);
        let sendAs = await TLObject.read(b);
        return new Raw.messages.SaveDefaultSendAs({ peer: peer, sendAs: sendAs });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.sendAs !== undefined) {
          b.write(this.sendAs.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendReaction extends TLObject {
      __response__!: Raw.TypeUpdates;
      big?: boolean;
      addToRecent?: boolean;
      peer!: Raw.TypeInputPeer;
      msgId!: int;
      reaction?: Vector<Raw.TypeReaction>;

      constructor(params: {
        big?: boolean;
        addToRecent?: boolean;
        peer: Raw.TypeInputPeer;
        msgId: int;
        reaction?: Vector<Raw.TypeReaction>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendReaction';
        this.constructorId = 0xd30d78d4;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['big', 'addToRecent', 'peer', 'msgId', 'reaction'];
        this.big = params.big;
        this.addToRecent = params.addToRecent;
        this.peer = params.peer;
        this.msgId = params.msgId;
        this.reaction = params.reaction;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SendReaction> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let big = flags & (1 << 1) ? true : false;
        let addToRecent = flags & (1 << 2) ? true : false;
        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        let reaction = flags & (1 << 0) ? await TLObject.read(b) : [];
        return new Raw.messages.SendReaction({
          big: big,
          addToRecent: addToRecent,
          peer: peer,
          msgId: msgId,
          reaction: reaction,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.big ? 1 << 1 : 0;
        flags |= this.addToRecent ? 1 << 2 : 0;
        flags |= this.reaction ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        if (this.reaction) {
          b.write(Primitive.Vector.write(this.reaction) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetMessagesReactions extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;

      constructor(params: { peer: Raw.TypeInputPeer; id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetMessagesReactions';
        this.constructorId = 0x8bba90e6;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'id'];
        this.peer = params.peer;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetMessagesReactions> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.messages.GetMessagesReactions({ peer: peer, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetMessageReactionsList extends TLObject {
      __response__!: Raw.messages.TypeMessageReactionsList;
      peer!: Raw.TypeInputPeer;
      id!: int;
      reaction?: Raw.TypeReaction;
      offset?: string;
      limit!: int;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        id: int;
        reaction?: Raw.TypeReaction;
        offset?: string;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetMessageReactionsList';
        this.constructorId = 0x461b3f48;
        this.subclassOfId = 0x60fce5e6;
        this._slots = ['peer', 'id', 'reaction', 'offset', 'limit'];
        this.peer = params.peer;
        this.id = params.id;
        this.reaction = params.reaction;
        this.offset = params.offset;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetMessageReactionsList> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = await TLObject.read(b);
        let id = await Primitive.Int.read(b);
        let reaction = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let offset = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let limit = await Primitive.Int.read(b);
        return new Raw.messages.GetMessageReactionsList({
          peer: peer,
          id: id,
          reaction: reaction,
          offset: offset,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.reaction !== undefined ? 1 << 0 : 0;
        flags |= this.offset !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        if (this.reaction !== undefined) {
          b.write(this.reaction.write() as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.String.write(this.offset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetChatAvailableReactions extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      availableReactions!: Raw.TypeChatReactions;

      constructor(params: { peer: Raw.TypeInputPeer; availableReactions: Raw.TypeChatReactions }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetChatAvailableReactions';
        this.constructorId = 0xfeb16771;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'availableReactions'];
        this.peer = params.peer;
        this.availableReactions = params.availableReactions;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SetChatAvailableReactions> {
        // no flags

        let peer = await TLObject.read(b);
        let availableReactions = await TLObject.read(b);
        return new Raw.messages.SetChatAvailableReactions({
          peer: peer,
          availableReactions: availableReactions,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.availableReactions !== undefined) {
          b.write(this.availableReactions.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAvailableReactions extends TLObject {
      __response__!: Raw.messages.TypeAvailableReactions;
      hash!: int;

      constructor(params: { hash: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetAvailableReactions';
        this.constructorId = 0x18dea0ac;
        this.subclassOfId = 0xe426ad82;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetAvailableReactions> {
        // no flags

        let hash = await Primitive.Int.read(b);
        return new Raw.messages.GetAvailableReactions({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetDefaultReaction extends TLObject {
      __response__!: Bool;
      reaction!: Raw.TypeReaction;

      constructor(params: { reaction: Raw.TypeReaction }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetDefaultReaction';
        this.constructorId = 0x4f47a016;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['reaction'];
        this.reaction = params.reaction;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SetDefaultReaction> {
        // no flags

        let reaction = await TLObject.read(b);
        return new Raw.messages.SetDefaultReaction({ reaction: reaction });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.reaction !== undefined) {
          b.write(this.reaction.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TranslateText extends TLObject {
      __response__!: Raw.messages.TypeTranslatedText;
      peer?: Raw.TypeInputPeer;
      id?: Vector<int>;
      text?: Vector<Raw.TypeTextWithEntities>;
      toLang!: string;

      constructor(params: {
        peer?: Raw.TypeInputPeer;
        id?: Vector<int>;
        text?: Vector<Raw.TypeTextWithEntities>;
        toLang: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.TranslateText';
        this.constructorId = 0x63183030;
        this.subclassOfId = 0x24243e8;
        this._slots = ['peer', 'id', 'text', 'toLang'];
        this.peer = params.peer;
        this.id = params.id;
        this.text = params.text;
        this.toLang = params.toLang;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.TranslateText> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let id = flags & (1 << 0) ? await TLObject.read(b, Primitive.Int) : [];
        let text = flags & (1 << 1) ? await TLObject.read(b) : [];
        let toLang = await Primitive.String.read(b);
        return new Raw.messages.TranslateText({ peer: peer, id: id, text: text, toLang: toLang });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.peer !== undefined ? 1 << 0 : 0;
        flags |= this.id ? 1 << 0 : 0;
        flags |= this.text ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        if (this.text) {
          b.write(Primitive.Vector.write(this.text) as unknown as Buffer);
        }
        if (this.toLang !== undefined) {
          b.write(Primitive.String.write(this.toLang) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetUnreadReactions extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      peer!: Raw.TypeInputPeer;
      topMsgId?: int;
      offsetId!: int;
      addOffset!: int;
      limit!: int;
      maxId!: int;
      minId!: int;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        topMsgId?: int;
        offsetId: int;
        addOffset: int;
        limit: int;
        maxId: int;
        minId: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetUnreadReactions';
        this.constructorId = 0x3223495b;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = ['peer', 'topMsgId', 'offsetId', 'addOffset', 'limit', 'maxId', 'minId'];
        this.peer = params.peer;
        this.topMsgId = params.topMsgId;
        this.offsetId = params.offsetId;
        this.addOffset = params.addOffset;
        this.limit = params.limit;
        this.maxId = params.maxId;
        this.minId = params.minId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetUnreadReactions> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = await TLObject.read(b);
        let topMsgId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let offsetId = await Primitive.Int.read(b);
        let addOffset = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        let maxId = await Primitive.Int.read(b);
        let minId = await Primitive.Int.read(b);
        return new Raw.messages.GetUnreadReactions({
          peer: peer,
          topMsgId: topMsgId,
          offsetId: offsetId,
          addOffset: addOffset,
          limit: limit,
          maxId: maxId,
          minId: minId,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.topMsgId !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.topMsgId !== undefined) {
          b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.addOffset !== undefined) {
          b.write(Primitive.Int.write(this.addOffset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
        }
        if (this.minId !== undefined) {
          b.write(Primitive.Int.write(this.minId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReadReactions extends TLObject {
      __response__!: Raw.messages.TypeAffectedHistory;
      peer!: Raw.TypeInputPeer;
      topMsgId?: int;

      constructor(params: { peer: Raw.TypeInputPeer; topMsgId?: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReadReactions';
        this.constructorId = 0x54aa7f8e;
        this.subclassOfId = 0x2c49c116;
        this._slots = ['peer', 'topMsgId'];
        this.peer = params.peer;
        this.topMsgId = params.topMsgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ReadReactions> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = await TLObject.read(b);
        let topMsgId = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        return new Raw.messages.ReadReactions({ peer: peer, topMsgId: topMsgId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.topMsgId !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.topMsgId !== undefined) {
          b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SearchSentMedia extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      q!: string;
      filter!: Raw.TypeMessagesFilter;
      limit!: int;

      constructor(params: { q: string; filter: Raw.TypeMessagesFilter; limit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SearchSentMedia';
        this.constructorId = 0x107e31a0;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = ['q', 'filter', 'limit'];
        this.q = params.q;
        this.filter = params.filter;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SearchSentMedia> {
        // no flags

        let q = await Primitive.String.read(b);
        let filter = await TLObject.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.messages.SearchSentMedia({ q: q, filter: filter, limit: limit });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.q !== undefined) {
          b.write(Primitive.String.write(this.q) as unknown as Buffer);
        }
        if (this.filter !== undefined) {
          b.write(this.filter.write() as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAttachMenuBots extends TLObject {
      __response__!: Raw.TypeAttachMenuBots;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetAttachMenuBots';
        this.constructorId = 0x16fcc2cb;
        this.subclassOfId = 0x842e23da;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetAttachMenuBots> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetAttachMenuBots({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAttachMenuBot extends TLObject {
      __response__!: Raw.TypeAttachMenuBotsBot;
      bot!: Raw.TypeInputUser;

      constructor(params: { bot: Raw.TypeInputUser }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetAttachMenuBot';
        this.constructorId = 0x77216192;
        this.subclassOfId = 0xdb33883d;
        this._slots = ['bot'];
        this.bot = params.bot;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetAttachMenuBot> {
        // no flags

        let bot = await TLObject.read(b);
        return new Raw.messages.GetAttachMenuBot({ bot: bot });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleBotInAttachMenu extends TLObject {
      __response__!: Bool;
      writeAllowed?: boolean;
      bot!: Raw.TypeInputUser;
      enabled!: Bool;

      constructor(params: { writeAllowed?: boolean; bot: Raw.TypeInputUser; enabled: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ToggleBotInAttachMenu';
        this.constructorId = 0x69f59d69;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['writeAllowed', 'bot', 'enabled'];
        this.writeAllowed = params.writeAllowed;
        this.bot = params.bot;
        this.enabled = params.enabled;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ToggleBotInAttachMenu> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let writeAllowed = flags & (1 << 0) ? true : false;
        let bot = await TLObject.read(b);
        let enabled = await Primitive.Bool.read(b);
        return new Raw.messages.ToggleBotInAttachMenu({
          writeAllowed: writeAllowed,
          bot: bot,
          enabled: enabled,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.writeAllowed ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.enabled !== undefined) {
          b.write(Primitive.Bool.write(this.enabled) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RequestWebView extends TLObject {
      __response__!: Raw.TypeWebViewResult;
      fromBotMenu?: boolean;
      silent?: boolean;
      peer!: Raw.TypeInputPeer;
      bot!: Raw.TypeInputUser;
      url?: string;
      startParam?: string;
      themeParams?: Raw.TypeDataJSON;
      platform!: string;
      replyTo?: Raw.TypeInputReplyTo;
      sendAs?: Raw.TypeInputPeer;

      constructor(params: {
        fromBotMenu?: boolean;
        silent?: boolean;
        peer: Raw.TypeInputPeer;
        bot: Raw.TypeInputUser;
        url?: string;
        startParam?: string;
        themeParams?: Raw.TypeDataJSON;
        platform: string;
        replyTo?: Raw.TypeInputReplyTo;
        sendAs?: Raw.TypeInputPeer;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.RequestWebView';
        this.constructorId = 0x269dc2c1;
        this.subclassOfId = 0x93cea746;
        this._slots = [
          'fromBotMenu',
          'silent',
          'peer',
          'bot',
          'url',
          'startParam',
          'themeParams',
          'platform',
          'replyTo',
          'sendAs',
        ];
        this.fromBotMenu = params.fromBotMenu;
        this.silent = params.silent;
        this.peer = params.peer;
        this.bot = params.bot;
        this.url = params.url;
        this.startParam = params.startParam;
        this.themeParams = params.themeParams;
        this.platform = params.platform;
        this.replyTo = params.replyTo;
        this.sendAs = params.sendAs;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.RequestWebView> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let fromBotMenu = flags & (1 << 4) ? true : false;
        let silent = flags & (1 << 5) ? true : false;
        let peer = await TLObject.read(b);
        let bot = await TLObject.read(b);
        let url = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let startParam = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
        let themeParams = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let platform = await Primitive.String.read(b);
        let replyTo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let sendAs = flags & (1 << 13) ? await TLObject.read(b) : undefined;
        return new Raw.messages.RequestWebView({
          fromBotMenu: fromBotMenu,
          silent: silent,
          peer: peer,
          bot: bot,
          url: url,
          startParam: startParam,
          themeParams: themeParams,
          platform: platform,
          replyTo: replyTo,
          sendAs: sendAs,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.fromBotMenu ? 1 << 4 : 0;
        flags |= this.silent ? 1 << 5 : 0;
        flags |= this.url !== undefined ? 1 << 1 : 0;
        flags |= this.startParam !== undefined ? 1 << 3 : 0;
        flags |= this.themeParams !== undefined ? 1 << 2 : 0;
        flags |= this.replyTo !== undefined ? 1 << 0 : 0;
        flags |= this.sendAs !== undefined ? 1 << 13 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        if (this.startParam !== undefined) {
          b.write(Primitive.String.write(this.startParam) as unknown as Buffer);
        }
        if (this.themeParams !== undefined) {
          b.write(this.themeParams.write() as unknown as Buffer);
        }
        if (this.platform !== undefined) {
          b.write(Primitive.String.write(this.platform) as unknown as Buffer);
        }
        if (this.replyTo !== undefined) {
          b.write(this.replyTo.write() as unknown as Buffer);
        }
        if (this.sendAs !== undefined) {
          b.write(this.sendAs.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ProlongWebView extends TLObject {
      __response__!: Bool;
      silent?: boolean;
      peer!: Raw.TypeInputPeer;
      bot!: Raw.TypeInputUser;
      queryId!: long;
      replyTo?: Raw.TypeInputReplyTo;
      sendAs?: Raw.TypeInputPeer;

      constructor(params: {
        silent?: boolean;
        peer: Raw.TypeInputPeer;
        bot: Raw.TypeInputUser;
        queryId: long;
        replyTo?: Raw.TypeInputReplyTo;
        sendAs?: Raw.TypeInputPeer;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ProlongWebView';
        this.constructorId = 0xb0d81a83;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['silent', 'peer', 'bot', 'queryId', 'replyTo', 'sendAs'];
        this.silent = params.silent;
        this.peer = params.peer;
        this.bot = params.bot;
        this.queryId = params.queryId;
        this.replyTo = params.replyTo;
        this.sendAs = params.sendAs;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ProlongWebView> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let silent = flags & (1 << 5) ? true : false;
        let peer = await TLObject.read(b);
        let bot = await TLObject.read(b);
        let queryId = await Primitive.Long.read(b);
        let replyTo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let sendAs = flags & (1 << 13) ? await TLObject.read(b) : undefined;
        return new Raw.messages.ProlongWebView({
          silent: silent,
          peer: peer,
          bot: bot,
          queryId: queryId,
          replyTo: replyTo,
          sendAs: sendAs,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.silent ? 1 << 5 : 0;
        flags |= this.replyTo !== undefined ? 1 << 0 : 0;
        flags |= this.sendAs !== undefined ? 1 << 13 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.queryId !== undefined) {
          b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
        }
        if (this.replyTo !== undefined) {
          b.write(this.replyTo.write() as unknown as Buffer);
        }
        if (this.sendAs !== undefined) {
          b.write(this.sendAs.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RequestSimpleWebView extends TLObject {
      __response__!: Raw.TypeSimpleWebViewResult;
      fromSwitchWebview?: boolean;
      fromSideMenu?: boolean;
      bot!: Raw.TypeInputUser;
      url?: string;
      startParam?: string;
      themeParams?: Raw.TypeDataJSON;
      platform!: string;

      constructor(params: {
        fromSwitchWebview?: boolean;
        fromSideMenu?: boolean;
        bot: Raw.TypeInputUser;
        url?: string;
        startParam?: string;
        themeParams?: Raw.TypeDataJSON;
        platform: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.RequestSimpleWebView';
        this.constructorId = 0x1a46500a;
        this.subclassOfId = 0x15eee3db;
        this._slots = [
          'fromSwitchWebview',
          'fromSideMenu',
          'bot',
          'url',
          'startParam',
          'themeParams',
          'platform',
        ];
        this.fromSwitchWebview = params.fromSwitchWebview;
        this.fromSideMenu = params.fromSideMenu;
        this.bot = params.bot;
        this.url = params.url;
        this.startParam = params.startParam;
        this.themeParams = params.themeParams;
        this.platform = params.platform;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.RequestSimpleWebView> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let fromSwitchWebview = flags & (1 << 1) ? true : false;
        let fromSideMenu = flags & (1 << 2) ? true : false;
        let bot = await TLObject.read(b);
        let url = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
        let startParam = flags & (1 << 4) ? await Primitive.String.read(b) : undefined;
        let themeParams = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let platform = await Primitive.String.read(b);
        return new Raw.messages.RequestSimpleWebView({
          fromSwitchWebview: fromSwitchWebview,
          fromSideMenu: fromSideMenu,
          bot: bot,
          url: url,
          startParam: startParam,
          themeParams: themeParams,
          platform: platform,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.fromSwitchWebview ? 1 << 1 : 0;
        flags |= this.fromSideMenu ? 1 << 2 : 0;
        flags |= this.url !== undefined ? 1 << 3 : 0;
        flags |= this.startParam !== undefined ? 1 << 4 : 0;
        flags |= this.themeParams !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        if (this.startParam !== undefined) {
          b.write(Primitive.String.write(this.startParam) as unknown as Buffer);
        }
        if (this.themeParams !== undefined) {
          b.write(this.themeParams.write() as unknown as Buffer);
        }
        if (this.platform !== undefined) {
          b.write(Primitive.String.write(this.platform) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendWebViewResultMessage extends TLObject {
      __response__!: Raw.TypeWebViewMessageSent;
      botQueryId!: string;
      result!: Raw.TypeInputBotInlineResult;

      constructor(params: { botQueryId: string; result: Raw.TypeInputBotInlineResult }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendWebViewResultMessage';
        this.constructorId = 0xa4314f5;
        this.subclassOfId = 0x75e49312;
        this._slots = ['botQueryId', 'result'];
        this.botQueryId = params.botQueryId;
        this.result = params.result;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SendWebViewResultMessage> {
        // no flags

        let botQueryId = await Primitive.String.read(b);
        let result = await TLObject.read(b);
        return new Raw.messages.SendWebViewResultMessage({
          botQueryId: botQueryId,
          result: result,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.botQueryId !== undefined) {
          b.write(Primitive.String.write(this.botQueryId) as unknown as Buffer);
        }
        if (this.result !== undefined) {
          b.write(this.result.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendWebViewData extends TLObject {
      __response__!: Raw.TypeUpdates;
      bot!: Raw.TypeInputUser;
      randomId!: long;
      buttonText!: string;
      data!: string;

      constructor(params: {
        bot: Raw.TypeInputUser;
        randomId: long;
        buttonText: string;
        data: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendWebViewData';
        this.constructorId = 0xdc0242c8;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['bot', 'randomId', 'buttonText', 'data'];
        this.bot = params.bot;
        this.randomId = params.randomId;
        this.buttonText = params.buttonText;
        this.data = params.data;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SendWebViewData> {
        // no flags

        let bot = await TLObject.read(b);
        let randomId = await Primitive.Long.read(b);
        let buttonText = await Primitive.String.read(b);
        let data = await Primitive.String.read(b);
        return new Raw.messages.SendWebViewData({
          bot: bot,
          randomId: randomId,
          buttonText: buttonText,
          data: data,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
        }
        if (this.buttonText !== undefined) {
          b.write(Primitive.String.write(this.buttonText) as unknown as Buffer);
        }
        if (this.data !== undefined) {
          b.write(Primitive.String.write(this.data) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TranscribeAudio extends TLObject {
      __response__!: Raw.messages.TypeTranscribedAudio;
      peer!: Raw.TypeInputPeer;
      msgId!: int;

      constructor(params: { peer: Raw.TypeInputPeer; msgId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.TranscribeAudio';
        this.constructorId = 0x269e9a49;
        this.subclassOfId = 0x21b24936;
        this._slots = ['peer', 'msgId'];
        this.peer = params.peer;
        this.msgId = params.msgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.TranscribeAudio> {
        // no flags

        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        return new Raw.messages.TranscribeAudio({ peer: peer, msgId: msgId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RateTranscribedAudio extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      msgId!: int;
      transcriptionId!: long;
      good!: Bool;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        msgId: int;
        transcriptionId: long;
        good: Bool;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.RateTranscribedAudio';
        this.constructorId = 0x7f1d072f;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'msgId', 'transcriptionId', 'good'];
        this.peer = params.peer;
        this.msgId = params.msgId;
        this.transcriptionId = params.transcriptionId;
        this.good = params.good;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.RateTranscribedAudio> {
        // no flags

        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        let transcriptionId = await Primitive.Long.read(b);
        let good = await Primitive.Bool.read(b);
        return new Raw.messages.RateTranscribedAudio({
          peer: peer,
          msgId: msgId,
          transcriptionId: transcriptionId,
          good: good,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        if (this.transcriptionId !== undefined) {
          b.write(Primitive.Long.write(this.transcriptionId) as unknown as Buffer);
        }
        if (this.good !== undefined) {
          b.write(Primitive.Bool.write(this.good) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetCustomEmojiDocuments extends TLObject {
      __response__!: Vector<Raw.TypeDocument>;
      documentId!: Vector<long>;

      constructor(params: { documentId: Vector<long> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetCustomEmojiDocuments';
        this.constructorId = 0xd9ab0f54;
        this.subclassOfId = 0xcc590e08;
        this._slots = ['documentId'];
        this.documentId = params.documentId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetCustomEmojiDocuments> {
        // no flags

        let documentId = await TLObject.read(b, Primitive.Long);
        return new Raw.messages.GetCustomEmojiDocuments({ documentId: documentId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.documentId) {
          b.write(Primitive.Vector.write(this.documentId, Primitive.Long) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetEmojiStickers extends TLObject {
      __response__!: Raw.messages.TypeAllStickers;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetEmojiStickers';
        this.constructorId = 0xfbfca18f;
        this.subclassOfId = 0x45834829;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetEmojiStickers> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetEmojiStickers({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetFeaturedEmojiStickers extends TLObject {
      __response__!: Raw.messages.TypeFeaturedStickers;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetFeaturedEmojiStickers';
        this.constructorId = 0xecf6736;
        this.subclassOfId = 0x2614b722;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetFeaturedEmojiStickers> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetFeaturedEmojiStickers({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReportReaction extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      id!: int;
      reactionPeer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer; id: int; reactionPeer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.ReportReaction';
        this.constructorId = 0x3f64c076;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'id', 'reactionPeer'];
        this.peer = params.peer;
        this.id = params.id;
        this.reactionPeer = params.reactionPeer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.ReportReaction> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await Primitive.Int.read(b);
        let reactionPeer = await TLObject.read(b);
        return new Raw.messages.ReportReaction({ peer: peer, id: id, reactionPeer: reactionPeer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        if (this.reactionPeer !== undefined) {
          b.write(this.reactionPeer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetTopReactions extends TLObject {
      __response__!: Raw.messages.TypeReactions;
      limit!: int;
      hash!: long;

      constructor(params: { limit: int; hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetTopReactions';
        this.constructorId = 0xbb8125ba;
        this.subclassOfId = 0xadc38324;
        this._slots = ['limit', 'hash'];
        this.limit = params.limit;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetTopReactions> {
        // no flags

        let limit = await Primitive.Int.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetTopReactions({ limit: limit, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetRecentReactions extends TLObject {
      __response__!: Raw.messages.TypeReactions;
      limit!: int;
      hash!: long;

      constructor(params: { limit: int; hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetRecentReactions';
        this.constructorId = 0x39461db2;
        this.subclassOfId = 0xadc38324;
        this._slots = ['limit', 'hash'];
        this.limit = params.limit;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetRecentReactions> {
        // no flags

        let limit = await Primitive.Int.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetRecentReactions({ limit: limit, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ClearRecentReactions extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'messages.ClearRecentReactions';
        this.constructorId = 0x9dfeefb4;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.ClearRecentReactions> {
        // no flags

        return new Raw.messages.ClearRecentReactions();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetExtendedMedia extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;

      constructor(params: { peer: Raw.TypeInputPeer; id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetExtendedMedia';
        this.constructorId = 0x84f80814;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'id'];
        this.peer = params.peer;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetExtendedMedia> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.messages.GetExtendedMedia({ peer: peer, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetDefaultHistoryTTL extends TLObject {
      __response__!: Bool;
      period!: int;

      constructor(params: { period: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetDefaultHistoryTTL';
        this.constructorId = 0x9eb51445;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['period'];
        this.period = params.period;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SetDefaultHistoryTTL> {
        // no flags

        let period = await Primitive.Int.read(b);
        return new Raw.messages.SetDefaultHistoryTTL({ period: period });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.period !== undefined) {
          b.write(Primitive.Int.write(this.period) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDefaultHistoryTTL extends TLObject {
      __response__!: Raw.TypeDefaultHistoryTTL;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetDefaultHistoryTTL';
        this.constructorId = 0x658b7188;
        this.subclassOfId = 0xf00d3367;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetDefaultHistoryTTL> {
        // no flags

        return new Raw.messages.GetDefaultHistoryTTL();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SendBotRequestedPeer extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      msgId!: int;
      buttonId!: int;
      requestedPeer!: Raw.TypeInputPeer;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        msgId: int;
        buttonId: int;
        requestedPeer: Raw.TypeInputPeer;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SendBotRequestedPeer';
        this.constructorId = 0xfe38d01b;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'msgId', 'buttonId', 'requestedPeer'];
        this.peer = params.peer;
        this.msgId = params.msgId;
        this.buttonId = params.buttonId;
        this.requestedPeer = params.requestedPeer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.SendBotRequestedPeer> {
        // no flags

        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        let buttonId = await Primitive.Int.read(b);
        let requestedPeer = await TLObject.read(b);
        return new Raw.messages.SendBotRequestedPeer({
          peer: peer,
          msgId: msgId,
          buttonId: buttonId,
          requestedPeer: requestedPeer,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        if (this.buttonId !== undefined) {
          b.write(Primitive.Int.write(this.buttonId) as unknown as Buffer);
        }
        if (this.requestedPeer !== undefined) {
          b.write(this.requestedPeer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetEmojiGroups extends TLObject {
      __response__!: Raw.messages.TypeEmojiGroups;
      hash!: int;

      constructor(params: { hash: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetEmojiGroups';
        this.constructorId = 0x7488ce5b;
        this.subclassOfId = 0x7eca55d9;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetEmojiGroups> {
        // no flags

        let hash = await Primitive.Int.read(b);
        return new Raw.messages.GetEmojiGroups({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetEmojiStatusGroups extends TLObject {
      __response__!: Raw.messages.TypeEmojiGroups;
      hash!: int;

      constructor(params: { hash: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetEmojiStatusGroups';
        this.constructorId = 0x2ecd56cd;
        this.subclassOfId = 0x7eca55d9;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetEmojiStatusGroups> {
        // no flags

        let hash = await Primitive.Int.read(b);
        return new Raw.messages.GetEmojiStatusGroups({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetEmojiProfilePhotoGroups extends TLObject {
      __response__!: Raw.messages.TypeEmojiGroups;
      hash!: int;

      constructor(params: { hash: int }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetEmojiProfilePhotoGroups';
        this.constructorId = 0x21a548f3;
        this.subclassOfId = 0x7eca55d9;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.GetEmojiProfilePhotoGroups> {
        // no flags

        let hash = await Primitive.Int.read(b);
        return new Raw.messages.GetEmojiProfilePhotoGroups({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Int.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SearchCustomEmoji extends TLObject {
      __response__!: Raw.TypeEmojiList;
      emoticon!: string;
      hash!: long;

      constructor(params: { emoticon: string; hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SearchCustomEmoji';
        this.constructorId = 0x2c11c0d7;
        this.subclassOfId = 0xbcef6aba;
        this._slots = ['emoticon', 'hash'];
        this.emoticon = params.emoticon;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SearchCustomEmoji> {
        // no flags

        let emoticon = await Primitive.String.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.SearchCustomEmoji({ emoticon: emoticon, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.emoticon !== undefined) {
          b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TogglePeerTranslations extends TLObject {
      __response__!: Bool;
      disabled?: boolean;
      peer!: Raw.TypeInputPeer;

      constructor(params: { disabled?: boolean; peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.TogglePeerTranslations';
        this.constructorId = 0xe47cb579;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['disabled', 'peer'];
        this.disabled = params.disabled;
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.messages.TogglePeerTranslations> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let disabled = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        return new Raw.messages.TogglePeerTranslations({ disabled: disabled, peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.disabled ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetBotApp extends TLObject {
      __response__!: Raw.messages.TypeBotApp;
      app!: Raw.TypeInputBotApp;
      hash!: long;

      constructor(params: { app: Raw.TypeInputBotApp; hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.GetBotApp';
        this.constructorId = 0x34fdc5c3;
        this.subclassOfId = 0x8f7243a7;
        this._slots = ['app', 'hash'];
        this.app = params.app;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.GetBotApp> {
        // no flags

        let app = await TLObject.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.messages.GetBotApp({ app: app, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.app !== undefined) {
          b.write(this.app.write() as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RequestAppWebView extends TLObject {
      __response__!: Raw.TypeAppWebViewResult;
      writeAllowed?: boolean;
      peer!: Raw.TypeInputPeer;
      app!: Raw.TypeInputBotApp;
      startParam?: string;
      themeParams?: Raw.TypeDataJSON;
      platform!: string;

      constructor(params: {
        writeAllowed?: boolean;
        peer: Raw.TypeInputPeer;
        app: Raw.TypeInputBotApp;
        startParam?: string;
        themeParams?: Raw.TypeDataJSON;
        platform: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.RequestAppWebView';
        this.constructorId = 0x8c5a3b3c;
        this.subclassOfId = 0x1c24a413;
        this._slots = ['writeAllowed', 'peer', 'app', 'startParam', 'themeParams', 'platform'];
        this.writeAllowed = params.writeAllowed;
        this.peer = params.peer;
        this.app = params.app;
        this.startParam = params.startParam;
        this.themeParams = params.themeParams;
        this.platform = params.platform;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.RequestAppWebView> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let writeAllowed = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        let app = await TLObject.read(b);
        let startParam = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let themeParams = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let platform = await Primitive.String.read(b);
        return new Raw.messages.RequestAppWebView({
          writeAllowed: writeAllowed,
          peer: peer,
          app: app,
          startParam: startParam,
          themeParams: themeParams,
          platform: platform,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.writeAllowed ? 1 << 0 : 0;
        flags |= this.startParam !== undefined ? 1 << 1 : 0;
        flags |= this.themeParams !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.app !== undefined) {
          b.write(this.app.write() as unknown as Buffer);
        }
        if (this.startParam !== undefined) {
          b.write(Primitive.String.write(this.startParam) as unknown as Buffer);
        }
        if (this.themeParams !== undefined) {
          b.write(this.themeParams.write() as unknown as Buffer);
        }
        if (this.platform !== undefined) {
          b.write(Primitive.String.write(this.platform) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetChatWallPaper extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      wallpaper?: Raw.TypeInputWallPaper;
      settings?: Raw.TypeWallPaperSettings;
      id?: int;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        wallpaper?: Raw.TypeInputWallPaper;
        settings?: Raw.TypeWallPaperSettings;
        id?: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'messages.SetChatWallPaper';
        this.constructorId = 0x8ffacae1;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'wallpaper', 'settings', 'id'];
        this.peer = params.peer;
        this.wallpaper = params.wallpaper;
        this.settings = params.settings;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.messages.SetChatWallPaper> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = await TLObject.read(b);
        let wallpaper = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let settings = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let id = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        return new Raw.messages.SetChatWallPaper({
          peer: peer,
          wallpaper: wallpaper,
          settings: settings,
          id: id,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.wallpaper !== undefined ? 1 << 0 : 0;
        flags |= this.settings !== undefined ? 1 << 2 : 0;
        flags |= this.id !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.wallpaper !== undefined) {
          b.write(this.wallpaper.write() as unknown as Buffer);
        }
        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace updates {
    export type TypeChannelDifference =
      | Raw.updates.ChannelDifferenceEmpty
      | Raw.updates.ChannelDifferenceTooLong
      | Raw.updates.ChannelDifference;
    export type TypeDifference =
      | Raw.updates.DifferenceEmpty
      | Raw.updates.Difference
      | Raw.updates.DifferenceSlice
      | Raw.updates.DifferenceTooLong;
    export type TypeState = Raw.updates.State;
    export class State extends TLObject {
      pts!: int;
      qts!: int;
      date!: int;
      seq!: int;
      unreadCount!: int;

      constructor(params: { pts: int; qts: int; date: int; seq: int; unreadCount: int }) {
        super();
        this.classType = 'types';
        this.className = 'updates.State';
        this.constructorId = 0xa56c2a3e;
        this.subclassOfId = 0x23df1a01;
        this._slots = ['pts', 'qts', 'date', 'seq', 'unreadCount'];
        this.pts = params.pts;
        this.qts = params.qts;
        this.date = params.date;
        this.seq = params.seq;
        this.unreadCount = params.unreadCount;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.updates.State> {
        // no flags

        let pts = await Primitive.Int.read(b);
        let qts = await Primitive.Int.read(b);
        let date = await Primitive.Int.read(b);
        let seq = await Primitive.Int.read(b);
        let unreadCount = await Primitive.Int.read(b);
        return new Raw.updates.State({
          pts: pts,
          qts: qts,
          date: date,
          seq: seq,
          unreadCount: unreadCount,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.pts !== undefined) {
          b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
        }
        if (this.qts !== undefined) {
          b.write(Primitive.Int.write(this.qts) as unknown as Buffer);
        }
        if (this.date !== undefined) {
          b.write(Primitive.Int.write(this.date) as unknown as Buffer);
        }
        if (this.seq !== undefined) {
          b.write(Primitive.Int.write(this.seq) as unknown as Buffer);
        }
        if (this.unreadCount !== undefined) {
          b.write(Primitive.Int.write(this.unreadCount) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DifferenceEmpty extends TLObject {
      date!: int;
      seq!: int;

      constructor(params: { date: int; seq: int }) {
        super();
        this.classType = 'types';
        this.className = 'updates.DifferenceEmpty';
        this.constructorId = 0x5d75a138;
        this.subclassOfId = 0x20482874;
        this._slots = ['date', 'seq'];
        this.date = params.date;
        this.seq = params.seq;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.updates.DifferenceEmpty> {
        // no flags

        let date = await Primitive.Int.read(b);
        let seq = await Primitive.Int.read(b);
        return new Raw.updates.DifferenceEmpty({ date: date, seq: seq });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.date !== undefined) {
          b.write(Primitive.Int.write(this.date) as unknown as Buffer);
        }
        if (this.seq !== undefined) {
          b.write(Primitive.Int.write(this.seq) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Difference extends TLObject {
      newMessages!: Vector<Raw.TypeMessage>;
      newEncryptedMessages!: Vector<Raw.TypeEncryptedMessage>;
      otherUpdates!: Vector<Raw.TypeUpdate>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;
      state!: Raw.updates.TypeState;

      constructor(params: {
        newMessages: Vector<Raw.TypeMessage>;
        newEncryptedMessages: Vector<Raw.TypeEncryptedMessage>;
        otherUpdates: Vector<Raw.TypeUpdate>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
        state: Raw.updates.TypeState;
      }) {
        super();
        this.classType = 'types';
        this.className = 'updates.Difference';
        this.constructorId = 0xf49ca0;
        this.subclassOfId = 0x20482874;
        this._slots = [
          'newMessages',
          'newEncryptedMessages',
          'otherUpdates',
          'chats',
          'users',
          'state',
        ];
        this.newMessages = params.newMessages;
        this.newEncryptedMessages = params.newEncryptedMessages;
        this.otherUpdates = params.otherUpdates;
        this.chats = params.chats;
        this.users = params.users;
        this.state = params.state;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.updates.Difference> {
        // no flags

        let newMessages = await TLObject.read(b);
        let newEncryptedMessages = await TLObject.read(b);
        let otherUpdates = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        let state = await TLObject.read(b);
        return new Raw.updates.Difference({
          newMessages: newMessages,
          newEncryptedMessages: newEncryptedMessages,
          otherUpdates: otherUpdates,
          chats: chats,
          users: users,
          state: state,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.newMessages) {
          b.write(Primitive.Vector.write(this.newMessages) as unknown as Buffer);
        }
        if (this.newEncryptedMessages) {
          b.write(Primitive.Vector.write(this.newEncryptedMessages) as unknown as Buffer);
        }
        if (this.otherUpdates) {
          b.write(Primitive.Vector.write(this.otherUpdates) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        if (this.state !== undefined) {
          b.write(this.state.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DifferenceSlice extends TLObject {
      newMessages!: Vector<Raw.TypeMessage>;
      newEncryptedMessages!: Vector<Raw.TypeEncryptedMessage>;
      otherUpdates!: Vector<Raw.TypeUpdate>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;
      intermediateState!: Raw.updates.TypeState;

      constructor(params: {
        newMessages: Vector<Raw.TypeMessage>;
        newEncryptedMessages: Vector<Raw.TypeEncryptedMessage>;
        otherUpdates: Vector<Raw.TypeUpdate>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
        intermediateState: Raw.updates.TypeState;
      }) {
        super();
        this.classType = 'types';
        this.className = 'updates.DifferenceSlice';
        this.constructorId = 0xa8fb1981;
        this.subclassOfId = 0x20482874;
        this._slots = [
          'newMessages',
          'newEncryptedMessages',
          'otherUpdates',
          'chats',
          'users',
          'intermediateState',
        ];
        this.newMessages = params.newMessages;
        this.newEncryptedMessages = params.newEncryptedMessages;
        this.otherUpdates = params.otherUpdates;
        this.chats = params.chats;
        this.users = params.users;
        this.intermediateState = params.intermediateState;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.updates.DifferenceSlice> {
        // no flags

        let newMessages = await TLObject.read(b);
        let newEncryptedMessages = await TLObject.read(b);
        let otherUpdates = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        let intermediateState = await TLObject.read(b);
        return new Raw.updates.DifferenceSlice({
          newMessages: newMessages,
          newEncryptedMessages: newEncryptedMessages,
          otherUpdates: otherUpdates,
          chats: chats,
          users: users,
          intermediateState: intermediateState,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.newMessages) {
          b.write(Primitive.Vector.write(this.newMessages) as unknown as Buffer);
        }
        if (this.newEncryptedMessages) {
          b.write(Primitive.Vector.write(this.newEncryptedMessages) as unknown as Buffer);
        }
        if (this.otherUpdates) {
          b.write(Primitive.Vector.write(this.otherUpdates) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        if (this.intermediateState !== undefined) {
          b.write(this.intermediateState.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DifferenceTooLong extends TLObject {
      pts!: int;

      constructor(params: { pts: int }) {
        super();
        this.classType = 'types';
        this.className = 'updates.DifferenceTooLong';
        this.constructorId = 0x4afe8f6d;
        this.subclassOfId = 0x20482874;
        this._slots = ['pts'];
        this.pts = params.pts;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.updates.DifferenceTooLong> {
        // no flags

        let pts = await Primitive.Int.read(b);
        return new Raw.updates.DifferenceTooLong({ pts: pts });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.pts !== undefined) {
          b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChannelDifferenceEmpty extends TLObject {
      final?: boolean;
      pts!: int;
      timeout?: int;

      constructor(params: { final?: boolean; pts: int; timeout?: int }) {
        super();
        this.classType = 'types';
        this.className = 'updates.ChannelDifferenceEmpty';
        this.constructorId = 0x3e11affb;
        this.subclassOfId = 0x29896f5d;
        this._slots = ['final', 'pts', 'timeout'];
        this.final = params.final;
        this.pts = params.pts;
        this.timeout = params.timeout;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.updates.ChannelDifferenceEmpty> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let final = flags & (1 << 0) ? true : false;
        let pts = await Primitive.Int.read(b);
        let timeout = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        return new Raw.updates.ChannelDifferenceEmpty({ final: final, pts: pts, timeout: timeout });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.final ? 1 << 0 : 0;
        flags |= this.timeout !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.pts !== undefined) {
          b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
        }
        if (this.timeout !== undefined) {
          b.write(Primitive.Int.write(this.timeout) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChannelDifferenceTooLong extends TLObject {
      final?: boolean;
      timeout?: int;
      dialog!: Raw.TypeDialog;
      messages!: Vector<Raw.TypeMessage>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        final?: boolean;
        timeout?: int;
        dialog: Raw.TypeDialog;
        messages: Vector<Raw.TypeMessage>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'updates.ChannelDifferenceTooLong';
        this.constructorId = 0xa4bcc6fe;
        this.subclassOfId = 0x29896f5d;
        this._slots = ['final', 'timeout', 'dialog', 'messages', 'chats', 'users'];
        this.final = params.final;
        this.timeout = params.timeout;
        this.dialog = params.dialog;
        this.messages = params.messages;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.updates.ChannelDifferenceTooLong> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let final = flags & (1 << 0) ? true : false;
        let timeout = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let dialog = await TLObject.read(b);
        let messages = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.updates.ChannelDifferenceTooLong({
          final: final,
          timeout: timeout,
          dialog: dialog,
          messages: messages,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.final ? 1 << 0 : 0;
        flags |= this.timeout !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.timeout !== undefined) {
          b.write(Primitive.Int.write(this.timeout) as unknown as Buffer);
        }
        if (this.dialog !== undefined) {
          b.write(this.dialog.write() as unknown as Buffer);
        }
        if (this.messages) {
          b.write(Primitive.Vector.write(this.messages) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChannelDifference extends TLObject {
      final?: boolean;
      pts!: int;
      timeout?: int;
      newMessages!: Vector<Raw.TypeMessage>;
      otherUpdates!: Vector<Raw.TypeUpdate>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        final?: boolean;
        pts: int;
        timeout?: int;
        newMessages: Vector<Raw.TypeMessage>;
        otherUpdates: Vector<Raw.TypeUpdate>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'updates.ChannelDifference';
        this.constructorId = 0x2064674e;
        this.subclassOfId = 0x29896f5d;
        this._slots = ['final', 'pts', 'timeout', 'newMessages', 'otherUpdates', 'chats', 'users'];
        this.final = params.final;
        this.pts = params.pts;
        this.timeout = params.timeout;
        this.newMessages = params.newMessages;
        this.otherUpdates = params.otherUpdates;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.updates.ChannelDifference> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let final = flags & (1 << 0) ? true : false;
        let pts = await Primitive.Int.read(b);
        let timeout = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let newMessages = await TLObject.read(b);
        let otherUpdates = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.updates.ChannelDifference({
          final: final,
          pts: pts,
          timeout: timeout,
          newMessages: newMessages,
          otherUpdates: otherUpdates,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.final ? 1 << 0 : 0;
        flags |= this.timeout !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.pts !== undefined) {
          b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
        }
        if (this.timeout !== undefined) {
          b.write(Primitive.Int.write(this.timeout) as unknown as Buffer);
        }
        if (this.newMessages) {
          b.write(Primitive.Vector.write(this.newMessages) as unknown as Buffer);
        }
        if (this.otherUpdates) {
          b.write(Primitive.Vector.write(this.otherUpdates) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetState extends TLObject {
      __response__!: Raw.updates.TypeState;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'updates.GetState';
        this.constructorId = 0xedd4882a;
        this.subclassOfId = 0x23df1a01;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.updates.GetState> {
        // no flags

        return new Raw.updates.GetState();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetDifference extends TLObject {
      __response__!: Raw.updates.TypeDifference;
      pts!: int;
      ptsLimit?: int;
      ptsTotalLimit?: int;
      date!: int;
      qts!: int;
      qtsLimit?: int;

      constructor(params: {
        pts: int;
        ptsLimit?: int;
        ptsTotalLimit?: int;
        date: int;
        qts: int;
        qtsLimit?: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'updates.GetDifference';
        this.constructorId = 0x19c2f763;
        this.subclassOfId = 0x20482874;
        this._slots = ['pts', 'ptsLimit', 'ptsTotalLimit', 'date', 'qts', 'qtsLimit'];
        this.pts = params.pts;
        this.ptsLimit = params.ptsLimit;
        this.ptsTotalLimit = params.ptsTotalLimit;
        this.date = params.date;
        this.qts = params.qts;
        this.qtsLimit = params.qtsLimit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.updates.GetDifference> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let pts = await Primitive.Int.read(b);
        let ptsLimit = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let ptsTotalLimit = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let date = await Primitive.Int.read(b);
        let qts = await Primitive.Int.read(b);
        let qtsLimit = flags & (1 << 2) ? await Primitive.Int.read(b) : undefined;
        return new Raw.updates.GetDifference({
          pts: pts,
          ptsLimit: ptsLimit,
          ptsTotalLimit: ptsTotalLimit,
          date: date,
          qts: qts,
          qtsLimit: qtsLimit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.ptsLimit !== undefined ? 1 << 1 : 0;
        flags |= this.ptsTotalLimit !== undefined ? 1 << 0 : 0;
        flags |= this.qtsLimit !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.pts !== undefined) {
          b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
        }
        if (this.ptsLimit !== undefined) {
          b.write(Primitive.Int.write(this.ptsLimit) as unknown as Buffer);
        }
        if (this.ptsTotalLimit !== undefined) {
          b.write(Primitive.Int.write(this.ptsTotalLimit) as unknown as Buffer);
        }
        if (this.date !== undefined) {
          b.write(Primitive.Int.write(this.date) as unknown as Buffer);
        }
        if (this.qts !== undefined) {
          b.write(Primitive.Int.write(this.qts) as unknown as Buffer);
        }
        if (this.qtsLimit !== undefined) {
          b.write(Primitive.Int.write(this.qtsLimit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetChannelDifference extends TLObject {
      __response__!: Raw.updates.TypeChannelDifference;
      force?: boolean;
      channel!: Raw.TypeInputChannel;
      filter!: Raw.TypeChannelMessagesFilter;
      pts!: int;
      limit!: int;

      constructor(params: {
        force?: boolean;
        channel: Raw.TypeInputChannel;
        filter: Raw.TypeChannelMessagesFilter;
        pts: int;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'updates.GetChannelDifference';
        this.constructorId = 0x3173d78;
        this.subclassOfId = 0x29896f5d;
        this._slots = ['force', 'channel', 'filter', 'pts', 'limit'];
        this.force = params.force;
        this.channel = params.channel;
        this.filter = params.filter;
        this.pts = params.pts;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.updates.GetChannelDifference> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let force = flags & (1 << 0) ? true : false;
        let channel = await TLObject.read(b);
        let filter = await TLObject.read(b);
        let pts = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.updates.GetChannelDifference({
          force: force,
          channel: channel,
          filter: filter,
          pts: pts,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.force ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.filter !== undefined) {
          b.write(this.filter.write() as unknown as Buffer);
        }
        if (this.pts !== undefined) {
          b.write(Primitive.Int.write(this.pts) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace photos {
    export type TypePhotos = Raw.photos.Photos | Raw.photos.PhotosSlice;
    export type TypePhoto = Raw.photos.Photo;
    export class Photos extends TLObject {
      photos!: Vector<Raw.TypePhoto>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: { photos: Vector<Raw.TypePhoto>; users: Vector<Raw.TypeUser> }) {
        super();
        this.classType = 'types';
        this.className = 'photos.Photos';
        this.constructorId = 0x8dca6aa5;
        this.subclassOfId = 0x27cfb967;
        this._slots = ['photos', 'users'];
        this.photos = params.photos;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.photos.Photos> {
        // no flags

        let photos = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.photos.Photos({ photos: photos, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.photos) {
          b.write(Primitive.Vector.write(this.photos) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PhotosSlice extends TLObject {
      count!: int;
      photos!: Vector<Raw.TypePhoto>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        count: int;
        photos: Vector<Raw.TypePhoto>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'photos.PhotosSlice';
        this.constructorId = 0x15051f54;
        this.subclassOfId = 0x27cfb967;
        this._slots = ['count', 'photos', 'users'];
        this.count = params.count;
        this.photos = params.photos;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.photos.PhotosSlice> {
        // no flags

        let count = await Primitive.Int.read(b);
        let photos = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.photos.PhotosSlice({ count: count, photos: photos, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.photos) {
          b.write(Primitive.Vector.write(this.photos) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Photo extends TLObject {
      photo!: Raw.TypePhoto;
      users!: Vector<Raw.TypeUser>;

      constructor(params: { photo: Raw.TypePhoto; users: Vector<Raw.TypeUser> }) {
        super();
        this.classType = 'types';
        this.className = 'photos.Photo';
        this.constructorId = 0x20212ca8;
        this.subclassOfId = 0xc292bd24;
        this._slots = ['photo', 'users'];
        this.photo = params.photo;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.photos.Photo> {
        // no flags

        let photo = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.photos.Photo({ photo: photo, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.photo !== undefined) {
          b.write(this.photo.write() as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdateProfilePhoto extends TLObject {
      __response__!: Raw.photos.TypePhoto;
      fallback?: boolean;
      bot?: Raw.TypeInputUser;
      id!: Raw.TypeInputPhoto;

      constructor(params: { fallback?: boolean; bot?: Raw.TypeInputUser; id: Raw.TypeInputPhoto }) {
        super();
        this.classType = 'functions';
        this.className = 'photos.UpdateProfilePhoto';
        this.constructorId = 0x9e82039;
        this.subclassOfId = 0xc292bd24;
        this._slots = ['fallback', 'bot', 'id'];
        this.fallback = params.fallback;
        this.bot = params.bot;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.photos.UpdateProfilePhoto> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let fallback = flags & (1 << 0) ? true : false;
        let bot = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        let id = await TLObject.read(b);
        return new Raw.photos.UpdateProfilePhoto({ fallback: fallback, bot: bot, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.fallback ? 1 << 0 : 0;
        flags |= this.bot !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UploadProfilePhoto extends TLObject {
      __response__!: Raw.photos.TypePhoto;
      fallback?: boolean;
      bot?: Raw.TypeInputUser;
      file?: Raw.TypeInputFile;
      video?: Raw.TypeInputFile;
      videoStartTs?: double;
      videoEmojiMarkup?: Raw.TypeVideoSize;

      constructor(params: {
        fallback?: boolean;
        bot?: Raw.TypeInputUser;
        file?: Raw.TypeInputFile;
        video?: Raw.TypeInputFile;
        videoStartTs?: double;
        videoEmojiMarkup?: Raw.TypeVideoSize;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'photos.UploadProfilePhoto';
        this.constructorId = 0x388a3b5;
        this.subclassOfId = 0xc292bd24;
        this._slots = ['fallback', 'bot', 'file', 'video', 'videoStartTs', 'videoEmojiMarkup'];
        this.fallback = params.fallback;
        this.bot = params.bot;
        this.file = params.file;
        this.video = params.video;
        this.videoStartTs = params.videoStartTs;
        this.videoEmojiMarkup = params.videoEmojiMarkup;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.photos.UploadProfilePhoto> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let fallback = flags & (1 << 3) ? true : false;
        let bot = flags & (1 << 5) ? await TLObject.read(b) : undefined;
        let file = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let video = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        let videoStartTs = flags & (1 << 2) ? await Primitive.Double.read(b) : undefined;
        let videoEmojiMarkup = flags & (1 << 4) ? await TLObject.read(b) : undefined;
        return new Raw.photos.UploadProfilePhoto({
          fallback: fallback,
          bot: bot,
          file: file,
          video: video,
          videoStartTs: videoStartTs,
          videoEmojiMarkup: videoEmojiMarkup,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.fallback ? 1 << 3 : 0;
        flags |= this.bot !== undefined ? 1 << 5 : 0;
        flags |= this.file !== undefined ? 1 << 0 : 0;
        flags |= this.video !== undefined ? 1 << 1 : 0;
        flags |= this.videoStartTs !== undefined ? 1 << 2 : 0;
        flags |= this.videoEmojiMarkup !== undefined ? 1 << 4 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.file !== undefined) {
          b.write(this.file.write() as unknown as Buffer);
        }
        if (this.video !== undefined) {
          b.write(this.video.write() as unknown as Buffer);
        }
        if (this.videoStartTs !== undefined) {
          b.write(Primitive.Double.write(this.videoStartTs) as unknown as Buffer);
        }
        if (this.videoEmojiMarkup !== undefined) {
          b.write(this.videoEmojiMarkup.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeletePhotos extends TLObject {
      __response__!: Vector<long>;
      id!: Vector<Raw.TypeInputPhoto>;

      constructor(params: { id: Vector<Raw.TypeInputPhoto> }) {
        super();
        this.classType = 'functions';
        this.className = 'photos.DeletePhotos';
        this.constructorId = 0x87cf7f2f;
        this.subclassOfId = 0x8918e168;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.photos.DeletePhotos> {
        // no flags

        let id = await TLObject.read(b);
        return new Raw.photos.DeletePhotos({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id) {
          b.write(Primitive.Vector.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetUserPhotos extends TLObject {
      __response__!: Raw.photos.TypePhotos;
      userId!: Raw.TypeInputUser;
      offset!: int;
      maxId!: long;
      limit!: int;

      constructor(params: { userId: Raw.TypeInputUser; offset: int; maxId: long; limit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'photos.GetUserPhotos';
        this.constructorId = 0x91cd32a8;
        this.subclassOfId = 0x27cfb967;
        this._slots = ['userId', 'offset', 'maxId', 'limit'];
        this.userId = params.userId;
        this.offset = params.offset;
        this.maxId = params.maxId;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.photos.GetUserPhotos> {
        // no flags

        let userId = await TLObject.read(b);
        let offset = await Primitive.Int.read(b);
        let maxId = await Primitive.Long.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.photos.GetUserPhotos({
          userId: userId,
          offset: offset,
          maxId: maxId,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Long.write(this.maxId) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UploadContactProfilePhoto extends TLObject {
      __response__!: Raw.photos.TypePhoto;
      suggest?: boolean;
      save?: boolean;
      userId!: Raw.TypeInputUser;
      file?: Raw.TypeInputFile;
      video?: Raw.TypeInputFile;
      videoStartTs?: double;
      videoEmojiMarkup?: Raw.TypeVideoSize;

      constructor(params: {
        suggest?: boolean;
        save?: boolean;
        userId: Raw.TypeInputUser;
        file?: Raw.TypeInputFile;
        video?: Raw.TypeInputFile;
        videoStartTs?: double;
        videoEmojiMarkup?: Raw.TypeVideoSize;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'photos.UploadContactProfilePhoto';
        this.constructorId = 0xe14c4a71;
        this.subclassOfId = 0xc292bd24;
        this._slots = [
          'suggest',
          'save',
          'userId',
          'file',
          'video',
          'videoStartTs',
          'videoEmojiMarkup',
        ];
        this.suggest = params.suggest;
        this.save = params.save;
        this.userId = params.userId;
        this.file = params.file;
        this.video = params.video;
        this.videoStartTs = params.videoStartTs;
        this.videoEmojiMarkup = params.videoEmojiMarkup;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.photos.UploadContactProfilePhoto> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let suggest = flags & (1 << 3) ? true : false;
        let save = flags & (1 << 4) ? true : false;
        let userId = await TLObject.read(b);
        let file = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let video = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        let videoStartTs = flags & (1 << 2) ? await Primitive.Double.read(b) : undefined;
        let videoEmojiMarkup = flags & (1 << 5) ? await TLObject.read(b) : undefined;
        return new Raw.photos.UploadContactProfilePhoto({
          suggest: suggest,
          save: save,
          userId: userId,
          file: file,
          video: video,
          videoStartTs: videoStartTs,
          videoEmojiMarkup: videoEmojiMarkup,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.suggest ? 1 << 3 : 0;
        flags |= this.save ? 1 << 4 : 0;
        flags |= this.file !== undefined ? 1 << 0 : 0;
        flags |= this.video !== undefined ? 1 << 1 : 0;
        flags |= this.videoStartTs !== undefined ? 1 << 2 : 0;
        flags |= this.videoEmojiMarkup !== undefined ? 1 << 5 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.file !== undefined) {
          b.write(this.file.write() as unknown as Buffer);
        }
        if (this.video !== undefined) {
          b.write(this.video.write() as unknown as Buffer);
        }
        if (this.videoStartTs !== undefined) {
          b.write(Primitive.Double.write(this.videoStartTs) as unknown as Buffer);
        }
        if (this.videoEmojiMarkup !== undefined) {
          b.write(this.videoEmojiMarkup.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace upload {
    export type TypeCdnFile = Raw.upload.CdnFileReuploadNeeded | Raw.upload.CdnFile;
    export type TypeWebFile = Raw.upload.WebFile;
    export type TypeFile = Raw.upload.File | Raw.upload.FileCdnRedirect;
    export class File extends TLObject {
      type!: Raw.storage.TypeFileType;
      mtime!: int;
      bytes!: bytes;

      constructor(params: { type: Raw.storage.TypeFileType; mtime: int; bytes: bytes }) {
        super();
        this.classType = 'types';
        this.className = 'upload.File';
        this.constructorId = 0x96a18d5;
        this.subclassOfId = 0x6c9bd728;
        this._slots = ['type', 'mtime', 'bytes'];
        this.type = params.type;
        this.mtime = params.mtime;
        this.bytes = params.bytes;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.upload.File> {
        // no flags

        let type = await TLObject.read(b);
        let mtime = await Primitive.Int.read(b);
        let bytes = await Primitive.Bytes.read(b);
        return new Raw.upload.File({ type: type, mtime: mtime, bytes: bytes });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.type !== undefined) {
          b.write(this.type.write() as unknown as Buffer);
        }
        if (this.mtime !== undefined) {
          b.write(Primitive.Int.write(this.mtime) as unknown as Buffer);
        }
        if (this.bytes !== undefined) {
          b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class FileCdnRedirect extends TLObject {
      dcId!: int;
      fileToken!: bytes;
      encryptionKey!: bytes;
      encryptionIv!: bytes;
      fileHashes!: Vector<Raw.TypeFileHash>;

      constructor(params: {
        dcId: int;
        fileToken: bytes;
        encryptionKey: bytes;
        encryptionIv: bytes;
        fileHashes: Vector<Raw.TypeFileHash>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'upload.FileCdnRedirect';
        this.constructorId = 0xf18cda44;
        this.subclassOfId = 0x6c9bd728;
        this._slots = ['dcId', 'fileToken', 'encryptionKey', 'encryptionIv', 'fileHashes'];
        this.dcId = params.dcId;
        this.fileToken = params.fileToken;
        this.encryptionKey = params.encryptionKey;
        this.encryptionIv = params.encryptionIv;
        this.fileHashes = params.fileHashes;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.upload.FileCdnRedirect> {
        // no flags

        let dcId = await Primitive.Int.read(b);
        let fileToken = await Primitive.Bytes.read(b);
        let encryptionKey = await Primitive.Bytes.read(b);
        let encryptionIv = await Primitive.Bytes.read(b);
        let fileHashes = await TLObject.read(b);
        return new Raw.upload.FileCdnRedirect({
          dcId: dcId,
          fileToken: fileToken,
          encryptionKey: encryptionKey,
          encryptionIv: encryptionIv,
          fileHashes: fileHashes,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.dcId !== undefined) {
          b.write(Primitive.Int.write(this.dcId) as unknown as Buffer);
        }
        if (this.fileToken !== undefined) {
          b.write(Primitive.Bytes.write(this.fileToken) as unknown as Buffer);
        }
        if (this.encryptionKey !== undefined) {
          b.write(Primitive.Bytes.write(this.encryptionKey) as unknown as Buffer);
        }
        if (this.encryptionIv !== undefined) {
          b.write(Primitive.Bytes.write(this.encryptionIv) as unknown as Buffer);
        }
        if (this.fileHashes) {
          b.write(Primitive.Vector.write(this.fileHashes) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class WebFile extends TLObject {
      size!: int;
      mimeType!: string;
      fileType!: Raw.storage.TypeFileType;
      mtime!: int;
      bytes!: bytes;

      constructor(params: {
        size: int;
        mimeType: string;
        fileType: Raw.storage.TypeFileType;
        mtime: int;
        bytes: bytes;
      }) {
        super();
        this.classType = 'types';
        this.className = 'upload.WebFile';
        this.constructorId = 0x21e753bc;
        this.subclassOfId = 0x68f17f51;
        this._slots = ['size', 'mimeType', 'fileType', 'mtime', 'bytes'];
        this.size = params.size;
        this.mimeType = params.mimeType;
        this.fileType = params.fileType;
        this.mtime = params.mtime;
        this.bytes = params.bytes;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.upload.WebFile> {
        // no flags

        let size = await Primitive.Int.read(b);
        let mimeType = await Primitive.String.read(b);
        let fileType = await TLObject.read(b);
        let mtime = await Primitive.Int.read(b);
        let bytes = await Primitive.Bytes.read(b);
        return new Raw.upload.WebFile({
          size: size,
          mimeType: mimeType,
          fileType: fileType,
          mtime: mtime,
          bytes: bytes,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.size !== undefined) {
          b.write(Primitive.Int.write(this.size) as unknown as Buffer);
        }
        if (this.mimeType !== undefined) {
          b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
        }
        if (this.fileType !== undefined) {
          b.write(this.fileType.write() as unknown as Buffer);
        }
        if (this.mtime !== undefined) {
          b.write(Primitive.Int.write(this.mtime) as unknown as Buffer);
        }
        if (this.bytes !== undefined) {
          b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CdnFileReuploadNeeded extends TLObject {
      requestToken!: bytes;

      constructor(params: { requestToken: bytes }) {
        super();
        this.classType = 'types';
        this.className = 'upload.CdnFileReuploadNeeded';
        this.constructorId = 0xeea8e46e;
        this.subclassOfId = 0xf5ccf928;
        this._slots = ['requestToken'];
        this.requestToken = params.requestToken;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.upload.CdnFileReuploadNeeded> {
        // no flags

        let requestToken = await Primitive.Bytes.read(b);
        return new Raw.upload.CdnFileReuploadNeeded({ requestToken: requestToken });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.requestToken !== undefined) {
          b.write(Primitive.Bytes.write(this.requestToken) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CdnFile extends TLObject {
      bytes!: bytes;

      constructor(params: { bytes: bytes }) {
        super();
        this.classType = 'types';
        this.className = 'upload.CdnFile';
        this.constructorId = 0xa99fca4f;
        this.subclassOfId = 0xf5ccf928;
        this._slots = ['bytes'];
        this.bytes = params.bytes;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.upload.CdnFile> {
        // no flags

        let bytes = await Primitive.Bytes.read(b);
        return new Raw.upload.CdnFile({ bytes: bytes });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.bytes !== undefined) {
          b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveFilePart extends TLObject {
      __response__!: Bool;
      fileId!: long;
      filePart!: int;
      bytes!: bytes;

      constructor(params: { fileId: long; filePart: int; bytes: bytes }) {
        super();
        this.classType = 'functions';
        this.className = 'upload.SaveFilePart';
        this.constructorId = 0xb304a621;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['fileId', 'filePart', 'bytes'];
        this.fileId = params.fileId;
        this.filePart = params.filePart;
        this.bytes = params.bytes;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.upload.SaveFilePart> {
        // no flags

        let fileId = await Primitive.Long.read(b);
        let filePart = await Primitive.Int.read(b);
        let bytes = await Primitive.Bytes.read(b);
        return new Raw.upload.SaveFilePart({ fileId: fileId, filePart: filePart, bytes: bytes });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.fileId !== undefined) {
          b.write(Primitive.Long.write(this.fileId) as unknown as Buffer);
        }
        if (this.filePart !== undefined) {
          b.write(Primitive.Int.write(this.filePart) as unknown as Buffer);
        }
        if (this.bytes !== undefined) {
          b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetFile extends TLObject {
      __response__!: Raw.upload.TypeFile;
      precise?: boolean;
      cdnSupported?: boolean;
      location!: Raw.TypeInputFileLocation;
      offset!: long;
      limit!: int;

      constructor(params: {
        precise?: boolean;
        cdnSupported?: boolean;
        location: Raw.TypeInputFileLocation;
        offset: long;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'upload.GetFile';
        this.constructorId = 0xbe5335be;
        this.subclassOfId = 0x6c9bd728;
        this._slots = ['precise', 'cdnSupported', 'location', 'offset', 'limit'];
        this.precise = params.precise;
        this.cdnSupported = params.cdnSupported;
        this.location = params.location;
        this.offset = params.offset;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.upload.GetFile> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let precise = flags & (1 << 0) ? true : false;
        let cdnSupported = flags & (1 << 1) ? true : false;
        let location = await TLObject.read(b);
        let offset = await Primitive.Long.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.upload.GetFile({
          precise: precise,
          cdnSupported: cdnSupported,
          location: location,
          offset: offset,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.precise ? 1 << 0 : 0;
        flags |= this.cdnSupported ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.location !== undefined) {
          b.write(this.location.write() as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.Long.write(this.offset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveBigFilePart extends TLObject {
      __response__!: Bool;
      fileId!: long;
      filePart!: int;
      fileTotalParts!: int;
      bytes!: bytes;

      constructor(params: { fileId: long; filePart: int; fileTotalParts: int; bytes: bytes }) {
        super();
        this.classType = 'functions';
        this.className = 'upload.SaveBigFilePart';
        this.constructorId = 0xde7b673d;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['fileId', 'filePart', 'fileTotalParts', 'bytes'];
        this.fileId = params.fileId;
        this.filePart = params.filePart;
        this.fileTotalParts = params.fileTotalParts;
        this.bytes = params.bytes;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.upload.SaveBigFilePart> {
        // no flags

        let fileId = await Primitive.Long.read(b);
        let filePart = await Primitive.Int.read(b);
        let fileTotalParts = await Primitive.Int.read(b);
        let bytes = await Primitive.Bytes.read(b);
        return new Raw.upload.SaveBigFilePart({
          fileId: fileId,
          filePart: filePart,
          fileTotalParts: fileTotalParts,
          bytes: bytes,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.fileId !== undefined) {
          b.write(Primitive.Long.write(this.fileId) as unknown as Buffer);
        }
        if (this.filePart !== undefined) {
          b.write(Primitive.Int.write(this.filePart) as unknown as Buffer);
        }
        if (this.fileTotalParts !== undefined) {
          b.write(Primitive.Int.write(this.fileTotalParts) as unknown as Buffer);
        }
        if (this.bytes !== undefined) {
          b.write(Primitive.Bytes.write(this.bytes) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetWebFile extends TLObject {
      __response__!: Raw.upload.TypeWebFile;
      location!: Raw.TypeInputWebFileLocation;
      offset!: int;
      limit!: int;

      constructor(params: { location: Raw.TypeInputWebFileLocation; offset: int; limit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'upload.GetWebFile';
        this.constructorId = 0x24e6818d;
        this.subclassOfId = 0x68f17f51;
        this._slots = ['location', 'offset', 'limit'];
        this.location = params.location;
        this.offset = params.offset;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.upload.GetWebFile> {
        // no flags

        let location = await TLObject.read(b);
        let offset = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.upload.GetWebFile({ location: location, offset: offset, limit: limit });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.location !== undefined) {
          b.write(this.location.write() as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetCdnFile extends TLObject {
      __response__!: Raw.upload.TypeCdnFile;
      fileToken!: bytes;
      offset!: long;
      limit!: int;

      constructor(params: { fileToken: bytes; offset: long; limit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'upload.GetCdnFile';
        this.constructorId = 0x395f69da;
        this.subclassOfId = 0xf5ccf928;
        this._slots = ['fileToken', 'offset', 'limit'];
        this.fileToken = params.fileToken;
        this.offset = params.offset;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.upload.GetCdnFile> {
        // no flags

        let fileToken = await Primitive.Bytes.read(b);
        let offset = await Primitive.Long.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.upload.GetCdnFile({ fileToken: fileToken, offset: offset, limit: limit });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.fileToken !== undefined) {
          b.write(Primitive.Bytes.write(this.fileToken) as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.Long.write(this.offset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReuploadCdnFile extends TLObject {
      __response__!: Vector<Raw.TypeFileHash>;
      fileToken!: bytes;
      requestToken!: bytes;

      constructor(params: { fileToken: bytes; requestToken: bytes }) {
        super();
        this.classType = 'functions';
        this.className = 'upload.ReuploadCdnFile';
        this.constructorId = 0x9b2754a8;
        this.subclassOfId = 0xa5940726;
        this._slots = ['fileToken', 'requestToken'];
        this.fileToken = params.fileToken;
        this.requestToken = params.requestToken;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.upload.ReuploadCdnFile> {
        // no flags

        let fileToken = await Primitive.Bytes.read(b);
        let requestToken = await Primitive.Bytes.read(b);
        return new Raw.upload.ReuploadCdnFile({ fileToken: fileToken, requestToken: requestToken });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.fileToken !== undefined) {
          b.write(Primitive.Bytes.write(this.fileToken) as unknown as Buffer);
        }
        if (this.requestToken !== undefined) {
          b.write(Primitive.Bytes.write(this.requestToken) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetCdnFileHashes extends TLObject {
      __response__!: Vector<Raw.TypeFileHash>;
      fileToken!: bytes;
      offset!: long;

      constructor(params: { fileToken: bytes; offset: long }) {
        super();
        this.classType = 'functions';
        this.className = 'upload.GetCdnFileHashes';
        this.constructorId = 0x91dc3f31;
        this.subclassOfId = 0xa5940726;
        this._slots = ['fileToken', 'offset'];
        this.fileToken = params.fileToken;
        this.offset = params.offset;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.upload.GetCdnFileHashes> {
        // no flags

        let fileToken = await Primitive.Bytes.read(b);
        let offset = await Primitive.Long.read(b);
        return new Raw.upload.GetCdnFileHashes({ fileToken: fileToken, offset: offset });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.fileToken !== undefined) {
          b.write(Primitive.Bytes.write(this.fileToken) as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.Long.write(this.offset) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetFileHashes extends TLObject {
      __response__!: Vector<Raw.TypeFileHash>;
      location!: Raw.TypeInputFileLocation;
      offset!: long;

      constructor(params: { location: Raw.TypeInputFileLocation; offset: long }) {
        super();
        this.classType = 'functions';
        this.className = 'upload.GetFileHashes';
        this.constructorId = 0x9156982a;
        this.subclassOfId = 0xa5940726;
        this._slots = ['location', 'offset'];
        this.location = params.location;
        this.offset = params.offset;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.upload.GetFileHashes> {
        // no flags

        let location = await TLObject.read(b);
        let offset = await Primitive.Long.read(b);
        return new Raw.upload.GetFileHashes({ location: location, offset: offset });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.location !== undefined) {
          b.write(this.location.write() as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.Long.write(this.offset) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace account {
    export type TypeAutoSaveSettings = Raw.account.AutoSaveSettings;
    export type TypeEmojiStatuses =
      | Raw.account.EmojiStatusesNotModified
      | Raw.account.EmojiStatuses;
    export type TypeSavedRingtone = Raw.account.SavedRingtone | Raw.account.SavedRingtoneConverted;
    export type TypeSavedRingtones =
      | Raw.account.SavedRingtonesNotModified
      | Raw.account.SavedRingtones;
    export type TypeResetPasswordResult =
      | Raw.account.ResetPasswordFailedWait
      | Raw.account.ResetPasswordRequestedWait
      | Raw.account.ResetPasswordOk;
    export type TypeContentSettings = Raw.account.ContentSettings;
    export type TypeThemes = Raw.account.ThemesNotModified | Raw.account.Themes;
    export type TypeAutoDownloadSettings = Raw.account.AutoDownloadSettings;
    export type TypeTakeout = Raw.account.Takeout;
    export type TypeEmailVerified = Raw.account.EmailVerified | Raw.account.EmailVerifiedLogin;
    export type TypeSentEmailCode = Raw.account.SentEmailCode;
    export type TypeAuthorizationForm = Raw.account.AuthorizationForm;
    export type TypeWebAuthorizations = Raw.account.WebAuthorizations;
    export type TypeTmpPassword = Raw.account.TmpPassword;
    export type TypePasswordSettings = Raw.account.PasswordSettings;
    export type TypePassword = Raw.account.Password;
    export type TypeAuthorizations = Raw.account.Authorizations;
    export type TypePrivacyRules = Raw.account.PrivacyRules;
    export type TypeWallPapers = Raw.account.WallPapersNotModified | Raw.account.WallPapers;
    export type TypePasswordInputSettings = Raw.account.PasswordInputSettings;
    export class PrivacyRules extends TLObject {
      rules!: Vector<Raw.TypePrivacyRule>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        rules: Vector<Raw.TypePrivacyRule>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'account.PrivacyRules';
        this.constructorId = 0x50a04e45;
        this.subclassOfId = 0xb55aba82;
        this._slots = ['rules', 'chats', 'users'];
        this.rules = params.rules;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.PrivacyRules> {
        // no flags

        let rules = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.account.PrivacyRules({ rules: rules, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.rules) {
          b.write(Primitive.Vector.write(this.rules) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Authorizations extends TLObject {
      authorizationTtlDays!: int;
      authorizations!: Vector<Raw.TypeAuthorization>;

      constructor(params: {
        authorizationTtlDays: int;
        authorizations: Vector<Raw.TypeAuthorization>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'account.Authorizations';
        this.constructorId = 0x4bff8ea0;
        this.subclassOfId = 0xbf5e0ff;
        this._slots = ['authorizationTtlDays', 'authorizations'];
        this.authorizationTtlDays = params.authorizationTtlDays;
        this.authorizations = params.authorizations;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.Authorizations> {
        // no flags

        let authorizationTtlDays = await Primitive.Int.read(b);
        let authorizations = await TLObject.read(b);
        return new Raw.account.Authorizations({
          authorizationTtlDays: authorizationTtlDays,
          authorizations: authorizations,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.authorizationTtlDays !== undefined) {
          b.write(Primitive.Int.write(this.authorizationTtlDays) as unknown as Buffer);
        }
        if (this.authorizations) {
          b.write(Primitive.Vector.write(this.authorizations) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Password extends TLObject {
      hasRecovery?: boolean;
      hasSecureValues?: boolean;
      hasPassword?: boolean;
      currentAlgo?: Raw.TypePasswordKdfAlgo;
      srpB?: bytes;
      srpId?: long;
      hint?: string;
      emailUnconfirmedPattern?: string;
      newAlgo!: Raw.TypePasswordKdfAlgo;
      newSecureAlgo!: Raw.TypeSecurePasswordKdfAlgo;
      secureRandom!: bytes;
      pendingResetDate?: int;
      loginEmailPattern?: string;

      constructor(params: {
        hasRecovery?: boolean;
        hasSecureValues?: boolean;
        hasPassword?: boolean;
        currentAlgo?: Raw.TypePasswordKdfAlgo;
        srpB?: bytes;
        srpId?: long;
        hint?: string;
        emailUnconfirmedPattern?: string;
        newAlgo: Raw.TypePasswordKdfAlgo;
        newSecureAlgo: Raw.TypeSecurePasswordKdfAlgo;
        secureRandom: bytes;
        pendingResetDate?: int;
        loginEmailPattern?: string;
      }) {
        super();
        this.classType = 'types';
        this.className = 'account.Password';
        this.constructorId = 0x957b50fb;
        this.subclassOfId = 0x53a211a3;
        this._slots = [
          'hasRecovery',
          'hasSecureValues',
          'hasPassword',
          'currentAlgo',
          'srpB',
          'srpId',
          'hint',
          'emailUnconfirmedPattern',
          'newAlgo',
          'newSecureAlgo',
          'secureRandom',
          'pendingResetDate',
          'loginEmailPattern',
        ];
        this.hasRecovery = params.hasRecovery;
        this.hasSecureValues = params.hasSecureValues;
        this.hasPassword = params.hasPassword;
        this.currentAlgo = params.currentAlgo;
        this.srpB = params.srpB;
        this.srpId = params.srpId;
        this.hint = params.hint;
        this.emailUnconfirmedPattern = params.emailUnconfirmedPattern;
        this.newAlgo = params.newAlgo;
        this.newSecureAlgo = params.newSecureAlgo;
        this.secureRandom = params.secureRandom;
        this.pendingResetDate = params.pendingResetDate;
        this.loginEmailPattern = params.loginEmailPattern;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.Password> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let hasRecovery = flags & (1 << 0) ? true : false;
        let hasSecureValues = flags & (1 << 1) ? true : false;
        let hasPassword = flags & (1 << 2) ? true : false;
        let currentAlgo = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let srpB = flags & (1 << 2) ? await Primitive.Bytes.read(b) : undefined;
        let srpId = flags & (1 << 2) ? await Primitive.Long.read(b) : undefined;
        let hint = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
        let emailUnconfirmedPattern = flags & (1 << 4) ? await Primitive.String.read(b) : undefined;
        let newAlgo = await TLObject.read(b);
        let newSecureAlgo = await TLObject.read(b);
        let secureRandom = await Primitive.Bytes.read(b);
        let pendingResetDate = flags & (1 << 5) ? await Primitive.Int.read(b) : undefined;
        let loginEmailPattern = flags & (1 << 6) ? await Primitive.String.read(b) : undefined;
        return new Raw.account.Password({
          hasRecovery: hasRecovery,
          hasSecureValues: hasSecureValues,
          hasPassword: hasPassword,
          currentAlgo: currentAlgo,
          srpB: srpB,
          srpId: srpId,
          hint: hint,
          emailUnconfirmedPattern: emailUnconfirmedPattern,
          newAlgo: newAlgo,
          newSecureAlgo: newSecureAlgo,
          secureRandom: secureRandom,
          pendingResetDate: pendingResetDate,
          loginEmailPattern: loginEmailPattern,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.hasRecovery ? 1 << 0 : 0;
        flags |= this.hasSecureValues ? 1 << 1 : 0;
        flags |= this.hasPassword ? 1 << 2 : 0;
        flags |= this.currentAlgo !== undefined ? 1 << 2 : 0;
        flags |= this.srpB !== undefined ? 1 << 2 : 0;
        flags |= this.srpId !== undefined ? 1 << 2 : 0;
        flags |= this.hint !== undefined ? 1 << 3 : 0;
        flags |= this.emailUnconfirmedPattern !== undefined ? 1 << 4 : 0;
        flags |= this.pendingResetDate !== undefined ? 1 << 5 : 0;
        flags |= this.loginEmailPattern !== undefined ? 1 << 6 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.currentAlgo !== undefined) {
          b.write(this.currentAlgo.write() as unknown as Buffer);
        }
        if (this.srpB !== undefined) {
          b.write(Primitive.Bytes.write(this.srpB) as unknown as Buffer);
        }
        if (this.srpId !== undefined) {
          b.write(Primitive.Long.write(this.srpId) as unknown as Buffer);
        }
        if (this.hint !== undefined) {
          b.write(Primitive.String.write(this.hint) as unknown as Buffer);
        }
        if (this.emailUnconfirmedPattern !== undefined) {
          b.write(Primitive.String.write(this.emailUnconfirmedPattern) as unknown as Buffer);
        }
        if (this.newAlgo !== undefined) {
          b.write(this.newAlgo.write() as unknown as Buffer);
        }
        if (this.newSecureAlgo !== undefined) {
          b.write(this.newSecureAlgo.write() as unknown as Buffer);
        }
        if (this.secureRandom !== undefined) {
          b.write(Primitive.Bytes.write(this.secureRandom) as unknown as Buffer);
        }
        if (this.pendingResetDate !== undefined) {
          b.write(Primitive.Int.write(this.pendingResetDate) as unknown as Buffer);
        }
        if (this.loginEmailPattern !== undefined) {
          b.write(Primitive.String.write(this.loginEmailPattern) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PasswordSettings extends TLObject {
      email?: string;
      secureSettings?: Raw.TypeSecureSecretSettings;

      constructor(params: { email?: string; secureSettings?: Raw.TypeSecureSecretSettings }) {
        super();
        this.classType = 'types';
        this.className = 'account.PasswordSettings';
        this.constructorId = 0x9a5c33e5;
        this.subclassOfId = 0xd23fb078;
        this._slots = ['email', 'secureSettings'];
        this.email = params.email;
        this.secureSettings = params.secureSettings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.PasswordSettings> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let email = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let secureSettings = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        return new Raw.account.PasswordSettings({ email: email, secureSettings: secureSettings });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.email !== undefined ? 1 << 0 : 0;
        flags |= this.secureSettings !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.email !== undefined) {
          b.write(Primitive.String.write(this.email) as unknown as Buffer);
        }
        if (this.secureSettings !== undefined) {
          b.write(this.secureSettings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PasswordInputSettings extends TLObject {
      newAlgo?: Raw.TypePasswordKdfAlgo;
      newPasswordHash?: bytes;
      hint?: string;
      email?: string;
      newSecureSettings?: Raw.TypeSecureSecretSettings;

      constructor(params: {
        newAlgo?: Raw.TypePasswordKdfAlgo;
        newPasswordHash?: bytes;
        hint?: string;
        email?: string;
        newSecureSettings?: Raw.TypeSecureSecretSettings;
      }) {
        super();
        this.classType = 'types';
        this.className = 'account.PasswordInputSettings';
        this.constructorId = 0xc23727c9;
        this.subclassOfId = 0xc426ca6;
        this._slots = ['newAlgo', 'newPasswordHash', 'hint', 'email', 'newSecureSettings'];
        this.newAlgo = params.newAlgo;
        this.newPasswordHash = params.newPasswordHash;
        this.hint = params.hint;
        this.email = params.email;
        this.newSecureSettings = params.newSecureSettings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.PasswordInputSettings> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let newAlgo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let newPasswordHash = flags & (1 << 0) ? await Primitive.Bytes.read(b) : undefined;
        let hint = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let email = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let newSecureSettings = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        return new Raw.account.PasswordInputSettings({
          newAlgo: newAlgo,
          newPasswordHash: newPasswordHash,
          hint: hint,
          email: email,
          newSecureSettings: newSecureSettings,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.newAlgo !== undefined ? 1 << 0 : 0;
        flags |= this.newPasswordHash !== undefined ? 1 << 0 : 0;
        flags |= this.hint !== undefined ? 1 << 0 : 0;
        flags |= this.email !== undefined ? 1 << 1 : 0;
        flags |= this.newSecureSettings !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.newAlgo !== undefined) {
          b.write(this.newAlgo.write() as unknown as Buffer);
        }
        if (this.newPasswordHash !== undefined) {
          b.write(Primitive.Bytes.write(this.newPasswordHash) as unknown as Buffer);
        }
        if (this.hint !== undefined) {
          b.write(Primitive.String.write(this.hint) as unknown as Buffer);
        }
        if (this.email !== undefined) {
          b.write(Primitive.String.write(this.email) as unknown as Buffer);
        }
        if (this.newSecureSettings !== undefined) {
          b.write(this.newSecureSettings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TmpPassword extends TLObject {
      tmpPassword!: bytes;
      validUntil!: int;

      constructor(params: { tmpPassword: bytes; validUntil: int }) {
        super();
        this.classType = 'types';
        this.className = 'account.TmpPassword';
        this.constructorId = 0xdb64fd34;
        this.subclassOfId = 0xb064992d;
        this._slots = ['tmpPassword', 'validUntil'];
        this.tmpPassword = params.tmpPassword;
        this.validUntil = params.validUntil;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.TmpPassword> {
        // no flags

        let tmpPassword = await Primitive.Bytes.read(b);
        let validUntil = await Primitive.Int.read(b);
        return new Raw.account.TmpPassword({ tmpPassword: tmpPassword, validUntil: validUntil });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.tmpPassword !== undefined) {
          b.write(Primitive.Bytes.write(this.tmpPassword) as unknown as Buffer);
        }
        if (this.validUntil !== undefined) {
          b.write(Primitive.Int.write(this.validUntil) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class WebAuthorizations extends TLObject {
      authorizations!: Vector<Raw.TypeWebAuthorization>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        authorizations: Vector<Raw.TypeWebAuthorization>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'account.WebAuthorizations';
        this.constructorId = 0xed56c9fc;
        this.subclassOfId = 0x9a365b32;
        this._slots = ['authorizations', 'users'];
        this.authorizations = params.authorizations;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.WebAuthorizations> {
        // no flags

        let authorizations = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.account.WebAuthorizations({ authorizations: authorizations, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.authorizations) {
          b.write(Primitive.Vector.write(this.authorizations) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AuthorizationForm extends TLObject {
      requiredTypes!: Vector<Raw.TypeSecureRequiredType>;
      values!: Vector<Raw.TypeSecureValue>;
      errors!: Vector<Raw.TypeSecureValueError>;
      users!: Vector<Raw.TypeUser>;
      privacyPolicyUrl?: string;

      constructor(params: {
        requiredTypes: Vector<Raw.TypeSecureRequiredType>;
        values: Vector<Raw.TypeSecureValue>;
        errors: Vector<Raw.TypeSecureValueError>;
        users: Vector<Raw.TypeUser>;
        privacyPolicyUrl?: string;
      }) {
        super();
        this.classType = 'types';
        this.className = 'account.AuthorizationForm';
        this.constructorId = 0xad2e1cd8;
        this.subclassOfId = 0x78049a94;
        this._slots = ['requiredTypes', 'values', 'errors', 'users', 'privacyPolicyUrl'];
        this.requiredTypes = params.requiredTypes;
        this.values = params.values;
        this.errors = params.errors;
        this.users = params.users;
        this.privacyPolicyUrl = params.privacyPolicyUrl;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.AuthorizationForm> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let requiredTypes = await TLObject.read(b);
        let values = await TLObject.read(b);
        let errors = await TLObject.read(b);
        let users = await TLObject.read(b);
        let privacyPolicyUrl = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        return new Raw.account.AuthorizationForm({
          requiredTypes: requiredTypes,
          values: values,
          errors: errors,
          users: users,
          privacyPolicyUrl: privacyPolicyUrl,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.privacyPolicyUrl !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.requiredTypes) {
          b.write(Primitive.Vector.write(this.requiredTypes) as unknown as Buffer);
        }
        if (this.values) {
          b.write(Primitive.Vector.write(this.values) as unknown as Buffer);
        }
        if (this.errors) {
          b.write(Primitive.Vector.write(this.errors) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        if (this.privacyPolicyUrl !== undefined) {
          b.write(Primitive.String.write(this.privacyPolicyUrl) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SentEmailCode extends TLObject {
      emailPattern!: string;
      length!: int;

      constructor(params: { emailPattern: string; length: int }) {
        super();
        this.classType = 'types';
        this.className = 'account.SentEmailCode';
        this.constructorId = 0x811f854f;
        this.subclassOfId = 0x69f3c06e;
        this._slots = ['emailPattern', 'length'];
        this.emailPattern = params.emailPattern;
        this.length = params.length;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SentEmailCode> {
        // no flags

        let emailPattern = await Primitive.String.read(b);
        let length = await Primitive.Int.read(b);
        return new Raw.account.SentEmailCode({ emailPattern: emailPattern, length: length });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.emailPattern !== undefined) {
          b.write(Primitive.String.write(this.emailPattern) as unknown as Buffer);
        }
        if (this.length !== undefined) {
          b.write(Primitive.Int.write(this.length) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Takeout extends TLObject {
      id!: long;

      constructor(params: { id: long }) {
        super();
        this.classType = 'types';
        this.className = 'account.Takeout';
        this.constructorId = 0x4dba4501;
        this.subclassOfId = 0x843ebe85;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.Takeout> {
        // no flags

        let id = await Primitive.Long.read(b);
        return new Raw.account.Takeout({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id !== undefined) {
          b.write(Primitive.Long.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class WallPapersNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'account.WallPapersNotModified';
        this.constructorId = 0x1c199183;
        this.subclassOfId = 0xa2c548fd;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.WallPapersNotModified> {
        // no flags

        return new Raw.account.WallPapersNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class WallPapers extends TLObject {
      hash!: long;
      wallpapers!: Vector<Raw.TypeWallPaper>;

      constructor(params: { hash: long; wallpapers: Vector<Raw.TypeWallPaper> }) {
        super();
        this.classType = 'types';
        this.className = 'account.WallPapers';
        this.constructorId = 0xcdc3858c;
        this.subclassOfId = 0xa2c548fd;
        this._slots = ['hash', 'wallpapers'];
        this.hash = params.hash;
        this.wallpapers = params.wallpapers;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.WallPapers> {
        // no flags

        let hash = await Primitive.Long.read(b);
        let wallpapers = await TLObject.read(b);
        return new Raw.account.WallPapers({ hash: hash, wallpapers: wallpapers });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.wallpapers) {
          b.write(Primitive.Vector.write(this.wallpapers) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AutoDownloadSettings extends TLObject {
      low!: Raw.TypeAutoDownloadSettings;
      medium!: Raw.TypeAutoDownloadSettings;
      high!: Raw.TypeAutoDownloadSettings;

      constructor(params: {
        low: Raw.TypeAutoDownloadSettings;
        medium: Raw.TypeAutoDownloadSettings;
        high: Raw.TypeAutoDownloadSettings;
      }) {
        super();
        this.classType = 'types';
        this.className = 'account.AutoDownloadSettings';
        this.constructorId = 0x63cacf26;
        this.subclassOfId = 0x2fb85921;
        this._slots = ['low', 'medium', 'high'];
        this.low = params.low;
        this.medium = params.medium;
        this.high = params.high;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.AutoDownloadSettings> {
        // no flags

        let low = await TLObject.read(b);
        let medium = await TLObject.read(b);
        let high = await TLObject.read(b);
        return new Raw.account.AutoDownloadSettings({ low: low, medium: medium, high: high });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.low !== undefined) {
          b.write(this.low.write() as unknown as Buffer);
        }
        if (this.medium !== undefined) {
          b.write(this.medium.write() as unknown as Buffer);
        }
        if (this.high !== undefined) {
          b.write(this.high.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ThemesNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'account.ThemesNotModified';
        this.constructorId = 0xf41eb622;
        this.subclassOfId = 0x7fc52204;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ThemesNotModified> {
        // no flags

        return new Raw.account.ThemesNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class Themes extends TLObject {
      hash!: long;
      themes!: Vector<Raw.TypeTheme>;

      constructor(params: { hash: long; themes: Vector<Raw.TypeTheme> }) {
        super();
        this.classType = 'types';
        this.className = 'account.Themes';
        this.constructorId = 0x9a3d8c6d;
        this.subclassOfId = 0x7fc52204;
        this._slots = ['hash', 'themes'];
        this.hash = params.hash;
        this.themes = params.themes;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.Themes> {
        // no flags

        let hash = await Primitive.Long.read(b);
        let themes = await TLObject.read(b);
        return new Raw.account.Themes({ hash: hash, themes: themes });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.themes) {
          b.write(Primitive.Vector.write(this.themes) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ContentSettings extends TLObject {
      sensitiveEnabled?: boolean;
      sensitiveCanChange?: boolean;

      constructor(params: { sensitiveEnabled?: boolean; sensitiveCanChange?: boolean }) {
        super();
        this.classType = 'types';
        this.className = 'account.ContentSettings';
        this.constructorId = 0x57e28221;
        this.subclassOfId = 0xae3ff891;
        this._slots = ['sensitiveEnabled', 'sensitiveCanChange'];
        this.sensitiveEnabled = params.sensitiveEnabled;
        this.sensitiveCanChange = params.sensitiveCanChange;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ContentSettings> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let sensitiveEnabled = flags & (1 << 0) ? true : false;
        let sensitiveCanChange = flags & (1 << 1) ? true : false;
        return new Raw.account.ContentSettings({
          sensitiveEnabled: sensitiveEnabled,
          sensitiveCanChange: sensitiveCanChange,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.sensitiveEnabled ? 1 << 0 : 0;
        flags |= this.sensitiveCanChange ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        return b.buffer;
      }
    }
    export class ResetPasswordFailedWait extends TLObject {
      retryDate!: int;

      constructor(params: { retryDate: int }) {
        super();
        this.classType = 'types';
        this.className = 'account.ResetPasswordFailedWait';
        this.constructorId = 0xe3779861;
        this.subclassOfId = 0x49507416;
        this._slots = ['retryDate'];
        this.retryDate = params.retryDate;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.ResetPasswordFailedWait> {
        // no flags

        let retryDate = await Primitive.Int.read(b);
        return new Raw.account.ResetPasswordFailedWait({ retryDate: retryDate });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.retryDate !== undefined) {
          b.write(Primitive.Int.write(this.retryDate) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResetPasswordRequestedWait extends TLObject {
      untilDate!: int;

      constructor(params: { untilDate: int }) {
        super();
        this.classType = 'types';
        this.className = 'account.ResetPasswordRequestedWait';
        this.constructorId = 0xe9effc7d;
        this.subclassOfId = 0x49507416;
        this._slots = ['untilDate'];
        this.untilDate = params.untilDate;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.ResetPasswordRequestedWait> {
        // no flags

        let untilDate = await Primitive.Int.read(b);
        return new Raw.account.ResetPasswordRequestedWait({ untilDate: untilDate });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.untilDate !== undefined) {
          b.write(Primitive.Int.write(this.untilDate) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResetPasswordOk extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'account.ResetPasswordOk';
        this.constructorId = 0xe926d63e;
        this.subclassOfId = 0x49507416;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ResetPasswordOk> {
        // no flags

        return new Raw.account.ResetPasswordOk();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SavedRingtonesNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'account.SavedRingtonesNotModified';
        this.constructorId = 0xfbf6e8b1;
        this.subclassOfId = 0x27bcc95e;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.SavedRingtonesNotModified> {
        // no flags

        return new Raw.account.SavedRingtonesNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SavedRingtones extends TLObject {
      hash!: long;
      ringtones!: Vector<Raw.TypeDocument>;

      constructor(params: { hash: long; ringtones: Vector<Raw.TypeDocument> }) {
        super();
        this.classType = 'types';
        this.className = 'account.SavedRingtones';
        this.constructorId = 0xc1e92cc5;
        this.subclassOfId = 0x27bcc95e;
        this._slots = ['hash', 'ringtones'];
        this.hash = params.hash;
        this.ringtones = params.ringtones;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SavedRingtones> {
        // no flags

        let hash = await Primitive.Long.read(b);
        let ringtones = await TLObject.read(b);
        return new Raw.account.SavedRingtones({ hash: hash, ringtones: ringtones });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.ringtones) {
          b.write(Primitive.Vector.write(this.ringtones) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SavedRingtone extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'account.SavedRingtone';
        this.constructorId = 0xb7263f6d;
        this.subclassOfId = 0xb1e28424;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SavedRingtone> {
        // no flags

        return new Raw.account.SavedRingtone();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SavedRingtoneConverted extends TLObject {
      document!: Raw.TypeDocument;

      constructor(params: { document: Raw.TypeDocument }) {
        super();
        this.classType = 'types';
        this.className = 'account.SavedRingtoneConverted';
        this.constructorId = 0x1f307eb7;
        this.subclassOfId = 0xb1e28424;
        this._slots = ['document'];
        this.document = params.document;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.SavedRingtoneConverted> {
        // no flags

        let document = await TLObject.read(b);
        return new Raw.account.SavedRingtoneConverted({ document: document });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.document !== undefined) {
          b.write(this.document.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EmojiStatusesNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'account.EmojiStatusesNotModified';
        this.constructorId = 0xd08ce645;
        this.subclassOfId = 0xd3e005ca;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.EmojiStatusesNotModified> {
        // no flags

        return new Raw.account.EmojiStatusesNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class EmojiStatuses extends TLObject {
      hash!: long;
      statuses!: Vector<Raw.TypeEmojiStatus>;

      constructor(params: { hash: long; statuses: Vector<Raw.TypeEmojiStatus> }) {
        super();
        this.classType = 'types';
        this.className = 'account.EmojiStatuses';
        this.constructorId = 0x90c467d1;
        this.subclassOfId = 0xd3e005ca;
        this._slots = ['hash', 'statuses'];
        this.hash = params.hash;
        this.statuses = params.statuses;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.EmojiStatuses> {
        // no flags

        let hash = await Primitive.Long.read(b);
        let statuses = await TLObject.read(b);
        return new Raw.account.EmojiStatuses({ hash: hash, statuses: statuses });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.statuses) {
          b.write(Primitive.Vector.write(this.statuses) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EmailVerified extends TLObject {
      email!: string;

      constructor(params: { email: string }) {
        super();
        this.classType = 'types';
        this.className = 'account.EmailVerified';
        this.constructorId = 0x2b96cd1b;
        this.subclassOfId = 0x64833188;
        this._slots = ['email'];
        this.email = params.email;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.EmailVerified> {
        // no flags

        let email = await Primitive.String.read(b);
        return new Raw.account.EmailVerified({ email: email });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.email !== undefined) {
          b.write(Primitive.String.write(this.email) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EmailVerifiedLogin extends TLObject {
      email!: string;
      sentCode!: Raw.auth.TypeSentCode;

      constructor(params: { email: string; sentCode: Raw.auth.TypeSentCode }) {
        super();
        this.classType = 'types';
        this.className = 'account.EmailVerifiedLogin';
        this.constructorId = 0xe1bb0d61;
        this.subclassOfId = 0x64833188;
        this._slots = ['email', 'sentCode'];
        this.email = params.email;
        this.sentCode = params.sentCode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.EmailVerifiedLogin> {
        // no flags

        let email = await Primitive.String.read(b);
        let sentCode = await TLObject.read(b);
        return new Raw.account.EmailVerifiedLogin({ email: email, sentCode: sentCode });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.email !== undefined) {
          b.write(Primitive.String.write(this.email) as unknown as Buffer);
        }
        if (this.sentCode !== undefined) {
          b.write(this.sentCode.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AutoSaveSettings extends TLObject {
      usersSettings!: Raw.TypeAutoSaveSettings;
      chatsSettings!: Raw.TypeAutoSaveSettings;
      broadcastsSettings!: Raw.TypeAutoSaveSettings;
      exceptions!: Vector<Raw.TypeAutoSaveException>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        usersSettings: Raw.TypeAutoSaveSettings;
        chatsSettings: Raw.TypeAutoSaveSettings;
        broadcastsSettings: Raw.TypeAutoSaveSettings;
        exceptions: Vector<Raw.TypeAutoSaveException>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'account.AutoSaveSettings';
        this.constructorId = 0x4c3e069d;
        this.subclassOfId = 0x48cf2f02;
        this._slots = [
          'usersSettings',
          'chatsSettings',
          'broadcastsSettings',
          'exceptions',
          'chats',
          'users',
        ];
        this.usersSettings = params.usersSettings;
        this.chatsSettings = params.chatsSettings;
        this.broadcastsSettings = params.broadcastsSettings;
        this.exceptions = params.exceptions;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.AutoSaveSettings> {
        // no flags

        let usersSettings = await TLObject.read(b);
        let chatsSettings = await TLObject.read(b);
        let broadcastsSettings = await TLObject.read(b);
        let exceptions = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.account.AutoSaveSettings({
          usersSettings: usersSettings,
          chatsSettings: chatsSettings,
          broadcastsSettings: broadcastsSettings,
          exceptions: exceptions,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.usersSettings !== undefined) {
          b.write(this.usersSettings.write() as unknown as Buffer);
        }
        if (this.chatsSettings !== undefined) {
          b.write(this.chatsSettings.write() as unknown as Buffer);
        }
        if (this.broadcastsSettings !== undefined) {
          b.write(this.broadcastsSettings.write() as unknown as Buffer);
        }
        if (this.exceptions) {
          b.write(Primitive.Vector.write(this.exceptions) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RegisterDevice extends TLObject {
      __response__!: Bool;
      noMuted?: boolean;
      tokenType!: int;
      token!: string;
      appSandbox!: Bool;
      secret!: bytes;
      otherUids!: Vector<long>;

      constructor(params: {
        noMuted?: boolean;
        tokenType: int;
        token: string;
        appSandbox: Bool;
        secret: bytes;
        otherUids: Vector<long>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.RegisterDevice';
        this.constructorId = 0xec86017a;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['noMuted', 'tokenType', 'token', 'appSandbox', 'secret', 'otherUids'];
        this.noMuted = params.noMuted;
        this.tokenType = params.tokenType;
        this.token = params.token;
        this.appSandbox = params.appSandbox;
        this.secret = params.secret;
        this.otherUids = params.otherUids;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.RegisterDevice> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let noMuted = flags & (1 << 0) ? true : false;
        let tokenType = await Primitive.Int.read(b);
        let token = await Primitive.String.read(b);
        let appSandbox = await Primitive.Bool.read(b);
        let secret = await Primitive.Bytes.read(b);
        let otherUids = await TLObject.read(b, Primitive.Long);
        return new Raw.account.RegisterDevice({
          noMuted: noMuted,
          tokenType: tokenType,
          token: token,
          appSandbox: appSandbox,
          secret: secret,
          otherUids: otherUids,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.noMuted ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.tokenType !== undefined) {
          b.write(Primitive.Int.write(this.tokenType) as unknown as Buffer);
        }
        if (this.token !== undefined) {
          b.write(Primitive.String.write(this.token) as unknown as Buffer);
        }
        if (this.appSandbox !== undefined) {
          b.write(Primitive.Bool.write(this.appSandbox) as unknown as Buffer);
        }
        if (this.secret !== undefined) {
          b.write(Primitive.Bytes.write(this.secret) as unknown as Buffer);
        }
        if (this.otherUids) {
          b.write(Primitive.Vector.write(this.otherUids, Primitive.Long) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UnregisterDevice extends TLObject {
      __response__!: Bool;
      tokenType!: int;
      token!: string;
      otherUids!: Vector<long>;

      constructor(params: { tokenType: int; token: string; otherUids: Vector<long> }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UnregisterDevice';
        this.constructorId = 0x6a0d3206;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['tokenType', 'token', 'otherUids'];
        this.tokenType = params.tokenType;
        this.token = params.token;
        this.otherUids = params.otherUids;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.UnregisterDevice> {
        // no flags

        let tokenType = await Primitive.Int.read(b);
        let token = await Primitive.String.read(b);
        let otherUids = await TLObject.read(b, Primitive.Long);
        return new Raw.account.UnregisterDevice({
          tokenType: tokenType,
          token: token,
          otherUids: otherUids,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.tokenType !== undefined) {
          b.write(Primitive.Int.write(this.tokenType) as unknown as Buffer);
        }
        if (this.token !== undefined) {
          b.write(Primitive.String.write(this.token) as unknown as Buffer);
        }
        if (this.otherUids) {
          b.write(Primitive.Vector.write(this.otherUids, Primitive.Long) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdateNotifySettings extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputNotifyPeer;
      settings!: Raw.TypeInputPeerNotifySettings;

      constructor(params: {
        peer: Raw.TypeInputNotifyPeer;
        settings: Raw.TypeInputPeerNotifySettings;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UpdateNotifySettings';
        this.constructorId = 0x84be5b93;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'settings'];
        this.peer = params.peer;
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.UpdateNotifySettings> {
        // no flags

        let peer = await TLObject.read(b);
        let settings = await TLObject.read(b);
        return new Raw.account.UpdateNotifySettings({ peer: peer, settings: settings });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetNotifySettings extends TLObject {
      __response__!: Raw.TypePeerNotifySettings;
      peer!: Raw.TypeInputNotifyPeer;

      constructor(params: { peer: Raw.TypeInputNotifyPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetNotifySettings';
        this.constructorId = 0x12b3ad31;
        this.subclassOfId = 0xcf20c074;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetNotifySettings> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.account.GetNotifySettings({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResetNotifySettings extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.ResetNotifySettings';
        this.constructorId = 0xdb7e1747;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ResetNotifySettings> {
        // no flags

        return new Raw.account.ResetNotifySettings();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class UpdateProfile extends TLObject {
      __response__!: Raw.TypeUser;
      firstName?: string;
      lastName?: string;
      about?: string;

      constructor(params: { firstName?: string; lastName?: string; about?: string }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UpdateProfile';
        this.constructorId = 0x78515775;
        this.subclassOfId = 0x2da17977;
        this._slots = ['firstName', 'lastName', 'about'];
        this.firstName = params.firstName;
        this.lastName = params.lastName;
        this.about = params.about;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.UpdateProfile> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let firstName = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let lastName = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let about = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        return new Raw.account.UpdateProfile({
          firstName: firstName,
          lastName: lastName,
          about: about,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.firstName !== undefined ? 1 << 0 : 0;
        flags |= this.lastName !== undefined ? 1 << 1 : 0;
        flags |= this.about !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.firstName !== undefined) {
          b.write(Primitive.String.write(this.firstName) as unknown as Buffer);
        }
        if (this.lastName !== undefined) {
          b.write(Primitive.String.write(this.lastName) as unknown as Buffer);
        }
        if (this.about !== undefined) {
          b.write(Primitive.String.write(this.about) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdateStatus extends TLObject {
      __response__!: Bool;
      offline!: Bool;

      constructor(params: { offline: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UpdateStatus';
        this.constructorId = 0x6628562c;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['offline'];
        this.offline = params.offline;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.UpdateStatus> {
        // no flags

        let offline = await Primitive.Bool.read(b);
        return new Raw.account.UpdateStatus({ offline: offline });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.offline !== undefined) {
          b.write(Primitive.Bool.write(this.offline) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetWallPapers extends TLObject {
      __response__!: Raw.account.TypeWallPapers;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetWallPapers';
        this.constructorId = 0x7967d36;
        this.subclassOfId = 0xa2c548fd;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetWallPapers> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.account.GetWallPapers({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReportPeer extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      reason!: Raw.TypeReportReason;
      message!: string;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        reason: Raw.TypeReportReason;
        message: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.ReportPeer';
        this.constructorId = 0xc5ba3d86;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'reason', 'message'];
        this.peer = params.peer;
        this.reason = params.reason;
        this.message = params.message;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ReportPeer> {
        // no flags

        let peer = await TLObject.read(b);
        let reason = await TLObject.read(b);
        let message = await Primitive.String.read(b);
        return new Raw.account.ReportPeer({ peer: peer, reason: reason, message: message });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.reason !== undefined) {
          b.write(this.reason.write() as unknown as Buffer);
        }
        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CheckUsername extends TLObject {
      __response__!: Bool;
      username!: string;

      constructor(params: { username: string }) {
        super();
        this.classType = 'functions';
        this.className = 'account.CheckUsername';
        this.constructorId = 0x2714d86c;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['username'];
        this.username = params.username;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.CheckUsername> {
        // no flags

        let username = await Primitive.String.read(b);
        return new Raw.account.CheckUsername({ username: username });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.username !== undefined) {
          b.write(Primitive.String.write(this.username) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdateUsername extends TLObject {
      __response__!: Raw.TypeUser;
      username!: string;

      constructor(params: { username: string }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UpdateUsername';
        this.constructorId = 0x3e0bdd7c;
        this.subclassOfId = 0x2da17977;
        this._slots = ['username'];
        this.username = params.username;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.UpdateUsername> {
        // no flags

        let username = await Primitive.String.read(b);
        return new Raw.account.UpdateUsername({ username: username });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.username !== undefined) {
          b.write(Primitive.String.write(this.username) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPrivacy extends TLObject {
      __response__!: Raw.account.TypePrivacyRules;
      key!: Raw.TypeInputPrivacyKey;

      constructor(params: { key: Raw.TypeInputPrivacyKey }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetPrivacy';
        this.constructorId = 0xdadbc950;
        this.subclassOfId = 0xb55aba82;
        this._slots = ['key'];
        this.key = params.key;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetPrivacy> {
        // no flags

        let key = await TLObject.read(b);
        return new Raw.account.GetPrivacy({ key: key });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.key !== undefined) {
          b.write(this.key.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetPrivacy extends TLObject {
      __response__!: Raw.account.TypePrivacyRules;
      key!: Raw.TypeInputPrivacyKey;
      rules!: Vector<Raw.TypeInputPrivacyRule>;

      constructor(params: {
        key: Raw.TypeInputPrivacyKey;
        rules: Vector<Raw.TypeInputPrivacyRule>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SetPrivacy';
        this.constructorId = 0xc9f81ce8;
        this.subclassOfId = 0xb55aba82;
        this._slots = ['key', 'rules'];
        this.key = params.key;
        this.rules = params.rules;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SetPrivacy> {
        // no flags

        let key = await TLObject.read(b);
        let rules = await TLObject.read(b);
        return new Raw.account.SetPrivacy({ key: key, rules: rules });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.key !== undefined) {
          b.write(this.key.write() as unknown as Buffer);
        }
        if (this.rules) {
          b.write(Primitive.Vector.write(this.rules) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteAccount extends TLObject {
      __response__!: Bool;
      reason!: string;
      password?: Raw.TypeInputCheckPasswordSRP;

      constructor(params: { reason: string; password?: Raw.TypeInputCheckPasswordSRP }) {
        super();
        this.classType = 'functions';
        this.className = 'account.DeleteAccount';
        this.constructorId = 0xa2c0cf74;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['reason', 'password'];
        this.reason = params.reason;
        this.password = params.password;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.DeleteAccount> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let reason = await Primitive.String.read(b);
        let password = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        return new Raw.account.DeleteAccount({ reason: reason, password: password });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.password !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.reason !== undefined) {
          b.write(Primitive.String.write(this.reason) as unknown as Buffer);
        }
        if (this.password !== undefined) {
          b.write(this.password.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAccountTTL extends TLObject {
      __response__!: Raw.TypeAccountDaysTTL;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.GetAccountTTL';
        this.constructorId = 0x8fc711d;
        this.subclassOfId = 0xbaa39d88;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetAccountTTL> {
        // no flags

        return new Raw.account.GetAccountTTL();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SetAccountTTL extends TLObject {
      __response__!: Bool;
      ttl!: Raw.TypeAccountDaysTTL;

      constructor(params: { ttl: Raw.TypeAccountDaysTTL }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SetAccountTTL';
        this.constructorId = 0x2442485e;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['ttl'];
        this.ttl = params.ttl;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SetAccountTTL> {
        // no flags

        let ttl = await TLObject.read(b);
        return new Raw.account.SetAccountTTL({ ttl: ttl });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.ttl !== undefined) {
          b.write(this.ttl.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendChangePhoneCode extends TLObject {
      __response__!: Raw.auth.TypeSentCode;
      phoneNumber!: string;
      settings!: Raw.TypeCodeSettings;

      constructor(params: { phoneNumber: string; settings: Raw.TypeCodeSettings }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SendChangePhoneCode';
        this.constructorId = 0x82574ae5;
        this.subclassOfId = 0x6ce87081;
        this._slots = ['phoneNumber', 'settings'];
        this.phoneNumber = params.phoneNumber;
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SendChangePhoneCode> {
        // no flags

        let phoneNumber = await Primitive.String.read(b);
        let settings = await TLObject.read(b);
        return new Raw.account.SendChangePhoneCode({
          phoneNumber: phoneNumber,
          settings: settings,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phoneNumber !== undefined) {
          b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
        }
        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChangePhone extends TLObject {
      __response__!: Raw.TypeUser;
      phoneNumber!: string;
      phoneCodeHash!: string;
      phoneCode!: string;

      constructor(params: { phoneNumber: string; phoneCodeHash: string; phoneCode: string }) {
        super();
        this.classType = 'functions';
        this.className = 'account.ChangePhone';
        this.constructorId = 0x70c32edb;
        this.subclassOfId = 0x2da17977;
        this._slots = ['phoneNumber', 'phoneCodeHash', 'phoneCode'];
        this.phoneNumber = params.phoneNumber;
        this.phoneCodeHash = params.phoneCodeHash;
        this.phoneCode = params.phoneCode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ChangePhone> {
        // no flags

        let phoneNumber = await Primitive.String.read(b);
        let phoneCodeHash = await Primitive.String.read(b);
        let phoneCode = await Primitive.String.read(b);
        return new Raw.account.ChangePhone({
          phoneNumber: phoneNumber,
          phoneCodeHash: phoneCodeHash,
          phoneCode: phoneCode,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phoneNumber !== undefined) {
          b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
        }
        if (this.phoneCodeHash !== undefined) {
          b.write(Primitive.String.write(this.phoneCodeHash) as unknown as Buffer);
        }
        if (this.phoneCode !== undefined) {
          b.write(Primitive.String.write(this.phoneCode) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdateDeviceLocked extends TLObject {
      __response__!: Bool;
      period!: int;

      constructor(params: { period: int }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UpdateDeviceLocked';
        this.constructorId = 0x38df3532;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['period'];
        this.period = params.period;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.UpdateDeviceLocked> {
        // no flags

        let period = await Primitive.Int.read(b);
        return new Raw.account.UpdateDeviceLocked({ period: period });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.period !== undefined) {
          b.write(Primitive.Int.write(this.period) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAuthorizations extends TLObject {
      __response__!: Raw.account.TypeAuthorizations;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.GetAuthorizations';
        this.constructorId = 0xe320c158;
        this.subclassOfId = 0xbf5e0ff;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetAuthorizations> {
        // no flags

        return new Raw.account.GetAuthorizations();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class ResetAuthorization extends TLObject {
      __response__!: Bool;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.ResetAuthorization';
        this.constructorId = 0xdf77f3bc;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ResetAuthorization> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.account.ResetAuthorization({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPassword extends TLObject {
      __response__!: Raw.account.TypePassword;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.GetPassword';
        this.constructorId = 0x548a30f5;
        this.subclassOfId = 0x53a211a3;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetPassword> {
        // no flags

        return new Raw.account.GetPassword();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetPasswordSettings extends TLObject {
      __response__!: Raw.account.TypePasswordSettings;
      password!: Raw.TypeInputCheckPasswordSRP;

      constructor(params: { password: Raw.TypeInputCheckPasswordSRP }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetPasswordSettings';
        this.constructorId = 0x9cd4eaf9;
        this.subclassOfId = 0xd23fb078;
        this._slots = ['password'];
        this.password = params.password;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetPasswordSettings> {
        // no flags

        let password = await TLObject.read(b);
        return new Raw.account.GetPasswordSettings({ password: password });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.password !== undefined) {
          b.write(this.password.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdatePasswordSettings extends TLObject {
      __response__!: Bool;
      password!: Raw.TypeInputCheckPasswordSRP;
      newSettings!: Raw.account.TypePasswordInputSettings;

      constructor(params: {
        password: Raw.TypeInputCheckPasswordSRP;
        newSettings: Raw.account.TypePasswordInputSettings;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UpdatePasswordSettings';
        this.constructorId = 0xa59b102f;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['password', 'newSettings'];
        this.password = params.password;
        this.newSettings = params.newSettings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.UpdatePasswordSettings> {
        // no flags

        let password = await TLObject.read(b);
        let newSettings = await TLObject.read(b);
        return new Raw.account.UpdatePasswordSettings({
          password: password,
          newSettings: newSettings,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.password !== undefined) {
          b.write(this.password.write() as unknown as Buffer);
        }
        if (this.newSettings !== undefined) {
          b.write(this.newSettings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendConfirmPhoneCode extends TLObject {
      __response__!: Raw.auth.TypeSentCode;
      hash!: string;
      settings!: Raw.TypeCodeSettings;

      constructor(params: { hash: string; settings: Raw.TypeCodeSettings }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SendConfirmPhoneCode';
        this.constructorId = 0x1b3faa88;
        this.subclassOfId = 0x6ce87081;
        this._slots = ['hash', 'settings'];
        this.hash = params.hash;
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.SendConfirmPhoneCode> {
        // no flags

        let hash = await Primitive.String.read(b);
        let settings = await TLObject.read(b);
        return new Raw.account.SendConfirmPhoneCode({ hash: hash, settings: settings });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.String.write(this.hash) as unknown as Buffer);
        }
        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ConfirmPhone extends TLObject {
      __response__!: Bool;
      phoneCodeHash!: string;
      phoneCode!: string;

      constructor(params: { phoneCodeHash: string; phoneCode: string }) {
        super();
        this.classType = 'functions';
        this.className = 'account.ConfirmPhone';
        this.constructorId = 0x5f2178c3;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['phoneCodeHash', 'phoneCode'];
        this.phoneCodeHash = params.phoneCodeHash;
        this.phoneCode = params.phoneCode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ConfirmPhone> {
        // no flags

        let phoneCodeHash = await Primitive.String.read(b);
        let phoneCode = await Primitive.String.read(b);
        return new Raw.account.ConfirmPhone({ phoneCodeHash: phoneCodeHash, phoneCode: phoneCode });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phoneCodeHash !== undefined) {
          b.write(Primitive.String.write(this.phoneCodeHash) as unknown as Buffer);
        }
        if (this.phoneCode !== undefined) {
          b.write(Primitive.String.write(this.phoneCode) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetTmpPassword extends TLObject {
      __response__!: Raw.account.TypeTmpPassword;
      password!: Raw.TypeInputCheckPasswordSRP;
      period!: int;

      constructor(params: { password: Raw.TypeInputCheckPasswordSRP; period: int }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetTmpPassword';
        this.constructorId = 0x449e0b51;
        this.subclassOfId = 0xb064992d;
        this._slots = ['password', 'period'];
        this.password = params.password;
        this.period = params.period;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetTmpPassword> {
        // no flags

        let password = await TLObject.read(b);
        let period = await Primitive.Int.read(b);
        return new Raw.account.GetTmpPassword({ password: password, period: period });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.password !== undefined) {
          b.write(this.password.write() as unknown as Buffer);
        }
        if (this.period !== undefined) {
          b.write(Primitive.Int.write(this.period) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetWebAuthorizations extends TLObject {
      __response__!: Raw.account.TypeWebAuthorizations;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.GetWebAuthorizations';
        this.constructorId = 0x182e6d6f;
        this.subclassOfId = 0x9a365b32;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.GetWebAuthorizations> {
        // no flags

        return new Raw.account.GetWebAuthorizations();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class ResetWebAuthorization extends TLObject {
      __response__!: Bool;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.ResetWebAuthorization';
        this.constructorId = 0x2d01b9ef;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.ResetWebAuthorization> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.account.ResetWebAuthorization({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResetWebAuthorizations extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.ResetWebAuthorizations';
        this.constructorId = 0x682d2594;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.ResetWebAuthorizations> {
        // no flags

        return new Raw.account.ResetWebAuthorizations();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetAllSecureValues extends TLObject {
      __response__!: Vector<Raw.TypeSecureValue>;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.GetAllSecureValues';
        this.constructorId = 0xb288bc7d;
        this.subclassOfId = 0xe82e4121;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetAllSecureValues> {
        // no flags

        return new Raw.account.GetAllSecureValues();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetSecureValue extends TLObject {
      __response__!: Vector<Raw.TypeSecureValue>;
      types!: Vector<Raw.TypeSecureValueType>;

      constructor(params: { types: Vector<Raw.TypeSecureValueType> }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetSecureValue';
        this.constructorId = 0x73665bc2;
        this.subclassOfId = 0xe82e4121;
        this._slots = ['types'];
        this.types = params.types;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetSecureValue> {
        // no flags

        let types = await TLObject.read(b);
        return new Raw.account.GetSecureValue({ types: types });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.types) {
          b.write(Primitive.Vector.write(this.types) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveSecureValue extends TLObject {
      __response__!: Raw.TypeSecureValue;
      value!: Raw.TypeInputSecureValue;
      secureSecretId!: long;

      constructor(params: { value: Raw.TypeInputSecureValue; secureSecretId: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SaveSecureValue';
        this.constructorId = 0x899fe31d;
        this.subclassOfId = 0x51138ae;
        this._slots = ['value', 'secureSecretId'];
        this.value = params.value;
        this.secureSecretId = params.secureSecretId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SaveSecureValue> {
        // no flags

        let value = await TLObject.read(b);
        let secureSecretId = await Primitive.Long.read(b);
        return new Raw.account.SaveSecureValue({ value: value, secureSecretId: secureSecretId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.value !== undefined) {
          b.write(this.value.write() as unknown as Buffer);
        }
        if (this.secureSecretId !== undefined) {
          b.write(Primitive.Long.write(this.secureSecretId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteSecureValue extends TLObject {
      __response__!: Bool;
      types!: Vector<Raw.TypeSecureValueType>;

      constructor(params: { types: Vector<Raw.TypeSecureValueType> }) {
        super();
        this.classType = 'functions';
        this.className = 'account.DeleteSecureValue';
        this.constructorId = 0xb880bc4b;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['types'];
        this.types = params.types;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.DeleteSecureValue> {
        // no flags

        let types = await TLObject.read(b);
        return new Raw.account.DeleteSecureValue({ types: types });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.types) {
          b.write(Primitive.Vector.write(this.types) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAuthorizationForm extends TLObject {
      __response__!: Raw.account.TypeAuthorizationForm;
      botId!: long;
      scope!: string;
      publicKey!: string;

      constructor(params: { botId: long; scope: string; publicKey: string }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetAuthorizationForm';
        this.constructorId = 0xa929597a;
        this.subclassOfId = 0x78049a94;
        this._slots = ['botId', 'scope', 'publicKey'];
        this.botId = params.botId;
        this.scope = params.scope;
        this.publicKey = params.publicKey;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.GetAuthorizationForm> {
        // no flags

        let botId = await Primitive.Long.read(b);
        let scope = await Primitive.String.read(b);
        let publicKey = await Primitive.String.read(b);
        return new Raw.account.GetAuthorizationForm({
          botId: botId,
          scope: scope,
          publicKey: publicKey,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.botId !== undefined) {
          b.write(Primitive.Long.write(this.botId) as unknown as Buffer);
        }
        if (this.scope !== undefined) {
          b.write(Primitive.String.write(this.scope) as unknown as Buffer);
        }
        if (this.publicKey !== undefined) {
          b.write(Primitive.String.write(this.publicKey) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AcceptAuthorization extends TLObject {
      __response__!: Bool;
      botId!: long;
      scope!: string;
      publicKey!: string;
      valueHashes!: Vector<Raw.TypeSecureValueHash>;
      credentials!: Raw.TypeSecureCredentialsEncrypted;

      constructor(params: {
        botId: long;
        scope: string;
        publicKey: string;
        valueHashes: Vector<Raw.TypeSecureValueHash>;
        credentials: Raw.TypeSecureCredentialsEncrypted;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.AcceptAuthorization';
        this.constructorId = 0xf3ed4c73;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['botId', 'scope', 'publicKey', 'valueHashes', 'credentials'];
        this.botId = params.botId;
        this.scope = params.scope;
        this.publicKey = params.publicKey;
        this.valueHashes = params.valueHashes;
        this.credentials = params.credentials;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.AcceptAuthorization> {
        // no flags

        let botId = await Primitive.Long.read(b);
        let scope = await Primitive.String.read(b);
        let publicKey = await Primitive.String.read(b);
        let valueHashes = await TLObject.read(b);
        let credentials = await TLObject.read(b);
        return new Raw.account.AcceptAuthorization({
          botId: botId,
          scope: scope,
          publicKey: publicKey,
          valueHashes: valueHashes,
          credentials: credentials,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.botId !== undefined) {
          b.write(Primitive.Long.write(this.botId) as unknown as Buffer);
        }
        if (this.scope !== undefined) {
          b.write(Primitive.String.write(this.scope) as unknown as Buffer);
        }
        if (this.publicKey !== undefined) {
          b.write(Primitive.String.write(this.publicKey) as unknown as Buffer);
        }
        if (this.valueHashes) {
          b.write(Primitive.Vector.write(this.valueHashes) as unknown as Buffer);
        }
        if (this.credentials !== undefined) {
          b.write(this.credentials.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendVerifyPhoneCode extends TLObject {
      __response__!: Raw.auth.TypeSentCode;
      phoneNumber!: string;
      settings!: Raw.TypeCodeSettings;

      constructor(params: { phoneNumber: string; settings: Raw.TypeCodeSettings }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SendVerifyPhoneCode';
        this.constructorId = 0xa5a356f9;
        this.subclassOfId = 0x6ce87081;
        this._slots = ['phoneNumber', 'settings'];
        this.phoneNumber = params.phoneNumber;
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SendVerifyPhoneCode> {
        // no flags

        let phoneNumber = await Primitive.String.read(b);
        let settings = await TLObject.read(b);
        return new Raw.account.SendVerifyPhoneCode({
          phoneNumber: phoneNumber,
          settings: settings,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phoneNumber !== undefined) {
          b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
        }
        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class VerifyPhone extends TLObject {
      __response__!: Bool;
      phoneNumber!: string;
      phoneCodeHash!: string;
      phoneCode!: string;

      constructor(params: { phoneNumber: string; phoneCodeHash: string; phoneCode: string }) {
        super();
        this.classType = 'functions';
        this.className = 'account.VerifyPhone';
        this.constructorId = 0x4dd3a7f6;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['phoneNumber', 'phoneCodeHash', 'phoneCode'];
        this.phoneNumber = params.phoneNumber;
        this.phoneCodeHash = params.phoneCodeHash;
        this.phoneCode = params.phoneCode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.VerifyPhone> {
        // no flags

        let phoneNumber = await Primitive.String.read(b);
        let phoneCodeHash = await Primitive.String.read(b);
        let phoneCode = await Primitive.String.read(b);
        return new Raw.account.VerifyPhone({
          phoneNumber: phoneNumber,
          phoneCodeHash: phoneCodeHash,
          phoneCode: phoneCode,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phoneNumber !== undefined) {
          b.write(Primitive.String.write(this.phoneNumber) as unknown as Buffer);
        }
        if (this.phoneCodeHash !== undefined) {
          b.write(Primitive.String.write(this.phoneCodeHash) as unknown as Buffer);
        }
        if (this.phoneCode !== undefined) {
          b.write(Primitive.String.write(this.phoneCode) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendVerifyEmailCode extends TLObject {
      __response__!: Raw.account.TypeSentEmailCode;
      purpose!: Raw.TypeEmailVerifyPurpose;
      email!: string;

      constructor(params: { purpose: Raw.TypeEmailVerifyPurpose; email: string }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SendVerifyEmailCode';
        this.constructorId = 0x98e037bb;
        this.subclassOfId = 0x69f3c06e;
        this._slots = ['purpose', 'email'];
        this.purpose = params.purpose;
        this.email = params.email;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SendVerifyEmailCode> {
        // no flags

        let purpose = await TLObject.read(b);
        let email = await Primitive.String.read(b);
        return new Raw.account.SendVerifyEmailCode({ purpose: purpose, email: email });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.purpose !== undefined) {
          b.write(this.purpose.write() as unknown as Buffer);
        }
        if (this.email !== undefined) {
          b.write(Primitive.String.write(this.email) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class VerifyEmail extends TLObject {
      __response__!: Raw.account.TypeEmailVerified;
      purpose!: Raw.TypeEmailVerifyPurpose;
      verification!: Raw.TypeEmailVerification;

      constructor(params: {
        purpose: Raw.TypeEmailVerifyPurpose;
        verification: Raw.TypeEmailVerification;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.VerifyEmail';
        this.constructorId = 0x32da4cf;
        this.subclassOfId = 0x64833188;
        this._slots = ['purpose', 'verification'];
        this.purpose = params.purpose;
        this.verification = params.verification;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.VerifyEmail> {
        // no flags

        let purpose = await TLObject.read(b);
        let verification = await TLObject.read(b);
        return new Raw.account.VerifyEmail({ purpose: purpose, verification: verification });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.purpose !== undefined) {
          b.write(this.purpose.write() as unknown as Buffer);
        }
        if (this.verification !== undefined) {
          b.write(this.verification.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class InitTakeoutSession extends TLObject {
      __response__!: Raw.account.TypeTakeout;
      contacts?: boolean;
      messageUsers?: boolean;
      messageChats?: boolean;
      messageMegagroups?: boolean;
      messageChannels?: boolean;
      files?: boolean;
      fileMaxSize?: long;

      constructor(params: {
        contacts?: boolean;
        messageUsers?: boolean;
        messageChats?: boolean;
        messageMegagroups?: boolean;
        messageChannels?: boolean;
        files?: boolean;
        fileMaxSize?: long;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.InitTakeoutSession';
        this.constructorId = 0x8ef3eab0;
        this.subclassOfId = 0x843ebe85;
        this._slots = [
          'contacts',
          'messageUsers',
          'messageChats',
          'messageMegagroups',
          'messageChannels',
          'files',
          'fileMaxSize',
        ];
        this.contacts = params.contacts;
        this.messageUsers = params.messageUsers;
        this.messageChats = params.messageChats;
        this.messageMegagroups = params.messageMegagroups;
        this.messageChannels = params.messageChannels;
        this.files = params.files;
        this.fileMaxSize = params.fileMaxSize;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.InitTakeoutSession> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let contacts = flags & (1 << 0) ? true : false;
        let messageUsers = flags & (1 << 1) ? true : false;
        let messageChats = flags & (1 << 2) ? true : false;
        let messageMegagroups = flags & (1 << 3) ? true : false;
        let messageChannels = flags & (1 << 4) ? true : false;
        let files = flags & (1 << 5) ? true : false;
        let fileMaxSize = flags & (1 << 5) ? await Primitive.Long.read(b) : undefined;
        return new Raw.account.InitTakeoutSession({
          contacts: contacts,
          messageUsers: messageUsers,
          messageChats: messageChats,
          messageMegagroups: messageMegagroups,
          messageChannels: messageChannels,
          files: files,
          fileMaxSize: fileMaxSize,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.contacts ? 1 << 0 : 0;
        flags |= this.messageUsers ? 1 << 1 : 0;
        flags |= this.messageChats ? 1 << 2 : 0;
        flags |= this.messageMegagroups ? 1 << 3 : 0;
        flags |= this.messageChannels ? 1 << 4 : 0;
        flags |= this.files ? 1 << 5 : 0;
        flags |= this.fileMaxSize !== undefined ? 1 << 5 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.fileMaxSize !== undefined) {
          b.write(Primitive.Long.write(this.fileMaxSize) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class FinishTakeoutSession extends TLObject {
      __response__!: Bool;
      success?: boolean;

      constructor(params: { success?: boolean }) {
        super();
        this.classType = 'functions';
        this.className = 'account.FinishTakeoutSession';
        this.constructorId = 0x1d2652ee;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['success'];
        this.success = params.success;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.FinishTakeoutSession> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let success = flags & (1 << 0) ? true : false;
        return new Raw.account.FinishTakeoutSession({ success: success });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.success ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        return b.buffer;
      }
    }
    export class ConfirmPasswordEmail extends TLObject {
      __response__!: Bool;
      code!: string;

      constructor(params: { code: string }) {
        super();
        this.classType = 'functions';
        this.className = 'account.ConfirmPasswordEmail';
        this.constructorId = 0x8fdf1920;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['code'];
        this.code = params.code;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.ConfirmPasswordEmail> {
        // no flags

        let code = await Primitive.String.read(b);
        return new Raw.account.ConfirmPasswordEmail({ code: code });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.code !== undefined) {
          b.write(Primitive.String.write(this.code) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResendPasswordEmail extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.ResendPasswordEmail';
        this.constructorId = 0x7a7f2a15;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ResendPasswordEmail> {
        // no flags

        return new Raw.account.ResendPasswordEmail();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class CancelPasswordEmail extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.CancelPasswordEmail';
        this.constructorId = 0xc1cbd5b6;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.CancelPasswordEmail> {
        // no flags

        return new Raw.account.CancelPasswordEmail();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetContactSignUpNotification extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.GetContactSignUpNotification';
        this.constructorId = 0x9f07c728;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.GetContactSignUpNotification> {
        // no flags

        return new Raw.account.GetContactSignUpNotification();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SetContactSignUpNotification extends TLObject {
      __response__!: Bool;
      silent!: Bool;

      constructor(params: { silent: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SetContactSignUpNotification';
        this.constructorId = 0xcff43f61;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['silent'];
        this.silent = params.silent;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.SetContactSignUpNotification> {
        // no flags

        let silent = await Primitive.Bool.read(b);
        return new Raw.account.SetContactSignUpNotification({ silent: silent });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.silent !== undefined) {
          b.write(Primitive.Bool.write(this.silent) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetNotifyExceptions extends TLObject {
      __response__!: Raw.TypeUpdates;
      compareSound?: boolean;
      compareStories?: boolean;
      peer?: Raw.TypeInputNotifyPeer;

      constructor(params: {
        compareSound?: boolean;
        compareStories?: boolean;
        peer?: Raw.TypeInputNotifyPeer;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetNotifyExceptions';
        this.constructorId = 0x53577479;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['compareSound', 'compareStories', 'peer'];
        this.compareSound = params.compareSound;
        this.compareStories = params.compareStories;
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetNotifyExceptions> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let compareSound = flags & (1 << 1) ? true : false;
        let compareStories = flags & (1 << 2) ? true : false;
        let peer = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        return new Raw.account.GetNotifyExceptions({
          compareSound: compareSound,
          compareStories: compareStories,
          peer: peer,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.compareSound ? 1 << 1 : 0;
        flags |= this.compareStories ? 1 << 2 : 0;
        flags |= this.peer !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetWallPaper extends TLObject {
      __response__!: Raw.TypeWallPaper;
      wallpaper!: Raw.TypeInputWallPaper;

      constructor(params: { wallpaper: Raw.TypeInputWallPaper }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetWallPaper';
        this.constructorId = 0xfc8ddbea;
        this.subclassOfId = 0x96a2c98b;
        this._slots = ['wallpaper'];
        this.wallpaper = params.wallpaper;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetWallPaper> {
        // no flags

        let wallpaper = await TLObject.read(b);
        return new Raw.account.GetWallPaper({ wallpaper: wallpaper });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.wallpaper !== undefined) {
          b.write(this.wallpaper.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UploadWallPaper extends TLObject {
      __response__!: Raw.TypeWallPaper;
      forChat?: boolean;
      file!: Raw.TypeInputFile;
      mimeType!: string;
      settings!: Raw.TypeWallPaperSettings;

      constructor(params: {
        forChat?: boolean;
        file: Raw.TypeInputFile;
        mimeType: string;
        settings: Raw.TypeWallPaperSettings;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UploadWallPaper';
        this.constructorId = 0xe39a8f03;
        this.subclassOfId = 0x96a2c98b;
        this._slots = ['forChat', 'file', 'mimeType', 'settings'];
        this.forChat = params.forChat;
        this.file = params.file;
        this.mimeType = params.mimeType;
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.UploadWallPaper> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let forChat = flags & (1 << 0) ? true : false;
        let file = await TLObject.read(b);
        let mimeType = await Primitive.String.read(b);
        let settings = await TLObject.read(b);
        return new Raw.account.UploadWallPaper({
          forChat: forChat,
          file: file,
          mimeType: mimeType,
          settings: settings,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.forChat ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.file !== undefined) {
          b.write(this.file.write() as unknown as Buffer);
        }
        if (this.mimeType !== undefined) {
          b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
        }
        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveWallPaper extends TLObject {
      __response__!: Bool;
      wallpaper!: Raw.TypeInputWallPaper;
      unsave!: Bool;
      settings!: Raw.TypeWallPaperSettings;

      constructor(params: {
        wallpaper: Raw.TypeInputWallPaper;
        unsave: Bool;
        settings: Raw.TypeWallPaperSettings;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SaveWallPaper';
        this.constructorId = 0x6c5a5b37;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['wallpaper', 'unsave', 'settings'];
        this.wallpaper = params.wallpaper;
        this.unsave = params.unsave;
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SaveWallPaper> {
        // no flags

        let wallpaper = await TLObject.read(b);
        let unsave = await Primitive.Bool.read(b);
        let settings = await TLObject.read(b);
        return new Raw.account.SaveWallPaper({
          wallpaper: wallpaper,
          unsave: unsave,
          settings: settings,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.wallpaper !== undefined) {
          b.write(this.wallpaper.write() as unknown as Buffer);
        }
        if (this.unsave !== undefined) {
          b.write(Primitive.Bool.write(this.unsave) as unknown as Buffer);
        }
        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class InstallWallPaper extends TLObject {
      __response__!: Bool;
      wallpaper!: Raw.TypeInputWallPaper;
      settings!: Raw.TypeWallPaperSettings;

      constructor(params: {
        wallpaper: Raw.TypeInputWallPaper;
        settings: Raw.TypeWallPaperSettings;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.InstallWallPaper';
        this.constructorId = 0xfeed5769;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['wallpaper', 'settings'];
        this.wallpaper = params.wallpaper;
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.InstallWallPaper> {
        // no flags

        let wallpaper = await TLObject.read(b);
        let settings = await TLObject.read(b);
        return new Raw.account.InstallWallPaper({ wallpaper: wallpaper, settings: settings });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.wallpaper !== undefined) {
          b.write(this.wallpaper.write() as unknown as Buffer);
        }
        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResetWallPapers extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.ResetWallPapers';
        this.constructorId = 0xbb3b9804;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ResetWallPapers> {
        // no flags

        return new Raw.account.ResetWallPapers();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetAutoDownloadSettings extends TLObject {
      __response__!: Raw.account.TypeAutoDownloadSettings;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.GetAutoDownloadSettings';
        this.constructorId = 0x56da0b3f;
        this.subclassOfId = 0x2fb85921;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.GetAutoDownloadSettings> {
        // no flags

        return new Raw.account.GetAutoDownloadSettings();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SaveAutoDownloadSettings extends TLObject {
      __response__!: Bool;
      low?: boolean;
      high?: boolean;
      settings!: Raw.TypeAutoDownloadSettings;

      constructor(params: {
        low?: boolean;
        high?: boolean;
        settings: Raw.TypeAutoDownloadSettings;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SaveAutoDownloadSettings';
        this.constructorId = 0x76f36233;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['low', 'high', 'settings'];
        this.low = params.low;
        this.high = params.high;
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.SaveAutoDownloadSettings> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let low = flags & (1 << 0) ? true : false;
        let high = flags & (1 << 1) ? true : false;
        let settings = await TLObject.read(b);
        return new Raw.account.SaveAutoDownloadSettings({
          low: low,
          high: high,
          settings: settings,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.low ? 1 << 0 : 0;
        flags |= this.high ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UploadTheme extends TLObject {
      __response__!: Raw.TypeDocument;
      file!: Raw.TypeInputFile;
      thumb?: Raw.TypeInputFile;
      fileName!: string;
      mimeType!: string;

      constructor(params: {
        file: Raw.TypeInputFile;
        thumb?: Raw.TypeInputFile;
        fileName: string;
        mimeType: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UploadTheme';
        this.constructorId = 0x1c3db333;
        this.subclassOfId = 0x211fe820;
        this._slots = ['file', 'thumb', 'fileName', 'mimeType'];
        this.file = params.file;
        this.thumb = params.thumb;
        this.fileName = params.fileName;
        this.mimeType = params.mimeType;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.UploadTheme> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let file = await TLObject.read(b);
        let thumb = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let fileName = await Primitive.String.read(b);
        let mimeType = await Primitive.String.read(b);
        return new Raw.account.UploadTheme({
          file: file,
          thumb: thumb,
          fileName: fileName,
          mimeType: mimeType,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.thumb !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.file !== undefined) {
          b.write(this.file.write() as unknown as Buffer);
        }
        if (this.thumb !== undefined) {
          b.write(this.thumb.write() as unknown as Buffer);
        }
        if (this.fileName !== undefined) {
          b.write(Primitive.String.write(this.fileName) as unknown as Buffer);
        }
        if (this.mimeType !== undefined) {
          b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CreateTheme extends TLObject {
      __response__!: Raw.TypeTheme;
      slug!: string;
      title!: string;
      document?: Raw.TypeInputDocument;
      settings?: Vector<Raw.TypeInputThemeSettings>;

      constructor(params: {
        slug: string;
        title: string;
        document?: Raw.TypeInputDocument;
        settings?: Vector<Raw.TypeInputThemeSettings>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.CreateTheme';
        this.constructorId = 0x652e4400;
        this.subclassOfId = 0x56b4c80c;
        this._slots = ['slug', 'title', 'document', 'settings'];
        this.slug = params.slug;
        this.title = params.title;
        this.document = params.document;
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.CreateTheme> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let slug = await Primitive.String.read(b);
        let title = await Primitive.String.read(b);
        let document = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let settings = flags & (1 << 3) ? await TLObject.read(b) : [];
        return new Raw.account.CreateTheme({
          slug: slug,
          title: title,
          document: document,
          settings: settings,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.document !== undefined ? 1 << 2 : 0;
        flags |= this.settings ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.slug !== undefined) {
          b.write(Primitive.String.write(this.slug) as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.document !== undefined) {
          b.write(this.document.write() as unknown as Buffer);
        }
        if (this.settings) {
          b.write(Primitive.Vector.write(this.settings) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdateTheme extends TLObject {
      __response__!: Raw.TypeTheme;
      format!: string;
      theme!: Raw.TypeInputTheme;
      slug?: string;
      title?: string;
      document?: Raw.TypeInputDocument;
      settings?: Vector<Raw.TypeInputThemeSettings>;

      constructor(params: {
        format: string;
        theme: Raw.TypeInputTheme;
        slug?: string;
        title?: string;
        document?: Raw.TypeInputDocument;
        settings?: Vector<Raw.TypeInputThemeSettings>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UpdateTheme';
        this.constructorId = 0x2bf40ccc;
        this.subclassOfId = 0x56b4c80c;
        this._slots = ['format', 'theme', 'slug', 'title', 'document', 'settings'];
        this.format = params.format;
        this.theme = params.theme;
        this.slug = params.slug;
        this.title = params.title;
        this.document = params.document;
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.UpdateTheme> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let format = await Primitive.String.read(b);
        let theme = await TLObject.read(b);
        let slug = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let title = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let document = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let settings = flags & (1 << 3) ? await TLObject.read(b) : [];
        return new Raw.account.UpdateTheme({
          format: format,
          theme: theme,
          slug: slug,
          title: title,
          document: document,
          settings: settings,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.slug !== undefined ? 1 << 0 : 0;
        flags |= this.title !== undefined ? 1 << 1 : 0;
        flags |= this.document !== undefined ? 1 << 2 : 0;
        flags |= this.settings ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.format !== undefined) {
          b.write(Primitive.String.write(this.format) as unknown as Buffer);
        }
        if (this.theme !== undefined) {
          b.write(this.theme.write() as unknown as Buffer);
        }
        if (this.slug !== undefined) {
          b.write(Primitive.String.write(this.slug) as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.document !== undefined) {
          b.write(this.document.write() as unknown as Buffer);
        }
        if (this.settings) {
          b.write(Primitive.Vector.write(this.settings) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveTheme extends TLObject {
      __response__!: Bool;
      theme!: Raw.TypeInputTheme;
      unsave!: Bool;

      constructor(params: { theme: Raw.TypeInputTheme; unsave: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SaveTheme';
        this.constructorId = 0xf257106c;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['theme', 'unsave'];
        this.theme = params.theme;
        this.unsave = params.unsave;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SaveTheme> {
        // no flags

        let theme = await TLObject.read(b);
        let unsave = await Primitive.Bool.read(b);
        return new Raw.account.SaveTheme({ theme: theme, unsave: unsave });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.theme !== undefined) {
          b.write(this.theme.write() as unknown as Buffer);
        }
        if (this.unsave !== undefined) {
          b.write(Primitive.Bool.write(this.unsave) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class InstallTheme extends TLObject {
      __response__!: Bool;
      dark?: boolean;
      theme?: Raw.TypeInputTheme;
      format?: string;
      baseTheme?: Raw.TypeBaseTheme;

      constructor(params: {
        dark?: boolean;
        theme?: Raw.TypeInputTheme;
        format?: string;
        baseTheme?: Raw.TypeBaseTheme;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.InstallTheme';
        this.constructorId = 0xc727bb3b;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['dark', 'theme', 'format', 'baseTheme'];
        this.dark = params.dark;
        this.theme = params.theme;
        this.format = params.format;
        this.baseTheme = params.baseTheme;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.InstallTheme> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let dark = flags & (1 << 0) ? true : false;
        let theme = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        let format = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        let baseTheme = flags & (1 << 3) ? await TLObject.read(b) : undefined;
        return new Raw.account.InstallTheme({
          dark: dark,
          theme: theme,
          format: format,
          baseTheme: baseTheme,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.dark ? 1 << 0 : 0;
        flags |= this.theme !== undefined ? 1 << 1 : 0;
        flags |= this.format !== undefined ? 1 << 2 : 0;
        flags |= this.baseTheme !== undefined ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.theme !== undefined) {
          b.write(this.theme.write() as unknown as Buffer);
        }
        if (this.format !== undefined) {
          b.write(Primitive.String.write(this.format) as unknown as Buffer);
        }
        if (this.baseTheme !== undefined) {
          b.write(this.baseTheme.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetTheme extends TLObject {
      __response__!: Raw.TypeTheme;
      format!: string;
      theme!: Raw.TypeInputTheme;

      constructor(params: { format: string; theme: Raw.TypeInputTheme }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetTheme';
        this.constructorId = 0x3a5869ec;
        this.subclassOfId = 0x56b4c80c;
        this._slots = ['format', 'theme'];
        this.format = params.format;
        this.theme = params.theme;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetTheme> {
        // no flags

        let format = await Primitive.String.read(b);
        let theme = await TLObject.read(b);
        return new Raw.account.GetTheme({ format: format, theme: theme });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.format !== undefined) {
          b.write(Primitive.String.write(this.format) as unknown as Buffer);
        }
        if (this.theme !== undefined) {
          b.write(this.theme.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetThemes extends TLObject {
      __response__!: Raw.account.TypeThemes;
      format!: string;
      hash!: long;

      constructor(params: { format: string; hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetThemes';
        this.constructorId = 0x7206e458;
        this.subclassOfId = 0x7fc52204;
        this._slots = ['format', 'hash'];
        this.format = params.format;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetThemes> {
        // no flags

        let format = await Primitive.String.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.account.GetThemes({ format: format, hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.format !== undefined) {
          b.write(Primitive.String.write(this.format) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetContentSettings extends TLObject {
      __response__!: Bool;
      sensitiveEnabled?: boolean;

      constructor(params: { sensitiveEnabled?: boolean }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SetContentSettings';
        this.constructorId = 0xb574b16b;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['sensitiveEnabled'];
        this.sensitiveEnabled = params.sensitiveEnabled;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SetContentSettings> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let sensitiveEnabled = flags & (1 << 0) ? true : false;
        return new Raw.account.SetContentSettings({ sensitiveEnabled: sensitiveEnabled });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.sensitiveEnabled ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        return b.buffer;
      }
    }
    export class GetContentSettings extends TLObject {
      __response__!: Raw.account.TypeContentSettings;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.GetContentSettings';
        this.constructorId = 0x8b9b4dae;
        this.subclassOfId = 0xae3ff891;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetContentSettings> {
        // no flags

        return new Raw.account.GetContentSettings();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetMultiWallPapers extends TLObject {
      __response__!: Vector<Raw.TypeWallPaper>;
      wallpapers!: Vector<Raw.TypeInputWallPaper>;

      constructor(params: { wallpapers: Vector<Raw.TypeInputWallPaper> }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetMultiWallPapers';
        this.constructorId = 0x65ad71dc;
        this.subclassOfId = 0x8ec35283;
        this._slots = ['wallpapers'];
        this.wallpapers = params.wallpapers;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetMultiWallPapers> {
        // no flags

        let wallpapers = await TLObject.read(b);
        return new Raw.account.GetMultiWallPapers({ wallpapers: wallpapers });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.wallpapers) {
          b.write(Primitive.Vector.write(this.wallpapers) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetGlobalPrivacySettings extends TLObject {
      __response__!: Raw.TypeGlobalPrivacySettings;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.GetGlobalPrivacySettings';
        this.constructorId = 0xeb2b4cf6;
        this.subclassOfId = 0xc90e5770;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.GetGlobalPrivacySettings> {
        // no flags

        return new Raw.account.GetGlobalPrivacySettings();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SetGlobalPrivacySettings extends TLObject {
      __response__!: Raw.TypeGlobalPrivacySettings;
      settings!: Raw.TypeGlobalPrivacySettings;

      constructor(params: { settings: Raw.TypeGlobalPrivacySettings }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SetGlobalPrivacySettings';
        this.constructorId = 0x1edaaac2;
        this.subclassOfId = 0xc90e5770;
        this._slots = ['settings'];
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.SetGlobalPrivacySettings> {
        // no flags

        let settings = await TLObject.read(b);
        return new Raw.account.SetGlobalPrivacySettings({ settings: settings });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReportProfilePhoto extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      photoId!: Raw.TypeInputPhoto;
      reason!: Raw.TypeReportReason;
      message!: string;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        photoId: Raw.TypeInputPhoto;
        reason: Raw.TypeReportReason;
        message: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.ReportProfilePhoto';
        this.constructorId = 0xfa8cc6f5;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'photoId', 'reason', 'message'];
        this.peer = params.peer;
        this.photoId = params.photoId;
        this.reason = params.reason;
        this.message = params.message;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ReportProfilePhoto> {
        // no flags

        let peer = await TLObject.read(b);
        let photoId = await TLObject.read(b);
        let reason = await TLObject.read(b);
        let message = await Primitive.String.read(b);
        return new Raw.account.ReportProfilePhoto({
          peer: peer,
          photoId: photoId,
          reason: reason,
          message: message,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.photoId !== undefined) {
          b.write(this.photoId.write() as unknown as Buffer);
        }
        if (this.reason !== undefined) {
          b.write(this.reason.write() as unknown as Buffer);
        }
        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResetPassword extends TLObject {
      __response__!: Raw.account.TypeResetPasswordResult;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.ResetPassword';
        this.constructorId = 0x9308ce1b;
        this.subclassOfId = 0x49507416;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ResetPassword> {
        // no flags

        return new Raw.account.ResetPassword();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class DeclinePasswordReset extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.DeclinePasswordReset';
        this.constructorId = 0x4c9409f6;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.DeclinePasswordReset> {
        // no flags

        return new Raw.account.DeclinePasswordReset();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetChatThemes extends TLObject {
      __response__!: Raw.account.TypeThemes;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetChatThemes';
        this.constructorId = 0xd638de89;
        this.subclassOfId = 0x7fc52204;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetChatThemes> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.account.GetChatThemes({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetAuthorizationTTL extends TLObject {
      __response__!: Bool;
      authorizationTtlDays!: int;

      constructor(params: { authorizationTtlDays: int }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SetAuthorizationTTL';
        this.constructorId = 0xbf899aa0;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['authorizationTtlDays'];
        this.authorizationTtlDays = params.authorizationTtlDays;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SetAuthorizationTTL> {
        // no flags

        let authorizationTtlDays = await Primitive.Int.read(b);
        return new Raw.account.SetAuthorizationTTL({ authorizationTtlDays: authorizationTtlDays });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.authorizationTtlDays !== undefined) {
          b.write(Primitive.Int.write(this.authorizationTtlDays) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChangeAuthorizationSettings extends TLObject {
      __response__!: Bool;
      confirmed?: boolean;
      hash!: long;
      encryptedRequestsDisabled?: Bool;
      callRequestsDisabled?: Bool;

      constructor(params: {
        confirmed?: boolean;
        hash: long;
        encryptedRequestsDisabled?: Bool;
        callRequestsDisabled?: Bool;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.ChangeAuthorizationSettings';
        this.constructorId = 0x40f48462;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['confirmed', 'hash', 'encryptedRequestsDisabled', 'callRequestsDisabled'];
        this.confirmed = params.confirmed;
        this.hash = params.hash;
        this.encryptedRequestsDisabled = params.encryptedRequestsDisabled;
        this.callRequestsDisabled = params.callRequestsDisabled;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.ChangeAuthorizationSettings> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let confirmed = flags & (1 << 3) ? true : false;
        let hash = await Primitive.Long.read(b);
        let encryptedRequestsDisabled = flags & (1 << 0) ? await Primitive.Bool.read(b) : undefined;
        let callRequestsDisabled = flags & (1 << 1) ? await Primitive.Bool.read(b) : undefined;
        return new Raw.account.ChangeAuthorizationSettings({
          confirmed: confirmed,
          hash: hash,
          encryptedRequestsDisabled: encryptedRequestsDisabled,
          callRequestsDisabled: callRequestsDisabled,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.confirmed ? 1 << 3 : 0;
        flags |= this.encryptedRequestsDisabled !== undefined ? 1 << 0 : 0;
        flags |= this.callRequestsDisabled !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        if (this.encryptedRequestsDisabled !== undefined) {
          b.write(Primitive.Bool.write(this.encryptedRequestsDisabled) as unknown as Buffer);
        }
        if (this.callRequestsDisabled !== undefined) {
          b.write(Primitive.Bool.write(this.callRequestsDisabled) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetSavedRingtones extends TLObject {
      __response__!: Raw.account.TypeSavedRingtones;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetSavedRingtones';
        this.constructorId = 0xe1902288;
        this.subclassOfId = 0x27bcc95e;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetSavedRingtones> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.account.GetSavedRingtones({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveRingtone extends TLObject {
      __response__!: Raw.account.TypeSavedRingtone;
      id!: Raw.TypeInputDocument;
      unsave!: Bool;

      constructor(params: { id: Raw.TypeInputDocument; unsave: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SaveRingtone';
        this.constructorId = 0x3dea5b03;
        this.subclassOfId = 0xb1e28424;
        this._slots = ['id', 'unsave'];
        this.id = params.id;
        this.unsave = params.unsave;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.SaveRingtone> {
        // no flags

        let id = await TLObject.read(b);
        let unsave = await Primitive.Bool.read(b);
        return new Raw.account.SaveRingtone({ id: id, unsave: unsave });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        if (this.unsave !== undefined) {
          b.write(Primitive.Bool.write(this.unsave) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UploadRingtone extends TLObject {
      __response__!: Raw.TypeDocument;
      file!: Raw.TypeInputFile;
      fileName!: string;
      mimeType!: string;

      constructor(params: { file: Raw.TypeInputFile; fileName: string; mimeType: string }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UploadRingtone';
        this.constructorId = 0x831a83a2;
        this.subclassOfId = 0x211fe820;
        this._slots = ['file', 'fileName', 'mimeType'];
        this.file = params.file;
        this.fileName = params.fileName;
        this.mimeType = params.mimeType;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.UploadRingtone> {
        // no flags

        let file = await TLObject.read(b);
        let fileName = await Primitive.String.read(b);
        let mimeType = await Primitive.String.read(b);
        return new Raw.account.UploadRingtone({
          file: file,
          fileName: fileName,
          mimeType: mimeType,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.file !== undefined) {
          b.write(this.file.write() as unknown as Buffer);
        }
        if (this.fileName !== undefined) {
          b.write(Primitive.String.write(this.fileName) as unknown as Buffer);
        }
        if (this.mimeType !== undefined) {
          b.write(Primitive.String.write(this.mimeType) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdateEmojiStatus extends TLObject {
      __response__!: Bool;
      emojiStatus!: Raw.TypeEmojiStatus;

      constructor(params: { emojiStatus: Raw.TypeEmojiStatus }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UpdateEmojiStatus';
        this.constructorId = 0xfbd3de6b;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['emojiStatus'];
        this.emojiStatus = params.emojiStatus;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.UpdateEmojiStatus> {
        // no flags

        let emojiStatus = await TLObject.read(b);
        return new Raw.account.UpdateEmojiStatus({ emojiStatus: emojiStatus });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.emojiStatus !== undefined) {
          b.write(this.emojiStatus.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDefaultEmojiStatuses extends TLObject {
      __response__!: Raw.account.TypeEmojiStatuses;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetDefaultEmojiStatuses';
        this.constructorId = 0xd6753386;
        this.subclassOfId = 0xd3e005ca;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.GetDefaultEmojiStatuses> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.account.GetDefaultEmojiStatuses({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetRecentEmojiStatuses extends TLObject {
      __response__!: Raw.account.TypeEmojiStatuses;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetRecentEmojiStatuses';
        this.constructorId = 0xf578105;
        this.subclassOfId = 0xd3e005ca;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.GetRecentEmojiStatuses> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.account.GetRecentEmojiStatuses({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ClearRecentEmojiStatuses extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.ClearRecentEmojiStatuses';
        this.constructorId = 0x18201aae;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.ClearRecentEmojiStatuses> {
        // no flags

        return new Raw.account.ClearRecentEmojiStatuses();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class ReorderUsernames extends TLObject {
      __response__!: Bool;
      order!: Vector<string>;

      constructor(params: { order: Vector<string> }) {
        super();
        this.classType = 'functions';
        this.className = 'account.ReorderUsernames';
        this.constructorId = 0xef500eab;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['order'];
        this.order = params.order;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ReorderUsernames> {
        // no flags

        let order = await TLObject.read(b, Primitive.String);
        return new Raw.account.ReorderUsernames({ order: order });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.order) {
          b.write(Primitive.Vector.write(this.order, Primitive.String) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleUsername extends TLObject {
      __response__!: Bool;
      username!: string;
      active!: Bool;

      constructor(params: { username: string; active: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'account.ToggleUsername';
        this.constructorId = 0x58d6b376;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['username', 'active'];
        this.username = params.username;
        this.active = params.active;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.ToggleUsername> {
        // no flags

        let username = await Primitive.String.read(b);
        let active = await Primitive.Bool.read(b);
        return new Raw.account.ToggleUsername({ username: username, active: active });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.username !== undefined) {
          b.write(Primitive.String.write(this.username) as unknown as Buffer);
        }
        if (this.active !== undefined) {
          b.write(Primitive.Bool.write(this.active) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDefaultProfilePhotoEmojis extends TLObject {
      __response__!: Raw.TypeEmojiList;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetDefaultProfilePhotoEmojis';
        this.constructorId = 0xe2750328;
        this.subclassOfId = 0xbcef6aba;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.GetDefaultProfilePhotoEmojis> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.account.GetDefaultProfilePhotoEmojis({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDefaultGroupPhotoEmojis extends TLObject {
      __response__!: Raw.TypeEmojiList;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetDefaultGroupPhotoEmojis';
        this.constructorId = 0x915860ae;
        this.subclassOfId = 0xbcef6aba;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.GetDefaultGroupPhotoEmojis> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.account.GetDefaultGroupPhotoEmojis({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAutoSaveSettings extends TLObject {
      __response__!: Raw.account.TypeAutoSaveSettings;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.GetAutoSaveSettings';
        this.constructorId = 0xadcbbcda;
        this.subclassOfId = 0x48cf2f02;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.GetAutoSaveSettings> {
        // no flags

        return new Raw.account.GetAutoSaveSettings();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SaveAutoSaveSettings extends TLObject {
      __response__!: Bool;
      users?: boolean;
      chats?: boolean;
      broadcasts?: boolean;
      peer?: Raw.TypeInputPeer;
      settings!: Raw.TypeAutoSaveSettings;

      constructor(params: {
        users?: boolean;
        chats?: boolean;
        broadcasts?: boolean;
        peer?: Raw.TypeInputPeer;
        settings: Raw.TypeAutoSaveSettings;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'account.SaveAutoSaveSettings';
        this.constructorId = 0xd69b8361;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['users', 'chats', 'broadcasts', 'peer', 'settings'];
        this.users = params.users;
        this.chats = params.chats;
        this.broadcasts = params.broadcasts;
        this.peer = params.peer;
        this.settings = params.settings;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.SaveAutoSaveSettings> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let users = flags & (1 << 0) ? true : false;
        let chats = flags & (1 << 1) ? true : false;
        let broadcasts = flags & (1 << 2) ? true : false;
        let peer = flags & (1 << 3) ? await TLObject.read(b) : undefined;
        let settings = await TLObject.read(b);
        return new Raw.account.SaveAutoSaveSettings({
          users: users,
          chats: chats,
          broadcasts: broadcasts,
          peer: peer,
          settings: settings,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.users ? 1 << 0 : 0;
        flags |= this.chats ? 1 << 1 : 0;
        flags |= this.broadcasts ? 1 << 2 : 0;
        flags |= this.peer !== undefined ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.settings !== undefined) {
          b.write(this.settings.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteAutoSaveExceptions extends TLObject {
      __response__!: Bool;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'account.DeleteAutoSaveExceptions';
        this.constructorId = 0x53bc0020;
        this.subclassOfId = 0xf5b399ac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.DeleteAutoSaveExceptions> {
        // no flags

        return new Raw.account.DeleteAutoSaveExceptions();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class InvalidateSignInCodes extends TLObject {
      __response__!: Bool;
      codes!: Vector<string>;

      constructor(params: { codes: Vector<string> }) {
        super();
        this.classType = 'functions';
        this.className = 'account.InvalidateSignInCodes';
        this.constructorId = 0xca8ae8ba;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['codes'];
        this.codes = params.codes;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.InvalidateSignInCodes> {
        // no flags

        let codes = await TLObject.read(b, Primitive.String);
        return new Raw.account.InvalidateSignInCodes({ codes: codes });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.codes) {
          b.write(Primitive.Vector.write(this.codes, Primitive.String) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdateColor extends TLObject {
      __response__!: Bool;
      color!: int;
      backgroundEmojiId?: long;

      constructor(params: { color: int; backgroundEmojiId?: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.UpdateColor';
        this.constructorId = 0xa001cc43;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['color', 'backgroundEmojiId'];
        this.color = params.color;
        this.backgroundEmojiId = params.backgroundEmojiId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.account.UpdateColor> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let color = await Primitive.Int.read(b);
        let backgroundEmojiId = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
        return new Raw.account.UpdateColor({ color: color, backgroundEmojiId: backgroundEmojiId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.backgroundEmojiId !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.color !== undefined) {
          b.write(Primitive.Int.write(this.color) as unknown as Buffer);
        }
        if (this.backgroundEmojiId !== undefined) {
          b.write(Primitive.Long.write(this.backgroundEmojiId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDefaultBackgroundEmojis extends TLObject {
      __response__!: Raw.TypeEmojiList;
      hash!: long;

      constructor(params: { hash: long }) {
        super();
        this.classType = 'functions';
        this.className = 'account.GetDefaultBackgroundEmojis';
        this.constructorId = 0xa60ab9ce;
        this.subclassOfId = 0xbcef6aba;
        this._slots = ['hash'];
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.account.GetDefaultBackgroundEmojis> {
        // no flags

        let hash = await Primitive.Long.read(b);
        return new Raw.account.GetDefaultBackgroundEmojis({ hash: hash });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace channels {
    export type TypeSendAsPeers = Raw.channels.SendAsPeers;
    export type TypeAdminLogResults = Raw.channels.AdminLogResults;
    export type TypeChannelParticipant = Raw.channels.ChannelParticipant;
    export type TypeChannelParticipants =
      | Raw.channels.ChannelParticipants
      | Raw.channels.ChannelParticipantsNotModified;
    export class ChannelParticipants extends TLObject {
      count!: int;
      participants!: Vector<Raw.TypeChannelParticipant>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        count: int;
        participants: Vector<Raw.TypeChannelParticipant>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'channels.ChannelParticipants';
        this.constructorId = 0x9ab0feaf;
        this.subclassOfId = 0xe60a6e64;
        this._slots = ['count', 'participants', 'chats', 'users'];
        this.count = params.count;
        this.participants = params.participants;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.ChannelParticipants> {
        // no flags

        let count = await Primitive.Int.read(b);
        let participants = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.channels.ChannelParticipants({
          count: count,
          participants: participants,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.participants) {
          b.write(Primitive.Vector.write(this.participants) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChannelParticipantsNotModified extends TLObject {
      constructor() {
        super();
        this.classType = 'types';
        this.className = 'channels.ChannelParticipantsNotModified';
        this.constructorId = 0xf0173fe9;
        this.subclassOfId = 0xe60a6e64;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.ChannelParticipantsNotModified> {
        // no flags

        return new Raw.channels.ChannelParticipantsNotModified();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class ChannelParticipant extends TLObject {
      participant!: Raw.TypeChannelParticipant;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        participant: Raw.TypeChannelParticipant;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'channels.ChannelParticipant';
        this.constructorId = 0xdfb80317;
        this.subclassOfId = 0x6658151a;
        this._slots = ['participant', 'chats', 'users'];
        this.participant = params.participant;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ChannelParticipant> {
        // no flags

        let participant = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.channels.ChannelParticipant({
          participant: participant,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.participant !== undefined) {
          b.write(this.participant.write() as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AdminLogResults extends TLObject {
      events!: Vector<Raw.TypeChannelAdminLogEvent>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        events: Vector<Raw.TypeChannelAdminLogEvent>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'channels.AdminLogResults';
        this.constructorId = 0xed8af74d;
        this.subclassOfId = 0x51f076bc;
        this._slots = ['events', 'chats', 'users'];
        this.events = params.events;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.AdminLogResults> {
        // no flags

        let events = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.channels.AdminLogResults({ events: events, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.events) {
          b.write(Primitive.Vector.write(this.events) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendAsPeers extends TLObject {
      peers!: Vector<Raw.TypeSendAsPeer>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        peers: Vector<Raw.TypeSendAsPeer>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'channels.SendAsPeers';
        this.constructorId = 0xf496b0c6;
        this.subclassOfId = 0x38cb8d21;
        this._slots = ['peers', 'chats', 'users'];
        this.peers = params.peers;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.SendAsPeers> {
        // no flags

        let peers = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.channels.SendAsPeers({ peers: peers, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peers) {
          b.write(Primitive.Vector.write(this.peers) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReadHistory extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;
      maxId!: int;

      constructor(params: { channel: Raw.TypeInputChannel; maxId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ReadHistory';
        this.constructorId = 0xcc104937;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel', 'maxId'];
        this.channel = params.channel;
        this.maxId = params.maxId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ReadHistory> {
        // no flags

        let channel = await TLObject.read(b);
        let maxId = await Primitive.Int.read(b);
        return new Raw.channels.ReadHistory({ channel: channel, maxId: maxId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteMessages extends TLObject {
      __response__!: Raw.messages.TypeAffectedMessages;
      channel!: Raw.TypeInputChannel;
      id!: Vector<int>;

      constructor(params: { channel: Raw.TypeInputChannel; id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.DeleteMessages';
        this.constructorId = 0x84c1fd4e;
        this.subclassOfId = 0xced3c06e;
        this._slots = ['channel', 'id'];
        this.channel = params.channel;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.DeleteMessages> {
        // no flags

        let channel = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.channels.DeleteMessages({ channel: channel, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReportSpam extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;
      participant!: Raw.TypeInputPeer;
      id!: Vector<int>;

      constructor(params: {
        channel: Raw.TypeInputChannel;
        participant: Raw.TypeInputPeer;
        id: Vector<int>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ReportSpam';
        this.constructorId = 0xf44a8315;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel', 'participant', 'id'];
        this.channel = params.channel;
        this.participant = params.participant;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ReportSpam> {
        // no flags

        let channel = await TLObject.read(b);
        let participant = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.channels.ReportSpam({ channel: channel, participant: participant, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.participant !== undefined) {
          b.write(this.participant.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetMessages extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      channel!: Raw.TypeInputChannel;
      id!: Vector<Raw.TypeInputMessage>;

      constructor(params: { channel: Raw.TypeInputChannel; id: Vector<Raw.TypeInputMessage> }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetMessages';
        this.constructorId = 0xad8c9a23;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = ['channel', 'id'];
        this.channel = params.channel;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.GetMessages> {
        // no flags

        let channel = await TLObject.read(b);
        let id = await TLObject.read(b);
        return new Raw.channels.GetMessages({ channel: channel, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetParticipants extends TLObject {
      __response__!: Raw.channels.TypeChannelParticipants;
      channel!: Raw.TypeInputChannel;
      filter!: Raw.TypeChannelParticipantsFilter;
      offset!: int;
      limit!: int;
      hash!: long;

      constructor(params: {
        channel: Raw.TypeInputChannel;
        filter: Raw.TypeChannelParticipantsFilter;
        offset: int;
        limit: int;
        hash: long;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetParticipants';
        this.constructorId = 0x77ced9d0;
        this.subclassOfId = 0xe60a6e64;
        this._slots = ['channel', 'filter', 'offset', 'limit', 'hash'];
        this.channel = params.channel;
        this.filter = params.filter;
        this.offset = params.offset;
        this.limit = params.limit;
        this.hash = params.hash;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.GetParticipants> {
        // no flags

        let channel = await TLObject.read(b);
        let filter = await TLObject.read(b);
        let offset = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        let hash = await Primitive.Long.read(b);
        return new Raw.channels.GetParticipants({
          channel: channel,
          filter: filter,
          offset: offset,
          limit: limit,
          hash: hash,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.filter !== undefined) {
          b.write(this.filter.write() as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        if (this.hash !== undefined) {
          b.write(Primitive.Long.write(this.hash) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetParticipant extends TLObject {
      __response__!: Raw.channels.TypeChannelParticipant;
      channel!: Raw.TypeInputChannel;
      participant!: Raw.TypeInputPeer;

      constructor(params: { channel: Raw.TypeInputChannel; participant: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetParticipant';
        this.constructorId = 0xa0ab6cc6;
        this.subclassOfId = 0x6658151a;
        this._slots = ['channel', 'participant'];
        this.channel = params.channel;
        this.participant = params.participant;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.GetParticipant> {
        // no flags

        let channel = await TLObject.read(b);
        let participant = await TLObject.read(b);
        return new Raw.channels.GetParticipant({ channel: channel, participant: participant });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.participant !== undefined) {
          b.write(this.participant.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetChannels extends TLObject {
      __response__!: Raw.messages.TypeChats;
      id!: Vector<Raw.TypeInputChannel>;

      constructor(params: { id: Vector<Raw.TypeInputChannel> }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetChannels';
        this.constructorId = 0xa7f6bbb;
        this.subclassOfId = 0x99d5cb14;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.GetChannels> {
        // no flags

        let id = await TLObject.read(b);
        return new Raw.channels.GetChannels({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id) {
          b.write(Primitive.Vector.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetFullChannel extends TLObject {
      __response__!: Raw.messages.TypeChatFull;
      channel!: Raw.TypeInputChannel;

      constructor(params: { channel: Raw.TypeInputChannel }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetFullChannel';
        this.constructorId = 0x8736a09;
        this.subclassOfId = 0x225a5109;
        this._slots = ['channel'];
        this.channel = params.channel;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.GetFullChannel> {
        // no flags

        let channel = await TLObject.read(b);
        return new Raw.channels.GetFullChannel({ channel: channel });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CreateChannel extends TLObject {
      __response__!: Raw.TypeUpdates;
      broadcast?: boolean;
      megagroup?: boolean;
      forImport?: boolean;
      forum?: boolean;
      title!: string;
      about!: string;
      geoPoint?: Raw.TypeInputGeoPoint;
      address?: string;
      ttlPeriod?: int;

      constructor(params: {
        broadcast?: boolean;
        megagroup?: boolean;
        forImport?: boolean;
        forum?: boolean;
        title: string;
        about: string;
        geoPoint?: Raw.TypeInputGeoPoint;
        address?: string;
        ttlPeriod?: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.CreateChannel';
        this.constructorId = 0x91006707;
        this.subclassOfId = 0x8af52aac;
        this._slots = [
          'broadcast',
          'megagroup',
          'forImport',
          'forum',
          'title',
          'about',
          'geoPoint',
          'address',
          'ttlPeriod',
        ];
        this.broadcast = params.broadcast;
        this.megagroup = params.megagroup;
        this.forImport = params.forImport;
        this.forum = params.forum;
        this.title = params.title;
        this.about = params.about;
        this.geoPoint = params.geoPoint;
        this.address = params.address;
        this.ttlPeriod = params.ttlPeriod;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.CreateChannel> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let broadcast = flags & (1 << 0) ? true : false;
        let megagroup = flags & (1 << 1) ? true : false;
        let forImport = flags & (1 << 3) ? true : false;
        let forum = flags & (1 << 5) ? true : false;
        let title = await Primitive.String.read(b);
        let about = await Primitive.String.read(b);
        let geoPoint = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let address = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        let ttlPeriod = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
        return new Raw.channels.CreateChannel({
          broadcast: broadcast,
          megagroup: megagroup,
          forImport: forImport,
          forum: forum,
          title: title,
          about: about,
          geoPoint: geoPoint,
          address: address,
          ttlPeriod: ttlPeriod,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.broadcast ? 1 << 0 : 0;
        flags |= this.megagroup ? 1 << 1 : 0;
        flags |= this.forImport ? 1 << 3 : 0;
        flags |= this.forum ? 1 << 5 : 0;
        flags |= this.geoPoint !== undefined ? 1 << 2 : 0;
        flags |= this.address !== undefined ? 1 << 2 : 0;
        flags |= this.ttlPeriod !== undefined ? 1 << 4 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.about !== undefined) {
          b.write(Primitive.String.write(this.about) as unknown as Buffer);
        }
        if (this.geoPoint !== undefined) {
          b.write(this.geoPoint.write() as unknown as Buffer);
        }
        if (this.address !== undefined) {
          b.write(Primitive.String.write(this.address) as unknown as Buffer);
        }
        if (this.ttlPeriod !== undefined) {
          b.write(Primitive.Int.write(this.ttlPeriod) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditAdmin extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      userId!: Raw.TypeInputUser;
      adminRights!: Raw.TypeChatAdminRights;
      rank!: string;

      constructor(params: {
        channel: Raw.TypeInputChannel;
        userId: Raw.TypeInputUser;
        adminRights: Raw.TypeChatAdminRights;
        rank: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.EditAdmin';
        this.constructorId = 0xd33c8902;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'userId', 'adminRights', 'rank'];
        this.channel = params.channel;
        this.userId = params.userId;
        this.adminRights = params.adminRights;
        this.rank = params.rank;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.EditAdmin> {
        // no flags

        let channel = await TLObject.read(b);
        let userId = await TLObject.read(b);
        let adminRights = await TLObject.read(b);
        let rank = await Primitive.String.read(b);
        return new Raw.channels.EditAdmin({
          channel: channel,
          userId: userId,
          adminRights: adminRights,
          rank: rank,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.adminRights !== undefined) {
          b.write(this.adminRights.write() as unknown as Buffer);
        }
        if (this.rank !== undefined) {
          b.write(Primitive.String.write(this.rank) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditTitle extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      title!: string;

      constructor(params: { channel: Raw.TypeInputChannel; title: string }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.EditTitle';
        this.constructorId = 0x566decd0;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'title'];
        this.channel = params.channel;
        this.title = params.title;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.EditTitle> {
        // no flags

        let channel = await TLObject.read(b);
        let title = await Primitive.String.read(b);
        return new Raw.channels.EditTitle({ channel: channel, title: title });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditPhoto extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      photo!: Raw.TypeInputChatPhoto;

      constructor(params: { channel: Raw.TypeInputChannel; photo: Raw.TypeInputChatPhoto }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.EditPhoto';
        this.constructorId = 0xf12e57c9;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'photo'];
        this.channel = params.channel;
        this.photo = params.photo;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.EditPhoto> {
        // no flags

        let channel = await TLObject.read(b);
        let photo = await TLObject.read(b);
        return new Raw.channels.EditPhoto({ channel: channel, photo: photo });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.photo !== undefined) {
          b.write(this.photo.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CheckUsername extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;
      username!: string;

      constructor(params: { channel: Raw.TypeInputChannel; username: string }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.CheckUsername';
        this.constructorId = 0x10e6bd2c;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel', 'username'];
        this.channel = params.channel;
        this.username = params.username;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.CheckUsername> {
        // no flags

        let channel = await TLObject.read(b);
        let username = await Primitive.String.read(b);
        return new Raw.channels.CheckUsername({ channel: channel, username: username });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.username !== undefined) {
          b.write(Primitive.String.write(this.username) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdateUsername extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;
      username!: string;

      constructor(params: { channel: Raw.TypeInputChannel; username: string }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.UpdateUsername';
        this.constructorId = 0x3514b3de;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel', 'username'];
        this.channel = params.channel;
        this.username = params.username;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.UpdateUsername> {
        // no flags

        let channel = await TLObject.read(b);
        let username = await Primitive.String.read(b);
        return new Raw.channels.UpdateUsername({ channel: channel, username: username });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.username !== undefined) {
          b.write(Primitive.String.write(this.username) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class JoinChannel extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;

      constructor(params: { channel: Raw.TypeInputChannel }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.JoinChannel';
        this.constructorId = 0x24b524c5;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel'];
        this.channel = params.channel;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.JoinChannel> {
        // no flags

        let channel = await TLObject.read(b);
        return new Raw.channels.JoinChannel({ channel: channel });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class LeaveChannel extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;

      constructor(params: { channel: Raw.TypeInputChannel }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.LeaveChannel';
        this.constructorId = 0xf836aa95;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel'];
        this.channel = params.channel;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.LeaveChannel> {
        // no flags

        let channel = await TLObject.read(b);
        return new Raw.channels.LeaveChannel({ channel: channel });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class InviteToChannel extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      users!: Vector<Raw.TypeInputUser>;

      constructor(params: { channel: Raw.TypeInputChannel; users: Vector<Raw.TypeInputUser> }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.InviteToChannel';
        this.constructorId = 0x199f3a6c;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'users'];
        this.channel = params.channel;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.InviteToChannel> {
        // no flags

        let channel = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.channels.InviteToChannel({ channel: channel, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteChannel extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;

      constructor(params: { channel: Raw.TypeInputChannel }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.DeleteChannel';
        this.constructorId = 0xc0111fe3;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel'];
        this.channel = params.channel;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.DeleteChannel> {
        // no flags

        let channel = await TLObject.read(b);
        return new Raw.channels.DeleteChannel({ channel: channel });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportMessageLink extends TLObject {
      __response__!: Raw.TypeExportedMessageLink;
      grouped?: boolean;
      thread?: boolean;
      channel!: Raw.TypeInputChannel;
      id!: int;

      constructor(params: {
        grouped?: boolean;
        thread?: boolean;
        channel: Raw.TypeInputChannel;
        id: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ExportMessageLink';
        this.constructorId = 0xe63fadeb;
        this.subclassOfId = 0xdee644cc;
        this._slots = ['grouped', 'thread', 'channel', 'id'];
        this.grouped = params.grouped;
        this.thread = params.thread;
        this.channel = params.channel;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ExportMessageLink> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let grouped = flags & (1 << 0) ? true : false;
        let thread = flags & (1 << 1) ? true : false;
        let channel = await TLObject.read(b);
        let id = await Primitive.Int.read(b);
        return new Raw.channels.ExportMessageLink({
          grouped: grouped,
          thread: thread,
          channel: channel,
          id: id,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.grouped ? 1 << 0 : 0;
        flags |= this.thread ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleSignatures extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      enabled!: Bool;

      constructor(params: { channel: Raw.TypeInputChannel; enabled: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ToggleSignatures';
        this.constructorId = 0x1f69b606;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'enabled'];
        this.channel = params.channel;
        this.enabled = params.enabled;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ToggleSignatures> {
        // no flags

        let channel = await TLObject.read(b);
        let enabled = await Primitive.Bool.read(b);
        return new Raw.channels.ToggleSignatures({ channel: channel, enabled: enabled });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.enabled !== undefined) {
          b.write(Primitive.Bool.write(this.enabled) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAdminedPublicChannels extends TLObject {
      __response__!: Raw.messages.TypeChats;
      byLocation?: boolean;
      checkLimit?: boolean;

      constructor(params: { byLocation?: boolean; checkLimit?: boolean }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetAdminedPublicChannels';
        this.constructorId = 0xf8b036af;
        this.subclassOfId = 0x99d5cb14;
        this._slots = ['byLocation', 'checkLimit'];
        this.byLocation = params.byLocation;
        this.checkLimit = params.checkLimit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.GetAdminedPublicChannels> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let byLocation = flags & (1 << 0) ? true : false;
        let checkLimit = flags & (1 << 1) ? true : false;
        return new Raw.channels.GetAdminedPublicChannels({
          byLocation: byLocation,
          checkLimit: checkLimit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.byLocation ? 1 << 0 : 0;
        flags |= this.checkLimit ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        return b.buffer;
      }
    }
    export class EditBanned extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      participant!: Raw.TypeInputPeer;
      bannedRights!: Raw.TypeChatBannedRights;

      constructor(params: {
        channel: Raw.TypeInputChannel;
        participant: Raw.TypeInputPeer;
        bannedRights: Raw.TypeChatBannedRights;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.EditBanned';
        this.constructorId = 0x96e6cd81;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'participant', 'bannedRights'];
        this.channel = params.channel;
        this.participant = params.participant;
        this.bannedRights = params.bannedRights;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.EditBanned> {
        // no flags

        let channel = await TLObject.read(b);
        let participant = await TLObject.read(b);
        let bannedRights = await TLObject.read(b);
        return new Raw.channels.EditBanned({
          channel: channel,
          participant: participant,
          bannedRights: bannedRights,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.participant !== undefined) {
          b.write(this.participant.write() as unknown as Buffer);
        }
        if (this.bannedRights !== undefined) {
          b.write(this.bannedRights.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAdminLog extends TLObject {
      __response__!: Raw.channels.TypeAdminLogResults;
      channel!: Raw.TypeInputChannel;
      q!: string;
      eventsFilter?: Raw.TypeChannelAdminLogEventsFilter;
      admins?: Vector<Raw.TypeInputUser>;
      maxId!: long;
      minId!: long;
      limit!: int;

      constructor(params: {
        channel: Raw.TypeInputChannel;
        q: string;
        eventsFilter?: Raw.TypeChannelAdminLogEventsFilter;
        admins?: Vector<Raw.TypeInputUser>;
        maxId: long;
        minId: long;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetAdminLog';
        this.constructorId = 0x33ddf480;
        this.subclassOfId = 0x51f076bc;
        this._slots = ['channel', 'q', 'eventsFilter', 'admins', 'maxId', 'minId', 'limit'];
        this.channel = params.channel;
        this.q = params.q;
        this.eventsFilter = params.eventsFilter;
        this.admins = params.admins;
        this.maxId = params.maxId;
        this.minId = params.minId;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.GetAdminLog> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let channel = await TLObject.read(b);
        let q = await Primitive.String.read(b);
        let eventsFilter = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let admins = flags & (1 << 1) ? await TLObject.read(b) : [];
        let maxId = await Primitive.Long.read(b);
        let minId = await Primitive.Long.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.channels.GetAdminLog({
          channel: channel,
          q: q,
          eventsFilter: eventsFilter,
          admins: admins,
          maxId: maxId,
          minId: minId,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.eventsFilter !== undefined ? 1 << 0 : 0;
        flags |= this.admins ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.q !== undefined) {
          b.write(Primitive.String.write(this.q) as unknown as Buffer);
        }
        if (this.eventsFilter !== undefined) {
          b.write(this.eventsFilter.write() as unknown as Buffer);
        }
        if (this.admins) {
          b.write(Primitive.Vector.write(this.admins) as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Long.write(this.maxId) as unknown as Buffer);
        }
        if (this.minId !== undefined) {
          b.write(Primitive.Long.write(this.minId) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetStickers extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;
      stickerset!: Raw.TypeInputStickerSet;

      constructor(params: { channel: Raw.TypeInputChannel; stickerset: Raw.TypeInputStickerSet }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.SetStickers';
        this.constructorId = 0xea8ca4f9;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel', 'stickerset'];
        this.channel = params.channel;
        this.stickerset = params.stickerset;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.SetStickers> {
        // no flags

        let channel = await TLObject.read(b);
        let stickerset = await TLObject.read(b);
        return new Raw.channels.SetStickers({ channel: channel, stickerset: stickerset });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.stickerset !== undefined) {
          b.write(this.stickerset.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReadMessageContents extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;
      id!: Vector<int>;

      constructor(params: { channel: Raw.TypeInputChannel; id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ReadMessageContents';
        this.constructorId = 0xeab5dc38;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel', 'id'];
        this.channel = params.channel;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.ReadMessageContents> {
        // no flags

        let channel = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.channels.ReadMessageContents({ channel: channel, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteHistory extends TLObject {
      __response__!: Raw.TypeUpdates;
      forEveryone?: boolean;
      channel!: Raw.TypeInputChannel;
      maxId!: int;

      constructor(params: { forEveryone?: boolean; channel: Raw.TypeInputChannel; maxId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.DeleteHistory';
        this.constructorId = 0x9baa9647;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['forEveryone', 'channel', 'maxId'];
        this.forEveryone = params.forEveryone;
        this.channel = params.channel;
        this.maxId = params.maxId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.DeleteHistory> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let forEveryone = flags & (1 << 0) ? true : false;
        let channel = await TLObject.read(b);
        let maxId = await Primitive.Int.read(b);
        return new Raw.channels.DeleteHistory({
          forEveryone: forEveryone,
          channel: channel,
          maxId: maxId,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.forEveryone ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TogglePreHistoryHidden extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      enabled!: Bool;

      constructor(params: { channel: Raw.TypeInputChannel; enabled: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.TogglePreHistoryHidden';
        this.constructorId = 0xeabbb94c;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'enabled'];
        this.channel = params.channel;
        this.enabled = params.enabled;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.TogglePreHistoryHidden> {
        // no flags

        let channel = await TLObject.read(b);
        let enabled = await Primitive.Bool.read(b);
        return new Raw.channels.TogglePreHistoryHidden({ channel: channel, enabled: enabled });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.enabled !== undefined) {
          b.write(Primitive.Bool.write(this.enabled) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetLeftChannels extends TLObject {
      __response__!: Raw.messages.TypeChats;
      offset!: int;

      constructor(params: { offset: int }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetLeftChannels';
        this.constructorId = 0x8341ecc0;
        this.subclassOfId = 0x99d5cb14;
        this._slots = ['offset'];
        this.offset = params.offset;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.GetLeftChannels> {
        // no flags

        let offset = await Primitive.Int.read(b);
        return new Raw.channels.GetLeftChannels({ offset: offset });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.offset !== undefined) {
          b.write(Primitive.Int.write(this.offset) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetGroupsForDiscussion extends TLObject {
      __response__!: Raw.messages.TypeChats;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetGroupsForDiscussion';
        this.constructorId = 0xf5dad378;
        this.subclassOfId = 0x99d5cb14;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.GetGroupsForDiscussion> {
        // no flags

        return new Raw.channels.GetGroupsForDiscussion();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class SetDiscussionGroup extends TLObject {
      __response__!: Bool;
      broadcast!: Raw.TypeInputChannel;
      group!: Raw.TypeInputChannel;

      constructor(params: { broadcast: Raw.TypeInputChannel; group: Raw.TypeInputChannel }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.SetDiscussionGroup';
        this.constructorId = 0x40582bb2;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['broadcast', 'group'];
        this.broadcast = params.broadcast;
        this.group = params.group;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.SetDiscussionGroup> {
        // no flags

        let broadcast = await TLObject.read(b);
        let group = await TLObject.read(b);
        return new Raw.channels.SetDiscussionGroup({ broadcast: broadcast, group: group });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.broadcast !== undefined) {
          b.write(this.broadcast.write() as unknown as Buffer);
        }
        if (this.group !== undefined) {
          b.write(this.group.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditCreator extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      userId!: Raw.TypeInputUser;
      password!: Raw.TypeInputCheckPasswordSRP;

      constructor(params: {
        channel: Raw.TypeInputChannel;
        userId: Raw.TypeInputUser;
        password: Raw.TypeInputCheckPasswordSRP;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.EditCreator';
        this.constructorId = 0x8f38cd1f;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'userId', 'password'];
        this.channel = params.channel;
        this.userId = params.userId;
        this.password = params.password;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.EditCreator> {
        // no flags

        let channel = await TLObject.read(b);
        let userId = await TLObject.read(b);
        let password = await TLObject.read(b);
        return new Raw.channels.EditCreator({
          channel: channel,
          userId: userId,
          password: password,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.password !== undefined) {
          b.write(this.password.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditLocation extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;
      geoPoint!: Raw.TypeInputGeoPoint;
      address!: string;

      constructor(params: {
        channel: Raw.TypeInputChannel;
        geoPoint: Raw.TypeInputGeoPoint;
        address: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.EditLocation';
        this.constructorId = 0x58e63f6d;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel', 'geoPoint', 'address'];
        this.channel = params.channel;
        this.geoPoint = params.geoPoint;
        this.address = params.address;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.EditLocation> {
        // no flags

        let channel = await TLObject.read(b);
        let geoPoint = await TLObject.read(b);
        let address = await Primitive.String.read(b);
        return new Raw.channels.EditLocation({
          channel: channel,
          geoPoint: geoPoint,
          address: address,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.geoPoint !== undefined) {
          b.write(this.geoPoint.write() as unknown as Buffer);
        }
        if (this.address !== undefined) {
          b.write(Primitive.String.write(this.address) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleSlowMode extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      seconds!: int;

      constructor(params: { channel: Raw.TypeInputChannel; seconds: int }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ToggleSlowMode';
        this.constructorId = 0xedd49ef0;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'seconds'];
        this.channel = params.channel;
        this.seconds = params.seconds;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ToggleSlowMode> {
        // no flags

        let channel = await TLObject.read(b);
        let seconds = await Primitive.Int.read(b);
        return new Raw.channels.ToggleSlowMode({ channel: channel, seconds: seconds });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.seconds !== undefined) {
          b.write(Primitive.Int.write(this.seconds) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetInactiveChannels extends TLObject {
      __response__!: Raw.messages.TypeInactiveChats;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetInactiveChannels';
        this.constructorId = 0x11e831ee;
        this.subclassOfId = 0x8bf3d7d4;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.GetInactiveChannels> {
        // no flags

        return new Raw.channels.GetInactiveChannels();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class ConvertToGigagroup extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;

      constructor(params: { channel: Raw.TypeInputChannel }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ConvertToGigagroup';
        this.constructorId = 0xb290c69;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel'];
        this.channel = params.channel;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ConvertToGigagroup> {
        // no flags

        let channel = await TLObject.read(b);
        return new Raw.channels.ConvertToGigagroup({ channel: channel });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ViewSponsoredMessage extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;
      randomId!: bytes;

      constructor(params: { channel: Raw.TypeInputChannel; randomId: bytes }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ViewSponsoredMessage';
        this.constructorId = 0xbeaedb94;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel', 'randomId'];
        this.channel = params.channel;
        this.randomId = params.randomId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.ViewSponsoredMessage> {
        // no flags

        let channel = await TLObject.read(b);
        let randomId = await Primitive.Bytes.read(b);
        return new Raw.channels.ViewSponsoredMessage({ channel: channel, randomId: randomId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Bytes.write(this.randomId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetSponsoredMessages extends TLObject {
      __response__!: Raw.messages.TypeSponsoredMessages;
      channel!: Raw.TypeInputChannel;

      constructor(params: { channel: Raw.TypeInputChannel }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetSponsoredMessages';
        this.constructorId = 0xec210fbf;
        this.subclassOfId = 0x7f4169e0;
        this._slots = ['channel'];
        this.channel = params.channel;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.GetSponsoredMessages> {
        // no flags

        let channel = await TLObject.read(b);
        return new Raw.channels.GetSponsoredMessages({ channel: channel });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetSendAs extends TLObject {
      __response__!: Raw.channels.TypeSendAsPeers;
      peer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetSendAs';
        this.constructorId = 0xdc770ee;
        this.subclassOfId = 0x38cb8d21;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.GetSendAs> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.channels.GetSendAs({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteParticipantHistory extends TLObject {
      __response__!: Raw.messages.TypeAffectedHistory;
      channel!: Raw.TypeInputChannel;
      participant!: Raw.TypeInputPeer;

      constructor(params: { channel: Raw.TypeInputChannel; participant: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.DeleteParticipantHistory';
        this.constructorId = 0x367544db;
        this.subclassOfId = 0x2c49c116;
        this._slots = ['channel', 'participant'];
        this.channel = params.channel;
        this.participant = params.participant;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.DeleteParticipantHistory> {
        // no flags

        let channel = await TLObject.read(b);
        let participant = await TLObject.read(b);
        return new Raw.channels.DeleteParticipantHistory({
          channel: channel,
          participant: participant,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.participant !== undefined) {
          b.write(this.participant.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleJoinToSend extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      enabled!: Bool;

      constructor(params: { channel: Raw.TypeInputChannel; enabled: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ToggleJoinToSend';
        this.constructorId = 0xe4cb9580;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'enabled'];
        this.channel = params.channel;
        this.enabled = params.enabled;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ToggleJoinToSend> {
        // no flags

        let channel = await TLObject.read(b);
        let enabled = await Primitive.Bool.read(b);
        return new Raw.channels.ToggleJoinToSend({ channel: channel, enabled: enabled });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.enabled !== undefined) {
          b.write(Primitive.Bool.write(this.enabled) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleJoinRequest extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      enabled!: Bool;

      constructor(params: { channel: Raw.TypeInputChannel; enabled: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ToggleJoinRequest';
        this.constructorId = 0x4c2985b6;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'enabled'];
        this.channel = params.channel;
        this.enabled = params.enabled;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ToggleJoinRequest> {
        // no flags

        let channel = await TLObject.read(b);
        let enabled = await Primitive.Bool.read(b);
        return new Raw.channels.ToggleJoinRequest({ channel: channel, enabled: enabled });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.enabled !== undefined) {
          b.write(Primitive.Bool.write(this.enabled) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReorderUsernames extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;
      order!: Vector<string>;

      constructor(params: { channel: Raw.TypeInputChannel; order: Vector<string> }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ReorderUsernames';
        this.constructorId = 0xb45ced1d;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel', 'order'];
        this.channel = params.channel;
        this.order = params.order;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ReorderUsernames> {
        // no flags

        let channel = await TLObject.read(b);
        let order = await TLObject.read(b, Primitive.String);
        return new Raw.channels.ReorderUsernames({ channel: channel, order: order });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.order) {
          b.write(Primitive.Vector.write(this.order, Primitive.String) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleUsername extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;
      username!: string;
      active!: Bool;

      constructor(params: { channel: Raw.TypeInputChannel; username: string; active: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ToggleUsername';
        this.constructorId = 0x50f24105;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel', 'username', 'active'];
        this.channel = params.channel;
        this.username = params.username;
        this.active = params.active;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ToggleUsername> {
        // no flags

        let channel = await TLObject.read(b);
        let username = await Primitive.String.read(b);
        let active = await Primitive.Bool.read(b);
        return new Raw.channels.ToggleUsername({
          channel: channel,
          username: username,
          active: active,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.username !== undefined) {
          b.write(Primitive.String.write(this.username) as unknown as Buffer);
        }
        if (this.active !== undefined) {
          b.write(Primitive.Bool.write(this.active) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeactivateAllUsernames extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;

      constructor(params: { channel: Raw.TypeInputChannel }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.DeactivateAllUsernames';
        this.constructorId = 0xa245dd3;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel'];
        this.channel = params.channel;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.DeactivateAllUsernames> {
        // no flags

        let channel = await TLObject.read(b);
        return new Raw.channels.DeactivateAllUsernames({ channel: channel });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleForum extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      enabled!: Bool;

      constructor(params: { channel: Raw.TypeInputChannel; enabled: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ToggleForum';
        this.constructorId = 0xa4298b29;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'enabled'];
        this.channel = params.channel;
        this.enabled = params.enabled;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ToggleForum> {
        // no flags

        let channel = await TLObject.read(b);
        let enabled = await Primitive.Bool.read(b);
        return new Raw.channels.ToggleForum({ channel: channel, enabled: enabled });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.enabled !== undefined) {
          b.write(Primitive.Bool.write(this.enabled) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CreateForumTopic extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      title!: string;
      iconColor?: int;
      iconEmojiId?: long;
      randomId!: long;
      sendAs?: Raw.TypeInputPeer;

      constructor(params: {
        channel: Raw.TypeInputChannel;
        title: string;
        iconColor?: int;
        iconEmojiId?: long;
        randomId: long;
        sendAs?: Raw.TypeInputPeer;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.CreateForumTopic';
        this.constructorId = 0xf40c0224;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'title', 'iconColor', 'iconEmojiId', 'randomId', 'sendAs'];
        this.channel = params.channel;
        this.title = params.title;
        this.iconColor = params.iconColor;
        this.iconEmojiId = params.iconEmojiId;
        this.randomId = params.randomId;
        this.sendAs = params.sendAs;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.CreateForumTopic> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let channel = await TLObject.read(b);
        let title = await Primitive.String.read(b);
        let iconColor = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let iconEmojiId = flags & (1 << 3) ? await Primitive.Long.read(b) : undefined;
        let randomId = await Primitive.Long.read(b);
        let sendAs = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        return new Raw.channels.CreateForumTopic({
          channel: channel,
          title: title,
          iconColor: iconColor,
          iconEmojiId: iconEmojiId,
          randomId: randomId,
          sendAs: sendAs,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.iconColor !== undefined ? 1 << 0 : 0;
        flags |= this.iconEmojiId !== undefined ? 1 << 3 : 0;
        flags |= this.sendAs !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.iconColor !== undefined) {
          b.write(Primitive.Int.write(this.iconColor) as unknown as Buffer);
        }
        if (this.iconEmojiId !== undefined) {
          b.write(Primitive.Long.write(this.iconEmojiId) as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
        }
        if (this.sendAs !== undefined) {
          b.write(this.sendAs.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetForumTopics extends TLObject {
      __response__!: Raw.messages.TypeForumTopics;
      channel!: Raw.TypeInputChannel;
      q?: string;
      offsetDate!: int;
      offsetId!: int;
      offsetTopic!: int;
      limit!: int;

      constructor(params: {
        channel: Raw.TypeInputChannel;
        q?: string;
        offsetDate: int;
        offsetId: int;
        offsetTopic: int;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetForumTopics';
        this.constructorId = 0xde560d1;
        this.subclassOfId = 0x8e1d3e1e;
        this._slots = ['channel', 'q', 'offsetDate', 'offsetId', 'offsetTopic', 'limit'];
        this.channel = params.channel;
        this.q = params.q;
        this.offsetDate = params.offsetDate;
        this.offsetId = params.offsetId;
        this.offsetTopic = params.offsetTopic;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.GetForumTopics> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let channel = await TLObject.read(b);
        let q = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let offsetDate = await Primitive.Int.read(b);
        let offsetId = await Primitive.Int.read(b);
        let offsetTopic = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.channels.GetForumTopics({
          channel: channel,
          q: q,
          offsetDate: offsetDate,
          offsetId: offsetId,
          offsetTopic: offsetTopic,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.q !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.q !== undefined) {
          b.write(Primitive.String.write(this.q) as unknown as Buffer);
        }
        if (this.offsetDate !== undefined) {
          b.write(Primitive.Int.write(this.offsetDate) as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.offsetTopic !== undefined) {
          b.write(Primitive.Int.write(this.offsetTopic) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetForumTopicsByID extends TLObject {
      __response__!: Raw.messages.TypeForumTopics;
      channel!: Raw.TypeInputChannel;
      topics!: Vector<int>;

      constructor(params: { channel: Raw.TypeInputChannel; topics: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.GetForumTopicsByID';
        this.constructorId = 0xb0831eb9;
        this.subclassOfId = 0x8e1d3e1e;
        this._slots = ['channel', 'topics'];
        this.channel = params.channel;
        this.topics = params.topics;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.GetForumTopicsByID> {
        // no flags

        let channel = await TLObject.read(b);
        let topics = await TLObject.read(b, Primitive.Int);
        return new Raw.channels.GetForumTopicsByID({ channel: channel, topics: topics });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.topics) {
          b.write(Primitive.Vector.write(this.topics, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditForumTopic extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      topicId!: int;
      title?: string;
      iconEmojiId?: long;
      closed?: Bool;
      hidden?: Bool;

      constructor(params: {
        channel: Raw.TypeInputChannel;
        topicId: int;
        title?: string;
        iconEmojiId?: long;
        closed?: Bool;
        hidden?: Bool;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.EditForumTopic';
        this.constructorId = 0xf4dfa185;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'topicId', 'title', 'iconEmojiId', 'closed', 'hidden'];
        this.channel = params.channel;
        this.topicId = params.topicId;
        this.title = params.title;
        this.iconEmojiId = params.iconEmojiId;
        this.closed = params.closed;
        this.hidden = params.hidden;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.EditForumTopic> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let channel = await TLObject.read(b);
        let topicId = await Primitive.Int.read(b);
        let title = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let iconEmojiId = flags & (1 << 1) ? await Primitive.Long.read(b) : undefined;
        let closed = flags & (1 << 2) ? await Primitive.Bool.read(b) : undefined;
        let hidden = flags & (1 << 3) ? await Primitive.Bool.read(b) : undefined;
        return new Raw.channels.EditForumTopic({
          channel: channel,
          topicId: topicId,
          title: title,
          iconEmojiId: iconEmojiId,
          closed: closed,
          hidden: hidden,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.title !== undefined ? 1 << 0 : 0;
        flags |= this.iconEmojiId !== undefined ? 1 << 1 : 0;
        flags |= this.closed !== undefined ? 1 << 2 : 0;
        flags |= this.hidden !== undefined ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.topicId !== undefined) {
          b.write(Primitive.Int.write(this.topicId) as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.iconEmojiId !== undefined) {
          b.write(Primitive.Long.write(this.iconEmojiId) as unknown as Buffer);
        }
        if (this.closed !== undefined) {
          b.write(Primitive.Bool.write(this.closed) as unknown as Buffer);
        }
        if (this.hidden !== undefined) {
          b.write(Primitive.Bool.write(this.hidden) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdatePinnedForumTopic extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      topicId!: int;
      pinned!: Bool;

      constructor(params: { channel: Raw.TypeInputChannel; topicId: int; pinned: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.UpdatePinnedForumTopic';
        this.constructorId = 0x6c2d9026;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'topicId', 'pinned'];
        this.channel = params.channel;
        this.topicId = params.topicId;
        this.pinned = params.pinned;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.UpdatePinnedForumTopic> {
        // no flags

        let channel = await TLObject.read(b);
        let topicId = await Primitive.Int.read(b);
        let pinned = await Primitive.Bool.read(b);
        return new Raw.channels.UpdatePinnedForumTopic({
          channel: channel,
          topicId: topicId,
          pinned: pinned,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.topicId !== undefined) {
          b.write(Primitive.Int.write(this.topicId) as unknown as Buffer);
        }
        if (this.pinned !== undefined) {
          b.write(Primitive.Bool.write(this.pinned) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteTopicHistory extends TLObject {
      __response__!: Raw.messages.TypeAffectedHistory;
      channel!: Raw.TypeInputChannel;
      topMsgId!: int;

      constructor(params: { channel: Raw.TypeInputChannel; topMsgId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.DeleteTopicHistory';
        this.constructorId = 0x34435f2d;
        this.subclassOfId = 0x2c49c116;
        this._slots = ['channel', 'topMsgId'];
        this.channel = params.channel;
        this.topMsgId = params.topMsgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.DeleteTopicHistory> {
        // no flags

        let channel = await TLObject.read(b);
        let topMsgId = await Primitive.Int.read(b);
        return new Raw.channels.DeleteTopicHistory({ channel: channel, topMsgId: topMsgId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.topMsgId !== undefined) {
          b.write(Primitive.Int.write(this.topMsgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReorderPinnedForumTopics extends TLObject {
      __response__!: Raw.TypeUpdates;
      force?: boolean;
      channel!: Raw.TypeInputChannel;
      order!: Vector<int>;

      constructor(params: { force?: boolean; channel: Raw.TypeInputChannel; order: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ReorderPinnedForumTopics';
        this.constructorId = 0x2950a18f;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['force', 'channel', 'order'];
        this.force = params.force;
        this.channel = params.channel;
        this.order = params.order;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.ReorderPinnedForumTopics> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let force = flags & (1 << 0) ? true : false;
        let channel = await TLObject.read(b);
        let order = await TLObject.read(b, Primitive.Int);
        return new Raw.channels.ReorderPinnedForumTopics({
          force: force,
          channel: channel,
          order: order,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.force ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.order) {
          b.write(Primitive.Vector.write(this.order, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleAntiSpam extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      enabled!: Bool;

      constructor(params: { channel: Raw.TypeInputChannel; enabled: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ToggleAntiSpam';
        this.constructorId = 0x68f3e4eb;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'enabled'];
        this.channel = params.channel;
        this.enabled = params.enabled;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.ToggleAntiSpam> {
        // no flags

        let channel = await TLObject.read(b);
        let enabled = await Primitive.Bool.read(b);
        return new Raw.channels.ToggleAntiSpam({ channel: channel, enabled: enabled });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.enabled !== undefined) {
          b.write(Primitive.Bool.write(this.enabled) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReportAntiSpamFalsePositive extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;
      msgId!: int;

      constructor(params: { channel: Raw.TypeInputChannel; msgId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ReportAntiSpamFalsePositive';
        this.constructorId = 0xa850a693;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel', 'msgId'];
        this.channel = params.channel;
        this.msgId = params.msgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.ReportAntiSpamFalsePositive> {
        // no flags

        let channel = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        return new Raw.channels.ReportAntiSpamFalsePositive({ channel: channel, msgId: msgId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleParticipantsHidden extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      enabled!: Bool;

      constructor(params: { channel: Raw.TypeInputChannel; enabled: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ToggleParticipantsHidden';
        this.constructorId = 0x6a6e7854;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'enabled'];
        this.channel = params.channel;
        this.enabled = params.enabled;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.ToggleParticipantsHidden> {
        // no flags

        let channel = await TLObject.read(b);
        let enabled = await Primitive.Bool.read(b);
        return new Raw.channels.ToggleParticipantsHidden({ channel: channel, enabled: enabled });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.enabled !== undefined) {
          b.write(Primitive.Bool.write(this.enabled) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ClickSponsoredMessage extends TLObject {
      __response__!: Bool;
      channel!: Raw.TypeInputChannel;
      randomId!: bytes;

      constructor(params: { channel: Raw.TypeInputChannel; randomId: bytes }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.ClickSponsoredMessage';
        this.constructorId = 0x18afbc93;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['channel', 'randomId'];
        this.channel = params.channel;
        this.randomId = params.randomId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.channels.ClickSponsoredMessage> {
        // no flags

        let channel = await TLObject.read(b);
        let randomId = await Primitive.Bytes.read(b);
        return new Raw.channels.ClickSponsoredMessage({ channel: channel, randomId: randomId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Bytes.write(this.randomId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class UpdateColor extends TLObject {
      __response__!: Raw.TypeUpdates;
      channel!: Raw.TypeInputChannel;
      color!: int;
      backgroundEmojiId?: long;

      constructor(params: { channel: Raw.TypeInputChannel; color: int; backgroundEmojiId?: long }) {
        super();
        this.classType = 'functions';
        this.className = 'channels.UpdateColor';
        this.constructorId = 0x621a201f;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['channel', 'color', 'backgroundEmojiId'];
        this.channel = params.channel;
        this.color = params.color;
        this.backgroundEmojiId = params.backgroundEmojiId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.channels.UpdateColor> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let channel = await TLObject.read(b);
        let color = await Primitive.Int.read(b);
        let backgroundEmojiId = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
        return new Raw.channels.UpdateColor({
          channel: channel,
          color: color,
          backgroundEmojiId: backgroundEmojiId,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.backgroundEmojiId !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.color !== undefined) {
          b.write(Primitive.Int.write(this.color) as unknown as Buffer);
        }
        if (this.backgroundEmojiId !== undefined) {
          b.write(Primitive.Long.write(this.backgroundEmojiId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace payments {
    export type TypeGiveawayInfo = Raw.payments.GiveawayInfo | Raw.payments.GiveawayInfoResults;
    export type TypeCheckedGiftCode = Raw.payments.CheckedGiftCode;
    export type TypeExportedInvoice = Raw.payments.ExportedInvoice;
    export type TypeBankCardData = Raw.payments.BankCardData;
    export type TypeSavedInfo = Raw.payments.SavedInfo;
    export type TypePaymentResult =
      | Raw.payments.PaymentResult
      | Raw.payments.PaymentVerificationNeeded;
    export type TypeValidatedRequestedInfo = Raw.payments.ValidatedRequestedInfo;
    export type TypePaymentReceipt = Raw.payments.PaymentReceipt;
    export type TypePaymentForm = Raw.payments.PaymentForm;
    export class PaymentForm extends TLObject {
      canSaveCredentials?: boolean;
      passwordMissing?: boolean;
      formId!: long;
      botId!: long;
      title!: string;
      description!: string;
      photo?: Raw.TypeWebDocument;
      invoice!: Raw.TypeInvoice;
      providerId!: long;
      url!: string;
      nativeProvider?: string;
      nativeParams?: Raw.TypeDataJSON;
      additionalMethods?: Vector<Raw.TypePaymentFormMethod>;
      savedInfo?: Raw.TypePaymentRequestedInfo;
      savedCredentials?: Vector<Raw.TypePaymentSavedCredentials>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        canSaveCredentials?: boolean;
        passwordMissing?: boolean;
        formId: long;
        botId: long;
        title: string;
        description: string;
        photo?: Raw.TypeWebDocument;
        invoice: Raw.TypeInvoice;
        providerId: long;
        url: string;
        nativeProvider?: string;
        nativeParams?: Raw.TypeDataJSON;
        additionalMethods?: Vector<Raw.TypePaymentFormMethod>;
        savedInfo?: Raw.TypePaymentRequestedInfo;
        savedCredentials?: Vector<Raw.TypePaymentSavedCredentials>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'payments.PaymentForm';
        this.constructorId = 0xa0058751;
        this.subclassOfId = 0xa0483f19;
        this._slots = [
          'canSaveCredentials',
          'passwordMissing',
          'formId',
          'botId',
          'title',
          'description',
          'photo',
          'invoice',
          'providerId',
          'url',
          'nativeProvider',
          'nativeParams',
          'additionalMethods',
          'savedInfo',
          'savedCredentials',
          'users',
        ];
        this.canSaveCredentials = params.canSaveCredentials;
        this.passwordMissing = params.passwordMissing;
        this.formId = params.formId;
        this.botId = params.botId;
        this.title = params.title;
        this.description = params.description;
        this.photo = params.photo;
        this.invoice = params.invoice;
        this.providerId = params.providerId;
        this.url = params.url;
        this.nativeProvider = params.nativeProvider;
        this.nativeParams = params.nativeParams;
        this.additionalMethods = params.additionalMethods;
        this.savedInfo = params.savedInfo;
        this.savedCredentials = params.savedCredentials;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.PaymentForm> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let canSaveCredentials = flags & (1 << 2) ? true : false;
        let passwordMissing = flags & (1 << 3) ? true : false;
        let formId = await Primitive.Long.read(b);
        let botId = await Primitive.Long.read(b);
        let title = await Primitive.String.read(b);
        let description = await Primitive.String.read(b);
        let photo = flags & (1 << 5) ? await TLObject.read(b) : undefined;
        let invoice = await TLObject.read(b);
        let providerId = await Primitive.Long.read(b);
        let url = await Primitive.String.read(b);
        let nativeProvider = flags & (1 << 4) ? await Primitive.String.read(b) : undefined;
        let nativeParams = flags & (1 << 4) ? await TLObject.read(b) : undefined;
        let additionalMethods = flags & (1 << 6) ? await TLObject.read(b) : [];
        let savedInfo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let savedCredentials = flags & (1 << 1) ? await TLObject.read(b) : [];
        let users = await TLObject.read(b);
        return new Raw.payments.PaymentForm({
          canSaveCredentials: canSaveCredentials,
          passwordMissing: passwordMissing,
          formId: formId,
          botId: botId,
          title: title,
          description: description,
          photo: photo,
          invoice: invoice,
          providerId: providerId,
          url: url,
          nativeProvider: nativeProvider,
          nativeParams: nativeParams,
          additionalMethods: additionalMethods,
          savedInfo: savedInfo,
          savedCredentials: savedCredentials,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.canSaveCredentials ? 1 << 2 : 0;
        flags |= this.passwordMissing ? 1 << 3 : 0;
        flags |= this.photo !== undefined ? 1 << 5 : 0;
        flags |= this.nativeProvider !== undefined ? 1 << 4 : 0;
        flags |= this.nativeParams !== undefined ? 1 << 4 : 0;
        flags |= this.additionalMethods ? 1 << 6 : 0;
        flags |= this.savedInfo !== undefined ? 1 << 0 : 0;
        flags |= this.savedCredentials ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.formId !== undefined) {
          b.write(Primitive.Long.write(this.formId) as unknown as Buffer);
        }
        if (this.botId !== undefined) {
          b.write(Primitive.Long.write(this.botId) as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.description !== undefined) {
          b.write(Primitive.String.write(this.description) as unknown as Buffer);
        }
        if (this.photo !== undefined) {
          b.write(this.photo.write() as unknown as Buffer);
        }
        if (this.invoice !== undefined) {
          b.write(this.invoice.write() as unknown as Buffer);
        }
        if (this.providerId !== undefined) {
          b.write(Primitive.Long.write(this.providerId) as unknown as Buffer);
        }
        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        if (this.nativeProvider !== undefined) {
          b.write(Primitive.String.write(this.nativeProvider) as unknown as Buffer);
        }
        if (this.nativeParams !== undefined) {
          b.write(this.nativeParams.write() as unknown as Buffer);
        }
        if (this.additionalMethods) {
          b.write(Primitive.Vector.write(this.additionalMethods) as unknown as Buffer);
        }
        if (this.savedInfo !== undefined) {
          b.write(this.savedInfo.write() as unknown as Buffer);
        }
        if (this.savedCredentials) {
          b.write(Primitive.Vector.write(this.savedCredentials) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ValidatedRequestedInfo extends TLObject {
      id?: string;
      shippingOptions?: Vector<Raw.TypeShippingOption>;

      constructor(params: { id?: string; shippingOptions?: Vector<Raw.TypeShippingOption> }) {
        super();
        this.classType = 'types';
        this.className = 'payments.ValidatedRequestedInfo';
        this.constructorId = 0xd1451883;
        this.subclassOfId = 0x8f8044b7;
        this._slots = ['id', 'shippingOptions'];
        this.id = params.id;
        this.shippingOptions = params.shippingOptions;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.payments.ValidatedRequestedInfo> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let id = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let shippingOptions = flags & (1 << 1) ? await TLObject.read(b) : [];
        return new Raw.payments.ValidatedRequestedInfo({
          id: id,
          shippingOptions: shippingOptions,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.id !== undefined ? 1 << 0 : 0;
        flags |= this.shippingOptions ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.id !== undefined) {
          b.write(Primitive.String.write(this.id) as unknown as Buffer);
        }
        if (this.shippingOptions) {
          b.write(Primitive.Vector.write(this.shippingOptions) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PaymentResult extends TLObject {
      updates!: Raw.TypeUpdates;

      constructor(params: { updates: Raw.TypeUpdates }) {
        super();
        this.classType = 'types';
        this.className = 'payments.PaymentResult';
        this.constructorId = 0x4e5f810d;
        this.subclassOfId = 0x8ae16a9d;
        this._slots = ['updates'];
        this.updates = params.updates;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.PaymentResult> {
        // no flags

        let updates = await TLObject.read(b);
        return new Raw.payments.PaymentResult({ updates: updates });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.updates !== undefined) {
          b.write(this.updates.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PaymentVerificationNeeded extends TLObject {
      url!: string;

      constructor(params: { url: string }) {
        super();
        this.classType = 'types';
        this.className = 'payments.PaymentVerificationNeeded';
        this.constructorId = 0xd8411139;
        this.subclassOfId = 0x8ae16a9d;
        this._slots = ['url'];
        this.url = params.url;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.payments.PaymentVerificationNeeded> {
        // no flags

        let url = await Primitive.String.read(b);
        return new Raw.payments.PaymentVerificationNeeded({ url: url });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PaymentReceipt extends TLObject {
      date!: int;
      botId!: long;
      providerId!: long;
      title!: string;
      description!: string;
      photo?: Raw.TypeWebDocument;
      invoice!: Raw.TypeInvoice;
      info?: Raw.TypePaymentRequestedInfo;
      shipping?: Raw.TypeShippingOption;
      tipAmount?: long;
      currency!: string;
      totalAmount!: long;
      credentialsTitle!: string;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        date: int;
        botId: long;
        providerId: long;
        title: string;
        description: string;
        photo?: Raw.TypeWebDocument;
        invoice: Raw.TypeInvoice;
        info?: Raw.TypePaymentRequestedInfo;
        shipping?: Raw.TypeShippingOption;
        tipAmount?: long;
        currency: string;
        totalAmount: long;
        credentialsTitle: string;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'payments.PaymentReceipt';
        this.constructorId = 0x70c4fe03;
        this.subclassOfId = 0x590093c9;
        this._slots = [
          'date',
          'botId',
          'providerId',
          'title',
          'description',
          'photo',
          'invoice',
          'info',
          'shipping',
          'tipAmount',
          'currency',
          'totalAmount',
          'credentialsTitle',
          'users',
        ];
        this.date = params.date;
        this.botId = params.botId;
        this.providerId = params.providerId;
        this.title = params.title;
        this.description = params.description;
        this.photo = params.photo;
        this.invoice = params.invoice;
        this.info = params.info;
        this.shipping = params.shipping;
        this.tipAmount = params.tipAmount;
        this.currency = params.currency;
        this.totalAmount = params.totalAmount;
        this.credentialsTitle = params.credentialsTitle;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.PaymentReceipt> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let date = await Primitive.Int.read(b);
        let botId = await Primitive.Long.read(b);
        let providerId = await Primitive.Long.read(b);
        let title = await Primitive.String.read(b);
        let description = await Primitive.String.read(b);
        let photo = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let invoice = await TLObject.read(b);
        let info = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let shipping = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        let tipAmount = flags & (1 << 3) ? await Primitive.Long.read(b) : undefined;
        let currency = await Primitive.String.read(b);
        let totalAmount = await Primitive.Long.read(b);
        let credentialsTitle = await Primitive.String.read(b);
        let users = await TLObject.read(b);
        return new Raw.payments.PaymentReceipt({
          date: date,
          botId: botId,
          providerId: providerId,
          title: title,
          description: description,
          photo: photo,
          invoice: invoice,
          info: info,
          shipping: shipping,
          tipAmount: tipAmount,
          currency: currency,
          totalAmount: totalAmount,
          credentialsTitle: credentialsTitle,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.photo !== undefined ? 1 << 2 : 0;
        flags |= this.info !== undefined ? 1 << 0 : 0;
        flags |= this.shipping !== undefined ? 1 << 1 : 0;
        flags |= this.tipAmount !== undefined ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.date !== undefined) {
          b.write(Primitive.Int.write(this.date) as unknown as Buffer);
        }
        if (this.botId !== undefined) {
          b.write(Primitive.Long.write(this.botId) as unknown as Buffer);
        }
        if (this.providerId !== undefined) {
          b.write(Primitive.Long.write(this.providerId) as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.description !== undefined) {
          b.write(Primitive.String.write(this.description) as unknown as Buffer);
        }
        if (this.photo !== undefined) {
          b.write(this.photo.write() as unknown as Buffer);
        }
        if (this.invoice !== undefined) {
          b.write(this.invoice.write() as unknown as Buffer);
        }
        if (this.info !== undefined) {
          b.write(this.info.write() as unknown as Buffer);
        }
        if (this.shipping !== undefined) {
          b.write(this.shipping.write() as unknown as Buffer);
        }
        if (this.tipAmount !== undefined) {
          b.write(Primitive.Long.write(this.tipAmount) as unknown as Buffer);
        }
        if (this.currency !== undefined) {
          b.write(Primitive.String.write(this.currency) as unknown as Buffer);
        }
        if (this.totalAmount !== undefined) {
          b.write(Primitive.Long.write(this.totalAmount) as unknown as Buffer);
        }
        if (this.credentialsTitle !== undefined) {
          b.write(Primitive.String.write(this.credentialsTitle) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SavedInfo extends TLObject {
      hasSavedCredentials?: boolean;
      savedInfo?: Raw.TypePaymentRequestedInfo;

      constructor(params: {
        hasSavedCredentials?: boolean;
        savedInfo?: Raw.TypePaymentRequestedInfo;
      }) {
        super();
        this.classType = 'types';
        this.className = 'payments.SavedInfo';
        this.constructorId = 0xfb8fe43c;
        this.subclassOfId = 0xad3cf146;
        this._slots = ['hasSavedCredentials', 'savedInfo'];
        this.hasSavedCredentials = params.hasSavedCredentials;
        this.savedInfo = params.savedInfo;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.SavedInfo> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let hasSavedCredentials = flags & (1 << 1) ? true : false;
        let savedInfo = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        return new Raw.payments.SavedInfo({
          hasSavedCredentials: hasSavedCredentials,
          savedInfo: savedInfo,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.hasSavedCredentials ? 1 << 1 : 0;
        flags |= this.savedInfo !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.savedInfo !== undefined) {
          b.write(this.savedInfo.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class BankCardData extends TLObject {
      title!: string;
      openUrls!: Vector<Raw.TypeBankCardOpenUrl>;

      constructor(params: { title: string; openUrls: Vector<Raw.TypeBankCardOpenUrl> }) {
        super();
        this.classType = 'types';
        this.className = 'payments.BankCardData';
        this.constructorId = 0x3e24e573;
        this.subclassOfId = 0x8c6dd68b;
        this._slots = ['title', 'openUrls'];
        this.title = params.title;
        this.openUrls = params.openUrls;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.BankCardData> {
        // no flags

        let title = await Primitive.String.read(b);
        let openUrls = await TLObject.read(b);
        return new Raw.payments.BankCardData({ title: title, openUrls: openUrls });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.openUrls) {
          b.write(Primitive.Vector.write(this.openUrls) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportedInvoice extends TLObject {
      url!: string;

      constructor(params: { url: string }) {
        super();
        this.classType = 'types';
        this.className = 'payments.ExportedInvoice';
        this.constructorId = 0xaed0cbd9;
        this.subclassOfId = 0x36105432;
        this._slots = ['url'];
        this.url = params.url;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.ExportedInvoice> {
        // no flags

        let url = await Primitive.String.read(b);
        return new Raw.payments.ExportedInvoice({ url: url });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CheckedGiftCode extends TLObject {
      viaGiveaway?: boolean;
      fromId!: Raw.TypePeer;
      giveawayMsgId?: int;
      toId?: long;
      date!: int;
      months!: int;
      usedDate?: int;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        viaGiveaway?: boolean;
        fromId: Raw.TypePeer;
        giveawayMsgId?: int;
        toId?: long;
        date: int;
        months: int;
        usedDate?: int;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'payments.CheckedGiftCode';
        this.constructorId = 0xb722f158;
        this.subclassOfId = 0x5b2997e8;
        this._slots = [
          'viaGiveaway',
          'fromId',
          'giveawayMsgId',
          'toId',
          'date',
          'months',
          'usedDate',
          'chats',
          'users',
        ];
        this.viaGiveaway = params.viaGiveaway;
        this.fromId = params.fromId;
        this.giveawayMsgId = params.giveawayMsgId;
        this.toId = params.toId;
        this.date = params.date;
        this.months = params.months;
        this.usedDate = params.usedDate;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.CheckedGiftCode> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let viaGiveaway = flags & (1 << 2) ? true : false;
        let fromId = await TLObject.read(b);
        let giveawayMsgId = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
        let toId = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
        let date = await Primitive.Int.read(b);
        let months = await Primitive.Int.read(b);
        let usedDate = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.payments.CheckedGiftCode({
          viaGiveaway: viaGiveaway,
          fromId: fromId,
          giveawayMsgId: giveawayMsgId,
          toId: toId,
          date: date,
          months: months,
          usedDate: usedDate,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.viaGiveaway ? 1 << 2 : 0;
        flags |= this.giveawayMsgId !== undefined ? 1 << 3 : 0;
        flags |= this.toId !== undefined ? 1 << 0 : 0;
        flags |= this.usedDate !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.fromId !== undefined) {
          b.write(this.fromId.write() as unknown as Buffer);
        }
        if (this.giveawayMsgId !== undefined) {
          b.write(Primitive.Int.write(this.giveawayMsgId) as unknown as Buffer);
        }
        if (this.toId !== undefined) {
          b.write(Primitive.Long.write(this.toId) as unknown as Buffer);
        }
        if (this.date !== undefined) {
          b.write(Primitive.Int.write(this.date) as unknown as Buffer);
        }
        if (this.months !== undefined) {
          b.write(Primitive.Int.write(this.months) as unknown as Buffer);
        }
        if (this.usedDate !== undefined) {
          b.write(Primitive.Int.write(this.usedDate) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GiveawayInfo extends TLObject {
      participating?: boolean;
      preparingResults?: boolean;
      startDate!: int;
      joinedTooEarlyDate?: int;
      adminDisallowedChatId?: long;
      disallowedCountry?: string;

      constructor(params: {
        participating?: boolean;
        preparingResults?: boolean;
        startDate: int;
        joinedTooEarlyDate?: int;
        adminDisallowedChatId?: long;
        disallowedCountry?: string;
      }) {
        super();
        this.classType = 'types';
        this.className = 'payments.GiveawayInfo';
        this.constructorId = 0x4367daa0;
        this.subclassOfId = 0x96a377bd;
        this._slots = [
          'participating',
          'preparingResults',
          'startDate',
          'joinedTooEarlyDate',
          'adminDisallowedChatId',
          'disallowedCountry',
        ];
        this.participating = params.participating;
        this.preparingResults = params.preparingResults;
        this.startDate = params.startDate;
        this.joinedTooEarlyDate = params.joinedTooEarlyDate;
        this.adminDisallowedChatId = params.adminDisallowedChatId;
        this.disallowedCountry = params.disallowedCountry;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.GiveawayInfo> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let participating = flags & (1 << 0) ? true : false;
        let preparingResults = flags & (1 << 3) ? true : false;
        let startDate = await Primitive.Int.read(b);
        let joinedTooEarlyDate = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let adminDisallowedChatId = flags & (1 << 2) ? await Primitive.Long.read(b) : undefined;
        let disallowedCountry = flags & (1 << 4) ? await Primitive.String.read(b) : undefined;
        return new Raw.payments.GiveawayInfo({
          participating: participating,
          preparingResults: preparingResults,
          startDate: startDate,
          joinedTooEarlyDate: joinedTooEarlyDate,
          adminDisallowedChatId: adminDisallowedChatId,
          disallowedCountry: disallowedCountry,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.participating ? 1 << 0 : 0;
        flags |= this.preparingResults ? 1 << 3 : 0;
        flags |= this.joinedTooEarlyDate !== undefined ? 1 << 1 : 0;
        flags |= this.adminDisallowedChatId !== undefined ? 1 << 2 : 0;
        flags |= this.disallowedCountry !== undefined ? 1 << 4 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.startDate !== undefined) {
          b.write(Primitive.Int.write(this.startDate) as unknown as Buffer);
        }
        if (this.joinedTooEarlyDate !== undefined) {
          b.write(Primitive.Int.write(this.joinedTooEarlyDate) as unknown as Buffer);
        }
        if (this.adminDisallowedChatId !== undefined) {
          b.write(Primitive.Long.write(this.adminDisallowedChatId) as unknown as Buffer);
        }
        if (this.disallowedCountry !== undefined) {
          b.write(Primitive.String.write(this.disallowedCountry) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GiveawayInfoResults extends TLObject {
      winner?: boolean;
      refunded?: boolean;
      startDate!: int;
      giftCodeSlug?: string;
      finishDate!: int;
      winnersCount!: int;
      activatedCount!: int;

      constructor(params: {
        winner?: boolean;
        refunded?: boolean;
        startDate: int;
        giftCodeSlug?: string;
        finishDate: int;
        winnersCount: int;
        activatedCount: int;
      }) {
        super();
        this.classType = 'types';
        this.className = 'payments.GiveawayInfoResults';
        this.constructorId = 0xcd5570;
        this.subclassOfId = 0x96a377bd;
        this._slots = [
          'winner',
          'refunded',
          'startDate',
          'giftCodeSlug',
          'finishDate',
          'winnersCount',
          'activatedCount',
        ];
        this.winner = params.winner;
        this.refunded = params.refunded;
        this.startDate = params.startDate;
        this.giftCodeSlug = params.giftCodeSlug;
        this.finishDate = params.finishDate;
        this.winnersCount = params.winnersCount;
        this.activatedCount = params.activatedCount;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.payments.GiveawayInfoResults> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let winner = flags & (1 << 0) ? true : false;
        let refunded = flags & (1 << 1) ? true : false;
        let startDate = await Primitive.Int.read(b);
        let giftCodeSlug = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let finishDate = await Primitive.Int.read(b);
        let winnersCount = await Primitive.Int.read(b);
        let activatedCount = await Primitive.Int.read(b);
        return new Raw.payments.GiveawayInfoResults({
          winner: winner,
          refunded: refunded,
          startDate: startDate,
          giftCodeSlug: giftCodeSlug,
          finishDate: finishDate,
          winnersCount: winnersCount,
          activatedCount: activatedCount,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.winner ? 1 << 0 : 0;
        flags |= this.refunded ? 1 << 1 : 0;
        flags |= this.giftCodeSlug !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.startDate !== undefined) {
          b.write(Primitive.Int.write(this.startDate) as unknown as Buffer);
        }
        if (this.giftCodeSlug !== undefined) {
          b.write(Primitive.String.write(this.giftCodeSlug) as unknown as Buffer);
        }
        if (this.finishDate !== undefined) {
          b.write(Primitive.Int.write(this.finishDate) as unknown as Buffer);
        }
        if (this.winnersCount !== undefined) {
          b.write(Primitive.Int.write(this.winnersCount) as unknown as Buffer);
        }
        if (this.activatedCount !== undefined) {
          b.write(Primitive.Int.write(this.activatedCount) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPaymentForm extends TLObject {
      __response__!: Raw.payments.TypePaymentForm;
      invoice!: Raw.TypeInputInvoice;
      themeParams?: Raw.TypeDataJSON;

      constructor(params: { invoice: Raw.TypeInputInvoice; themeParams?: Raw.TypeDataJSON }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.GetPaymentForm';
        this.constructorId = 0x37148dbb;
        this.subclassOfId = 0xa0483f19;
        this._slots = ['invoice', 'themeParams'];
        this.invoice = params.invoice;
        this.themeParams = params.themeParams;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.GetPaymentForm> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let invoice = await TLObject.read(b);
        let themeParams = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        return new Raw.payments.GetPaymentForm({ invoice: invoice, themeParams: themeParams });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.themeParams !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.invoice !== undefined) {
          b.write(this.invoice.write() as unknown as Buffer);
        }
        if (this.themeParams !== undefined) {
          b.write(this.themeParams.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPaymentReceipt extends TLObject {
      __response__!: Raw.payments.TypePaymentReceipt;
      peer!: Raw.TypeInputPeer;
      msgId!: int;

      constructor(params: { peer: Raw.TypeInputPeer; msgId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.GetPaymentReceipt';
        this.constructorId = 0x2478d1cc;
        this.subclassOfId = 0x590093c9;
        this._slots = ['peer', 'msgId'];
        this.peer = params.peer;
        this.msgId = params.msgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.GetPaymentReceipt> {
        // no flags

        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        return new Raw.payments.GetPaymentReceipt({ peer: peer, msgId: msgId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ValidateRequestedInfo extends TLObject {
      __response__!: Raw.payments.TypeValidatedRequestedInfo;
      save?: boolean;
      invoice!: Raw.TypeInputInvoice;
      info!: Raw.TypePaymentRequestedInfo;

      constructor(params: {
        save?: boolean;
        invoice: Raw.TypeInputInvoice;
        info: Raw.TypePaymentRequestedInfo;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.ValidateRequestedInfo';
        this.constructorId = 0xb6c8f12b;
        this.subclassOfId = 0x8f8044b7;
        this._slots = ['save', 'invoice', 'info'];
        this.save = params.save;
        this.invoice = params.invoice;
        this.info = params.info;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.payments.ValidateRequestedInfo> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let save = flags & (1 << 0) ? true : false;
        let invoice = await TLObject.read(b);
        let info = await TLObject.read(b);
        return new Raw.payments.ValidateRequestedInfo({ save: save, invoice: invoice, info: info });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.save ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.invoice !== undefined) {
          b.write(this.invoice.write() as unknown as Buffer);
        }
        if (this.info !== undefined) {
          b.write(this.info.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendPaymentForm extends TLObject {
      __response__!: Raw.payments.TypePaymentResult;
      formId!: long;
      invoice!: Raw.TypeInputInvoice;
      requestedInfoId?: string;
      shippingOptionId?: string;
      credentials!: Raw.TypeInputPaymentCredentials;
      tipAmount?: long;

      constructor(params: {
        formId: long;
        invoice: Raw.TypeInputInvoice;
        requestedInfoId?: string;
        shippingOptionId?: string;
        credentials: Raw.TypeInputPaymentCredentials;
        tipAmount?: long;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.SendPaymentForm';
        this.constructorId = 0x2d03522f;
        this.subclassOfId = 0x8ae16a9d;
        this._slots = [
          'formId',
          'invoice',
          'requestedInfoId',
          'shippingOptionId',
          'credentials',
          'tipAmount',
        ];
        this.formId = params.formId;
        this.invoice = params.invoice;
        this.requestedInfoId = params.requestedInfoId;
        this.shippingOptionId = params.shippingOptionId;
        this.credentials = params.credentials;
        this.tipAmount = params.tipAmount;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.SendPaymentForm> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let formId = await Primitive.Long.read(b);
        let invoice = await TLObject.read(b);
        let requestedInfoId = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let shippingOptionId = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let credentials = await TLObject.read(b);
        let tipAmount = flags & (1 << 2) ? await Primitive.Long.read(b) : undefined;
        return new Raw.payments.SendPaymentForm({
          formId: formId,
          invoice: invoice,
          requestedInfoId: requestedInfoId,
          shippingOptionId: shippingOptionId,
          credentials: credentials,
          tipAmount: tipAmount,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.requestedInfoId !== undefined ? 1 << 0 : 0;
        flags |= this.shippingOptionId !== undefined ? 1 << 1 : 0;
        flags |= this.tipAmount !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.formId !== undefined) {
          b.write(Primitive.Long.write(this.formId) as unknown as Buffer);
        }
        if (this.invoice !== undefined) {
          b.write(this.invoice.write() as unknown as Buffer);
        }
        if (this.requestedInfoId !== undefined) {
          b.write(Primitive.String.write(this.requestedInfoId) as unknown as Buffer);
        }
        if (this.shippingOptionId !== undefined) {
          b.write(Primitive.String.write(this.shippingOptionId) as unknown as Buffer);
        }
        if (this.credentials !== undefined) {
          b.write(this.credentials.write() as unknown as Buffer);
        }
        if (this.tipAmount !== undefined) {
          b.write(Primitive.Long.write(this.tipAmount) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetSavedInfo extends TLObject {
      __response__!: Raw.payments.TypeSavedInfo;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'payments.GetSavedInfo';
        this.constructorId = 0x227d824b;
        this.subclassOfId = 0xad3cf146;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.GetSavedInfo> {
        // no flags

        return new Raw.payments.GetSavedInfo();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class ClearSavedInfo extends TLObject {
      __response__!: Bool;
      credentials?: boolean;
      info?: boolean;

      constructor(params: { credentials?: boolean; info?: boolean }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.ClearSavedInfo';
        this.constructorId = 0xd83d70c1;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['credentials', 'info'];
        this.credentials = params.credentials;
        this.info = params.info;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.ClearSavedInfo> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let credentials = flags & (1 << 0) ? true : false;
        let info = flags & (1 << 1) ? true : false;
        return new Raw.payments.ClearSavedInfo({ credentials: credentials, info: info });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.credentials ? 1 << 0 : 0;
        flags |= this.info ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        return b.buffer;
      }
    }
    export class GetBankCardData extends TLObject {
      __response__!: Raw.payments.TypeBankCardData;
      number!: string;

      constructor(params: { number: string }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.GetBankCardData';
        this.constructorId = 0x2e79d779;
        this.subclassOfId = 0x8c6dd68b;
        this._slots = ['number'];
        this.number = params.number;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.GetBankCardData> {
        // no flags

        let number = await Primitive.String.read(b);
        return new Raw.payments.GetBankCardData({ number: number });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.number !== undefined) {
          b.write(Primitive.String.write(this.number) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportInvoice extends TLObject {
      __response__!: Raw.payments.TypeExportedInvoice;
      invoiceMedia!: Raw.TypeInputMedia;

      constructor(params: { invoiceMedia: Raw.TypeInputMedia }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.ExportInvoice';
        this.constructorId = 0xf91b065;
        this.subclassOfId = 0x36105432;
        this._slots = ['invoiceMedia'];
        this.invoiceMedia = params.invoiceMedia;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.ExportInvoice> {
        // no flags

        let invoiceMedia = await TLObject.read(b);
        return new Raw.payments.ExportInvoice({ invoiceMedia: invoiceMedia });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.invoiceMedia !== undefined) {
          b.write(this.invoiceMedia.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AssignAppStoreTransaction extends TLObject {
      __response__!: Raw.TypeUpdates;
      receipt!: bytes;
      purpose!: Raw.TypeInputStorePaymentPurpose;

      constructor(params: { receipt: bytes; purpose: Raw.TypeInputStorePaymentPurpose }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.AssignAppStoreTransaction';
        this.constructorId = 0x80ed747d;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['receipt', 'purpose'];
        this.receipt = params.receipt;
        this.purpose = params.purpose;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.payments.AssignAppStoreTransaction> {
        // no flags

        let receipt = await Primitive.Bytes.read(b);
        let purpose = await TLObject.read(b);
        return new Raw.payments.AssignAppStoreTransaction({ receipt: receipt, purpose: purpose });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.receipt !== undefined) {
          b.write(Primitive.Bytes.write(this.receipt) as unknown as Buffer);
        }
        if (this.purpose !== undefined) {
          b.write(this.purpose.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AssignPlayMarketTransaction extends TLObject {
      __response__!: Raw.TypeUpdates;
      receipt!: Raw.TypeDataJSON;
      purpose!: Raw.TypeInputStorePaymentPurpose;

      constructor(params: {
        receipt: Raw.TypeDataJSON;
        purpose: Raw.TypeInputStorePaymentPurpose;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.AssignPlayMarketTransaction';
        this.constructorId = 0xdffd50d3;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['receipt', 'purpose'];
        this.receipt = params.receipt;
        this.purpose = params.purpose;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.payments.AssignPlayMarketTransaction> {
        // no flags

        let receipt = await TLObject.read(b);
        let purpose = await TLObject.read(b);
        return new Raw.payments.AssignPlayMarketTransaction({ receipt: receipt, purpose: purpose });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.receipt !== undefined) {
          b.write(this.receipt.write() as unknown as Buffer);
        }
        if (this.purpose !== undefined) {
          b.write(this.purpose.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CanPurchasePremium extends TLObject {
      __response__!: Bool;
      purpose!: Raw.TypeInputStorePaymentPurpose;

      constructor(params: { purpose: Raw.TypeInputStorePaymentPurpose }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.CanPurchasePremium';
        this.constructorId = 0x9fc19eb6;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['purpose'];
        this.purpose = params.purpose;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.CanPurchasePremium> {
        // no flags

        let purpose = await TLObject.read(b);
        return new Raw.payments.CanPurchasePremium({ purpose: purpose });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.purpose !== undefined) {
          b.write(this.purpose.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPremiumGiftCodeOptions extends TLObject {
      __response__!: Vector<Raw.TypePremiumGiftCodeOption>;
      boostPeer?: Raw.TypeInputPeer;

      constructor(params: { boostPeer?: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.GetPremiumGiftCodeOptions';
        this.constructorId = 0x2757ba54;
        this.subclassOfId = 0xaa92583;
        this._slots = ['boostPeer'];
        this.boostPeer = params.boostPeer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.payments.GetPremiumGiftCodeOptions> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let boostPeer = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        return new Raw.payments.GetPremiumGiftCodeOptions({ boostPeer: boostPeer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.boostPeer !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.boostPeer !== undefined) {
          b.write(this.boostPeer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CheckGiftCode extends TLObject {
      __response__!: Raw.payments.TypeCheckedGiftCode;
      slug!: string;

      constructor(params: { slug: string }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.CheckGiftCode';
        this.constructorId = 0x8e51b4c1;
        this.subclassOfId = 0x5b2997e8;
        this._slots = ['slug'];
        this.slug = params.slug;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.CheckGiftCode> {
        // no flags

        let slug = await Primitive.String.read(b);
        return new Raw.payments.CheckGiftCode({ slug: slug });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.slug !== undefined) {
          b.write(Primitive.String.write(this.slug) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ApplyGiftCode extends TLObject {
      __response__!: Raw.TypeUpdates;
      slug!: string;

      constructor(params: { slug: string }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.ApplyGiftCode';
        this.constructorId = 0xf6e26854;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['slug'];
        this.slug = params.slug;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.ApplyGiftCode> {
        // no flags

        let slug = await Primitive.String.read(b);
        return new Raw.payments.ApplyGiftCode({ slug: slug });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.slug !== undefined) {
          b.write(Primitive.String.write(this.slug) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetGiveawayInfo extends TLObject {
      __response__!: Raw.payments.TypeGiveawayInfo;
      peer!: Raw.TypeInputPeer;
      msgId!: int;

      constructor(params: { peer: Raw.TypeInputPeer; msgId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.GetGiveawayInfo';
        this.constructorId = 0xf4239425;
        this.subclassOfId = 0x96a377bd;
        this._slots = ['peer', 'msgId'];
        this.peer = params.peer;
        this.msgId = params.msgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.payments.GetGiveawayInfo> {
        // no flags

        let peer = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        return new Raw.payments.GetGiveawayInfo({ peer: peer, msgId: msgId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class LaunchPrepaidGiveaway extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      giveawayId!: long;
      purpose!: Raw.TypeInputStorePaymentPurpose;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        giveawayId: long;
        purpose: Raw.TypeInputStorePaymentPurpose;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'payments.LaunchPrepaidGiveaway';
        this.constructorId = 0x5ff58f20;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'giveawayId', 'purpose'];
        this.peer = params.peer;
        this.giveawayId = params.giveawayId;
        this.purpose = params.purpose;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.payments.LaunchPrepaidGiveaway> {
        // no flags

        let peer = await TLObject.read(b);
        let giveawayId = await Primitive.Long.read(b);
        let purpose = await TLObject.read(b);
        return new Raw.payments.LaunchPrepaidGiveaway({
          peer: peer,
          giveawayId: giveawayId,
          purpose: purpose,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.giveawayId !== undefined) {
          b.write(Primitive.Long.write(this.giveawayId) as unknown as Buffer);
        }
        if (this.purpose !== undefined) {
          b.write(this.purpose.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace phone {
    export type TypeGroupCallStreamRtmpUrl = Raw.phone.GroupCallStreamRtmpUrl;
    export type TypeGroupCallStreamChannels = Raw.phone.GroupCallStreamChannels;
    export type TypeExportedGroupCallInvite = Raw.phone.ExportedGroupCallInvite;
    export type TypeJoinAsPeers = Raw.phone.JoinAsPeers;
    export type TypeGroupParticipants = Raw.phone.GroupParticipants;
    export type TypeGroupCall = Raw.phone.GroupCall;
    export type TypePhoneCall = Raw.phone.PhoneCall;
    export class PhoneCall extends TLObject {
      phoneCall!: Raw.TypePhoneCall;
      users!: Vector<Raw.TypeUser>;

      constructor(params: { phoneCall: Raw.TypePhoneCall; users: Vector<Raw.TypeUser> }) {
        super();
        this.classType = 'types';
        this.className = 'phone.PhoneCall';
        this.constructorId = 0xec82e140;
        this.subclassOfId = 0xd48afe4f;
        this._slots = ['phoneCall', 'users'];
        this.phoneCall = params.phoneCall;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.PhoneCall> {
        // no flags

        let phoneCall = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.phone.PhoneCall({ phoneCall: phoneCall, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.phoneCall !== undefined) {
          b.write(this.phoneCall.write() as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GroupCall extends TLObject {
      call!: Raw.TypeGroupCall;
      participants!: Vector<Raw.TypeGroupCallParticipant>;
      participantsNextOffset!: string;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        call: Raw.TypeGroupCall;
        participants: Vector<Raw.TypeGroupCallParticipant>;
        participantsNextOffset: string;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'phone.GroupCall';
        this.constructorId = 0x9e727aad;
        this.subclassOfId = 0x304116be;
        this._slots = ['call', 'participants', 'participantsNextOffset', 'chats', 'users'];
        this.call = params.call;
        this.participants = params.participants;
        this.participantsNextOffset = params.participantsNextOffset;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.GroupCall> {
        // no flags

        let call = await TLObject.read(b);
        let participants = await TLObject.read(b);
        let participantsNextOffset = await Primitive.String.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.phone.GroupCall({
          call: call,
          participants: participants,
          participantsNextOffset: participantsNextOffset,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.participants) {
          b.write(Primitive.Vector.write(this.participants) as unknown as Buffer);
        }
        if (this.participantsNextOffset !== undefined) {
          b.write(Primitive.String.write(this.participantsNextOffset) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GroupParticipants extends TLObject {
      count!: int;
      participants!: Vector<Raw.TypeGroupCallParticipant>;
      nextOffset!: string;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;
      version!: int;

      constructor(params: {
        count: int;
        participants: Vector<Raw.TypeGroupCallParticipant>;
        nextOffset: string;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
        version: int;
      }) {
        super();
        this.classType = 'types';
        this.className = 'phone.GroupParticipants';
        this.constructorId = 0xf47751b6;
        this.subclassOfId = 0x72d304f4;
        this._slots = ['count', 'participants', 'nextOffset', 'chats', 'users', 'version'];
        this.count = params.count;
        this.participants = params.participants;
        this.nextOffset = params.nextOffset;
        this.chats = params.chats;
        this.users = params.users;
        this.version = params.version;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.GroupParticipants> {
        // no flags

        let count = await Primitive.Int.read(b);
        let participants = await TLObject.read(b);
        let nextOffset = await Primitive.String.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        let version = await Primitive.Int.read(b);
        return new Raw.phone.GroupParticipants({
          count: count,
          participants: participants,
          nextOffset: nextOffset,
          chats: chats,
          users: users,
          version: version,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.participants) {
          b.write(Primitive.Vector.write(this.participants) as unknown as Buffer);
        }
        if (this.nextOffset !== undefined) {
          b.write(Primitive.String.write(this.nextOffset) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        if (this.version !== undefined) {
          b.write(Primitive.Int.write(this.version) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class JoinAsPeers extends TLObject {
      peers!: Vector<Raw.TypePeer>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        peers: Vector<Raw.TypePeer>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'phone.JoinAsPeers';
        this.constructorId = 0xafe5623f;
        this.subclassOfId = 0xb4b770fb;
        this._slots = ['peers', 'chats', 'users'];
        this.peers = params.peers;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.JoinAsPeers> {
        // no flags

        let peers = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.phone.JoinAsPeers({ peers: peers, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peers) {
          b.write(Primitive.Vector.write(this.peers) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportedGroupCallInvite extends TLObject {
      link!: string;

      constructor(params: { link: string }) {
        super();
        this.classType = 'types';
        this.className = 'phone.ExportedGroupCallInvite';
        this.constructorId = 0x204bd158;
        this.subclassOfId = 0x3b3bfe8f;
        this._slots = ['link'];
        this.link = params.link;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.phone.ExportedGroupCallInvite> {
        // no flags

        let link = await Primitive.String.read(b);
        return new Raw.phone.ExportedGroupCallInvite({ link: link });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.link !== undefined) {
          b.write(Primitive.String.write(this.link) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GroupCallStreamChannels extends TLObject {
      channels!: Vector<Raw.TypeGroupCallStreamChannel>;

      constructor(params: { channels: Vector<Raw.TypeGroupCallStreamChannel> }) {
        super();
        this.classType = 'types';
        this.className = 'phone.GroupCallStreamChannels';
        this.constructorId = 0xd0e482b2;
        this.subclassOfId = 0x9157c5e4;
        this._slots = ['channels'];
        this.channels = params.channels;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.phone.GroupCallStreamChannels> {
        // no flags

        let channels = await TLObject.read(b);
        return new Raw.phone.GroupCallStreamChannels({ channels: channels });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channels) {
          b.write(Primitive.Vector.write(this.channels) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GroupCallStreamRtmpUrl extends TLObject {
      url!: string;
      key!: string;

      constructor(params: { url: string; key: string }) {
        super();
        this.classType = 'types';
        this.className = 'phone.GroupCallStreamRtmpUrl';
        this.constructorId = 0x2dbf3432;
        this.subclassOfId = 0xd1f515cb;
        this._slots = ['url', 'key'];
        this.url = params.url;
        this.key = params.key;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.phone.GroupCallStreamRtmpUrl> {
        // no flags

        let url = await Primitive.String.read(b);
        let key = await Primitive.String.read(b);
        return new Raw.phone.GroupCallStreamRtmpUrl({ url: url, key: key });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.url !== undefined) {
          b.write(Primitive.String.write(this.url) as unknown as Buffer);
        }
        if (this.key !== undefined) {
          b.write(Primitive.String.write(this.key) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetCallConfig extends TLObject {
      __response__!: Raw.TypeDataJSON;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'phone.GetCallConfig';
        this.constructorId = 0x55451fa9;
        this.subclassOfId = 0xad0352e8;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.GetCallConfig> {
        // no flags

        return new Raw.phone.GetCallConfig();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class RequestCall extends TLObject {
      __response__!: Raw.phone.TypePhoneCall;
      video?: boolean;
      userId!: Raw.TypeInputUser;
      randomId!: int;
      gAHash!: bytes;
      protocol!: Raw.TypePhoneCallProtocol;

      constructor(params: {
        video?: boolean;
        userId: Raw.TypeInputUser;
        randomId: int;
        gAHash: bytes;
        protocol: Raw.TypePhoneCallProtocol;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.RequestCall';
        this.constructorId = 0x42ff96ed;
        this.subclassOfId = 0xd48afe4f;
        this._slots = ['video', 'userId', 'randomId', 'gAHash', 'protocol'];
        this.video = params.video;
        this.userId = params.userId;
        this.randomId = params.randomId;
        this.gAHash = params.gAHash;
        this.protocol = params.protocol;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.RequestCall> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let video = flags & (1 << 0) ? true : false;
        let userId = await TLObject.read(b);
        let randomId = await Primitive.Int.read(b);
        let gAHash = await Primitive.Bytes.read(b);
        let protocol = await TLObject.read(b);
        return new Raw.phone.RequestCall({
          video: video,
          userId: userId,
          randomId: randomId,
          gAHash: gAHash,
          protocol: protocol,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.video ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Int.write(this.randomId) as unknown as Buffer);
        }
        if (this.gAHash !== undefined) {
          b.write(Primitive.Bytes.write(this.gAHash) as unknown as Buffer);
        }
        if (this.protocol !== undefined) {
          b.write(this.protocol.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AcceptCall extends TLObject {
      __response__!: Raw.phone.TypePhoneCall;
      peer!: Raw.TypeInputPhoneCall;
      gB!: bytes;
      protocol!: Raw.TypePhoneCallProtocol;

      constructor(params: {
        peer: Raw.TypeInputPhoneCall;
        gB: bytes;
        protocol: Raw.TypePhoneCallProtocol;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.AcceptCall';
        this.constructorId = 0x3bd2b4a0;
        this.subclassOfId = 0xd48afe4f;
        this._slots = ['peer', 'gB', 'protocol'];
        this.peer = params.peer;
        this.gB = params.gB;
        this.protocol = params.protocol;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.AcceptCall> {
        // no flags

        let peer = await TLObject.read(b);
        let gB = await Primitive.Bytes.read(b);
        let protocol = await TLObject.read(b);
        return new Raw.phone.AcceptCall({ peer: peer, gB: gB, protocol: protocol });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.gB !== undefined) {
          b.write(Primitive.Bytes.write(this.gB) as unknown as Buffer);
        }
        if (this.protocol !== undefined) {
          b.write(this.protocol.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ConfirmCall extends TLObject {
      __response__!: Raw.phone.TypePhoneCall;
      peer!: Raw.TypeInputPhoneCall;
      gA!: bytes;
      keyFingerprint!: long;
      protocol!: Raw.TypePhoneCallProtocol;

      constructor(params: {
        peer: Raw.TypeInputPhoneCall;
        gA: bytes;
        keyFingerprint: long;
        protocol: Raw.TypePhoneCallProtocol;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.ConfirmCall';
        this.constructorId = 0x2efe1722;
        this.subclassOfId = 0xd48afe4f;
        this._slots = ['peer', 'gA', 'keyFingerprint', 'protocol'];
        this.peer = params.peer;
        this.gA = params.gA;
        this.keyFingerprint = params.keyFingerprint;
        this.protocol = params.protocol;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.ConfirmCall> {
        // no flags

        let peer = await TLObject.read(b);
        let gA = await Primitive.Bytes.read(b);
        let keyFingerprint = await Primitive.Long.read(b);
        let protocol = await TLObject.read(b);
        return new Raw.phone.ConfirmCall({
          peer: peer,
          gA: gA,
          keyFingerprint: keyFingerprint,
          protocol: protocol,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.gA !== undefined) {
          b.write(Primitive.Bytes.write(this.gA) as unknown as Buffer);
        }
        if (this.keyFingerprint !== undefined) {
          b.write(Primitive.Long.write(this.keyFingerprint) as unknown as Buffer);
        }
        if (this.protocol !== undefined) {
          b.write(this.protocol.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReceivedCall extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPhoneCall;

      constructor(params: { peer: Raw.TypeInputPhoneCall }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.ReceivedCall';
        this.constructorId = 0x17d54f61;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.ReceivedCall> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.phone.ReceivedCall({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DiscardCall extends TLObject {
      __response__!: Raw.TypeUpdates;
      video?: boolean;
      peer!: Raw.TypeInputPhoneCall;
      duration!: int;
      reason!: Raw.TypePhoneCallDiscardReason;
      connectionId!: long;

      constructor(params: {
        video?: boolean;
        peer: Raw.TypeInputPhoneCall;
        duration: int;
        reason: Raw.TypePhoneCallDiscardReason;
        connectionId: long;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.DiscardCall';
        this.constructorId = 0xb2cbc1c0;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['video', 'peer', 'duration', 'reason', 'connectionId'];
        this.video = params.video;
        this.peer = params.peer;
        this.duration = params.duration;
        this.reason = params.reason;
        this.connectionId = params.connectionId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.DiscardCall> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let video = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        let duration = await Primitive.Int.read(b);
        let reason = await TLObject.read(b);
        let connectionId = await Primitive.Long.read(b);
        return new Raw.phone.DiscardCall({
          video: video,
          peer: peer,
          duration: duration,
          reason: reason,
          connectionId: connectionId,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.video ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.duration !== undefined) {
          b.write(Primitive.Int.write(this.duration) as unknown as Buffer);
        }
        if (this.reason !== undefined) {
          b.write(this.reason.write() as unknown as Buffer);
        }
        if (this.connectionId !== undefined) {
          b.write(Primitive.Long.write(this.connectionId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetCallRating extends TLObject {
      __response__!: Raw.TypeUpdates;
      userInitiative?: boolean;
      peer!: Raw.TypeInputPhoneCall;
      rating!: int;
      comment!: string;

      constructor(params: {
        userInitiative?: boolean;
        peer: Raw.TypeInputPhoneCall;
        rating: int;
        comment: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.SetCallRating';
        this.constructorId = 0x59ead627;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['userInitiative', 'peer', 'rating', 'comment'];
        this.userInitiative = params.userInitiative;
        this.peer = params.peer;
        this.rating = params.rating;
        this.comment = params.comment;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.SetCallRating> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let userInitiative = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        let rating = await Primitive.Int.read(b);
        let comment = await Primitive.String.read(b);
        return new Raw.phone.SetCallRating({
          userInitiative: userInitiative,
          peer: peer,
          rating: rating,
          comment: comment,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.userInitiative ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.rating !== undefined) {
          b.write(Primitive.Int.write(this.rating) as unknown as Buffer);
        }
        if (this.comment !== undefined) {
          b.write(Primitive.String.write(this.comment) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveCallDebug extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPhoneCall;
      debug!: Raw.TypeDataJSON;

      constructor(params: { peer: Raw.TypeInputPhoneCall; debug: Raw.TypeDataJSON }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.SaveCallDebug';
        this.constructorId = 0x277add7e;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'debug'];
        this.peer = params.peer;
        this.debug = params.debug;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.SaveCallDebug> {
        // no flags

        let peer = await TLObject.read(b);
        let debug = await TLObject.read(b);
        return new Raw.phone.SaveCallDebug({ peer: peer, debug: debug });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.debug !== undefined) {
          b.write(this.debug.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendSignalingData extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPhoneCall;
      data!: bytes;

      constructor(params: { peer: Raw.TypeInputPhoneCall; data: bytes }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.SendSignalingData';
        this.constructorId = 0xff7a9383;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'data'];
        this.peer = params.peer;
        this.data = params.data;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.SendSignalingData> {
        // no flags

        let peer = await TLObject.read(b);
        let data = await Primitive.Bytes.read(b);
        return new Raw.phone.SendSignalingData({ peer: peer, data: data });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.data !== undefined) {
          b.write(Primitive.Bytes.write(this.data) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CreateGroupCall extends TLObject {
      __response__!: Raw.TypeUpdates;
      rtmpStream?: boolean;
      peer!: Raw.TypeInputPeer;
      randomId!: int;
      title?: string;
      scheduleDate?: int;

      constructor(params: {
        rtmpStream?: boolean;
        peer: Raw.TypeInputPeer;
        randomId: int;
        title?: string;
        scheduleDate?: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.CreateGroupCall';
        this.constructorId = 0x48cdc6d8;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['rtmpStream', 'peer', 'randomId', 'title', 'scheduleDate'];
        this.rtmpStream = params.rtmpStream;
        this.peer = params.peer;
        this.randomId = params.randomId;
        this.title = params.title;
        this.scheduleDate = params.scheduleDate;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.CreateGroupCall> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let rtmpStream = flags & (1 << 2) ? true : false;
        let peer = await TLObject.read(b);
        let randomId = await Primitive.Int.read(b);
        let title = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let scheduleDate = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        return new Raw.phone.CreateGroupCall({
          rtmpStream: rtmpStream,
          peer: peer,
          randomId: randomId,
          title: title,
          scheduleDate: scheduleDate,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.rtmpStream ? 1 << 2 : 0;
        flags |= this.title !== undefined ? 1 << 0 : 0;
        flags |= this.scheduleDate !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Int.write(this.randomId) as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.scheduleDate !== undefined) {
          b.write(Primitive.Int.write(this.scheduleDate) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class JoinGroupCall extends TLObject {
      __response__!: Raw.TypeUpdates;
      muted?: boolean;
      videoStopped?: boolean;
      call!: Raw.TypeInputGroupCall;
      joinAs!: Raw.TypeInputPeer;
      inviteHash?: string;
      params!: Raw.TypeDataJSON;

      constructor(params: {
        muted?: boolean;
        videoStopped?: boolean;
        call: Raw.TypeInputGroupCall;
        joinAs: Raw.TypeInputPeer;
        inviteHash?: string;
        params: Raw.TypeDataJSON;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.JoinGroupCall';
        this.constructorId = 0xb132ff7b;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['muted', 'videoStopped', 'call', 'joinAs', 'inviteHash', 'params'];
        this.muted = params.muted;
        this.videoStopped = params.videoStopped;
        this.call = params.call;
        this.joinAs = params.joinAs;
        this.inviteHash = params.inviteHash;
        this.params = params.params;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.JoinGroupCall> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let muted = flags & (1 << 0) ? true : false;
        let videoStopped = flags & (1 << 2) ? true : false;
        let call = await TLObject.read(b);
        let joinAs = await TLObject.read(b);
        let inviteHash = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let params = await TLObject.read(b);
        return new Raw.phone.JoinGroupCall({
          muted: muted,
          videoStopped: videoStopped,
          call: call,
          joinAs: joinAs,
          inviteHash: inviteHash,
          params: params,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.muted ? 1 << 0 : 0;
        flags |= this.videoStopped ? 1 << 2 : 0;
        flags |= this.inviteHash !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.joinAs !== undefined) {
          b.write(this.joinAs.write() as unknown as Buffer);
        }
        if (this.inviteHash !== undefined) {
          b.write(Primitive.String.write(this.inviteHash) as unknown as Buffer);
        }
        if (this.params !== undefined) {
          b.write(this.params.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class LeaveGroupCall extends TLObject {
      __response__!: Raw.TypeUpdates;
      call!: Raw.TypeInputGroupCall;
      source!: int;

      constructor(params: { call: Raw.TypeInputGroupCall; source: int }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.LeaveGroupCall';
        this.constructorId = 0x500377f9;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['call', 'source'];
        this.call = params.call;
        this.source = params.source;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.LeaveGroupCall> {
        // no flags

        let call = await TLObject.read(b);
        let source = await Primitive.Int.read(b);
        return new Raw.phone.LeaveGroupCall({ call: call, source: source });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.source !== undefined) {
          b.write(Primitive.Int.write(this.source) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class InviteToGroupCall extends TLObject {
      __response__!: Raw.TypeUpdates;
      call!: Raw.TypeInputGroupCall;
      users!: Vector<Raw.TypeInputUser>;

      constructor(params: { call: Raw.TypeInputGroupCall; users: Vector<Raw.TypeInputUser> }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.InviteToGroupCall';
        this.constructorId = 0x7b393160;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['call', 'users'];
        this.call = params.call;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.InviteToGroupCall> {
        // no flags

        let call = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.phone.InviteToGroupCall({ call: call, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DiscardGroupCall extends TLObject {
      __response__!: Raw.TypeUpdates;
      call!: Raw.TypeInputGroupCall;

      constructor(params: { call: Raw.TypeInputGroupCall }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.DiscardGroupCall';
        this.constructorId = 0x7a777135;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['call'];
        this.call = params.call;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.DiscardGroupCall> {
        // no flags

        let call = await TLObject.read(b);
        return new Raw.phone.DiscardGroupCall({ call: call });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleGroupCallSettings extends TLObject {
      __response__!: Raw.TypeUpdates;
      resetInviteHash?: boolean;
      call!: Raw.TypeInputGroupCall;
      joinMuted?: Bool;

      constructor(params: {
        resetInviteHash?: boolean;
        call: Raw.TypeInputGroupCall;
        joinMuted?: Bool;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.ToggleGroupCallSettings';
        this.constructorId = 0x74bbb43d;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['resetInviteHash', 'call', 'joinMuted'];
        this.resetInviteHash = params.resetInviteHash;
        this.call = params.call;
        this.joinMuted = params.joinMuted;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.phone.ToggleGroupCallSettings> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let resetInviteHash = flags & (1 << 1) ? true : false;
        let call = await TLObject.read(b);
        let joinMuted = flags & (1 << 0) ? await Primitive.Bool.read(b) : undefined;
        return new Raw.phone.ToggleGroupCallSettings({
          resetInviteHash: resetInviteHash,
          call: call,
          joinMuted: joinMuted,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.resetInviteHash ? 1 << 1 : 0;
        flags |= this.joinMuted !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.joinMuted !== undefined) {
          b.write(Primitive.Bool.write(this.joinMuted) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetGroupCall extends TLObject {
      __response__!: Raw.phone.TypeGroupCall;
      call!: Raw.TypeInputGroupCall;
      limit!: int;

      constructor(params: { call: Raw.TypeInputGroupCall; limit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.GetGroupCall';
        this.constructorId = 0x41845db;
        this.subclassOfId = 0x304116be;
        this._slots = ['call', 'limit'];
        this.call = params.call;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.GetGroupCall> {
        // no flags

        let call = await TLObject.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.phone.GetGroupCall({ call: call, limit: limit });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetGroupParticipants extends TLObject {
      __response__!: Raw.phone.TypeGroupParticipants;
      call!: Raw.TypeInputGroupCall;
      ids!: Vector<Raw.TypeInputPeer>;
      sources!: Vector<int>;
      offset!: string;
      limit!: int;

      constructor(params: {
        call: Raw.TypeInputGroupCall;
        ids: Vector<Raw.TypeInputPeer>;
        sources: Vector<int>;
        offset: string;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.GetGroupParticipants';
        this.constructorId = 0xc558d8ab;
        this.subclassOfId = 0x72d304f4;
        this._slots = ['call', 'ids', 'sources', 'offset', 'limit'];
        this.call = params.call;
        this.ids = params.ids;
        this.sources = params.sources;
        this.offset = params.offset;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.GetGroupParticipants> {
        // no flags

        let call = await TLObject.read(b);
        let ids = await TLObject.read(b);
        let sources = await TLObject.read(b, Primitive.Int);
        let offset = await Primitive.String.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.phone.GetGroupParticipants({
          call: call,
          ids: ids,
          sources: sources,
          offset: offset,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.ids) {
          b.write(Primitive.Vector.write(this.ids) as unknown as Buffer);
        }
        if (this.sources) {
          b.write(Primitive.Vector.write(this.sources, Primitive.Int) as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.String.write(this.offset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CheckGroupCall extends TLObject {
      __response__!: Vector<int>;
      call!: Raw.TypeInputGroupCall;
      sources!: Vector<int>;

      constructor(params: { call: Raw.TypeInputGroupCall; sources: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.CheckGroupCall';
        this.constructorId = 0xb59cf977;
        this.subclassOfId = 0x5026710f;
        this._slots = ['call', 'sources'];
        this.call = params.call;
        this.sources = params.sources;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.CheckGroupCall> {
        // no flags

        let call = await TLObject.read(b);
        let sources = await TLObject.read(b, Primitive.Int);
        return new Raw.phone.CheckGroupCall({ call: call, sources: sources });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.sources) {
          b.write(Primitive.Vector.write(this.sources, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleGroupCallRecord extends TLObject {
      __response__!: Raw.TypeUpdates;
      start?: boolean;
      video?: boolean;
      call!: Raw.TypeInputGroupCall;
      title?: string;
      videoPortrait?: Bool;

      constructor(params: {
        start?: boolean;
        video?: boolean;
        call: Raw.TypeInputGroupCall;
        title?: string;
        videoPortrait?: Bool;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.ToggleGroupCallRecord';
        this.constructorId = 0xf128c708;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['start', 'video', 'call', 'title', 'videoPortrait'];
        this.start = params.start;
        this.video = params.video;
        this.call = params.call;
        this.title = params.title;
        this.videoPortrait = params.videoPortrait;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.ToggleGroupCallRecord> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let start = flags & (1 << 0) ? true : false;
        let video = flags & (1 << 2) ? true : false;
        let call = await TLObject.read(b);
        let title = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let videoPortrait = flags & (1 << 2) ? await Primitive.Bool.read(b) : undefined;
        return new Raw.phone.ToggleGroupCallRecord({
          start: start,
          video: video,
          call: call,
          title: title,
          videoPortrait: videoPortrait,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.start ? 1 << 0 : 0;
        flags |= this.video ? 1 << 2 : 0;
        flags |= this.title !== undefined ? 1 << 1 : 0;
        flags |= this.videoPortrait !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.videoPortrait !== undefined) {
          b.write(Primitive.Bool.write(this.videoPortrait) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditGroupCallParticipant extends TLObject {
      __response__!: Raw.TypeUpdates;
      call!: Raw.TypeInputGroupCall;
      participant!: Raw.TypeInputPeer;
      muted?: Bool;
      volume?: int;
      raiseHand?: Bool;
      videoStopped?: Bool;
      videoPaused?: Bool;
      presentationPaused?: Bool;

      constructor(params: {
        call: Raw.TypeInputGroupCall;
        participant: Raw.TypeInputPeer;
        muted?: Bool;
        volume?: int;
        raiseHand?: Bool;
        videoStopped?: Bool;
        videoPaused?: Bool;
        presentationPaused?: Bool;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.EditGroupCallParticipant';
        this.constructorId = 0xa5273abf;
        this.subclassOfId = 0x8af52aac;
        this._slots = [
          'call',
          'participant',
          'muted',
          'volume',
          'raiseHand',
          'videoStopped',
          'videoPaused',
          'presentationPaused',
        ];
        this.call = params.call;
        this.participant = params.participant;
        this.muted = params.muted;
        this.volume = params.volume;
        this.raiseHand = params.raiseHand;
        this.videoStopped = params.videoStopped;
        this.videoPaused = params.videoPaused;
        this.presentationPaused = params.presentationPaused;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.phone.EditGroupCallParticipant> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let call = await TLObject.read(b);
        let participant = await TLObject.read(b);
        let muted = flags & (1 << 0) ? await Primitive.Bool.read(b) : undefined;
        let volume = flags & (1 << 1) ? await Primitive.Int.read(b) : undefined;
        let raiseHand = flags & (1 << 2) ? await Primitive.Bool.read(b) : undefined;
        let videoStopped = flags & (1 << 3) ? await Primitive.Bool.read(b) : undefined;
        let videoPaused = flags & (1 << 4) ? await Primitive.Bool.read(b) : undefined;
        let presentationPaused = flags & (1 << 5) ? await Primitive.Bool.read(b) : undefined;
        return new Raw.phone.EditGroupCallParticipant({
          call: call,
          participant: participant,
          muted: muted,
          volume: volume,
          raiseHand: raiseHand,
          videoStopped: videoStopped,
          videoPaused: videoPaused,
          presentationPaused: presentationPaused,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.muted !== undefined ? 1 << 0 : 0;
        flags |= this.volume !== undefined ? 1 << 1 : 0;
        flags |= this.raiseHand !== undefined ? 1 << 2 : 0;
        flags |= this.videoStopped !== undefined ? 1 << 3 : 0;
        flags |= this.videoPaused !== undefined ? 1 << 4 : 0;
        flags |= this.presentationPaused !== undefined ? 1 << 5 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.participant !== undefined) {
          b.write(this.participant.write() as unknown as Buffer);
        }
        if (this.muted !== undefined) {
          b.write(Primitive.Bool.write(this.muted) as unknown as Buffer);
        }
        if (this.volume !== undefined) {
          b.write(Primitive.Int.write(this.volume) as unknown as Buffer);
        }
        if (this.raiseHand !== undefined) {
          b.write(Primitive.Bool.write(this.raiseHand) as unknown as Buffer);
        }
        if (this.videoStopped !== undefined) {
          b.write(Primitive.Bool.write(this.videoStopped) as unknown as Buffer);
        }
        if (this.videoPaused !== undefined) {
          b.write(Primitive.Bool.write(this.videoPaused) as unknown as Buffer);
        }
        if (this.presentationPaused !== undefined) {
          b.write(Primitive.Bool.write(this.presentationPaused) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditGroupCallTitle extends TLObject {
      __response__!: Raw.TypeUpdates;
      call!: Raw.TypeInputGroupCall;
      title!: string;

      constructor(params: { call: Raw.TypeInputGroupCall; title: string }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.EditGroupCallTitle';
        this.constructorId = 0x1ca6ac0a;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['call', 'title'];
        this.call = params.call;
        this.title = params.title;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.EditGroupCallTitle> {
        // no flags

        let call = await TLObject.read(b);
        let title = await Primitive.String.read(b);
        return new Raw.phone.EditGroupCallTitle({ call: call, title: title });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetGroupCallJoinAs extends TLObject {
      __response__!: Raw.phone.TypeJoinAsPeers;
      peer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.GetGroupCallJoinAs';
        this.constructorId = 0xef7c213a;
        this.subclassOfId = 0xb4b770fb;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.GetGroupCallJoinAs> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.phone.GetGroupCallJoinAs({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportGroupCallInvite extends TLObject {
      __response__!: Raw.phone.TypeExportedGroupCallInvite;
      canSelfUnmute?: boolean;
      call!: Raw.TypeInputGroupCall;

      constructor(params: { canSelfUnmute?: boolean; call: Raw.TypeInputGroupCall }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.ExportGroupCallInvite';
        this.constructorId = 0xe6aa647f;
        this.subclassOfId = 0x3b3bfe8f;
        this._slots = ['canSelfUnmute', 'call'];
        this.canSelfUnmute = params.canSelfUnmute;
        this.call = params.call;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.ExportGroupCallInvite> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let canSelfUnmute = flags & (1 << 0) ? true : false;
        let call = await TLObject.read(b);
        return new Raw.phone.ExportGroupCallInvite({ canSelfUnmute: canSelfUnmute, call: call });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.canSelfUnmute ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleGroupCallStartSubscription extends TLObject {
      __response__!: Raw.TypeUpdates;
      call!: Raw.TypeInputGroupCall;
      subscribed!: Bool;

      constructor(params: { call: Raw.TypeInputGroupCall; subscribed: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.ToggleGroupCallStartSubscription';
        this.constructorId = 0x219c34e6;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['call', 'subscribed'];
        this.call = params.call;
        this.subscribed = params.subscribed;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.phone.ToggleGroupCallStartSubscription> {
        // no flags

        let call = await TLObject.read(b);
        let subscribed = await Primitive.Bool.read(b);
        return new Raw.phone.ToggleGroupCallStartSubscription({
          call: call,
          subscribed: subscribed,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.subscribed !== undefined) {
          b.write(Primitive.Bool.write(this.subscribed) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class StartScheduledGroupCall extends TLObject {
      __response__!: Raw.TypeUpdates;
      call!: Raw.TypeInputGroupCall;

      constructor(params: { call: Raw.TypeInputGroupCall }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.StartScheduledGroupCall';
        this.constructorId = 0x5680e342;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['call'];
        this.call = params.call;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.phone.StartScheduledGroupCall> {
        // no flags

        let call = await TLObject.read(b);
        return new Raw.phone.StartScheduledGroupCall({ call: call });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveDefaultGroupCallJoinAs extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      joinAs!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer; joinAs: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.SaveDefaultGroupCallJoinAs';
        this.constructorId = 0x575e1f8c;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'joinAs'];
        this.peer = params.peer;
        this.joinAs = params.joinAs;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.phone.SaveDefaultGroupCallJoinAs> {
        // no flags

        let peer = await TLObject.read(b);
        let joinAs = await TLObject.read(b);
        return new Raw.phone.SaveDefaultGroupCallJoinAs({ peer: peer, joinAs: joinAs });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.joinAs !== undefined) {
          b.write(this.joinAs.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class JoinGroupCallPresentation extends TLObject {
      __response__!: Raw.TypeUpdates;
      call!: Raw.TypeInputGroupCall;
      params!: Raw.TypeDataJSON;

      constructor(params: { call: Raw.TypeInputGroupCall; params: Raw.TypeDataJSON }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.JoinGroupCallPresentation';
        this.constructorId = 0xcbea6bc4;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['call', 'params'];
        this.call = params.call;
        this.params = params.params;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.phone.JoinGroupCallPresentation> {
        // no flags

        let call = await TLObject.read(b);
        let params = await TLObject.read(b);
        return new Raw.phone.JoinGroupCallPresentation({ call: call, params: params });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        if (this.params !== undefined) {
          b.write(this.params.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class LeaveGroupCallPresentation extends TLObject {
      __response__!: Raw.TypeUpdates;
      call!: Raw.TypeInputGroupCall;

      constructor(params: { call: Raw.TypeInputGroupCall }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.LeaveGroupCallPresentation';
        this.constructorId = 0x1c50d144;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['call'];
        this.call = params.call;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.phone.LeaveGroupCallPresentation> {
        // no flags

        let call = await TLObject.read(b);
        return new Raw.phone.LeaveGroupCallPresentation({ call: call });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetGroupCallStreamChannels extends TLObject {
      __response__!: Raw.phone.TypeGroupCallStreamChannels;
      call!: Raw.TypeInputGroupCall;

      constructor(params: { call: Raw.TypeInputGroupCall }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.GetGroupCallStreamChannels';
        this.constructorId = 0x1ab21940;
        this.subclassOfId = 0x9157c5e4;
        this._slots = ['call'];
        this.call = params.call;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.phone.GetGroupCallStreamChannels> {
        // no flags

        let call = await TLObject.read(b);
        return new Raw.phone.GetGroupCallStreamChannels({ call: call });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.call !== undefined) {
          b.write(this.call.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetGroupCallStreamRtmpUrl extends TLObject {
      __response__!: Raw.phone.TypeGroupCallStreamRtmpUrl;
      peer!: Raw.TypeInputPeer;
      revoke!: Bool;

      constructor(params: { peer: Raw.TypeInputPeer; revoke: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.GetGroupCallStreamRtmpUrl';
        this.constructorId = 0xdeb3abbf;
        this.subclassOfId = 0xd1f515cb;
        this._slots = ['peer', 'revoke'];
        this.peer = params.peer;
        this.revoke = params.revoke;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.phone.GetGroupCallStreamRtmpUrl> {
        // no flags

        let peer = await TLObject.read(b);
        let revoke = await Primitive.Bool.read(b);
        return new Raw.phone.GetGroupCallStreamRtmpUrl({ peer: peer, revoke: revoke });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.revoke !== undefined) {
          b.write(Primitive.Bool.write(this.revoke) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SaveCallLog extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPhoneCall;
      file!: Raw.TypeInputFile;

      constructor(params: { peer: Raw.TypeInputPhoneCall; file: Raw.TypeInputFile }) {
        super();
        this.classType = 'functions';
        this.className = 'phone.SaveCallLog';
        this.constructorId = 0x41248786;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'file'];
        this.peer = params.peer;
        this.file = params.file;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.phone.SaveCallLog> {
        // no flags

        let peer = await TLObject.read(b);
        let file = await TLObject.read(b);
        return new Raw.phone.SaveCallLog({ peer: peer, file: file });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.file !== undefined) {
          b.write(this.file.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace stats {
    export type TypeMessageStats = Raw.stats.MessageStats;
    export type TypeMegagroupStats = Raw.stats.MegagroupStats;
    export type TypeBroadcastStats = Raw.stats.BroadcastStats;
    export class BroadcastStats extends TLObject {
      period!: Raw.TypeStatsDateRangeDays;
      followers!: Raw.TypeStatsAbsValueAndPrev;
      viewsPerPost!: Raw.TypeStatsAbsValueAndPrev;
      sharesPerPost!: Raw.TypeStatsAbsValueAndPrev;
      enabledNotifications!: Raw.TypeStatsPercentValue;
      growthGraph!: Raw.TypeStatsGraph;
      followersGraph!: Raw.TypeStatsGraph;
      muteGraph!: Raw.TypeStatsGraph;
      topHoursGraph!: Raw.TypeStatsGraph;
      interactionsGraph!: Raw.TypeStatsGraph;
      ivInteractionsGraph!: Raw.TypeStatsGraph;
      viewsBySourceGraph!: Raw.TypeStatsGraph;
      newFollowersBySourceGraph!: Raw.TypeStatsGraph;
      languagesGraph!: Raw.TypeStatsGraph;
      recentMessageInteractions!: Vector<Raw.TypeMessageInteractionCounters>;

      constructor(params: {
        period: Raw.TypeStatsDateRangeDays;
        followers: Raw.TypeStatsAbsValueAndPrev;
        viewsPerPost: Raw.TypeStatsAbsValueAndPrev;
        sharesPerPost: Raw.TypeStatsAbsValueAndPrev;
        enabledNotifications: Raw.TypeStatsPercentValue;
        growthGraph: Raw.TypeStatsGraph;
        followersGraph: Raw.TypeStatsGraph;
        muteGraph: Raw.TypeStatsGraph;
        topHoursGraph: Raw.TypeStatsGraph;
        interactionsGraph: Raw.TypeStatsGraph;
        ivInteractionsGraph: Raw.TypeStatsGraph;
        viewsBySourceGraph: Raw.TypeStatsGraph;
        newFollowersBySourceGraph: Raw.TypeStatsGraph;
        languagesGraph: Raw.TypeStatsGraph;
        recentMessageInteractions: Vector<Raw.TypeMessageInteractionCounters>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'stats.BroadcastStats';
        this.constructorId = 0xbdf78394;
        this.subclassOfId = 0x7ff25428;
        this._slots = [
          'period',
          'followers',
          'viewsPerPost',
          'sharesPerPost',
          'enabledNotifications',
          'growthGraph',
          'followersGraph',
          'muteGraph',
          'topHoursGraph',
          'interactionsGraph',
          'ivInteractionsGraph',
          'viewsBySourceGraph',
          'newFollowersBySourceGraph',
          'languagesGraph',
          'recentMessageInteractions',
        ];
        this.period = params.period;
        this.followers = params.followers;
        this.viewsPerPost = params.viewsPerPost;
        this.sharesPerPost = params.sharesPerPost;
        this.enabledNotifications = params.enabledNotifications;
        this.growthGraph = params.growthGraph;
        this.followersGraph = params.followersGraph;
        this.muteGraph = params.muteGraph;
        this.topHoursGraph = params.topHoursGraph;
        this.interactionsGraph = params.interactionsGraph;
        this.ivInteractionsGraph = params.ivInteractionsGraph;
        this.viewsBySourceGraph = params.viewsBySourceGraph;
        this.newFollowersBySourceGraph = params.newFollowersBySourceGraph;
        this.languagesGraph = params.languagesGraph;
        this.recentMessageInteractions = params.recentMessageInteractions;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stats.BroadcastStats> {
        // no flags

        let period = await TLObject.read(b);
        let followers = await TLObject.read(b);
        let viewsPerPost = await TLObject.read(b);
        let sharesPerPost = await TLObject.read(b);
        let enabledNotifications = await TLObject.read(b);
        let growthGraph = await TLObject.read(b);
        let followersGraph = await TLObject.read(b);
        let muteGraph = await TLObject.read(b);
        let topHoursGraph = await TLObject.read(b);
        let interactionsGraph = await TLObject.read(b);
        let ivInteractionsGraph = await TLObject.read(b);
        let viewsBySourceGraph = await TLObject.read(b);
        let newFollowersBySourceGraph = await TLObject.read(b);
        let languagesGraph = await TLObject.read(b);
        let recentMessageInteractions = await TLObject.read(b);
        return new Raw.stats.BroadcastStats({
          period: period,
          followers: followers,
          viewsPerPost: viewsPerPost,
          sharesPerPost: sharesPerPost,
          enabledNotifications: enabledNotifications,
          growthGraph: growthGraph,
          followersGraph: followersGraph,
          muteGraph: muteGraph,
          topHoursGraph: topHoursGraph,
          interactionsGraph: interactionsGraph,
          ivInteractionsGraph: ivInteractionsGraph,
          viewsBySourceGraph: viewsBySourceGraph,
          newFollowersBySourceGraph: newFollowersBySourceGraph,
          languagesGraph: languagesGraph,
          recentMessageInteractions: recentMessageInteractions,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.period !== undefined) {
          b.write(this.period.write() as unknown as Buffer);
        }
        if (this.followers !== undefined) {
          b.write(this.followers.write() as unknown as Buffer);
        }
        if (this.viewsPerPost !== undefined) {
          b.write(this.viewsPerPost.write() as unknown as Buffer);
        }
        if (this.sharesPerPost !== undefined) {
          b.write(this.sharesPerPost.write() as unknown as Buffer);
        }
        if (this.enabledNotifications !== undefined) {
          b.write(this.enabledNotifications.write() as unknown as Buffer);
        }
        if (this.growthGraph !== undefined) {
          b.write(this.growthGraph.write() as unknown as Buffer);
        }
        if (this.followersGraph !== undefined) {
          b.write(this.followersGraph.write() as unknown as Buffer);
        }
        if (this.muteGraph !== undefined) {
          b.write(this.muteGraph.write() as unknown as Buffer);
        }
        if (this.topHoursGraph !== undefined) {
          b.write(this.topHoursGraph.write() as unknown as Buffer);
        }
        if (this.interactionsGraph !== undefined) {
          b.write(this.interactionsGraph.write() as unknown as Buffer);
        }
        if (this.ivInteractionsGraph !== undefined) {
          b.write(this.ivInteractionsGraph.write() as unknown as Buffer);
        }
        if (this.viewsBySourceGraph !== undefined) {
          b.write(this.viewsBySourceGraph.write() as unknown as Buffer);
        }
        if (this.newFollowersBySourceGraph !== undefined) {
          b.write(this.newFollowersBySourceGraph.write() as unknown as Buffer);
        }
        if (this.languagesGraph !== undefined) {
          b.write(this.languagesGraph.write() as unknown as Buffer);
        }
        if (this.recentMessageInteractions) {
          b.write(Primitive.Vector.write(this.recentMessageInteractions) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class MegagroupStats extends TLObject {
      period!: Raw.TypeStatsDateRangeDays;
      members!: Raw.TypeStatsAbsValueAndPrev;
      messages!: Raw.TypeStatsAbsValueAndPrev;
      viewers!: Raw.TypeStatsAbsValueAndPrev;
      posters!: Raw.TypeStatsAbsValueAndPrev;
      growthGraph!: Raw.TypeStatsGraph;
      membersGraph!: Raw.TypeStatsGraph;
      newMembersBySourceGraph!: Raw.TypeStatsGraph;
      languagesGraph!: Raw.TypeStatsGraph;
      messagesGraph!: Raw.TypeStatsGraph;
      actionsGraph!: Raw.TypeStatsGraph;
      topHoursGraph!: Raw.TypeStatsGraph;
      weekdaysGraph!: Raw.TypeStatsGraph;
      topPosters!: Vector<Raw.TypeStatsGroupTopPoster>;
      topAdmins!: Vector<Raw.TypeStatsGroupTopAdmin>;
      topInviters!: Vector<Raw.TypeStatsGroupTopInviter>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        period: Raw.TypeStatsDateRangeDays;
        members: Raw.TypeStatsAbsValueAndPrev;
        messages: Raw.TypeStatsAbsValueAndPrev;
        viewers: Raw.TypeStatsAbsValueAndPrev;
        posters: Raw.TypeStatsAbsValueAndPrev;
        growthGraph: Raw.TypeStatsGraph;
        membersGraph: Raw.TypeStatsGraph;
        newMembersBySourceGraph: Raw.TypeStatsGraph;
        languagesGraph: Raw.TypeStatsGraph;
        messagesGraph: Raw.TypeStatsGraph;
        actionsGraph: Raw.TypeStatsGraph;
        topHoursGraph: Raw.TypeStatsGraph;
        weekdaysGraph: Raw.TypeStatsGraph;
        topPosters: Vector<Raw.TypeStatsGroupTopPoster>;
        topAdmins: Vector<Raw.TypeStatsGroupTopAdmin>;
        topInviters: Vector<Raw.TypeStatsGroupTopInviter>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'stats.MegagroupStats';
        this.constructorId = 0xef7ff916;
        this.subclassOfId = 0x5b59be8d;
        this._slots = [
          'period',
          'members',
          'messages',
          'viewers',
          'posters',
          'growthGraph',
          'membersGraph',
          'newMembersBySourceGraph',
          'languagesGraph',
          'messagesGraph',
          'actionsGraph',
          'topHoursGraph',
          'weekdaysGraph',
          'topPosters',
          'topAdmins',
          'topInviters',
          'users',
        ];
        this.period = params.period;
        this.members = params.members;
        this.messages = params.messages;
        this.viewers = params.viewers;
        this.posters = params.posters;
        this.growthGraph = params.growthGraph;
        this.membersGraph = params.membersGraph;
        this.newMembersBySourceGraph = params.newMembersBySourceGraph;
        this.languagesGraph = params.languagesGraph;
        this.messagesGraph = params.messagesGraph;
        this.actionsGraph = params.actionsGraph;
        this.topHoursGraph = params.topHoursGraph;
        this.weekdaysGraph = params.weekdaysGraph;
        this.topPosters = params.topPosters;
        this.topAdmins = params.topAdmins;
        this.topInviters = params.topInviters;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stats.MegagroupStats> {
        // no flags

        let period = await TLObject.read(b);
        let members = await TLObject.read(b);
        let messages = await TLObject.read(b);
        let viewers = await TLObject.read(b);
        let posters = await TLObject.read(b);
        let growthGraph = await TLObject.read(b);
        let membersGraph = await TLObject.read(b);
        let newMembersBySourceGraph = await TLObject.read(b);
        let languagesGraph = await TLObject.read(b);
        let messagesGraph = await TLObject.read(b);
        let actionsGraph = await TLObject.read(b);
        let topHoursGraph = await TLObject.read(b);
        let weekdaysGraph = await TLObject.read(b);
        let topPosters = await TLObject.read(b);
        let topAdmins = await TLObject.read(b);
        let topInviters = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.stats.MegagroupStats({
          period: period,
          members: members,
          messages: messages,
          viewers: viewers,
          posters: posters,
          growthGraph: growthGraph,
          membersGraph: membersGraph,
          newMembersBySourceGraph: newMembersBySourceGraph,
          languagesGraph: languagesGraph,
          messagesGraph: messagesGraph,
          actionsGraph: actionsGraph,
          topHoursGraph: topHoursGraph,
          weekdaysGraph: weekdaysGraph,
          topPosters: topPosters,
          topAdmins: topAdmins,
          topInviters: topInviters,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.period !== undefined) {
          b.write(this.period.write() as unknown as Buffer);
        }
        if (this.members !== undefined) {
          b.write(this.members.write() as unknown as Buffer);
        }
        if (this.messages !== undefined) {
          b.write(this.messages.write() as unknown as Buffer);
        }
        if (this.viewers !== undefined) {
          b.write(this.viewers.write() as unknown as Buffer);
        }
        if (this.posters !== undefined) {
          b.write(this.posters.write() as unknown as Buffer);
        }
        if (this.growthGraph !== undefined) {
          b.write(this.growthGraph.write() as unknown as Buffer);
        }
        if (this.membersGraph !== undefined) {
          b.write(this.membersGraph.write() as unknown as Buffer);
        }
        if (this.newMembersBySourceGraph !== undefined) {
          b.write(this.newMembersBySourceGraph.write() as unknown as Buffer);
        }
        if (this.languagesGraph !== undefined) {
          b.write(this.languagesGraph.write() as unknown as Buffer);
        }
        if (this.messagesGraph !== undefined) {
          b.write(this.messagesGraph.write() as unknown as Buffer);
        }
        if (this.actionsGraph !== undefined) {
          b.write(this.actionsGraph.write() as unknown as Buffer);
        }
        if (this.topHoursGraph !== undefined) {
          b.write(this.topHoursGraph.write() as unknown as Buffer);
        }
        if (this.weekdaysGraph !== undefined) {
          b.write(this.weekdaysGraph.write() as unknown as Buffer);
        }
        if (this.topPosters) {
          b.write(Primitive.Vector.write(this.topPosters) as unknown as Buffer);
        }
        if (this.topAdmins) {
          b.write(Primitive.Vector.write(this.topAdmins) as unknown as Buffer);
        }
        if (this.topInviters) {
          b.write(Primitive.Vector.write(this.topInviters) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class MessageStats extends TLObject {
      viewsGraph!: Raw.TypeStatsGraph;

      constructor(params: { viewsGraph: Raw.TypeStatsGraph }) {
        super();
        this.classType = 'types';
        this.className = 'stats.MessageStats';
        this.constructorId = 0x8999f295;
        this.subclassOfId = 0x9604a322;
        this._slots = ['viewsGraph'];
        this.viewsGraph = params.viewsGraph;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stats.MessageStats> {
        // no flags

        let viewsGraph = await TLObject.read(b);
        return new Raw.stats.MessageStats({ viewsGraph: viewsGraph });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.viewsGraph !== undefined) {
          b.write(this.viewsGraph.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetBroadcastStats extends TLObject {
      __response__!: Raw.stats.TypeBroadcastStats;
      dark?: boolean;
      channel!: Raw.TypeInputChannel;

      constructor(params: { dark?: boolean; channel: Raw.TypeInputChannel }) {
        super();
        this.classType = 'functions';
        this.className = 'stats.GetBroadcastStats';
        this.constructorId = 0xab42441a;
        this.subclassOfId = 0x7ff25428;
        this._slots = ['dark', 'channel'];
        this.dark = params.dark;
        this.channel = params.channel;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stats.GetBroadcastStats> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let dark = flags & (1 << 0) ? true : false;
        let channel = await TLObject.read(b);
        return new Raw.stats.GetBroadcastStats({ dark: dark, channel: channel });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.dark ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class LoadAsyncGraph extends TLObject {
      __response__!: Raw.TypeStatsGraph;
      token!: string;
      x?: long;

      constructor(params: { token: string; x?: long }) {
        super();
        this.classType = 'functions';
        this.className = 'stats.LoadAsyncGraph';
        this.constructorId = 0x621d5fa0;
        this.subclassOfId = 0x9b903153;
        this._slots = ['token', 'x'];
        this.token = params.token;
        this.x = params.x;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stats.LoadAsyncGraph> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let token = await Primitive.String.read(b);
        let x = flags & (1 << 0) ? await Primitive.Long.read(b) : undefined;
        return new Raw.stats.LoadAsyncGraph({ token: token, x: x });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.x !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.token !== undefined) {
          b.write(Primitive.String.write(this.token) as unknown as Buffer);
        }
        if (this.x !== undefined) {
          b.write(Primitive.Long.write(this.x) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetMegagroupStats extends TLObject {
      __response__!: Raw.stats.TypeMegagroupStats;
      dark?: boolean;
      channel!: Raw.TypeInputChannel;

      constructor(params: { dark?: boolean; channel: Raw.TypeInputChannel }) {
        super();
        this.classType = 'functions';
        this.className = 'stats.GetMegagroupStats';
        this.constructorId = 0xdcdf8607;
        this.subclassOfId = 0x5b59be8d;
        this._slots = ['dark', 'channel'];
        this.dark = params.dark;
        this.channel = params.channel;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stats.GetMegagroupStats> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let dark = flags & (1 << 0) ? true : false;
        let channel = await TLObject.read(b);
        return new Raw.stats.GetMegagroupStats({ dark: dark, channel: channel });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.dark ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetMessagePublicForwards extends TLObject {
      __response__!: Raw.messages.TypeMessages;
      channel!: Raw.TypeInputChannel;
      msgId!: int;
      offsetRate!: int;
      offsetPeer!: Raw.TypeInputPeer;
      offsetId!: int;
      limit!: int;

      constructor(params: {
        channel: Raw.TypeInputChannel;
        msgId: int;
        offsetRate: int;
        offsetPeer: Raw.TypeInputPeer;
        offsetId: int;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'stats.GetMessagePublicForwards';
        this.constructorId = 0x5630281b;
        this.subclassOfId = 0xd4b40b5e;
        this._slots = ['channel', 'msgId', 'offsetRate', 'offsetPeer', 'offsetId', 'limit'];
        this.channel = params.channel;
        this.msgId = params.msgId;
        this.offsetRate = params.offsetRate;
        this.offsetPeer = params.offsetPeer;
        this.offsetId = params.offsetId;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.stats.GetMessagePublicForwards> {
        // no flags

        let channel = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        let offsetRate = await Primitive.Int.read(b);
        let offsetPeer = await TLObject.read(b);
        let offsetId = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.stats.GetMessagePublicForwards({
          channel: channel,
          msgId: msgId,
          offsetRate: offsetRate,
          offsetPeer: offsetPeer,
          offsetId: offsetId,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        if (this.offsetRate !== undefined) {
          b.write(Primitive.Int.write(this.offsetRate) as unknown as Buffer);
        }
        if (this.offsetPeer !== undefined) {
          b.write(this.offsetPeer.write() as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetMessageStats extends TLObject {
      __response__!: Raw.stats.TypeMessageStats;
      dark?: boolean;
      channel!: Raw.TypeInputChannel;
      msgId!: int;

      constructor(params: { dark?: boolean; channel: Raw.TypeInputChannel; msgId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'stats.GetMessageStats';
        this.constructorId = 0xb6e0a3f5;
        this.subclassOfId = 0x9604a322;
        this._slots = ['dark', 'channel', 'msgId'];
        this.dark = params.dark;
        this.channel = params.channel;
        this.msgId = params.msgId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stats.GetMessageStats> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let dark = flags & (1 << 0) ? true : false;
        let channel = await TLObject.read(b);
        let msgId = await Primitive.Int.read(b);
        return new Raw.stats.GetMessageStats({ dark: dark, channel: channel, msgId: msgId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.dark ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.channel !== undefined) {
          b.write(this.channel.write() as unknown as Buffer);
        }
        if (this.msgId !== undefined) {
          b.write(Primitive.Int.write(this.msgId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace stickers {
    export type TypeSuggestedShortName = Raw.stickers.SuggestedShortName;
    export class SuggestedShortName extends TLObject {
      shortName!: string;

      constructor(params: { shortName: string }) {
        super();
        this.classType = 'types';
        this.className = 'stickers.SuggestedShortName';
        this.constructorId = 0x85fea03f;
        this.subclassOfId = 0xc44a4b21;
        this._slots = ['shortName'];
        this.shortName = params.shortName;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stickers.SuggestedShortName> {
        // no flags

        let shortName = await Primitive.String.read(b);
        return new Raw.stickers.SuggestedShortName({ shortName: shortName });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.shortName !== undefined) {
          b.write(Primitive.String.write(this.shortName) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CreateStickerSet extends TLObject {
      __response__!: Raw.messages.TypeStickerSet;
      masks?: boolean;
      animated?: boolean;
      videos?: boolean;
      emojis?: boolean;
      textColor?: boolean;
      userId!: Raw.TypeInputUser;
      title!: string;
      shortName!: string;
      thumb?: Raw.TypeInputDocument;
      stickers!: Vector<Raw.TypeInputStickerSetItem>;
      software?: string;

      constructor(params: {
        masks?: boolean;
        animated?: boolean;
        videos?: boolean;
        emojis?: boolean;
        textColor?: boolean;
        userId: Raw.TypeInputUser;
        title: string;
        shortName: string;
        thumb?: Raw.TypeInputDocument;
        stickers: Vector<Raw.TypeInputStickerSetItem>;
        software?: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'stickers.CreateStickerSet';
        this.constructorId = 0x9021ab67;
        this.subclassOfId = 0x9b704a5a;
        this._slots = [
          'masks',
          'animated',
          'videos',
          'emojis',
          'textColor',
          'userId',
          'title',
          'shortName',
          'thumb',
          'stickers',
          'software',
        ];
        this.masks = params.masks;
        this.animated = params.animated;
        this.videos = params.videos;
        this.emojis = params.emojis;
        this.textColor = params.textColor;
        this.userId = params.userId;
        this.title = params.title;
        this.shortName = params.shortName;
        this.thumb = params.thumb;
        this.stickers = params.stickers;
        this.software = params.software;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stickers.CreateStickerSet> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let masks = flags & (1 << 0) ? true : false;
        let animated = flags & (1 << 1) ? true : false;
        let videos = flags & (1 << 4) ? true : false;
        let emojis = flags & (1 << 5) ? true : false;
        let textColor = flags & (1 << 6) ? true : false;
        let userId = await TLObject.read(b);
        let title = await Primitive.String.read(b);
        let shortName = await Primitive.String.read(b);
        let thumb = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let stickers = await TLObject.read(b);
        let software = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
        return new Raw.stickers.CreateStickerSet({
          masks: masks,
          animated: animated,
          videos: videos,
          emojis: emojis,
          textColor: textColor,
          userId: userId,
          title: title,
          shortName: shortName,
          thumb: thumb,
          stickers: stickers,
          software: software,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.masks ? 1 << 0 : 0;
        flags |= this.animated ? 1 << 1 : 0;
        flags |= this.videos ? 1 << 4 : 0;
        flags |= this.emojis ? 1 << 5 : 0;
        flags |= this.textColor ? 1 << 6 : 0;
        flags |= this.thumb !== undefined ? 1 << 2 : 0;
        flags |= this.software !== undefined ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.shortName !== undefined) {
          b.write(Primitive.String.write(this.shortName) as unknown as Buffer);
        }
        if (this.thumb !== undefined) {
          b.write(this.thumb.write() as unknown as Buffer);
        }
        if (this.stickers) {
          b.write(Primitive.Vector.write(this.stickers) as unknown as Buffer);
        }
        if (this.software !== undefined) {
          b.write(Primitive.String.write(this.software) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RemoveStickerFromSet extends TLObject {
      __response__!: Raw.messages.TypeStickerSet;
      sticker!: Raw.TypeInputDocument;

      constructor(params: { sticker: Raw.TypeInputDocument }) {
        super();
        this.classType = 'functions';
        this.className = 'stickers.RemoveStickerFromSet';
        this.constructorId = 0xf7760f51;
        this.subclassOfId = 0x9b704a5a;
        this._slots = ['sticker'];
        this.sticker = params.sticker;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.stickers.RemoveStickerFromSet> {
        // no flags

        let sticker = await TLObject.read(b);
        return new Raw.stickers.RemoveStickerFromSet({ sticker: sticker });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.sticker !== undefined) {
          b.write(this.sticker.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChangeStickerPosition extends TLObject {
      __response__!: Raw.messages.TypeStickerSet;
      sticker!: Raw.TypeInputDocument;
      position!: int;

      constructor(params: { sticker: Raw.TypeInputDocument; position: int }) {
        super();
        this.classType = 'functions';
        this.className = 'stickers.ChangeStickerPosition';
        this.constructorId = 0xffb6d4ca;
        this.subclassOfId = 0x9b704a5a;
        this._slots = ['sticker', 'position'];
        this.sticker = params.sticker;
        this.position = params.position;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.stickers.ChangeStickerPosition> {
        // no flags

        let sticker = await TLObject.read(b);
        let position = await Primitive.Int.read(b);
        return new Raw.stickers.ChangeStickerPosition({ sticker: sticker, position: position });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.sticker !== undefined) {
          b.write(this.sticker.write() as unknown as Buffer);
        }
        if (this.position !== undefined) {
          b.write(Primitive.Int.write(this.position) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AddStickerToSet extends TLObject {
      __response__!: Raw.messages.TypeStickerSet;
      stickerset!: Raw.TypeInputStickerSet;
      sticker!: Raw.TypeInputStickerSetItem;

      constructor(params: {
        stickerset: Raw.TypeInputStickerSet;
        sticker: Raw.TypeInputStickerSetItem;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'stickers.AddStickerToSet';
        this.constructorId = 0x8653febe;
        this.subclassOfId = 0x9b704a5a;
        this._slots = ['stickerset', 'sticker'];
        this.stickerset = params.stickerset;
        this.sticker = params.sticker;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stickers.AddStickerToSet> {
        // no flags

        let stickerset = await TLObject.read(b);
        let sticker = await TLObject.read(b);
        return new Raw.stickers.AddStickerToSet({ stickerset: stickerset, sticker: sticker });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.stickerset !== undefined) {
          b.write(this.stickerset.write() as unknown as Buffer);
        }
        if (this.sticker !== undefined) {
          b.write(this.sticker.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetStickerSetThumb extends TLObject {
      __response__!: Raw.messages.TypeStickerSet;
      stickerset!: Raw.TypeInputStickerSet;
      thumb?: Raw.TypeInputDocument;
      thumbDocumentId?: long;

      constructor(params: {
        stickerset: Raw.TypeInputStickerSet;
        thumb?: Raw.TypeInputDocument;
        thumbDocumentId?: long;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'stickers.SetStickerSetThumb';
        this.constructorId = 0xa76a5392;
        this.subclassOfId = 0x9b704a5a;
        this._slots = ['stickerset', 'thumb', 'thumbDocumentId'];
        this.stickerset = params.stickerset;
        this.thumb = params.thumb;
        this.thumbDocumentId = params.thumbDocumentId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stickers.SetStickerSetThumb> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let stickerset = await TLObject.read(b);
        let thumb = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let thumbDocumentId = flags & (1 << 1) ? await Primitive.Long.read(b) : undefined;
        return new Raw.stickers.SetStickerSetThumb({
          stickerset: stickerset,
          thumb: thumb,
          thumbDocumentId: thumbDocumentId,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.thumb !== undefined ? 1 << 0 : 0;
        flags |= this.thumbDocumentId !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.stickerset !== undefined) {
          b.write(this.stickerset.write() as unknown as Buffer);
        }
        if (this.thumb !== undefined) {
          b.write(this.thumb.write() as unknown as Buffer);
        }
        if (this.thumbDocumentId !== undefined) {
          b.write(Primitive.Long.write(this.thumbDocumentId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CheckShortName extends TLObject {
      __response__!: Bool;
      shortName!: string;

      constructor(params: { shortName: string }) {
        super();
        this.classType = 'functions';
        this.className = 'stickers.CheckShortName';
        this.constructorId = 0x284b3639;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['shortName'];
        this.shortName = params.shortName;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stickers.CheckShortName> {
        // no flags

        let shortName = await Primitive.String.read(b);
        return new Raw.stickers.CheckShortName({ shortName: shortName });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.shortName !== undefined) {
          b.write(Primitive.String.write(this.shortName) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SuggestShortName extends TLObject {
      __response__!: Raw.stickers.TypeSuggestedShortName;
      title!: string;

      constructor(params: { title: string }) {
        super();
        this.classType = 'functions';
        this.className = 'stickers.SuggestShortName';
        this.constructorId = 0x4dafc503;
        this.subclassOfId = 0xc44a4b21;
        this._slots = ['title'];
        this.title = params.title;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stickers.SuggestShortName> {
        // no flags

        let title = await Primitive.String.read(b);
        return new Raw.stickers.SuggestShortName({ title: title });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChangeSticker extends TLObject {
      __response__!: Raw.messages.TypeStickerSet;
      sticker!: Raw.TypeInputDocument;
      emoji?: string;
      maskCoords?: Raw.TypeMaskCoords;
      keywords?: string;

      constructor(params: {
        sticker: Raw.TypeInputDocument;
        emoji?: string;
        maskCoords?: Raw.TypeMaskCoords;
        keywords?: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'stickers.ChangeSticker';
        this.constructorId = 0xf5537ebc;
        this.subclassOfId = 0x9b704a5a;
        this._slots = ['sticker', 'emoji', 'maskCoords', 'keywords'];
        this.sticker = params.sticker;
        this.emoji = params.emoji;
        this.maskCoords = params.maskCoords;
        this.keywords = params.keywords;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stickers.ChangeSticker> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let sticker = await TLObject.read(b);
        let emoji = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let maskCoords = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        let keywords = flags & (1 << 2) ? await Primitive.String.read(b) : undefined;
        return new Raw.stickers.ChangeSticker({
          sticker: sticker,
          emoji: emoji,
          maskCoords: maskCoords,
          keywords: keywords,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.emoji !== undefined ? 1 << 0 : 0;
        flags |= this.maskCoords !== undefined ? 1 << 1 : 0;
        flags |= this.keywords !== undefined ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.sticker !== undefined) {
          b.write(this.sticker.write() as unknown as Buffer);
        }
        if (this.emoji !== undefined) {
          b.write(Primitive.String.write(this.emoji) as unknown as Buffer);
        }
        if (this.maskCoords !== undefined) {
          b.write(this.maskCoords.write() as unknown as Buffer);
        }
        if (this.keywords !== undefined) {
          b.write(Primitive.String.write(this.keywords) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class RenameStickerSet extends TLObject {
      __response__!: Raw.messages.TypeStickerSet;
      stickerset!: Raw.TypeInputStickerSet;
      title!: string;

      constructor(params: { stickerset: Raw.TypeInputStickerSet; title: string }) {
        super();
        this.classType = 'functions';
        this.className = 'stickers.RenameStickerSet';
        this.constructorId = 0x124b1c00;
        this.subclassOfId = 0x9b704a5a;
        this._slots = ['stickerset', 'title'];
        this.stickerset = params.stickerset;
        this.title = params.title;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stickers.RenameStickerSet> {
        // no flags

        let stickerset = await TLObject.read(b);
        let title = await Primitive.String.read(b);
        return new Raw.stickers.RenameStickerSet({ stickerset: stickerset, title: title });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.stickerset !== undefined) {
          b.write(this.stickerset.write() as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteStickerSet extends TLObject {
      __response__!: Bool;
      stickerset!: Raw.TypeInputStickerSet;

      constructor(params: { stickerset: Raw.TypeInputStickerSet }) {
        super();
        this.classType = 'functions';
        this.className = 'stickers.DeleteStickerSet';
        this.constructorId = 0x87704394;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['stickerset'];
        this.stickerset = params.stickerset;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stickers.DeleteStickerSet> {
        // no flags

        let stickerset = await TLObject.read(b);
        return new Raw.stickers.DeleteStickerSet({ stickerset: stickerset });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.stickerset !== undefined) {
          b.write(this.stickerset.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace users {
    export type TypeUserFull = Raw.users.UserFull;
    export class UserFull extends TLObject {
      fullUser!: Raw.TypeUserFull;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        fullUser: Raw.TypeUserFull;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'users.UserFull';
        this.constructorId = 0x3b6d152e;
        this.subclassOfId = 0x83df9df5;
        this._slots = ['fullUser', 'chats', 'users'];
        this.fullUser = params.fullUser;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.users.UserFull> {
        // no flags

        let fullUser = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.users.UserFull({ fullUser: fullUser, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.fullUser !== undefined) {
          b.write(this.fullUser.write() as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetUsers extends TLObject {
      __response__!: Vector<Raw.TypeUser>;
      id!: Vector<Raw.TypeInputUser>;

      constructor(params: { id: Vector<Raw.TypeInputUser> }) {
        super();
        this.classType = 'functions';
        this.className = 'users.GetUsers';
        this.constructorId = 0xd91a548;
        this.subclassOfId = 0x406da4d;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.users.GetUsers> {
        // no flags

        let id = await TLObject.read(b);
        return new Raw.users.GetUsers({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id) {
          b.write(Primitive.Vector.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetFullUser extends TLObject {
      __response__!: Raw.users.TypeUserFull;
      id!: Raw.TypeInputUser;

      constructor(params: { id: Raw.TypeInputUser }) {
        super();
        this.classType = 'functions';
        this.className = 'users.GetFullUser';
        this.constructorId = 0xb60f5918;
        this.subclassOfId = 0x83df9df5;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.users.GetFullUser> {
        // no flags

        let id = await TLObject.read(b);
        return new Raw.users.GetFullUser({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetSecureValueErrors extends TLObject {
      __response__!: Bool;
      id!: Raw.TypeInputUser;
      errors!: Vector<Raw.TypeSecureValueError>;

      constructor(params: { id: Raw.TypeInputUser; errors: Vector<Raw.TypeSecureValueError> }) {
        super();
        this.classType = 'functions';
        this.className = 'users.SetSecureValueErrors';
        this.constructorId = 0x90c894b5;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['id', 'errors'];
        this.id = params.id;
        this.errors = params.errors;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.users.SetSecureValueErrors> {
        // no flags

        let id = await TLObject.read(b);
        let errors = await TLObject.read(b);
        return new Raw.users.SetSecureValueErrors({ id: id, errors: errors });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id !== undefined) {
          b.write(this.id.write() as unknown as Buffer);
        }
        if (this.errors) {
          b.write(Primitive.Vector.write(this.errors) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace chatlists {
    export type TypeChatlistUpdates = Raw.chatlists.ChatlistUpdates;
    export type TypeChatlistInvite =
      | Raw.chatlists.ChatlistInviteAlready
      | Raw.chatlists.ChatlistInvite;
    export type TypeExportedInvites = Raw.chatlists.ExportedInvites;
    export type TypeExportedChatlistInvite = Raw.chatlists.ExportedChatlistInvite;
    export class ExportedChatlistInvite extends TLObject {
      filter!: Raw.TypeDialogFilter;
      invite!: Raw.TypeExportedChatlistInvite;

      constructor(params: {
        filter: Raw.TypeDialogFilter;
        invite: Raw.TypeExportedChatlistInvite;
      }) {
        super();
        this.classType = 'types';
        this.className = 'chatlists.ExportedChatlistInvite';
        this.constructorId = 0x10e6e3a6;
        this.subclassOfId = 0xc2694ee9;
        this._slots = ['filter', 'invite'];
        this.filter = params.filter;
        this.invite = params.invite;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.chatlists.ExportedChatlistInvite> {
        // no flags

        let filter = await TLObject.read(b);
        let invite = await TLObject.read(b);
        return new Raw.chatlists.ExportedChatlistInvite({ filter: filter, invite: invite });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.filter !== undefined) {
          b.write(this.filter.write() as unknown as Buffer);
        }
        if (this.invite !== undefined) {
          b.write(this.invite.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportedInvites extends TLObject {
      invites!: Vector<Raw.TypeExportedChatlistInvite>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        invites: Vector<Raw.TypeExportedChatlistInvite>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'chatlists.ExportedInvites';
        this.constructorId = 0x10ab6dc7;
        this.subclassOfId = 0xe6c209c0;
        this._slots = ['invites', 'chats', 'users'];
        this.invites = params.invites;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.chatlists.ExportedInvites> {
        // no flags

        let invites = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.chatlists.ExportedInvites({ invites: invites, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.invites) {
          b.write(Primitive.Vector.write(this.invites) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChatlistInviteAlready extends TLObject {
      filterId!: int;
      missingPeers!: Vector<Raw.TypePeer>;
      alreadyPeers!: Vector<Raw.TypePeer>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        filterId: int;
        missingPeers: Vector<Raw.TypePeer>;
        alreadyPeers: Vector<Raw.TypePeer>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'chatlists.ChatlistInviteAlready';
        this.constructorId = 0xfa87f659;
        this.subclassOfId = 0x41720e75;
        this._slots = ['filterId', 'missingPeers', 'alreadyPeers', 'chats', 'users'];
        this.filterId = params.filterId;
        this.missingPeers = params.missingPeers;
        this.alreadyPeers = params.alreadyPeers;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.chatlists.ChatlistInviteAlready> {
        // no flags

        let filterId = await Primitive.Int.read(b);
        let missingPeers = await TLObject.read(b);
        let alreadyPeers = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.chatlists.ChatlistInviteAlready({
          filterId: filterId,
          missingPeers: missingPeers,
          alreadyPeers: alreadyPeers,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.filterId !== undefined) {
          b.write(Primitive.Int.write(this.filterId) as unknown as Buffer);
        }
        if (this.missingPeers) {
          b.write(Primitive.Vector.write(this.missingPeers) as unknown as Buffer);
        }
        if (this.alreadyPeers) {
          b.write(Primitive.Vector.write(this.alreadyPeers) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChatlistInvite extends TLObject {
      title!: string;
      emoticon?: string;
      peers!: Vector<Raw.TypePeer>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        title: string;
        emoticon?: string;
        peers: Vector<Raw.TypePeer>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'chatlists.ChatlistInvite';
        this.constructorId = 0x1dcd839d;
        this.subclassOfId = 0x41720e75;
        this._slots = ['title', 'emoticon', 'peers', 'chats', 'users'];
        this.title = params.title;
        this.emoticon = params.emoticon;
        this.peers = params.peers;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.chatlists.ChatlistInvite> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let title = await Primitive.String.read(b);
        let emoticon = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let peers = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.chatlists.ChatlistInvite({
          title: title,
          emoticon: emoticon,
          peers: peers,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.emoticon !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.emoticon !== undefined) {
          b.write(Primitive.String.write(this.emoticon) as unknown as Buffer);
        }
        if (this.peers) {
          b.write(Primitive.Vector.write(this.peers) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ChatlistUpdates extends TLObject {
      missingPeers!: Vector<Raw.TypePeer>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        missingPeers: Vector<Raw.TypePeer>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'chatlists.ChatlistUpdates';
        this.constructorId = 0x93bd878d;
        this.subclassOfId = 0x7d1641ea;
        this._slots = ['missingPeers', 'chats', 'users'];
        this.missingPeers = params.missingPeers;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.chatlists.ChatlistUpdates> {
        // no flags

        let missingPeers = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.chatlists.ChatlistUpdates({
          missingPeers: missingPeers,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.missingPeers) {
          b.write(Primitive.Vector.write(this.missingPeers) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportChatlistInvite extends TLObject {
      __response__!: Raw.chatlists.TypeExportedChatlistInvite;
      chatlist!: Raw.TypeInputChatlist;
      title!: string;
      peers!: Vector<Raw.TypeInputPeer>;

      constructor(params: {
        chatlist: Raw.TypeInputChatlist;
        title: string;
        peers: Vector<Raw.TypeInputPeer>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'chatlists.ExportChatlistInvite';
        this.constructorId = 0x8472478e;
        this.subclassOfId = 0xc2694ee9;
        this._slots = ['chatlist', 'title', 'peers'];
        this.chatlist = params.chatlist;
        this.title = params.title;
        this.peers = params.peers;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.chatlists.ExportChatlistInvite> {
        // no flags

        let chatlist = await TLObject.read(b);
        let title = await Primitive.String.read(b);
        let peers = await TLObject.read(b);
        return new Raw.chatlists.ExportChatlistInvite({
          chatlist: chatlist,
          title: title,
          peers: peers,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatlist !== undefined) {
          b.write(this.chatlist.write() as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.peers) {
          b.write(Primitive.Vector.write(this.peers) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteExportedInvite extends TLObject {
      __response__!: Bool;
      chatlist!: Raw.TypeInputChatlist;
      slug!: string;

      constructor(params: { chatlist: Raw.TypeInputChatlist; slug: string }) {
        super();
        this.classType = 'functions';
        this.className = 'chatlists.DeleteExportedInvite';
        this.constructorId = 0x719c5c5e;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['chatlist', 'slug'];
        this.chatlist = params.chatlist;
        this.slug = params.slug;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.chatlists.DeleteExportedInvite> {
        // no flags

        let chatlist = await TLObject.read(b);
        let slug = await Primitive.String.read(b);
        return new Raw.chatlists.DeleteExportedInvite({ chatlist: chatlist, slug: slug });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatlist !== undefined) {
          b.write(this.chatlist.write() as unknown as Buffer);
        }
        if (this.slug !== undefined) {
          b.write(Primitive.String.write(this.slug) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditExportedInvite extends TLObject {
      __response__!: Raw.TypeExportedChatlistInvite;
      chatlist!: Raw.TypeInputChatlist;
      slug!: string;
      title?: string;
      peers?: Vector<Raw.TypeInputPeer>;

      constructor(params: {
        chatlist: Raw.TypeInputChatlist;
        slug: string;
        title?: string;
        peers?: Vector<Raw.TypeInputPeer>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'chatlists.EditExportedInvite';
        this.constructorId = 0x653db63d;
        this.subclassOfId = 0x7711f8ff;
        this._slots = ['chatlist', 'slug', 'title', 'peers'];
        this.chatlist = params.chatlist;
        this.slug = params.slug;
        this.title = params.title;
        this.peers = params.peers;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.chatlists.EditExportedInvite> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let chatlist = await TLObject.read(b);
        let slug = await Primitive.String.read(b);
        let title = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let peers = flags & (1 << 2) ? await TLObject.read(b) : [];
        return new Raw.chatlists.EditExportedInvite({
          chatlist: chatlist,
          slug: slug,
          title: title,
          peers: peers,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.title !== undefined ? 1 << 1 : 0;
        flags |= this.peers ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.chatlist !== undefined) {
          b.write(this.chatlist.write() as unknown as Buffer);
        }
        if (this.slug !== undefined) {
          b.write(Primitive.String.write(this.slug) as unknown as Buffer);
        }
        if (this.title !== undefined) {
          b.write(Primitive.String.write(this.title) as unknown as Buffer);
        }
        if (this.peers) {
          b.write(Primitive.Vector.write(this.peers) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetExportedInvites extends TLObject {
      __response__!: Raw.chatlists.TypeExportedInvites;
      chatlist!: Raw.TypeInputChatlist;

      constructor(params: { chatlist: Raw.TypeInputChatlist }) {
        super();
        this.classType = 'functions';
        this.className = 'chatlists.GetExportedInvites';
        this.constructorId = 0xce03da83;
        this.subclassOfId = 0xe6c209c0;
        this._slots = ['chatlist'];
        this.chatlist = params.chatlist;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.chatlists.GetExportedInvites> {
        // no flags

        let chatlist = await TLObject.read(b);
        return new Raw.chatlists.GetExportedInvites({ chatlist: chatlist });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatlist !== undefined) {
          b.write(this.chatlist.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CheckChatlistInvite extends TLObject {
      __response__!: Raw.chatlists.TypeChatlistInvite;
      slug!: string;

      constructor(params: { slug: string }) {
        super();
        this.classType = 'functions';
        this.className = 'chatlists.CheckChatlistInvite';
        this.constructorId = 0x41c10fff;
        this.subclassOfId = 0x41720e75;
        this._slots = ['slug'];
        this.slug = params.slug;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.chatlists.CheckChatlistInvite> {
        // no flags

        let slug = await Primitive.String.read(b);
        return new Raw.chatlists.CheckChatlistInvite({ slug: slug });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.slug !== undefined) {
          b.write(Primitive.String.write(this.slug) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class JoinChatlistInvite extends TLObject {
      __response__!: Raw.TypeUpdates;
      slug!: string;
      peers!: Vector<Raw.TypeInputPeer>;

      constructor(params: { slug: string; peers: Vector<Raw.TypeInputPeer> }) {
        super();
        this.classType = 'functions';
        this.className = 'chatlists.JoinChatlistInvite';
        this.constructorId = 0xa6b1e39a;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['slug', 'peers'];
        this.slug = params.slug;
        this.peers = params.peers;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.chatlists.JoinChatlistInvite> {
        // no flags

        let slug = await Primitive.String.read(b);
        let peers = await TLObject.read(b);
        return new Raw.chatlists.JoinChatlistInvite({ slug: slug, peers: peers });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.slug !== undefined) {
          b.write(Primitive.String.write(this.slug) as unknown as Buffer);
        }
        if (this.peers) {
          b.write(Primitive.Vector.write(this.peers) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetChatlistUpdates extends TLObject {
      __response__!: Raw.chatlists.TypeChatlistUpdates;
      chatlist!: Raw.TypeInputChatlist;

      constructor(params: { chatlist: Raw.TypeInputChatlist }) {
        super();
        this.classType = 'functions';
        this.className = 'chatlists.GetChatlistUpdates';
        this.constructorId = 0x89419521;
        this.subclassOfId = 0x7d1641ea;
        this._slots = ['chatlist'];
        this.chatlist = params.chatlist;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.chatlists.GetChatlistUpdates> {
        // no flags

        let chatlist = await TLObject.read(b);
        return new Raw.chatlists.GetChatlistUpdates({ chatlist: chatlist });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatlist !== undefined) {
          b.write(this.chatlist.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class JoinChatlistUpdates extends TLObject {
      __response__!: Raw.TypeUpdates;
      chatlist!: Raw.TypeInputChatlist;
      peers!: Vector<Raw.TypeInputPeer>;

      constructor(params: { chatlist: Raw.TypeInputChatlist; peers: Vector<Raw.TypeInputPeer> }) {
        super();
        this.classType = 'functions';
        this.className = 'chatlists.JoinChatlistUpdates';
        this.constructorId = 0xe089f8f5;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['chatlist', 'peers'];
        this.chatlist = params.chatlist;
        this.peers = params.peers;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.chatlists.JoinChatlistUpdates> {
        // no flags

        let chatlist = await TLObject.read(b);
        let peers = await TLObject.read(b);
        return new Raw.chatlists.JoinChatlistUpdates({ chatlist: chatlist, peers: peers });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatlist !== undefined) {
          b.write(this.chatlist.write() as unknown as Buffer);
        }
        if (this.peers) {
          b.write(Primitive.Vector.write(this.peers) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class HideChatlistUpdates extends TLObject {
      __response__!: Bool;
      chatlist!: Raw.TypeInputChatlist;

      constructor(params: { chatlist: Raw.TypeInputChatlist }) {
        super();
        this.classType = 'functions';
        this.className = 'chatlists.HideChatlistUpdates';
        this.constructorId = 0x66e486fb;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['chatlist'];
        this.chatlist = params.chatlist;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.chatlists.HideChatlistUpdates> {
        // no flags

        let chatlist = await TLObject.read(b);
        return new Raw.chatlists.HideChatlistUpdates({ chatlist: chatlist });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatlist !== undefined) {
          b.write(this.chatlist.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetLeaveChatlistSuggestions extends TLObject {
      __response__!: Vector<Raw.TypePeer>;
      chatlist!: Raw.TypeInputChatlist;

      constructor(params: { chatlist: Raw.TypeInputChatlist }) {
        super();
        this.classType = 'functions';
        this.className = 'chatlists.GetLeaveChatlistSuggestions';
        this.constructorId = 0xfdbcd714;
        this.subclassOfId = 0xb9945d7e;
        this._slots = ['chatlist'];
        this.chatlist = params.chatlist;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.chatlists.GetLeaveChatlistSuggestions> {
        // no flags

        let chatlist = await TLObject.read(b);
        return new Raw.chatlists.GetLeaveChatlistSuggestions({ chatlist: chatlist });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatlist !== undefined) {
          b.write(this.chatlist.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class LeaveChatlist extends TLObject {
      __response__!: Raw.TypeUpdates;
      chatlist!: Raw.TypeInputChatlist;
      peers!: Vector<Raw.TypeInputPeer>;

      constructor(params: { chatlist: Raw.TypeInputChatlist; peers: Vector<Raw.TypeInputPeer> }) {
        super();
        this.classType = 'functions';
        this.className = 'chatlists.LeaveChatlist';
        this.constructorId = 0x74fae13a;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['chatlist', 'peers'];
        this.chatlist = params.chatlist;
        this.peers = params.peers;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.chatlists.LeaveChatlist> {
        // no flags

        let chatlist = await TLObject.read(b);
        let peers = await TLObject.read(b);
        return new Raw.chatlists.LeaveChatlist({ chatlist: chatlist, peers: peers });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.chatlist !== undefined) {
          b.write(this.chatlist.write() as unknown as Buffer);
        }
        if (this.peers) {
          b.write(Primitive.Vector.write(this.peers) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace bots {
    export type TypeBotInfo = Raw.bots.BotInfo;
    export class BotInfo extends TLObject {
      name!: string;
      about!: string;
      description!: string;

      constructor(params: { name: string; about: string; description: string }) {
        super();
        this.classType = 'types';
        this.className = 'bots.BotInfo';
        this.constructorId = 0xe8a775b0;
        this.subclassOfId = 0xca7b2235;
        this._slots = ['name', 'about', 'description'];
        this.name = params.name;
        this.about = params.about;
        this.description = params.description;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.BotInfo> {
        // no flags

        let name = await Primitive.String.read(b);
        let about = await Primitive.String.read(b);
        let description = await Primitive.String.read(b);
        return new Raw.bots.BotInfo({ name: name, about: about, description: description });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.name !== undefined) {
          b.write(Primitive.String.write(this.name) as unknown as Buffer);
        }
        if (this.about !== undefined) {
          b.write(Primitive.String.write(this.about) as unknown as Buffer);
        }
        if (this.description !== undefined) {
          b.write(Primitive.String.write(this.description) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendCustomRequest extends TLObject {
      __response__!: Raw.TypeDataJSON;
      customMethod!: string;
      params!: Raw.TypeDataJSON;

      constructor(params: { customMethod: string; params: Raw.TypeDataJSON }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.SendCustomRequest';
        this.constructorId = 0xaa2769ed;
        this.subclassOfId = 0xad0352e8;
        this._slots = ['customMethod', 'params'];
        this.customMethod = params.customMethod;
        this.params = params.params;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.SendCustomRequest> {
        // no flags

        let customMethod = await Primitive.String.read(b);
        let params = await TLObject.read(b);
        return new Raw.bots.SendCustomRequest({ customMethod: customMethod, params: params });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.customMethod !== undefined) {
          b.write(Primitive.String.write(this.customMethod) as unknown as Buffer);
        }
        if (this.params !== undefined) {
          b.write(this.params.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AnswerWebhookJSONQuery extends TLObject {
      __response__!: Bool;
      queryId!: long;
      data!: Raw.TypeDataJSON;

      constructor(params: { queryId: long; data: Raw.TypeDataJSON }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.AnswerWebhookJSONQuery';
        this.constructorId = 0xe6213f4d;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['queryId', 'data'];
        this.queryId = params.queryId;
        this.data = params.data;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.AnswerWebhookJSONQuery> {
        // no flags

        let queryId = await Primitive.Long.read(b);
        let data = await TLObject.read(b);
        return new Raw.bots.AnswerWebhookJSONQuery({ queryId: queryId, data: data });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.queryId !== undefined) {
          b.write(Primitive.Long.write(this.queryId) as unknown as Buffer);
        }
        if (this.data !== undefined) {
          b.write(this.data.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetBotCommands extends TLObject {
      __response__!: Bool;
      scope!: Raw.TypeBotCommandScope;
      langCode!: string;
      commands!: Vector<Raw.TypeBotCommand>;

      constructor(params: {
        scope: Raw.TypeBotCommandScope;
        langCode: string;
        commands: Vector<Raw.TypeBotCommand>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.SetBotCommands';
        this.constructorId = 0x517165a;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['scope', 'langCode', 'commands'];
        this.scope = params.scope;
        this.langCode = params.langCode;
        this.commands = params.commands;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.SetBotCommands> {
        // no flags

        let scope = await TLObject.read(b);
        let langCode = await Primitive.String.read(b);
        let commands = await TLObject.read(b);
        return new Raw.bots.SetBotCommands({
          scope: scope,
          langCode: langCode,
          commands: commands,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.scope !== undefined) {
          b.write(this.scope.write() as unknown as Buffer);
        }
        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        if (this.commands) {
          b.write(Primitive.Vector.write(this.commands) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ResetBotCommands extends TLObject {
      __response__!: Bool;
      scope!: Raw.TypeBotCommandScope;
      langCode!: string;

      constructor(params: { scope: Raw.TypeBotCommandScope; langCode: string }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.ResetBotCommands';
        this.constructorId = 0x3d8de0f9;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['scope', 'langCode'];
        this.scope = params.scope;
        this.langCode = params.langCode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.ResetBotCommands> {
        // no flags

        let scope = await TLObject.read(b);
        let langCode = await Primitive.String.read(b);
        return new Raw.bots.ResetBotCommands({ scope: scope, langCode: langCode });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.scope !== undefined) {
          b.write(this.scope.write() as unknown as Buffer);
        }
        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetBotCommands extends TLObject {
      __response__!: Vector<Raw.TypeBotCommand>;
      scope!: Raw.TypeBotCommandScope;
      langCode!: string;

      constructor(params: { scope: Raw.TypeBotCommandScope; langCode: string }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.GetBotCommands';
        this.constructorId = 0xe34c0dd6;
        this.subclassOfId = 0xfae91529;
        this._slots = ['scope', 'langCode'];
        this.scope = params.scope;
        this.langCode = params.langCode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.GetBotCommands> {
        // no flags

        let scope = await TLObject.read(b);
        let langCode = await Primitive.String.read(b);
        return new Raw.bots.GetBotCommands({ scope: scope, langCode: langCode });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.scope !== undefined) {
          b.write(this.scope.write() as unknown as Buffer);
        }
        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetBotMenuButton extends TLObject {
      __response__!: Bool;
      userId!: Raw.TypeInputUser;
      button!: Raw.TypeBotMenuButton;

      constructor(params: { userId: Raw.TypeInputUser; button: Raw.TypeBotMenuButton }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.SetBotMenuButton';
        this.constructorId = 0x4504d54f;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['userId', 'button'];
        this.userId = params.userId;
        this.button = params.button;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.SetBotMenuButton> {
        // no flags

        let userId = await TLObject.read(b);
        let button = await TLObject.read(b);
        return new Raw.bots.SetBotMenuButton({ userId: userId, button: button });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        if (this.button !== undefined) {
          b.write(this.button.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetBotMenuButton extends TLObject {
      __response__!: Raw.TypeBotMenuButton;
      userId!: Raw.TypeInputUser;

      constructor(params: { userId: Raw.TypeInputUser }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.GetBotMenuButton';
        this.constructorId = 0x9c60eb28;
        this.subclassOfId = 0x4c71bd3c;
        this._slots = ['userId'];
        this.userId = params.userId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.GetBotMenuButton> {
        // no flags

        let userId = await TLObject.read(b);
        return new Raw.bots.GetBotMenuButton({ userId: userId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.userId !== undefined) {
          b.write(this.userId.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetBotBroadcastDefaultAdminRights extends TLObject {
      __response__!: Bool;
      adminRights!: Raw.TypeChatAdminRights;

      constructor(params: { adminRights: Raw.TypeChatAdminRights }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.SetBotBroadcastDefaultAdminRights';
        this.constructorId = 0x788464e1;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['adminRights'];
        this.adminRights = params.adminRights;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.bots.SetBotBroadcastDefaultAdminRights> {
        // no flags

        let adminRights = await TLObject.read(b);
        return new Raw.bots.SetBotBroadcastDefaultAdminRights({ adminRights: adminRights });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.adminRights !== undefined) {
          b.write(this.adminRights.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetBotGroupDefaultAdminRights extends TLObject {
      __response__!: Bool;
      adminRights!: Raw.TypeChatAdminRights;

      constructor(params: { adminRights: Raw.TypeChatAdminRights }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.SetBotGroupDefaultAdminRights';
        this.constructorId = 0x925ec9ea;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['adminRights'];
        this.adminRights = params.adminRights;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.bots.SetBotGroupDefaultAdminRights> {
        // no flags

        let adminRights = await TLObject.read(b);
        return new Raw.bots.SetBotGroupDefaultAdminRights({ adminRights: adminRights });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.adminRights !== undefined) {
          b.write(this.adminRights.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SetBotInfo extends TLObject {
      __response__!: Bool;
      bot?: Raw.TypeInputUser;
      langCode!: string;
      name?: string;
      about?: string;
      description?: string;

      constructor(params: {
        bot?: Raw.TypeInputUser;
        langCode: string;
        name?: string;
        about?: string;
        description?: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.SetBotInfo';
        this.constructorId = 0x10cf3123;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['bot', 'langCode', 'name', 'about', 'description'];
        this.bot = params.bot;
        this.langCode = params.langCode;
        this.name = params.name;
        this.about = params.about;
        this.description = params.description;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.SetBotInfo> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let bot = flags & (1 << 2) ? await TLObject.read(b) : undefined;
        let langCode = await Primitive.String.read(b);
        let name = flags & (1 << 3) ? await Primitive.String.read(b) : undefined;
        let about = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let description = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        return new Raw.bots.SetBotInfo({
          bot: bot,
          langCode: langCode,
          name: name,
          about: about,
          description: description,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.bot !== undefined ? 1 << 2 : 0;
        flags |= this.name !== undefined ? 1 << 3 : 0;
        flags |= this.about !== undefined ? 1 << 0 : 0;
        flags |= this.description !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        if (this.name !== undefined) {
          b.write(Primitive.String.write(this.name) as unknown as Buffer);
        }
        if (this.about !== undefined) {
          b.write(Primitive.String.write(this.about) as unknown as Buffer);
        }
        if (this.description !== undefined) {
          b.write(Primitive.String.write(this.description) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetBotInfo extends TLObject {
      __response__!: Raw.bots.TypeBotInfo;
      bot?: Raw.TypeInputUser;
      langCode!: string;

      constructor(params: { bot?: Raw.TypeInputUser; langCode: string }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.GetBotInfo';
        this.constructorId = 0xdcd914fd;
        this.subclassOfId = 0xca7b2235;
        this._slots = ['bot', 'langCode'];
        this.bot = params.bot;
        this.langCode = params.langCode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.GetBotInfo> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let bot = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let langCode = await Primitive.String.read(b);
        return new Raw.bots.GetBotInfo({ bot: bot, langCode: langCode });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.bot !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReorderUsernames extends TLObject {
      __response__!: Bool;
      bot!: Raw.TypeInputUser;
      order!: Vector<string>;

      constructor(params: { bot: Raw.TypeInputUser; order: Vector<string> }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.ReorderUsernames';
        this.constructorId = 0x9709b1c2;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['bot', 'order'];
        this.bot = params.bot;
        this.order = params.order;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.ReorderUsernames> {
        // no flags

        let bot = await TLObject.read(b);
        let order = await TLObject.read(b, Primitive.String);
        return new Raw.bots.ReorderUsernames({ bot: bot, order: order });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.order) {
          b.write(Primitive.Vector.write(this.order, Primitive.String) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleUsername extends TLObject {
      __response__!: Bool;
      bot!: Raw.TypeInputUser;
      username!: string;
      active!: Bool;

      constructor(params: { bot: Raw.TypeInputUser; username: string; active: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.ToggleUsername';
        this.constructorId = 0x53ca973;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['bot', 'username', 'active'];
        this.bot = params.bot;
        this.username = params.username;
        this.active = params.active;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.ToggleUsername> {
        // no flags

        let bot = await TLObject.read(b);
        let username = await Primitive.String.read(b);
        let active = await Primitive.Bool.read(b);
        return new Raw.bots.ToggleUsername({ bot: bot, username: username, active: active });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.username !== undefined) {
          b.write(Primitive.String.write(this.username) as unknown as Buffer);
        }
        if (this.active !== undefined) {
          b.write(Primitive.Bool.write(this.active) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CanSendMessage extends TLObject {
      __response__!: Bool;
      bot!: Raw.TypeInputUser;

      constructor(params: { bot: Raw.TypeInputUser }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.CanSendMessage';
        this.constructorId = 0x1359f4e6;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['bot'];
        this.bot = params.bot;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.CanSendMessage> {
        // no flags

        let bot = await TLObject.read(b);
        return new Raw.bots.CanSendMessage({ bot: bot });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AllowSendMessage extends TLObject {
      __response__!: Raw.TypeUpdates;
      bot!: Raw.TypeInputUser;

      constructor(params: { bot: Raw.TypeInputUser }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.AllowSendMessage';
        this.constructorId = 0xf132e3ef;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['bot'];
        this.bot = params.bot;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.bots.AllowSendMessage> {
        // no flags

        let bot = await TLObject.read(b);
        return new Raw.bots.AllowSendMessage({ bot: bot });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class InvokeWebViewCustomMethod extends TLObject {
      __response__!: Raw.TypeDataJSON;
      bot!: Raw.TypeInputUser;
      customMethod!: string;
      params!: Raw.TypeDataJSON;

      constructor(params: {
        bot: Raw.TypeInputUser;
        customMethod: string;
        params: Raw.TypeDataJSON;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'bots.InvokeWebViewCustomMethod';
        this.constructorId = 0x87fc5e7;
        this.subclassOfId = 0xad0352e8;
        this._slots = ['bot', 'customMethod', 'params'];
        this.bot = params.bot;
        this.customMethod = params.customMethod;
        this.params = params.params;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.bots.InvokeWebViewCustomMethod> {
        // no flags

        let bot = await TLObject.read(b);
        let customMethod = await Primitive.String.read(b);
        let params = await TLObject.read(b);
        return new Raw.bots.InvokeWebViewCustomMethod({
          bot: bot,
          customMethod: customMethod,
          params: params,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.bot !== undefined) {
          b.write(this.bot.write() as unknown as Buffer);
        }
        if (this.customMethod !== undefined) {
          b.write(Primitive.String.write(this.customMethod) as unknown as Buffer);
        }
        if (this.params !== undefined) {
          b.write(this.params.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace stories {
    export type TypePeerStories = Raw.stories.PeerStories;
    export type TypeStoryViews = Raw.stories.StoryViews;
    export type TypeStoryViewsList = Raw.stories.StoryViewsList;
    export type TypeStories = Raw.stories.Stories;
    export type TypeAllStories = Raw.stories.AllStoriesNotModified | Raw.stories.AllStories;
    export class AllStoriesNotModified extends TLObject {
      state!: string;
      stealthMode!: Raw.TypeStoriesStealthMode;

      constructor(params: { state: string; stealthMode: Raw.TypeStoriesStealthMode }) {
        super();
        this.classType = 'types';
        this.className = 'stories.AllStoriesNotModified';
        this.constructorId = 0x1158fe3e;
        this.subclassOfId = 0x7e60d0cd;
        this._slots = ['state', 'stealthMode'];
        this.state = params.state;
        this.stealthMode = params.stealthMode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.stories.AllStoriesNotModified> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let state = await Primitive.String.read(b);
        let stealthMode = await TLObject.read(b);
        return new Raw.stories.AllStoriesNotModified({ state: state, stealthMode: stealthMode });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;

        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.state !== undefined) {
          b.write(Primitive.String.write(this.state) as unknown as Buffer);
        }
        if (this.stealthMode !== undefined) {
          b.write(this.stealthMode.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class AllStories extends TLObject {
      hasMore?: boolean;
      count!: int;
      state!: string;
      peerStories!: Vector<Raw.TypePeerStories>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;
      stealthMode!: Raw.TypeStoriesStealthMode;

      constructor(params: {
        hasMore?: boolean;
        count: int;
        state: string;
        peerStories: Vector<Raw.TypePeerStories>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
        stealthMode: Raw.TypeStoriesStealthMode;
      }) {
        super();
        this.classType = 'types';
        this.className = 'stories.AllStories';
        this.constructorId = 0x6efc5e81;
        this.subclassOfId = 0x7e60d0cd;
        this._slots = ['hasMore', 'count', 'state', 'peerStories', 'chats', 'users', 'stealthMode'];
        this.hasMore = params.hasMore;
        this.count = params.count;
        this.state = params.state;
        this.peerStories = params.peerStories;
        this.chats = params.chats;
        this.users = params.users;
        this.stealthMode = params.stealthMode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.AllStories> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let hasMore = flags & (1 << 0) ? true : false;
        let count = await Primitive.Int.read(b);
        let state = await Primitive.String.read(b);
        let peerStories = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        let stealthMode = await TLObject.read(b);
        return new Raw.stories.AllStories({
          hasMore: hasMore,
          count: count,
          state: state,
          peerStories: peerStories,
          chats: chats,
          users: users,
          stealthMode: stealthMode,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.hasMore ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.state !== undefined) {
          b.write(Primitive.String.write(this.state) as unknown as Buffer);
        }
        if (this.peerStories) {
          b.write(Primitive.Vector.write(this.peerStories) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        if (this.stealthMode !== undefined) {
          b.write(this.stealthMode.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Stories extends TLObject {
      count!: int;
      stories!: Vector<Raw.TypeStoryItem>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        count: int;
        stories: Vector<Raw.TypeStoryItem>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'stories.Stories';
        this.constructorId = 0x5dd8c3c8;
        this.subclassOfId = 0x251c0c2c;
        this._slots = ['count', 'stories', 'chats', 'users'];
        this.count = params.count;
        this.stories = params.stories;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.Stories> {
        // no flags

        let count = await Primitive.Int.read(b);
        let stories = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.stories.Stories({
          count: count,
          stories: stories,
          chats: chats,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.stories) {
          b.write(Primitive.Vector.write(this.stories) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class StoryViewsList extends TLObject {
      count!: int;
      reactionsCount!: int;
      views!: Vector<Raw.TypeStoryView>;
      users!: Vector<Raw.TypeUser>;
      nextOffset?: string;

      constructor(params: {
        count: int;
        reactionsCount: int;
        views: Vector<Raw.TypeStoryView>;
        users: Vector<Raw.TypeUser>;
        nextOffset?: string;
      }) {
        super();
        this.classType = 'types';
        this.className = 'stories.StoryViewsList';
        this.constructorId = 0x46e9b9ec;
        this.subclassOfId = 0xb9437560;
        this._slots = ['count', 'reactionsCount', 'views', 'users', 'nextOffset'];
        this.count = params.count;
        this.reactionsCount = params.reactionsCount;
        this.views = params.views;
        this.users = params.users;
        this.nextOffset = params.nextOffset;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.StoryViewsList> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let count = await Primitive.Int.read(b);
        let reactionsCount = await Primitive.Int.read(b);
        let views = await TLObject.read(b);
        let users = await TLObject.read(b);
        let nextOffset = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        return new Raw.stories.StoryViewsList({
          count: count,
          reactionsCount: reactionsCount,
          views: views,
          users: users,
          nextOffset: nextOffset,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.nextOffset !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.reactionsCount !== undefined) {
          b.write(Primitive.Int.write(this.reactionsCount) as unknown as Buffer);
        }
        if (this.views) {
          b.write(Primitive.Vector.write(this.views) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        if (this.nextOffset !== undefined) {
          b.write(Primitive.String.write(this.nextOffset) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class StoryViews extends TLObject {
      views!: Vector<Raw.TypeStoryViews>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: { views: Vector<Raw.TypeStoryViews>; users: Vector<Raw.TypeUser> }) {
        super();
        this.classType = 'types';
        this.className = 'stories.StoryViews';
        this.constructorId = 0xde9eed1d;
        this.subclassOfId = 0x4b3fc4ba;
        this._slots = ['views', 'users'];
        this.views = params.views;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.StoryViews> {
        // no flags

        let views = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.stories.StoryViews({ views: views, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.views) {
          b.write(Primitive.Vector.write(this.views) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class PeerStories extends TLObject {
      stories!: Raw.TypePeerStories;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        stories: Raw.TypePeerStories;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'stories.PeerStories';
        this.constructorId = 0xcae68768;
        this.subclassOfId = 0x9d56cfd0;
        this._slots = ['stories', 'chats', 'users'];
        this.stories = params.stories;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.PeerStories> {
        // no flags

        let stories = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.stories.PeerStories({ stories: stories, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.stories !== undefined) {
          b.write(this.stories.write() as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class CanSendStory extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.CanSendStory';
        this.constructorId = 0xc7dfdfdd;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.CanSendStory> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.stories.CanSendStory({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class SendStory extends TLObject {
      __response__!: Raw.TypeUpdates;
      pinned?: boolean;
      noforwards?: boolean;
      peer!: Raw.TypeInputPeer;
      media!: Raw.TypeInputMedia;
      mediaAreas?: Vector<Raw.TypeMediaArea>;
      caption?: string;
      entities?: Vector<Raw.TypeMessageEntity>;
      privacyRules!: Vector<Raw.TypeInputPrivacyRule>;
      randomId!: long;
      period?: int;

      constructor(params: {
        pinned?: boolean;
        noforwards?: boolean;
        peer: Raw.TypeInputPeer;
        media: Raw.TypeInputMedia;
        mediaAreas?: Vector<Raw.TypeMediaArea>;
        caption?: string;
        entities?: Vector<Raw.TypeMessageEntity>;
        privacyRules: Vector<Raw.TypeInputPrivacyRule>;
        randomId: long;
        period?: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.SendStory';
        this.constructorId = 0xbcb73644;
        this.subclassOfId = 0x8af52aac;
        this._slots = [
          'pinned',
          'noforwards',
          'peer',
          'media',
          'mediaAreas',
          'caption',
          'entities',
          'privacyRules',
          'randomId',
          'period',
        ];
        this.pinned = params.pinned;
        this.noforwards = params.noforwards;
        this.peer = params.peer;
        this.media = params.media;
        this.mediaAreas = params.mediaAreas;
        this.caption = params.caption;
        this.entities = params.entities;
        this.privacyRules = params.privacyRules;
        this.randomId = params.randomId;
        this.period = params.period;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.SendStory> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let pinned = flags & (1 << 2) ? true : false;
        let noforwards = flags & (1 << 4) ? true : false;
        let peer = await TLObject.read(b);
        let media = await TLObject.read(b);
        let mediaAreas = flags & (1 << 5) ? await TLObject.read(b) : [];
        let caption = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let entities = flags & (1 << 1) ? await TLObject.read(b) : [];
        let privacyRules = await TLObject.read(b);
        let randomId = await Primitive.Long.read(b);
        let period = flags & (1 << 3) ? await Primitive.Int.read(b) : undefined;
        return new Raw.stories.SendStory({
          pinned: pinned,
          noforwards: noforwards,
          peer: peer,
          media: media,
          mediaAreas: mediaAreas,
          caption: caption,
          entities: entities,
          privacyRules: privacyRules,
          randomId: randomId,
          period: period,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.pinned ? 1 << 2 : 0;
        flags |= this.noforwards ? 1 << 4 : 0;
        flags |= this.mediaAreas ? 1 << 5 : 0;
        flags |= this.caption !== undefined ? 1 << 0 : 0;
        flags |= this.entities ? 1 << 1 : 0;
        flags |= this.period !== undefined ? 1 << 3 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.media !== undefined) {
          b.write(this.media.write() as unknown as Buffer);
        }
        if (this.mediaAreas) {
          b.write(Primitive.Vector.write(this.mediaAreas) as unknown as Buffer);
        }
        if (this.caption !== undefined) {
          b.write(Primitive.String.write(this.caption) as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        if (this.privacyRules) {
          b.write(Primitive.Vector.write(this.privacyRules) as unknown as Buffer);
        }
        if (this.randomId !== undefined) {
          b.write(Primitive.Long.write(this.randomId) as unknown as Buffer);
        }
        if (this.period !== undefined) {
          b.write(Primitive.Int.write(this.period) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class EditStory extends TLObject {
      __response__!: Raw.TypeUpdates;
      peer!: Raw.TypeInputPeer;
      id!: int;
      media?: Raw.TypeInputMedia;
      mediaAreas?: Vector<Raw.TypeMediaArea>;
      caption?: string;
      entities?: Vector<Raw.TypeMessageEntity>;
      privacyRules?: Vector<Raw.TypeInputPrivacyRule>;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        id: int;
        media?: Raw.TypeInputMedia;
        mediaAreas?: Vector<Raw.TypeMediaArea>;
        caption?: string;
        entities?: Vector<Raw.TypeMessageEntity>;
        privacyRules?: Vector<Raw.TypeInputPrivacyRule>;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.EditStory';
        this.constructorId = 0xb583ba46;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['peer', 'id', 'media', 'mediaAreas', 'caption', 'entities', 'privacyRules'];
        this.peer = params.peer;
        this.id = params.id;
        this.media = params.media;
        this.mediaAreas = params.mediaAreas;
        this.caption = params.caption;
        this.entities = params.entities;
        this.privacyRules = params.privacyRules;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.EditStory> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let peer = await TLObject.read(b);
        let id = await Primitive.Int.read(b);
        let media = flags & (1 << 0) ? await TLObject.read(b) : undefined;
        let mediaAreas = flags & (1 << 3) ? await TLObject.read(b) : [];
        let caption = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let entities = flags & (1 << 1) ? await TLObject.read(b) : [];
        let privacyRules = flags & (1 << 2) ? await TLObject.read(b) : [];
        return new Raw.stories.EditStory({
          peer: peer,
          id: id,
          media: media,
          mediaAreas: mediaAreas,
          caption: caption,
          entities: entities,
          privacyRules: privacyRules,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.media !== undefined ? 1 << 0 : 0;
        flags |= this.mediaAreas ? 1 << 3 : 0;
        flags |= this.caption !== undefined ? 1 << 1 : 0;
        flags |= this.entities ? 1 << 1 : 0;
        flags |= this.privacyRules ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        if (this.media !== undefined) {
          b.write(this.media.write() as unknown as Buffer);
        }
        if (this.mediaAreas) {
          b.write(Primitive.Vector.write(this.mediaAreas) as unknown as Buffer);
        }
        if (this.caption !== undefined) {
          b.write(Primitive.String.write(this.caption) as unknown as Buffer);
        }
        if (this.entities) {
          b.write(Primitive.Vector.write(this.entities) as unknown as Buffer);
        }
        if (this.privacyRules) {
          b.write(Primitive.Vector.write(this.privacyRules) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class DeleteStories extends TLObject {
      __response__!: Vector<int>;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;

      constructor(params: { peer: Raw.TypeInputPeer; id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.DeleteStories';
        this.constructorId = 0xae59db5f;
        this.subclassOfId = 0x5026710f;
        this._slots = ['peer', 'id'];
        this.peer = params.peer;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.DeleteStories> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.stories.DeleteStories({ peer: peer, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class TogglePinned extends TLObject {
      __response__!: Vector<int>;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;
      pinned!: Bool;

      constructor(params: { peer: Raw.TypeInputPeer; id: Vector<int>; pinned: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.TogglePinned';
        this.constructorId = 0x9a75a1ef;
        this.subclassOfId = 0x5026710f;
        this._slots = ['peer', 'id', 'pinned'];
        this.peer = params.peer;
        this.id = params.id;
        this.pinned = params.pinned;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.TogglePinned> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        let pinned = await Primitive.Bool.read(b);
        return new Raw.stories.TogglePinned({ peer: peer, id: id, pinned: pinned });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        if (this.pinned !== undefined) {
          b.write(Primitive.Bool.write(this.pinned) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAllStories extends TLObject {
      __response__!: Raw.stories.TypeAllStories;
      next?: boolean;
      hidden?: boolean;
      state?: string;

      constructor(params: { next?: boolean; hidden?: boolean; state?: string }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.GetAllStories';
        this.constructorId = 0xeeb0d625;
        this.subclassOfId = 0x7e60d0cd;
        this._slots = ['next', 'hidden', 'state'];
        this.next = params.next;
        this.hidden = params.hidden;
        this.state = params.state;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.GetAllStories> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let next = flags & (1 << 1) ? true : false;
        let hidden = flags & (1 << 2) ? true : false;
        let state = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        return new Raw.stories.GetAllStories({ next: next, hidden: hidden, state: state });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.next ? 1 << 1 : 0;
        flags |= this.hidden ? 1 << 2 : 0;
        flags |= this.state !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.state !== undefined) {
          b.write(Primitive.String.write(this.state) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPinnedStories extends TLObject {
      __response__!: Raw.stories.TypeStories;
      peer!: Raw.TypeInputPeer;
      offsetId!: int;
      limit!: int;

      constructor(params: { peer: Raw.TypeInputPeer; offsetId: int; limit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.GetPinnedStories';
        this.constructorId = 0x5821a5dc;
        this.subclassOfId = 0x251c0c2c;
        this._slots = ['peer', 'offsetId', 'limit'];
        this.peer = params.peer;
        this.offsetId = params.offsetId;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.GetPinnedStories> {
        // no flags

        let peer = await TLObject.read(b);
        let offsetId = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.stories.GetPinnedStories({ peer: peer, offsetId: offsetId, limit: limit });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetStoriesArchive extends TLObject {
      __response__!: Raw.stories.TypeStories;
      peer!: Raw.TypeInputPeer;
      offsetId!: int;
      limit!: int;

      constructor(params: { peer: Raw.TypeInputPeer; offsetId: int; limit: int }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.GetStoriesArchive';
        this.constructorId = 0xb4352016;
        this.subclassOfId = 0x251c0c2c;
        this._slots = ['peer', 'offsetId', 'limit'];
        this.peer = params.peer;
        this.offsetId = params.offsetId;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.GetStoriesArchive> {
        // no flags

        let peer = await TLObject.read(b);
        let offsetId = await Primitive.Int.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.stories.GetStoriesArchive({ peer: peer, offsetId: offsetId, limit: limit });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.offsetId !== undefined) {
          b.write(Primitive.Int.write(this.offsetId) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetStoriesByID extends TLObject {
      __response__!: Raw.stories.TypeStories;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;

      constructor(params: { peer: Raw.TypeInputPeer; id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.GetStoriesByID';
        this.constructorId = 0x5774ca74;
        this.subclassOfId = 0x251c0c2c;
        this._slots = ['peer', 'id'];
        this.peer = params.peer;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.GetStoriesByID> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.stories.GetStoriesByID({ peer: peer, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ToggleAllStoriesHidden extends TLObject {
      __response__!: Bool;
      hidden!: Bool;

      constructor(params: { hidden: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.ToggleAllStoriesHidden';
        this.constructorId = 0x7c2557c4;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['hidden'];
        this.hidden = params.hidden;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.stories.ToggleAllStoriesHidden> {
        // no flags

        let hidden = await Primitive.Bool.read(b);
        return new Raw.stories.ToggleAllStoriesHidden({ hidden: hidden });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.hidden !== undefined) {
          b.write(Primitive.Bool.write(this.hidden) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ReadStories extends TLObject {
      __response__!: Vector<int>;
      peer!: Raw.TypeInputPeer;
      maxId!: int;

      constructor(params: { peer: Raw.TypeInputPeer; maxId: int }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.ReadStories';
        this.constructorId = 0xa556dac8;
        this.subclassOfId = 0x5026710f;
        this._slots = ['peer', 'maxId'];
        this.peer = params.peer;
        this.maxId = params.maxId;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.ReadStories> {
        // no flags

        let peer = await TLObject.read(b);
        let maxId = await Primitive.Int.read(b);
        return new Raw.stories.ReadStories({ peer: peer, maxId: maxId });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.maxId !== undefined) {
          b.write(Primitive.Int.write(this.maxId) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class IncrementStoryViews extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;

      constructor(params: { peer: Raw.TypeInputPeer; id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.IncrementStoryViews';
        this.constructorId = 0xb2028afb;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'id'];
        this.peer = params.peer;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.IncrementStoryViews> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.stories.IncrementStoryViews({ peer: peer, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetStoryViewsList extends TLObject {
      __response__!: Raw.stories.TypeStoryViewsList;
      justContacts?: boolean;
      reactionsFirst?: boolean;
      peer!: Raw.TypeInputPeer;
      q?: string;
      id!: int;
      offset!: string;
      limit!: int;

      constructor(params: {
        justContacts?: boolean;
        reactionsFirst?: boolean;
        peer: Raw.TypeInputPeer;
        q?: string;
        id: int;
        offset: string;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.GetStoryViewsList';
        this.constructorId = 0x7ed23c57;
        this.subclassOfId = 0xb9437560;
        this._slots = ['justContacts', 'reactionsFirst', 'peer', 'q', 'id', 'offset', 'limit'];
        this.justContacts = params.justContacts;
        this.reactionsFirst = params.reactionsFirst;
        this.peer = params.peer;
        this.q = params.q;
        this.id = params.id;
        this.offset = params.offset;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.GetStoryViewsList> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let justContacts = flags & (1 << 0) ? true : false;
        let reactionsFirst = flags & (1 << 2) ? true : false;
        let peer = await TLObject.read(b);
        let q = flags & (1 << 1) ? await Primitive.String.read(b) : undefined;
        let id = await Primitive.Int.read(b);
        let offset = await Primitive.String.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.stories.GetStoryViewsList({
          justContacts: justContacts,
          reactionsFirst: reactionsFirst,
          peer: peer,
          q: q,
          id: id,
          offset: offset,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.justContacts ? 1 << 0 : 0;
        flags |= this.reactionsFirst ? 1 << 2 : 0;
        flags |= this.q !== undefined ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.q !== undefined) {
          b.write(Primitive.String.write(this.q) as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.String.write(this.offset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetStoriesViews extends TLObject {
      __response__!: Raw.stories.TypeStoryViews;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;

      constructor(params: { peer: Raw.TypeInputPeer; id: Vector<int> }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.GetStoriesViews';
        this.constructorId = 0x28e16cc8;
        this.subclassOfId = 0x4b3fc4ba;
        this._slots = ['peer', 'id'];
        this.peer = params.peer;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.GetStoriesViews> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        return new Raw.stories.GetStoriesViews({ peer: peer, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ExportStoryLink extends TLObject {
      __response__!: Raw.TypeExportedStoryLink;
      peer!: Raw.TypeInputPeer;
      id!: int;

      constructor(params: { peer: Raw.TypeInputPeer; id: int }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.ExportStoryLink';
        this.constructorId = 0x7b8def20;
        this.subclassOfId = 0xfc541a6;
        this._slots = ['peer', 'id'];
        this.peer = params.peer;
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.ExportStoryLink> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await Primitive.Int.read(b);
        return new Raw.stories.ExportStoryLink({ peer: peer, id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id !== undefined) {
          b.write(Primitive.Int.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class Report extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      id!: Vector<int>;
      reason!: Raw.TypeReportReason;
      message!: string;

      constructor(params: {
        peer: Raw.TypeInputPeer;
        id: Vector<int>;
        reason: Raw.TypeReportReason;
        message: string;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.Report';
        this.constructorId = 0x1923fa8c;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'id', 'reason', 'message'];
        this.peer = params.peer;
        this.id = params.id;
        this.reason = params.reason;
        this.message = params.message;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.Report> {
        // no flags

        let peer = await TLObject.read(b);
        let id = await TLObject.read(b, Primitive.Int);
        let reason = await TLObject.read(b);
        let message = await Primitive.String.read(b);
        return new Raw.stories.Report({ peer: peer, id: id, reason: reason, message: message });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.id) {
          b.write(Primitive.Vector.write(this.id, Primitive.Int) as unknown as Buffer);
        }
        if (this.reason !== undefined) {
          b.write(this.reason.write() as unknown as Buffer);
        }
        if (this.message !== undefined) {
          b.write(Primitive.String.write(this.message) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class ActivateStealthMode extends TLObject {
      __response__!: Raw.TypeUpdates;
      past?: boolean;
      future?: boolean;

      constructor(params: { past?: boolean; future?: boolean }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.ActivateStealthMode';
        this.constructorId = 0x57bbd166;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['past', 'future'];
        this.past = params.past;
        this.future = params.future;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.ActivateStealthMode> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let past = flags & (1 << 0) ? true : false;
        let future = flags & (1 << 1) ? true : false;
        return new Raw.stories.ActivateStealthMode({ past: past, future: future });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.past ? 1 << 0 : 0;
        flags |= this.future ? 1 << 1 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        return b.buffer;
      }
    }
    export class SendReaction extends TLObject {
      __response__!: Raw.TypeUpdates;
      addToRecent?: boolean;
      peer!: Raw.TypeInputPeer;
      storyId!: int;
      reaction!: Raw.TypeReaction;

      constructor(params: {
        addToRecent?: boolean;
        peer: Raw.TypeInputPeer;
        storyId: int;
        reaction: Raw.TypeReaction;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.SendReaction';
        this.constructorId = 0x7fd736b2;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['addToRecent', 'peer', 'storyId', 'reaction'];
        this.addToRecent = params.addToRecent;
        this.peer = params.peer;
        this.storyId = params.storyId;
        this.reaction = params.reaction;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.SendReaction> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let addToRecent = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        let storyId = await Primitive.Int.read(b);
        let reaction = await TLObject.read(b);
        return new Raw.stories.SendReaction({
          addToRecent: addToRecent,
          peer: peer,
          storyId: storyId,
          reaction: reaction,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.addToRecent ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.storyId !== undefined) {
          b.write(Primitive.Int.write(this.storyId) as unknown as Buffer);
        }
        if (this.reaction !== undefined) {
          b.write(this.reaction.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetPeerStories extends TLObject {
      __response__!: Raw.stories.TypePeerStories;
      peer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.GetPeerStories';
        this.constructorId = 0x2c4ada50;
        this.subclassOfId = 0x9d56cfd0;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.GetPeerStories> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.stories.GetPeerStories({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetAllReadPeerStories extends TLObject {
      __response__!: Raw.TypeUpdates;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'stories.GetAllReadPeerStories';
        this.constructorId = 0x9b5ae7f9;
        this.subclassOfId = 0x8af52aac;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.stories.GetAllReadPeerStories> {
        // no flags

        return new Raw.stories.GetAllReadPeerStories();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class GetPeerMaxIDs extends TLObject {
      __response__!: Vector<int>;
      id!: Vector<Raw.TypeInputPeer>;

      constructor(params: { id: Vector<Raw.TypeInputPeer> }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.GetPeerMaxIDs';
        this.constructorId = 0x535983c3;
        this.subclassOfId = 0x5026710f;
        this._slots = ['id'];
        this.id = params.id;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.GetPeerMaxIDs> {
        // no flags

        let id = await TLObject.read(b);
        return new Raw.stories.GetPeerMaxIDs({ id: id });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.id) {
          b.write(Primitive.Vector.write(this.id) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetChatsToSend extends TLObject {
      __response__!: Raw.messages.TypeChats;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'stories.GetChatsToSend';
        this.constructorId = 0xa56a8b60;
        this.subclassOfId = 0x99d5cb14;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.stories.GetChatsToSend> {
        // no flags

        return new Raw.stories.GetChatsToSend();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class TogglePeerStoriesHidden extends TLObject {
      __response__!: Bool;
      peer!: Raw.TypeInputPeer;
      hidden!: Bool;

      constructor(params: { peer: Raw.TypeInputPeer; hidden: Bool }) {
        super();
        this.classType = 'functions';
        this.className = 'stories.TogglePeerStoriesHidden';
        this.constructorId = 0xbd0415c4;
        this.subclassOfId = 0xf5b399ac;
        this._slots = ['peer', 'hidden'];
        this.peer = params.peer;
        this.hidden = params.hidden;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(
        b: BytesIO,
        ...args: Array<any>
      ): Promise<Raw.stories.TogglePeerStoriesHidden> {
        // no flags

        let peer = await TLObject.read(b);
        let hidden = await Primitive.Bool.read(b);
        return new Raw.stories.TogglePeerStoriesHidden({ peer: peer, hidden: hidden });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.hidden !== undefined) {
          b.write(Primitive.Bool.write(this.hidden) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace premium {
    export type TypeBoostsStatus = Raw.premium.BoostsStatus;
    export type TypeMyBoosts = Raw.premium.MyBoosts;
    export type TypeBoostsList = Raw.premium.BoostsList;
    export class BoostsList extends TLObject {
      count!: int;
      boosts!: Vector<Raw.TypeBoost>;
      nextOffset?: string;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        count: int;
        boosts: Vector<Raw.TypeBoost>;
        nextOffset?: string;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'premium.BoostsList';
        this.constructorId = 0x86f8613c;
        this.subclassOfId = 0x2235a8bd;
        this._slots = ['count', 'boosts', 'nextOffset', 'users'];
        this.count = params.count;
        this.boosts = params.boosts;
        this.nextOffset = params.nextOffset;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.premium.BoostsList> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let count = await Primitive.Int.read(b);
        let boosts = await TLObject.read(b);
        let nextOffset = flags & (1 << 0) ? await Primitive.String.read(b) : undefined;
        let users = await TLObject.read(b);
        return new Raw.premium.BoostsList({
          count: count,
          boosts: boosts,
          nextOffset: nextOffset,
          users: users,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.nextOffset !== undefined ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.count !== undefined) {
          b.write(Primitive.Int.write(this.count) as unknown as Buffer);
        }
        if (this.boosts) {
          b.write(Primitive.Vector.write(this.boosts) as unknown as Buffer);
        }
        if (this.nextOffset !== undefined) {
          b.write(Primitive.String.write(this.nextOffset) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class MyBoosts extends TLObject {
      myBoosts!: Vector<Raw.TypeMyBoost>;
      chats!: Vector<Raw.TypeChat>;
      users!: Vector<Raw.TypeUser>;

      constructor(params: {
        myBoosts: Vector<Raw.TypeMyBoost>;
        chats: Vector<Raw.TypeChat>;
        users: Vector<Raw.TypeUser>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'premium.MyBoosts';
        this.constructorId = 0x9ae228e2;
        this.subclassOfId = 0xad3512db;
        this._slots = ['myBoosts', 'chats', 'users'];
        this.myBoosts = params.myBoosts;
        this.chats = params.chats;
        this.users = params.users;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.premium.MyBoosts> {
        // no flags

        let myBoosts = await TLObject.read(b);
        let chats = await TLObject.read(b);
        let users = await TLObject.read(b);
        return new Raw.premium.MyBoosts({ myBoosts: myBoosts, chats: chats, users: users });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.myBoosts) {
          b.write(Primitive.Vector.write(this.myBoosts) as unknown as Buffer);
        }
        if (this.chats) {
          b.write(Primitive.Vector.write(this.chats) as unknown as Buffer);
        }
        if (this.users) {
          b.write(Primitive.Vector.write(this.users) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class BoostsStatus extends TLObject {
      myBoost?: boolean;
      level!: int;
      currentLevelBoosts!: int;
      boosts!: int;
      giftBoosts?: int;
      nextLevelBoosts?: int;
      premiumAudience?: Raw.TypeStatsPercentValue;
      boostUrl!: string;
      prepaidGiveaways?: Vector<Raw.TypePrepaidGiveaway>;
      myBoostSlots?: Vector<int>;

      constructor(params: {
        myBoost?: boolean;
        level: int;
        currentLevelBoosts: int;
        boosts: int;
        giftBoosts?: int;
        nextLevelBoosts?: int;
        premiumAudience?: Raw.TypeStatsPercentValue;
        boostUrl: string;
        prepaidGiveaways?: Vector<Raw.TypePrepaidGiveaway>;
        myBoostSlots?: Vector<int>;
      }) {
        super();
        this.classType = 'types';
        this.className = 'premium.BoostsStatus';
        this.constructorId = 0x4959427a;
        this.subclassOfId = 0xc31b1ab9;
        this._slots = [
          'myBoost',
          'level',
          'currentLevelBoosts',
          'boosts',
          'giftBoosts',
          'nextLevelBoosts',
          'premiumAudience',
          'boostUrl',
          'prepaidGiveaways',
          'myBoostSlots',
        ];
        this.myBoost = params.myBoost;
        this.level = params.level;
        this.currentLevelBoosts = params.currentLevelBoosts;
        this.boosts = params.boosts;
        this.giftBoosts = params.giftBoosts;
        this.nextLevelBoosts = params.nextLevelBoosts;
        this.premiumAudience = params.premiumAudience;
        this.boostUrl = params.boostUrl;
        this.prepaidGiveaways = params.prepaidGiveaways;
        this.myBoostSlots = params.myBoostSlots;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.premium.BoostsStatus> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let myBoost = flags & (1 << 2) ? true : false;
        let level = await Primitive.Int.read(b);
        let currentLevelBoosts = await Primitive.Int.read(b);
        let boosts = await Primitive.Int.read(b);
        let giftBoosts = flags & (1 << 4) ? await Primitive.Int.read(b) : undefined;
        let nextLevelBoosts = flags & (1 << 0) ? await Primitive.Int.read(b) : undefined;
        let premiumAudience = flags & (1 << 1) ? await TLObject.read(b) : undefined;
        let boostUrl = await Primitive.String.read(b);
        let prepaidGiveaways = flags & (1 << 3) ? await TLObject.read(b) : [];
        let myBoostSlots = flags & (1 << 2) ? await TLObject.read(b, Primitive.Int) : [];
        return new Raw.premium.BoostsStatus({
          myBoost: myBoost,
          level: level,
          currentLevelBoosts: currentLevelBoosts,
          boosts: boosts,
          giftBoosts: giftBoosts,
          nextLevelBoosts: nextLevelBoosts,
          premiumAudience: premiumAudience,
          boostUrl: boostUrl,
          prepaidGiveaways: prepaidGiveaways,
          myBoostSlots: myBoostSlots,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.myBoost ? 1 << 2 : 0;
        flags |= this.giftBoosts !== undefined ? 1 << 4 : 0;
        flags |= this.nextLevelBoosts !== undefined ? 1 << 0 : 0;
        flags |= this.premiumAudience !== undefined ? 1 << 1 : 0;
        flags |= this.prepaidGiveaways ? 1 << 3 : 0;
        flags |= this.myBoostSlots ? 1 << 2 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.level !== undefined) {
          b.write(Primitive.Int.write(this.level) as unknown as Buffer);
        }
        if (this.currentLevelBoosts !== undefined) {
          b.write(Primitive.Int.write(this.currentLevelBoosts) as unknown as Buffer);
        }
        if (this.boosts !== undefined) {
          b.write(Primitive.Int.write(this.boosts) as unknown as Buffer);
        }
        if (this.giftBoosts !== undefined) {
          b.write(Primitive.Int.write(this.giftBoosts) as unknown as Buffer);
        }
        if (this.nextLevelBoosts !== undefined) {
          b.write(Primitive.Int.write(this.nextLevelBoosts) as unknown as Buffer);
        }
        if (this.premiumAudience !== undefined) {
          b.write(this.premiumAudience.write() as unknown as Buffer);
        }
        if (this.boostUrl !== undefined) {
          b.write(Primitive.String.write(this.boostUrl) as unknown as Buffer);
        }
        if (this.prepaidGiveaways) {
          b.write(Primitive.Vector.write(this.prepaidGiveaways) as unknown as Buffer);
        }
        if (this.myBoostSlots) {
          b.write(Primitive.Vector.write(this.myBoostSlots, Primitive.Int) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetBoostsList extends TLObject {
      __response__!: Raw.premium.TypeBoostsList;
      gifts?: boolean;
      peer!: Raw.TypeInputPeer;
      offset!: string;
      limit!: int;

      constructor(params: {
        gifts?: boolean;
        peer: Raw.TypeInputPeer;
        offset: string;
        limit: int;
      }) {
        super();
        this.classType = 'functions';
        this.className = 'premium.GetBoostsList';
        this.constructorId = 0x60f67660;
        this.subclassOfId = 0x2235a8bd;
        this._slots = ['gifts', 'peer', 'offset', 'limit'];
        this.gifts = params.gifts;
        this.peer = params.peer;
        this.offset = params.offset;
        this.limit = params.limit;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.premium.GetBoostsList> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let gifts = flags & (1 << 0) ? true : false;
        let peer = await TLObject.read(b);
        let offset = await Primitive.String.read(b);
        let limit = await Primitive.Int.read(b);
        return new Raw.premium.GetBoostsList({
          gifts: gifts,
          peer: peer,
          offset: offset,
          limit: limit,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.gifts ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        if (this.offset !== undefined) {
          b.write(Primitive.String.write(this.offset) as unknown as Buffer);
        }
        if (this.limit !== undefined) {
          b.write(Primitive.Int.write(this.limit) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetMyBoosts extends TLObject {
      __response__!: Raw.premium.TypeMyBoosts;

      constructor() {
        super();
        this.classType = 'functions';
        this.className = 'premium.GetMyBoosts';
        this.constructorId = 0xbe77b4a;
        this.subclassOfId = 0xad3512db;
        this._slots = [];
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.premium.GetMyBoosts> {
        // no flags

        return new Raw.premium.GetMyBoosts();
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        return b.buffer;
      }
    }
    export class ApplyBoost extends TLObject {
      __response__!: Raw.premium.TypeMyBoosts;
      slots?: Vector<int>;
      peer!: Raw.TypeInputPeer;

      constructor(params: { slots?: Vector<int>; peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'premium.ApplyBoost';
        this.constructorId = 0x6b7da746;
        this.subclassOfId = 0xad3512db;
        this._slots = ['slots', 'peer'];
        this.slots = params.slots;
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.premium.ApplyBoost> {
        // no flags

        let flags = await Primitive.Int.read(b);

        let slots = flags & (1 << 0) ? await TLObject.read(b, Primitive.Int) : [];
        let peer = await TLObject.read(b);
        return new Raw.premium.ApplyBoost({ slots: slots, peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        let flags = 0;
        flags |= this.slots ? 1 << 0 : 0;
        b.write(Primitive.Int.write(flags) as unknown as Buffer);

        if (this.slots) {
          b.write(Primitive.Vector.write(this.slots, Primitive.Int) as unknown as Buffer);
        }
        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetBoostsStatus extends TLObject {
      __response__!: Raw.premium.TypeBoostsStatus;
      peer!: Raw.TypeInputPeer;

      constructor(params: { peer: Raw.TypeInputPeer }) {
        super();
        this.classType = 'functions';
        this.className = 'premium.GetBoostsStatus';
        this.constructorId = 0x42f1f61;
        this.subclassOfId = 0xc31b1ab9;
        this._slots = ['peer'];
        this.peer = params.peer;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.premium.GetBoostsStatus> {
        // no flags

        let peer = await TLObject.read(b);
        return new Raw.premium.GetBoostsStatus({ peer: peer });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.peer !== undefined) {
          b.write(this.peer.write() as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace langpack {
    export class GetLangPack extends TLObject {
      __response__!: Raw.TypeLangPackDifference;
      langPack!: string;
      langCode!: string;

      constructor(params: { langPack: string; langCode: string }) {
        super();
        this.classType = 'functions';
        this.className = 'langpack.GetLangPack';
        this.constructorId = 0xf2f2330a;
        this.subclassOfId = 0x52662d55;
        this._slots = ['langPack', 'langCode'];
        this.langPack = params.langPack;
        this.langCode = params.langCode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.langpack.GetLangPack> {
        // no flags

        let langPack = await Primitive.String.read(b);
        let langCode = await Primitive.String.read(b);
        return new Raw.langpack.GetLangPack({ langPack: langPack, langCode: langCode });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.langPack !== undefined) {
          b.write(Primitive.String.write(this.langPack) as unknown as Buffer);
        }
        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetStrings extends TLObject {
      __response__!: Vector<Raw.TypeLangPackString>;
      langPack!: string;
      langCode!: string;
      keys!: Vector<string>;

      constructor(params: { langPack: string; langCode: string; keys: Vector<string> }) {
        super();
        this.classType = 'functions';
        this.className = 'langpack.GetStrings';
        this.constructorId = 0xefea3803;
        this.subclassOfId = 0xc7b7353d;
        this._slots = ['langPack', 'langCode', 'keys'];
        this.langPack = params.langPack;
        this.langCode = params.langCode;
        this.keys = params.keys;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.langpack.GetStrings> {
        // no flags

        let langPack = await Primitive.String.read(b);
        let langCode = await Primitive.String.read(b);
        let keys = await TLObject.read(b, Primitive.String);
        return new Raw.langpack.GetStrings({ langPack: langPack, langCode: langCode, keys: keys });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.langPack !== undefined) {
          b.write(Primitive.String.write(this.langPack) as unknown as Buffer);
        }
        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        if (this.keys) {
          b.write(Primitive.Vector.write(this.keys, Primitive.String) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetDifference extends TLObject {
      __response__!: Raw.TypeLangPackDifference;
      langPack!: string;
      langCode!: string;
      fromVersion!: int;

      constructor(params: { langPack: string; langCode: string; fromVersion: int }) {
        super();
        this.classType = 'functions';
        this.className = 'langpack.GetDifference';
        this.constructorId = 0xcd984aa5;
        this.subclassOfId = 0x52662d55;
        this._slots = ['langPack', 'langCode', 'fromVersion'];
        this.langPack = params.langPack;
        this.langCode = params.langCode;
        this.fromVersion = params.fromVersion;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.langpack.GetDifference> {
        // no flags

        let langPack = await Primitive.String.read(b);
        let langCode = await Primitive.String.read(b);
        let fromVersion = await Primitive.Int.read(b);
        return new Raw.langpack.GetDifference({
          langPack: langPack,
          langCode: langCode,
          fromVersion: fromVersion,
        });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.langPack !== undefined) {
          b.write(Primitive.String.write(this.langPack) as unknown as Buffer);
        }
        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        if (this.fromVersion !== undefined) {
          b.write(Primitive.Int.write(this.fromVersion) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetLanguages extends TLObject {
      __response__!: Vector<Raw.TypeLangPackLanguage>;
      langPack!: string;

      constructor(params: { langPack: string }) {
        super();
        this.classType = 'functions';
        this.className = 'langpack.GetLanguages';
        this.constructorId = 0x42c6978f;
        this.subclassOfId = 0x280912c9;
        this._slots = ['langPack'];
        this.langPack = params.langPack;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.langpack.GetLanguages> {
        // no flags

        let langPack = await Primitive.String.read(b);
        return new Raw.langpack.GetLanguages({ langPack: langPack });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.langPack !== undefined) {
          b.write(Primitive.String.write(this.langPack) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
    export class GetLanguage extends TLObject {
      __response__!: Raw.TypeLangPackLanguage;
      langPack!: string;
      langCode!: string;

      constructor(params: { langPack: string; langCode: string }) {
        super();
        this.classType = 'functions';
        this.className = 'langpack.GetLanguage';
        this.constructorId = 0x6a596502;
        this.subclassOfId = 0xabac89b7;
        this._slots = ['langPack', 'langCode'];
        this.langPack = params.langPack;
        this.langCode = params.langCode;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.langpack.GetLanguage> {
        // no flags

        let langPack = await Primitive.String.read(b);
        let langCode = await Primitive.String.read(b);
        return new Raw.langpack.GetLanguage({ langPack: langPack, langCode: langCode });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.langPack !== undefined) {
          b.write(Primitive.String.write(this.langPack) as unknown as Buffer);
        }
        if (this.langCode !== undefined) {
          b.write(Primitive.String.write(this.langCode) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  export namespace folders {
    export class EditPeerFolders extends TLObject {
      __response__!: Raw.TypeUpdates;
      folderPeers!: Vector<Raw.TypeInputFolderPeer>;

      constructor(params: { folderPeers: Vector<Raw.TypeInputFolderPeer> }) {
        super();
        this.classType = 'functions';
        this.className = 'folders.EditPeerFolders';
        this.constructorId = 0x6847d0ab;
        this.subclassOfId = 0x8af52aac;
        this._slots = ['folderPeers'];
        this.folderPeers = params.folderPeers;
      }
      /**
       * Generate the TLObject from buffer.
       * @param {Object} data - BytesIO class from TLObject will be convert to TLObject class.
       */
      static async read(b: BytesIO, ...args: Array<any>): Promise<Raw.folders.EditPeerFolders> {
        // no flags

        let folderPeers = await TLObject.read(b);
        return new Raw.folders.EditPeerFolders({ folderPeers: folderPeers });
      }
      /**
       * Generate buffer from TLObject.
       */
      write(): Buffer {
        let b: BytesIO = new BytesIO();
        b.write(Primitive.Int.write(this.constructorId, false) as unknown as Buffer);
        // no flags

        if (this.folderPeers) {
          b.write(Primitive.Vector.write(this.folderPeers) as unknown as Buffer);
        }
        return b.buffer;
      }
    }
  }
  // End telegram schema
}
